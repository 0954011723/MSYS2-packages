From ddaa73bb5739f09556a95fb5d3d7002f4a680bea Mon Sep 17 00:00:00 2001
From: Ray Donnelly <mingw.android@gmail.com>
Date: Fri, 5 Sep 2014 21:09:10 +0100
Subject: [PATCH 4/5] mount: Add longest_native_sorted and longest_posix_sorted

.. to mount_info.

.. they are calculated as:
strlen (ap->native_path) - strlen (ap->posix_path)
.. and:
strlen (ap->posix_path) - strlen (ap->native_path)
.. respectively.

.. and used in:
conv_to_win32_path()
.. and:
conv_to_posix_path()
.. respectively.

The logic being that when converting any paths you always want the result
that is the longest route to the node as the others will be shortcuts (or
bind mounts).

If I was brave enough, I'd just have changed the sorting of the existing
posix_shared and native_shared to be (what I think is) correct.

tidy
---
 winsup/cygwin/mount.cc | 149 +++++++++++++++++++++++++++++++++++++++++++++++--
 winsup/cygwin/mount.h  |   2 +
 2 files changed, 149 insertions(+), 8 deletions(-)

diff --git a/winsup/cygwin/mount.cc b/winsup/cygwin/mount.cc
index f218c96..80e39b6 100644
--- a/winsup/cygwin/mount.cc
+++ b/winsup/cygwin/mount.cc
@@ -585,6 +585,7 @@ mount_info::conv_to_win32_path (const char *src_path, char *dst, device& dev,
   /* See if this is a cygwin "device" */
   if (win32_device_name (src_path, dst, dev))
     {
+      debug_printf ("win32_device_name (%s)", src_path);
       *flags = MOUNT_BINARY;	/* FIXME: Is this a sensible default for devices? */
       rc = 0;
       goto out_no_chroot_check;
@@ -616,6 +617,7 @@ mount_info::conv_to_win32_path (const char *src_path, char *dst, device& dev,
     }
   if (isproc (src_path))
     {
+      debug_printf ("isproc (%s)", src_path);
       dev = *proc_dev;
       dev = fhandler_proc::get_proc_fhandler (src_path);
       if (dev == FH_NADA)
@@ -637,6 +639,7 @@ mount_info::conv_to_win32_path (const char *src_path, char *dst, device& dev,
      off the prefix and transform it into an MS-DOS path. */
   else if (iscygdrive (src_path))
     {
+      debug_printf ("iscygdrive (%s) mount_table->cygdrive %s", src_path, mount_table->cygdrive);
       int n = mount_table->cygdrive_len - 1;
       int unit;
 
@@ -648,11 +651,15 @@ mount_info::conv_to_win32_path (const char *src_path, char *dst, device& dev,
 	}
       else if (cygdrive_win32_path (src_path, dst, unit))
 	{
-	  set_flags (flags, (unsigned) cygdrive_flags);
+      debug_printf ("cygdrive_win32_path (%s)", src_path);
+      set_flags (flags, (unsigned) cygdrive_flags);
 	  goto out;
 	}
       else if (mount_table->cygdrive_len > 1)
-	return ENOENT;
+      {
+          debug_printf ("mount_table->cygdrive_len > 1 (%s)", src_path);
+    return ENOENT;
+      }
     }
 
   int chroot_pathlen;
@@ -663,7 +670,9 @@ mount_info::conv_to_win32_path (const char *src_path, char *dst, device& dev,
       const char *path;
       int len;
 
-      mi = mount + posix_sorted[i];
+      mi = mount + shortest_native_sorted[i];
+      debug_printf (" mount[%d] .. checking %s -> %s ", i, mi->posix_path, mi->native_path);
+
       if (!cygheap->root.exists ()
 	  || (mi->posix_pathlen == 1 && mi->posix_path[0] == '/'))
 	{
@@ -882,7 +891,8 @@ mount_info::conv_to_posix_path (const char *src_path, char *posix_path,
   int pathbuflen = tail - pathbuf;
   for (int i = 0; i < nmounts; ++i)
     {
-      mount_item &mi = mount[native_sorted[i]];
+      mount_item &mi = mount[longest_posix_sorted[i]];
+      debug_printf (" mount[%d] .. checking %s -> %s ", i, mi.posix_path, mi.native_path);
       if (!path_prefix_p (mi.native_path, pathbuf, mi.native_pathlen,
 			  mi.flags & MOUNT_NOPOSIX))
 	continue;
@@ -1331,16 +1341,145 @@ sort_by_native_name (const void *a, const void *b)
   return res;
 }
 
+/* sort_by_longest_posix_name: qsort callback to sort the mount entries.
+   Sort user mounts ahead of system mounts to the same POSIX path. */
+/* FIXME: should the user should be able to choose whether to
+   prefer user or system mounts??? */
+static int
+sort_by_longest_posix_name (const void *a, const void *b)
+{
+  mount_item *ap = mounts_for_sort + (*((int*) a));
+  mount_item *bp = mounts_for_sort + (*((int*) b));
+
+  /* Base weighting on the conversion that would give the longest
+     posix path. */
+  ssize_t alen = (ssize_t) strlen (ap->posix_path) - (ssize_t) strlen (ap->native_path);
+  ssize_t blen = (ssize_t) strlen (bp->posix_path) - (ssize_t) strlen (bp->native_path);
+
+  int res = blen - alen;
+
+  if (res)
+    return res;		/* Path lengths differed */
+
+  /* The two paths were the same length, so just determine normal
+     lexical sorted order. */
+  res = strcmp (ap->posix_path, bp->posix_path);
+
+  if (res == 0)
+   {
+     /* need to select between user and system mount to same POSIX path */
+     if (!(bp->flags & MOUNT_SYSTEM))	/* user mount */
+      return 1;
+     else
+      return -1;
+   }
+
+  return res;
+}
+
+/* sort_by_shortest_native_name: qsort callback to sort the mount entries.
+   Sort user mounts ahead of system mounts to the same POSIX path. */
+/* FIXME: should the user should be able to choose whether to
+   prefer user or system mounts??? */
+static int
+sort_by_shortest_native_name (const void *a, const void *b)
+{
+  mount_item *ap = mounts_for_sort + (*((int*) a));
+  mount_item *bp = mounts_for_sort + (*((int*) b));
+
+  /* Base weighting on the conversion that would give the shortest
+     native path. */
+  ssize_t alen = (ssize_t) strlen (ap->native_path);
+  ssize_t blen = (ssize_t) strlen (bp->native_path);
+
+  int res = alen - blen;
+
+  if (res)
+    return res;		/* Path lengths differed */
+
+  /* The two paths were the same length, so just determine normal
+     lexical sorted order. */
+  res = strcmp (ap->native_path, bp->native_path);
+
+  if (res == 0)
+   {
+     /* need to select between user and system mount to same POSIX path */
+     if (!(bp->flags & MOUNT_SYSTEM))	/* user mount */
+      return 1;
+     else
+      return -1;
+   }
+
+  return res;
+}
+
+static int
+sort_posix_subdirs_before_parents (const void *a, const void *b)
+{
+    mount_item *ap = mounts_for_sort + (*((int*) a));
+    mount_item *bp = mounts_for_sort + (*((int*) b));
+
+    if (ap->posix_pathlen > bp->posix_pathlen)
+    {
+        if (!memcmp (bp->posix_path, ap->posix_path, bp->posix_pathlen))
+        {
+            // bp is a subdir of ap (bp must be moved in-front)
+            return -1;
+        }
+    }
+    else if (ap->posix_pathlen < bp->posix_pathlen)
+    {
+        if (!memcmp (ap->posix_path, bp->posix_path, ap->posix_pathlen))
+        {
+            // ap is a subdir of bp (good as we are)
+            return 1;
+        }
+    }
+    return 0;
+}
+
+#define DISABLE_NEW_STUFF 0
+#define ONLY_USE_NEW_STUFF 1
+
 void
 mount_info::sort ()
 {
   for (int i = 0; i < nmounts; i++)
-    native_sorted[i] = posix_sorted[i] = i;
+    native_sorted[i] = posix_sorted[i] = shortest_native_sorted[i] = longest_posix_sorted[i] = i;
   /* Sort them into reverse length order, otherwise we won't
      be able to look for /foo in /.  */
   mounts_for_sort = mount;	/* ouch. */
   qsort (posix_sorted, nmounts, sizeof (posix_sorted[0]), sort_by_posix_name);
   qsort (native_sorted, nmounts, sizeof (native_sorted[0]), sort_by_native_name);
+  qsort (longest_posix_sorted, nmounts, sizeof (longest_posix_sorted[0]), sort_by_longest_posix_name);
+  qsort (shortest_native_sorted, nmounts, sizeof (shortest_native_sorted[0]), sort_by_shortest_native_name);
+  qsort (shortest_native_sorted, nmounts, sizeof (shortest_native_sorted[0]), sort_posix_subdirs_before_parents);
+  /* Disabling my new crap. */
+  #if DISABLE_NEW_STUFF
+  for (int i = 0; i < nmounts; i++)
+  {
+      longest_posix_sorted[i] = native_sorted[i];
+      shortest_native_sorted[i] = posix_sorted[i];
+  }
+  #else
+  #if ONLY_USE_NEW_STUFF
+  for (int i = 0; i < nmounts; i++)
+  {
+      native_sorted[i] = longest_posix_sorted[i];
+      posix_sorted[i] = shortest_native_sorted[i];
+  }
+  #endif
+  #endif
+  for (int i = 0; i < nmounts; i++)
+  {
+      mount_item *mi = mount + shortest_native_sorted[i];
+      debug_printf ("shortest_native_sorted (subdirs before parents)[%d] %12s       %12s", i, mi->native_path, mi->posix_path);
+  }
+  for (int i = 0; i < nmounts; i++)
+  {
+      mount_item *mi = mount + longest_posix_sorted[i];
+      debug_printf ("longest_posix_sorted[%d] %12s       %12s", i, mi->native_path, mi->posix_path);
+  }
 }
 
 /* Add an entry to the mount table.
diff --git a/winsup/cygwin/mount.h b/winsup/cygwin/mount.h
index ba0ef4c..25465c0 100644
--- a/winsup/cygwin/mount.h
+++ b/winsup/cygwin/mount.h
@@ -181,6 +181,8 @@ class mount_info
  private:
   int posix_sorted[MAX_MOUNTS];
   int native_sorted[MAX_MOUNTS];
+  int longest_posix_sorted[MAX_MOUNTS];
+  int shortest_native_sorted[MAX_MOUNTS];
 
  public:
   void init ();
-- 
2.1.0

