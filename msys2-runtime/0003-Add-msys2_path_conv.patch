diff -Naur msys-orig/winsup/cygwin/Makefile.in src/msys2-runtime/winsup/cygwin/Makefile.in
--- msys-orig/winsup/cygwin/Makefile.in	2014-03-14 00:44:45.762800000 +0400
+++ src/msys2-runtime/winsup/cygwin/Makefile.in	2014-03-15 00:02:55.906000000 +0400
@@ -169,8 +169,8 @@
 	glob_pattern_p.o globals.o grp.o heap.o hookapi.o inet_addr.o \
 	inet_network.o init.o ioctl.o ipc.o kernel32.o ldap.o libstdcxx_wrapper.o \
 	localtime.o lsearch.o malloc_wrapper.o minires-os-if.o minires.o \
-	miscfuncs.o mktemp.o mmap.o msg.o mount.o net.o netdb.o nfs.o nftw.o \
-	nlsfuncs.o ntea.o passwd.o path.o pinfo.o pipe.o poll.o posix_ipc.o \
+	miscfuncs.o mktemp.o mmap.o msg.o msys2_path_conv.o mount.o net.o netdb.o nfs.o \
+	nftw.o nlsfuncs.o ntea.o passwd.o path.o pinfo.o pipe.o poll.o posix_ipc.o \
 	pseudo-reloc.o pthread.o random.o regcomp.o regerror.o regexec.o regfree.o \
 	registry.o resource.o rexec.o rcmd.o scandir.o sched.o sec_acl.o \
 	sec_auth.o sec_helper.o security.o select.o sem.o setlsapwd.o shared.o \
diff -Naur msys-orig/winsup/cygwin/msys2_path_conv.cc src/msys2-runtime/winsup/cygwin/msys2_path_conv.cc
--- msys-orig/winsup/cygwin/msys2_path_conv.cc	1970-01-01 03:00:00.000000000 +0300
+++ src/msys2-runtime/winsup/cygwin/msys2_path_conv.cc	2014-03-18 18:15:36.220600000 +0400
@@ -0,0 +1,441 @@
+/*
+  The BSD 3-Clause License. http://www.opensource.org/licenses/BSD-3-Clause
+
+  This file is part of 'MSYS2' project.
+  Copyright (c) 2014 by Alexey Pavlov <alexpux@gmail.com>
+  Copyright (c) 2014 by niXman <i.nixman@autistici.org>
+  Copyright (c) 2014 by Ray Donnelly <mingw.android@gmail.com>
+  All rights reserved.
+
+  Project: MSYS2 ( http://sourceforge.net/projects/msys2/ )
+
+  Redistribution and use in source and binary forms, with or without 
+  modification, are permitted provided that the following conditions are met:
+  - Redistributions of source code must retain the above copyright 
+      notice, this list of conditions and the following disclaimer.
+  - Redistributions in binary form must reproduce the above copyright 
+      notice, this list of conditions and the following disclaimer in 
+      the documentation and/or other materials provided with the distribution.
+  - Neither the name of the 'MinGW-W64' nor the names of its contributors may 
+      be used to endorse or promote products derived from this software 
+      without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+  A PARTICULAR PURPOSE ARE DISCLAIMED.
+  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
+  OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
+  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
+  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
+  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include "winsup.h"
+#include "miscfuncs.h"
+#include <ctype.h>
+#include <winioctl.h>
+#include <shlobj.h>
+#include <sys/param.h>
+#include <sys/cygwin.h>
+#include "cygerrno.h"
+#include "security.h"
+#include "path.h"
+#include "fhandler.h"
+#include "dtable.h"
+#include "cygheap.h"
+#include "shared_info.h"
+#include "cygtls.h"
+#include "tls_pbuf.h"
+#include "environ.h"
+#include <assert.h>
+#include <ntdll.h>
+#include <wchar.h>
+#include <wctype.h>
+
+#include "msys2_path_conv.h"
+
+typedef enum PATH_TYPE_E {
+    NONE = 0,
+    SIMPLE_WINDOWS_PATH,
+    ESCAPE_WINDOWS_PATH,
+    WINDOWS_PATH_LIST,
+    UNC,
+    ESCAPED_PATH,
+    ROOTED_PATH,
+    POSIX_PATH_LIST,
+    URL,
+} path_type;
+
+int is_special_posix_path(const char* from, const char* to, char** dst, const char* dstend);
+void posix_to_win32_path(const char* from, const char* to, char** dst, const char* dstend);
+
+
+path_type find_path_start_and_type(const char** src, int recurse, const char* end);
+void copy_to_dst(const char* from, const char* to, char** dst, const char* dstend);
+void convert_path(const char** from, const char* to, path_type type, char** dst, const char* dstend);
+
+//Transformations
+//SIMPLE_WINDOWS_PATH converter. Copy as is. Hold C:\Something\like\this
+void swp_convert(const char** from, const char* to, char** dst, const char* dstend);
+//ESCAPE_WINDOWS_PATH converter. Turn backslashes to slashes and skip first /. Hold /C:\Somethind\like\this
+void ewp_convert(const char** from, const char* to, char** dst, const char* dstend);
+//WINDOWS_PATH_LIST converter. Copy as is. Hold /something/like/this;
+void wpl_convert(const char** from, const char* to, char** dst, const char* dstend);
+//UNC convert converter. Copy as is. Hold //somethig/like/this
+void unc_convert(const char** from, const char* to, char** dst, const char* dstend);
+//ESCAPED_PATH converter. Turn backslashes to slashes and skip first /. Hold //something\like\this
+void ep_convert(const char** from, const char* to, char** dst, const char* dstend);
+//ROOTED_PATH converter. Prepend root dir to front. Hold /something/like/this
+void rp_convert(const char** from, const char* to, char** dst, const char* dstend);
+//URL converter. Copy as is.
+void url_convert(const char** from, const char* to, char** dst, const char* dstend);
+//POSIX_PATH_LIST. Hold x::x/y:z
+void ppl_convert(const char** from, const char* to, char** dst, const char* dstend);
+
+
+void find_end_of_posix_list(const char** to, int in_string) {
+    for (; **to != '\0' && (in_string ? (**to != in_string) : **to != ' '); ++*to) {
+    }
+}
+
+void sub_convert(const char** from, const char** to, char** dst, const char* dstend, char end_with, int in_string) {
+    const char* copy_from = *from;
+    path_type type = find_path_start_and_type(from, false, *to);
+
+    if (type == POSIX_PATH_LIST) {
+        find_end_of_posix_list(to, in_string);
+    }
+
+    if (type != NONE) {
+        copy_to_dst(copy_from, *from, dst, dstend);
+        convert_path(from, *to, type, dst, dstend);
+    }
+
+    if (*dst != dstend) {
+        **dst = (in_string && type == POSIX_PATH_LIST) ? in_string : end_with;
+        *dst += 1;
+    }
+}
+
+const char* convert(char *dst, size_t dstlen, const char *src) {
+    const char* srcit = src;
+    const char* srcbeg = src;
+    char* dstit = dst;
+    char* dstend = dst + dstlen;
+
+    int prev_was_space = 0;
+    int in_string = false;
+
+    for (;*srcit!= '\0'; ++srcit) {
+        if (*srcit == '\'' || *srcit == '"') {
+            if (in_string == *srcit) {
+                in_string = 0;
+            } else {
+                in_string = *srcit;
+            }
+            continue;
+        }
+
+        if (isspace(*srcit)) {
+            if (prev_was_space) {
+                continue;
+            }
+
+            prev_was_space = true;
+            sub_convert(&srcbeg, &srcit, &dstit, dstend, ' ', in_string);
+        }
+
+        if (!isspace(*srcit) && prev_was_space) {
+            prev_was_space = false;
+            srcbeg = srcit;
+        }
+    }
+
+    sub_convert(&srcbeg, &srcit, &dstit, dstend, '\0', in_string);
+
+    return dst;
+}
+
+void copy_to_dst(const char* from, const char* to, char** dst, const char* dstend) {
+    for (; (*from != '\0') && (from != to) && (*dst != dstend); ++from, ++(*dst)) {
+        **dst = *from;
+    }
+}
+
+int is_spec_start_symbl(char ch) {
+    return (ch == '-')  || (ch == '@');
+}
+
+const char** move(const char** p, int count) {
+    *p += count;
+    return p;
+}
+
+path_type find_path_start_and_type(const char** src, int recurse, const char* end) {
+    const char* it = *src;
+
+    if (*it == '\0' || it == end) return NONE;
+
+    path_type result = NONE;
+
+    if (isalpha(*it) && *(it + 1) == ':') {
+        if ((recurse && *(it + 2) == '/') ||
+            (*(it + 2) == '\\')) {
+            return SIMPLE_WINDOWS_PATH;
+        }
+    }
+
+    if (*it == '/') {
+        it += 1;
+
+        if (isalpha(*it) && *(it + 1) == ':') {
+            return ESCAPE_WINDOWS_PATH;
+        }
+
+        if (*it == '.' && *(it + 1) == '.') {
+            return SIMPLE_WINDOWS_PATH;
+        }
+
+        int double_slashed = 0;
+        if (*it == '/') {
+            double_slashed = 1;
+            it += 1;
+        }
+
+        if (double_slashed && *it == ':') {
+            return URL;
+        }
+
+
+        for (; *it != '\0' && it != end; ++it) {
+            switch(*it) {
+                case ':': {char ch = *(it + 1); if (ch == '/' || ch == ':' || ch == '.') return POSIX_PATH_LIST;}
+                case '/': result = (double_slashed) ? UNC : ROOTED_PATH; break;
+                case ';': return WINDOWS_PATH_LIST;
+            }
+        }
+
+        if (result != NONE) {
+            return result;
+        }
+
+        return (double_slashed) ? ESCAPED_PATH : ROOTED_PATH;
+    }
+
+    if (*it == '@') {
+        return find_path_start_and_type(move(src, 1), true, end);
+    }
+
+    if (*it == '"' || *it == '\'') {
+        return find_path_start_and_type(move(src, 1), true, end);
+    }
+
+    int starts_with_minus = (*it == '-');
+
+    if (starts_with_minus) {
+        char n2 = *(it + 2);
+        char n3 = *(it + 3);
+
+        if (n2 == '/') {
+            it += 2;
+            result = ROOTED_PATH;
+        } else if ((n2 == '\'' || n2 == '"') && n3 == '/') {
+            it += 3;
+            result = ROOTED_PATH;
+        }
+    }
+
+    int not_starte_with_spec = recurse == 0
+                                ? !is_spec_start_symbl(*it)
+                                : !is_spec_start_symbl(*(it - 1));
+
+    for (const char* it2 = it; *it2 != '\0' && it2 != end; ++it2) {
+        char ch = *it2;
+        if (ch == '=') {
+            *src = it2 + 1;
+            return find_path_start_and_type(src, true, end);
+        }
+
+        if (ch == ',' && starts_with_minus) {
+            *src = it2 + 1;
+            return find_path_start_and_type(src, true, end);
+        }
+
+        if (ch == ':' && not_starte_with_spec && !starts_with_minus) {
+            it2 += 1;
+            ch = *it2;
+            if (ch == '/' || ch == ':' || ch == '.') {
+                if (ch == '/' && *(it2 + 1) == '/') {
+                    return URL;
+                } else {
+                    return POSIX_PATH_LIST;
+                }
+            } else {
+                return SIMPLE_WINDOWS_PATH;
+            }
+        }
+    }
+
+    if (result != NONE) {
+        *src = it;
+        return result;
+    }
+
+    return SIMPLE_WINDOWS_PATH;
+}
+
+void convert_path(const char** from, const char* to, path_type type, char** dst, const char* dstend) {
+    switch(type) {
+        case SIMPLE_WINDOWS_PATH: swp_convert(from, to, dst, dstend); break;
+        case ESCAPE_WINDOWS_PATH: ewp_convert(from, to, dst, dstend); break;
+        case WINDOWS_PATH_LIST: wpl_convert(from, to, dst, dstend); break;
+        case UNC: unc_convert(from, to, dst, dstend); break;
+        case ESCAPED_PATH: ep_convert(from, to, dst, dstend); break;
+        case ROOTED_PATH: rp_convert(from, to, dst, dstend); break;
+        case URL: url_convert(from, to, dst, dstend); break;
+        case POSIX_PATH_LIST: ppl_convert(from, to, dst, dstend); break;
+        case NONE: // prevent warnings;
+        default:
+                return;
+    }
+}
+
+void swp_convert(const char** from, const char* to, char** dst, const char* dstend) {
+    copy_to_dst(*from, to, dst, dstend);
+}
+
+void ewp_convert(const char** from, const char* to, char** dst, const char* dstend) {
+    *from += 1;
+    unc_convert(from, to, dst, dstend);
+}
+
+void wpl_convert(const char** from, const char* to, char** dst, const char* dstend) {
+    swp_convert(from, to, dst, dstend);
+}
+
+void unc_convert(const char** from, const char* to, char** dst, const char* dstend) {
+    const char* it = *from;
+    for (; (*it != '\0' && it != to) && (*dst != dstend); ++it, ++(*dst)) {
+        if (*it == '\\') {
+            **dst = '/';
+        } else {
+            **dst = *it;
+        }
+    }
+}
+
+void ep_convert(const char** from, const char* to, char** dst, const char* dstend) {
+    ewp_convert(from, to, dst, dstend);
+}
+
+void rp_convert(const char** from, const char* to, char** dst, const char* dstend) {
+    const char* it = *from;
+    const char* real_to = to;
+
+    if (*real_to == '\0')  {
+        real_to -= 1;
+        if (*real_to != '\'' && *real_to != '"') {
+            real_to += 1;
+        }
+    }
+
+    if (!is_special_posix_path(*from, real_to, dst, dstend)) {
+        posix_to_win32_path(it, real_to, dst, dstend);
+    }
+
+    if (real_to != to) {
+        **dst = *real_to;
+        *dst += 1;
+    }
+}
+
+void url_convert(const char** from, const char* to, char** dst, const char* dstend) {
+    unc_convert(from, to, dst, dstend);
+}
+
+void subp_convert(const char** from, const char* end, int is_url, char** dst, const char* dstend) {
+    const char* begin = *from;
+    path_type type = find_path_start_and_type(from, 0, end);
+    copy_to_dst(begin, *from, dst, dstend);
+
+    if (type == NONE) {
+        return;
+    }
+
+    char* start = *dst;
+    convert_path(from, end, type, dst, dstend);
+
+    if (!is_url) {
+        for (; start != *dst; ++start) {
+            if (*start == '/') {
+                *start = '\\';
+            }
+        }
+    }
+}
+
+void ppl_convert(const char** from, const char* to, char** dst, const char* dstend) {
+    const char* it = *from;
+    const char* beg = it;
+    int prev_was_simc = 0;
+    int is_url = 0;
+    for (; (*it != '\0' && it != to) && (*dst != dstend); ++it) {
+        if (*it == ':') {
+            if (prev_was_simc) {
+                continue;
+            }
+            if (*(it + 1) == '/' && *(it + 2) == '/') {
+                is_url = 1;
+                continue;
+            }
+            prev_was_simc = 1;
+            subp_convert(&beg, it, is_url, dst, dstend);
+            is_url = 0;
+
+            **dst = ';';
+            *dst += 1;
+        }
+
+        if (*it != ':' && prev_was_simc) {
+            prev_was_simc = 0;
+            beg = it;
+        }
+    }
+
+    subp_convert(&beg, it, is_url, dst, dstend);
+}
+
+int is_special_posix_path(const char* from, const char* to, char** dst, const char* dstend) {
+    const char dev_null[] = "/dev/null";
+
+    if ((to - from) == (sizeof(dev_null) - 1) && strncmp(from, "/dev/null", to - from) == 0) {
+        copy_to_dst("nul", NULL, dst, dstend);
+        return true;
+    }
+    return false;
+}
+
+void posix_to_win32_path(const char* from, const char* to, char** dst, const char* dstend) {
+    if ( from != to ) {
+        tmp_pathbuf tp;
+        char *one_path = tp.c_get();
+        strncpy(one_path, from, to-from);
+        one_path[to-from] = '\0';
+
+        path_conv conv (one_path, 0);
+        if (conv.error)
+        {
+          set_errno(conv.error);
+          copy_to_dst(one_path, NULL, dst, dstend);
+        } else {
+          char* win32_path = tp.c_get();
+          stpcpy (win32_path, conv.get_win32 ());
+          for (; (*win32_path != '\0') && (*dst != dstend); ++win32_path, ++(*dst)) {
+             **dst = (*win32_path == '\\') ? '/' : *win32_path;
+          }
+        }
+    }
+}
diff -Naur msys-orig/winsup/cygwin/msys2_path_conv.h src/msys2-runtime/winsup/cygwin/msys2_path_conv.h
--- msys-orig/winsup/cygwin/msys2_path_conv.h	1970-01-01 03:00:00.000000000 +0300
+++ src/msys2-runtime/winsup/cygwin/msys2_path_conv.h	2014-03-15 00:02:57.403600000 +0400
@@ -0,0 +1,44 @@
+/*
+  The BSD 3-Clause License. http://www.opensource.org/licenses/BSD-3-Clause
+
+  This file is part of 'MSYS2' project.
+  Copyright (c) 2014 by Alexey Pavlov <alexpux@gmail.com>
+  Copyright (c) 2014 by niXman <i.nixman@autistici.org>
+  Copyright (c) 2014 by Ray Donnelly <mingw.android@gmail.com>
+  All rights reserved.
+
+  Project: MSYS2 ( http://sourceforge.net/projects/msys2/ )
+
+  Redistribution and use in source and binary forms, with or without 
+  modification, are permitted provided that the following conditions are met:
+  - Redistributions of source code must retain the above copyright 
+      notice, this list of conditions and the following disclaimer.
+  - Redistributions in binary form must reproduce the above copyright 
+      notice, this list of conditions and the following disclaimer in 
+      the documentation and/or other materials provided with the distribution.
+  - Neither the name of the 'MinGW-W64' nor the names of its contributors may 
+      be used to endorse or promote products derived from this software 
+      without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+  A PARTICULAR PURPOSE ARE DISCLAIMED.
+  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY 
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
+  OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
+  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
+  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
+  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef PATH_CONV_H_DB4IQBH3
+#define PATH_CONV_H_DB4IQBH3
+
+#include <stdlib.h>
+
+const char* convert(char *dst, size_t dstlen, const char *src);
+
+#endif /* end of include guard: PATH_CONV_H_DB4IQBH3 */
+
diff -Naur msys-orig/winsup/cygwin/path.cc src/msys2-runtime/winsup/cygwin/path.cc
--- msys-orig/winsup/cygwin/path.cc	2014-03-14 00:44:50.364800000 +0400
+++ src/msys2-runtime/winsup/cygwin/path.cc	2014-03-15 19:54:44.298800000 +0400
@@ -65,6 +65,7 @@
 #include "cygtls.h"
 #include "tls_pbuf.h"
 #include "environ.h"
+#include "msys2_path_conv.h"
 #include <assert.h>
 #include <ntdll.h>
 #include <wchar.h>
@@ -3344,84 +3345,23 @@
   return res;
 }
 
-static bool
-isabswinpath (const char * path)
-{
-  int plen = strlen (path);
-  bool p0alpha = isalpha (path[0]) != 0;
-  bool p1colon = (plen > 1 && path[1] == ':');
-  bool rval = 
-         (   ((plen == 2) && p0alpha && p1colon)
-          || (  (plen > 2) 
-	      && p0alpha 
-	      && p1colon 
-	      && (strchr (&path[2], ':') == (char *)NULL)
-	     )
-	  || (   plen > 3 
-	      && path[0] == '\\' 
-	      && path[1] == '\\' 
-	      && path[3] == '\\'
-	     )
-	 );
-    return rval;
-}
-
-static char *
-ScrubRetpath (char * const retpath)
-{ 
-  char * sspath = (char *)retpath;
-  //
-  // Check for null path because Win32 doesn't like them.
-  // I.E.:  Path lists of c:/foo;;c:/bar need changed to 
-  // c:/foo;c:/bar.
-  //
-  // This need be executed only if we actually converted the path.
-  //
-  while (*sspath)
-    {
-      if (*sspath == ';' && sspath[1] == ';')
-	  for (char *i = sspath; *i; i++)
-	      *i = *(i + 1);
-      else
-	sspath++;
-    }
-  if (*(sspath - 1) == ';')
-    *(sspath - 1) = '\0';
-
-  //
-  // If we modified the path then convert all / to \ if we have a path list
-  // else convert all \ to /.
-  // 
-  if ((strchr (retpath, ';')))
-  {
-    backslashify (retpath, retpath, 0);
-  } else
-  {
-    slashify (retpath, retpath, 0);
-  }
-  debug_printf("returning: %s", retpath);
-  return retpath;
-}
-
 //
-// The returned pointer should be freed with free unless,
-// as it turns out, it is equal to the input pointer.
+// Important: If returned pointer == arg, then this function
+//            did not malloc that pointer; otherwise free it.
 //
 extern "C" char *
 arg_heuristic_with_exclusions (char const * const arg, char const * exclusions, size_t exclusions_count)
 {
+  char *arg_result;
 
-  int arglen = (arg ? strlen (arg): 0);
-  
-  if (arglen == 0)
+  // Must return something ..
+  if (!arg)
   {
-    char *retpath = (char *)malloc (sizeof (char));
-    memset (retpath, 0, sizeof (char));
-    return retpath;
+    arg_result = (char *)malloc (sizeof (char));
+    arg_result[0] = '\0';
+    return arg_result;
   }
 
-  debug_printf("Input value: (%s)", arg);
-
   for (size_t excl = 0; excl < exclusions_count; ++excl)
     {
       if ( strstr (arg, exclusions) == arg )
@@ -3429,408 +3369,30 @@
       exclusions += strlen (exclusions) + 1;
     }
 
-  //
-  // copy of the path string that we can overwrite
-  //
-  char *spath = (char *)alloca (arglen + 1);
-  memcpy (spath, arg, arglen + 1);
-  
-  char * sspath;
-  
-  //
-  // retpath contains the converted path string to be returned
-  //
-  char *retpath = (char *)malloc(((MAX_PATH - arglen) > 0) ? 
-      MAX_PATH : arglen + MAX_PATH);
-  memset (retpath, 0, MAX_PATH);
-  int retpath_len = 0;
-  int retpath_buflen = MAX_PATH;
-    
-#define retpathcat(retstr) \
-  retpath_len += strlen(retstr); \
-  if (retpath_buflen <= retpath_len) \
-    { \
-      retpath_buflen = ((retpath_buflen * 2 <= retpath_len) ? \
-	  retpath_len + 1 : retpath_buflen * 2); \
-      retpath = (char *)realloc (retpath, retpath_buflen); \
-    } \
-  strcat (retpath, retstr);
-
-#define retpathcpy(retstr) \
-  retpath_len = strlen (retstr); \
-  *retpath = '\0'; \
-  if (retpath_buflen <= retpath_len ) \
-    { \
-      retpath_buflen = ((retpath_buflen * 2 <= retpath_len) ? \
-	  retpath_len + 1 : retpath_buflen * 2); \
-      retpath = (char *)realloc (retpath, retpath_buflen); \
-    } \
-  strcpy (retpath, retstr);
-
-  //
-  // Just return win32 paths and path lists.
-  //
-  if (isabswinpath (arg) 
-      || (strchr (arg, ';') > 0)
-      )
+  size_t stack_len = strlen (arg)+1024;
+  char * stack_path = (char *)alloca (stack_len);
+  if (!stack_len)
+    {
+      debug_printf ("out of stack space?");
+      return (char *)arg;
+    }
+  convert (stack_path, stack_len - 1, arg);
+  debug_printf ("convert()'ed: %s\n.....->: %s", arg, stack_path);
+  // Don't allocate memory if no conversion happened.
+  if (!strcmp (arg, stack_path))
     {
-      debug_printf("returning Win32 absolute path: %s", arg);
       return ((char *)arg);
     }
-  //
-  // Multiple forward slashes are treated special,
-  // Remove one and return for the form of //foo or ///bar
-  // but just return for the form of //server/share.
-  //
-  else if (arg[0] == '/' && arg[1] == '/')
-    {
-      int tidx = 2;
-      while (spath[tidx] && spath[tidx] == '/')
-	  tidx++;
-      if (strchr (&spath[tidx], '/'))
-	{
-	  retpathcpy (spath);
-	}
-      else
-	{
-	  retpathcpy (&spath[1]);
-	}
-      return ScrubRetpath (retpath);
-    }
-  //
-  // special case confusion elimination
-  // Translate a path that looks similar to /c: to c:/.
-  //
-  else if (arg[0] == '/' && isabswinpath (arg + 1))
-    {
-      retpathcpy (&arg[1]);
-      return ScrubRetpath (retpath);
-    }
-  //
-  // Check for variable set.
-  //
-  else if ((sspath = strchr(spath, '=')) && isalpha (spath[0]))
-    {
-      if (isabswinpath (sspath + 1)) {
-	debug_printf("returning: %s", arg);
-	return (char *)arg;
-      }
-      char *swin32_path = arg_heuristic(sspath + 1);
-      if (swin32_path == (sspath + 1)) {
-	debug_printf("returning: %s", arg);
-	return (char *)arg;
-      }
-      *sspath = '\0';
-      retpathcpy (spath);
-      retpathcat ("=");
-      retpathcat (swin32_path);
-      free (swin32_path);
-      return ScrubRetpath (retpath);
-    }
-  //
-  // Check for paths after commas, if string begins with a '-' character.
-  //
-  else if ((sspath = strchr(spath, ',')) && spath[0] == '-')
-    {
-      if (isabswinpath (sspath + 1)) {
-	debug_printf("returning: %s", arg);
-	return (char *)arg;
-      }
-      char *swin32_path = arg_heuristic(sspath + 1);
-      if (swin32_path == (sspath + 1)) {
-	debug_printf("returning: %s", arg);
-	return (char *)arg;
-      }
-      *sspath = '\0';
-      retpathcpy (spath);
-      retpathcat (",");
-      retpathcat (swin32_path);
-      free (swin32_path);
-      return ScrubRetpath (retpath);
-    }
-  //
-  // Check for POSIX path lists.
-  // But we have to allow processing of quoted strings and switches first
-  // which uses recursion so this code will be seen again.
-  //
-  else 
-    {
-      sspath = strchr (spath, ':');
-      //
-      // Prevent http://some.string/ from being modified.
-      // 
-      if ((sspath > 0 && strlen (sspath) > 2)
-	  && (sspath[1] == '/')
-	  && (sspath[2] == '/')
-	  )
-	{
-	  debug_printf("returning: %s", arg);
-	  return ((char *)arg);
-	}
-      else
-      if ((sspath > 0)
-	   && (strchr (spath, '/') > 0)
-	   // 
-	   // Prevent strings beginning with -, ", ', or @ from being processed,
-	   // remember that this is a recursive routine.
-	   // 
-	   && (strchr ("-\"\'@", spath[0]) == 0)
-	   // 
-	   // Prevent ``foo:echo /bar/baz'' from being considered a path list.
-	   // 
-	   && (strlen (sspath) > 1 && strchr (":./", sspath[1]) > 0)
-	   )
-    {
-      //
-      // Yes, convert to Win32 path list.
-      //
-      while (sspath)
-	{
-	  *sspath = '\0';
-	  char *swin32_path = arg_heuristic (spath);
-	  //
-	  // Just ignore sret; swin32_path has the value we need.
-	  //
-	  retpathcat (swin32_path);
-	  if (swin32_path != spath)
-	    free (swin32_path);
-	  spath = sspath + 1;
-	  sspath = strchr (spath, ':');
-	  retpathcat (";");
-	  //
-	  // Handle the last path in the list.
-	  //
-	  if (!sspath)
-	    {
-	      char *swin32_path = arg_heuristic (spath);
-	      retpathcat (swin32_path);
-	      if (swin32_path != spath)
-		free (swin32_path);
-	    }
-	}
-      return ScrubRetpath (retpath);
-    }
-  else
+  arg_result = (char *)malloc (strlen (stack_path)+1);
+  strcpy (arg_result, stack_path);
+  // Windows doesn't like empty entries in PATH env. variables (;;)
+  char* semisemi = strstr(arg_result, ";;");
+  while (semisemi)
     {
-      switch (spath[0])
-	{
-	case '/':
-	  //
-	  // Just a normal POSIX path.
-	  //
-	  {
-	    //
-	    // Convert only up to a ".." path component, and
-	    // keep all what follows as is.
-	    //
-	    sspath = strstr (spath, "/..");
-	    if (sspath)
-	      {
-		*sspath = '\0';
-		char *swin32_path = arg_heuristic (spath);
-		if (swin32_path == spath)
-		  {
-		    debug_printf("returning: %s", arg);
-		    return ((char *)arg);
-		  }
-		retpathcpy (swin32_path);
-		retpathcat ("/");
-		retpathcat (sspath+1);
-		free (swin32_path);
-		return ScrubRetpath (retpath);
-	      }
-		if (strcmp(spath, "/dev/null") == 0)
-	      {
-		retpathcpy("nul");
-		return ScrubRetpath (retpath);
-	      }
-	    path_conv p (spath, 0);
-	    if (p.error)
-	      {
-		set_errno(p.error);
-		debug_printf("returning: %s", arg);
-		return ((char *)arg);
-	      }
-	    retpathcpy (p.get_win32 ());
-	    return ScrubRetpath (retpath);
-	  }
-	case '-':
-	  //
-	  // here we check for POSIX paths as attributes to a POSIX switch.
-	  //
-	  sspath = strchr (spath, '=');
-	  if (sspath)
-	    {
-	      //
-	      // just use recursion if we find a set variable token.
-	      //
-	      *sspath = '\0';
-	      if (isabswinpath (sspath + 1)) {
-		debug_printf("returning: %s", arg);
-		return (char *)arg;
-	      }
-	      char *swin32_path = arg_heuristic(sspath + 1);
-	      if (swin32_path == sspath + 1)
-		{
-		  debug_printf("returning: %s", arg);
-		  return ((char *)arg);
-		}
-	      retpathcpy (spath);
-	      retpathcat ("=");
-	      retpathcat (swin32_path);
-	      free (swin32_path);
-	      return ScrubRetpath (retpath);
-	    }
-	  else
-	    {
-	      //
-	      // Check for single letter option with a
-	      // path argument attached, eg -I/include */
-	      //
-	      if (spath[1] && spath[2] == '/')
-		{
-		  debug_printf("spath = %s", spath);
-		  sspath = spath + 2;
-		  char *swin32_path = arg_heuristic (sspath);
-		  if (swin32_path == sspath)
-		    {
-		      debug_printf("returning: %s", arg);
-		      return ((char *)arg);
-		    }
-		  sspath = (char *)spath;
-		  sspath++;
-		  sspath++;
-		  *sspath = '\0';
-		  retpathcpy (spath);
-		  *sspath = '/';
-		  retpathcat (swin32_path);
-		  free (swin32_path);
-		  return ScrubRetpath (retpath);
-		}
-	      else
-		{
-		  debug_printf("returning: %s", arg);
-		  return ((char *)arg);
-		}
-	    }
-	  break;
-	case '@':
-	  //
-	  // here we check for POSIX paths as attributes to a response
-	  // file argument (@file). This is specifically to support
-	  // MinGW binutils and gcc.
-	  //
-	  sspath = spath + 1;
-	  if (isabswinpath (sspath))
-	    {
-	      debug_printf("returning: %s", arg);
-	      return (char *)arg;
-	    }
-	  if (spath[1] == '/')
-	    {
-	      debug_printf("spath = %s", spath);
-	      char *swin32_path = arg_heuristic (sspath);
-	      if (swin32_path == sspath)
-		{
-		  debug_printf("returning: %s", arg);
-		  return ((char *)arg);
-		}
-	      sspath = (char *)spath;
-	      sspath++;
-	      *sspath = '\0';
-	      retpathcpy (spath);
-	      *sspath = '/';
-	      retpathcat (swin32_path);
-	      free (swin32_path);
-	      return ScrubRetpath (retpath);
-	    }
-	  else
-	    {
-	      debug_printf("returning: %s", arg);
-	      return ((char *)arg);
-	    }
-	  break;
-	case '"':
-	  //
-	  // Handle a double quote case.
-	  //
-	  debug_printf ("spath: %s", spath);
-	  if (spath[1] == '/')
-	    {
-	      retpathcpy ("\"");
-	      char *tpath = strchr(&spath[1], '"');
-	      if (tpath)
-		*tpath = (char)NULL;
-	      char *swin32_path = arg_heuristic (&spath[1]);
-	      if (swin32_path == &spath[1])
-		{
-		  debug_printf("returning: %s", arg);
-		  return ((char *)arg);
-		}
-	      retpathcat (swin32_path);
-	      free (swin32_path);
-	      if (tpath)
-		retpathcat ("\"");
-	      return ScrubRetpath (retpath);
-	    }
-	  debug_printf("returning: %s", arg);
-	  return ((char *)arg);
-	case '\'':
-	  //
-	  // Handle a single quote case.
-	  //
-	  debug_printf ("spath: %s", spath);
-	  if (spath[1] == '/')
-	    {
-	      retpathcpy ("'");
-	      char *tpath = strchr(&spath[1], '\'');
-	      if (tpath)
-		*tpath = (char)NULL;
-	      char *swin32_path = arg_heuristic (&spath[1]);
-	      if (swin32_path == &spath[1])
-		{
-		  debug_printf("returning: %s", arg);
-		  return ((char *)arg);
-		}
-	      retpathcat (swin32_path);
-	      free (swin32_path);
-	      if (tpath)
-		retpathcat ("'");
-	      return ScrubRetpath (retpath);
-	    }
-	  debug_printf("returning: %s", arg);
-	  return ((char *)arg);
-	default:
-	  //
-	  // This takes care of variable_foo=/bar/baz
-	  //
-	  if ((sspath = strchr(spath, '=')) && (sspath[1] == '/'))
-	    {
-	      sspath[1] = '\0';
-	      retpathcpy (spath);
-	      sspath[1] = '/';
-	      char *swin32_path = arg_heuristic (&sspath[1]);
-	      if (swin32_path == &sspath[1])
-		{
-		  debug_printf("returning: %s", arg);
-		  return ((char *)arg);
-		}
-	      retpathcat (swin32_path);
-	      free (swin32_path);
-	      return ScrubRetpath (retpath);
-	    }
-	  //
-	  // Oh well, nothing special found, set win32_path same as path.
-	  //
-	  debug_printf("returning: %s", arg);
-	  return ((char *)arg);
-	}
-      }
-    }
-  // I should not get to this point.
-  assert (false);
-  debug_printf("returning: %s", arg);
-  return ScrubRetpath (retpath);
+      memmove(semisemi, semisemi+1, strlen(semisemi));
+      semisemi = strstr(semisemi, ";;");
+    }
+  return arg_result;
 }
 
 extern "C" char *
