diff -Naur binutils-2.26/bfd/coff-arm.c binutils-2.26.0007/bfd/coff-arm.c
--- binutils-2.26/bfd/coff-arm.c	2015-11-13 09:27:40.000000000 +0100
+++ binutils-2.26.0007/bfd/coff-arm.c	2016-03-10 17:02:24.170720241 +0100
@@ -146,7 +146,12 @@
       }
 
   /* Now let bfd_perform_relocation finish everything up.  */
+#ifndef ARM_WINNT
   return bfd_reloc_continue;
+#else
+  /* This seems to fix ARM_32 relocations */
+  return bfd_reloc_ok;
+#endif
 }
 
 /* If USER_LABEL_PREFIX is defined as "_" (see coff_arm_is_local_label_name()
@@ -163,15 +168,19 @@
 /* These most certainly belong somewhere else. Just had to get rid of
    the manifest constants in the code.  */
 
-#ifdef ARM_WINCE
+#if defined(ARM_WINCE) || defined(ARM_WINNT)
 
-#define ARM_26D      0
-#define ARM_32       1
-#define ARM_RVA32    2
-#define ARM_26	     3
-#define ARM_THUMB12  4
-#define ARM_SECTION  14
-#define ARM_SECREL   15
+#define ARM_26D        0
+#define ARM_32         1
+#define ARM_RVA32      2
+#define ARM_26         3
+#define ARM_THUMB12    4
+#define ARM_SECTION   14
+#define ARM_SECREL    15
+#define ARM_MOV32T    17
+#define ARM_BRANCH20T 18
+#define ARM_BRANCH24T 20
+#define ARM_BLX23T    21
 
 #else
 
@@ -193,21 +202,181 @@
 
 #endif
 
+#ifdef ARM_WINNT
+static bfd_reloc_status_type bfd_coff_generic_reloc
+  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
+static bfd_reloc_status_type coff_reloc_mov32t
+  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
+#else
 static bfd_reloc_status_type aoutarm_fix_pcrel_26_done
   (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
 static bfd_reloc_status_type aoutarm_fix_pcrel_26
   (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
 static bfd_reloc_status_type coff_thumb_pcrel_12
   (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
-#ifndef ARM_WINCE
+#endif
+#if ! defined(ARM_WINCE) && ! defined(ARM_WINNT)
 static bfd_reloc_status_type coff_thumb_pcrel_9
   (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
 static bfd_reloc_status_type coff_thumb_pcrel_23
   (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
 #endif
 
+#ifdef ARM_WINNT
+static bfd_reloc_status_type
+bfd_coff_generic_reloc (bfd *abfd ATTRIBUTE_UNUSED,
+                        arelent *reloc_entry,
+                        asymbol *symbol,
+                        void * data ATTRIBUTE_UNUSED,
+                        asection *input_section,
+                        bfd *output_bfd,
+                        char **error_message ATTRIBUTE_UNUSED)
+{
+  if (output_bfd != (bfd *) NULL
+      && (symbol->flags & BSF_SECTION_SYM) == 0)
+    {
+      reloc_entry->address += input_section->output_offset;
+      return bfd_reloc_ok;
+    }
+
+  return bfd_reloc_continue;
+}
+#endif
+
 static reloc_howto_type aoutarm_std_reloc_howto[] =
   {
+#ifdef ARM_WINNT
+    EMPTY_HOWTO (-1),
+    HOWTO (ARM_32,
+	   0,
+	   2,
+	   32,
+	   FALSE,
+	   0,
+	   complain_overflow_bitfield,
+	   coff_arm_reloc,
+	   "ARM_32",
+	   TRUE, 	/* partial_inplace.  */
+	   0xffffffff,
+	   0xffffffff,
+	   FALSE),
+    HOWTO (ARM_RVA32,
+	   0,
+	   2,
+	   32,
+	   FALSE,
+	   0,
+	   complain_overflow_bitfield,
+	   coff_arm_reloc,
+	   "ARM_RVA32",
+	   TRUE, 	/* partial_inplace.  */
+	   0xffffffff,
+	   0xffffffff,
+	   PCRELOFFSET),
+    EMPTY_HOWTO (-1),
+    HOWTO (ARM_THUMB12,
+	   1,
+	   1,
+	   11,
+	   TRUE,
+	   0,
+	   complain_overflow_signed,
+	   bfd_coff_generic_reloc,
+	   "ARM_THUMB12",
+	   FALSE,
+	   0x000007ff,
+	   0x000007ff,
+	   PCRELOFFSET),
+    EMPTY_HOWTO (-1),
+    EMPTY_HOWTO (-1),
+    EMPTY_HOWTO (-1),
+    EMPTY_HOWTO (-1),
+    EMPTY_HOWTO (-1),
+    EMPTY_HOWTO (-1),
+    EMPTY_HOWTO (-1),
+    EMPTY_HOWTO (-1),
+    EMPTY_HOWTO (-1),
+    HOWTO (ARM_SECTION,
+	   0,
+	   1,
+	   16,
+	   FALSE,
+	   0,
+	   complain_overflow_bitfield,
+	   coff_arm_reloc,
+	   "ARM_SECTION",
+	   TRUE, 	/* partial_inplace.  */
+	   0x0000ffff,
+	   0x0000ffff,
+	   PCRELOFFSET),
+    HOWTO (ARM_SECREL,
+	   0,
+	   2,
+	   32,
+	   FALSE,
+	   0,
+	   complain_overflow_bitfield,
+	   coff_arm_reloc,
+	   "ARM_SECREL",
+	   TRUE, 	/* partial_inplace.  */
+	   0xffffffff,
+	   0xffffffff,
+	   PCRELOFFSET),
+    EMPTY_HOWTO (-1), /* ARM_MOV32A */
+    HOWTO (ARM_MOV32T,
+	   0,
+	   4,
+	   64,
+	   FALSE,
+	   0,
+	   complain_overflow_bitfield,
+	   coff_reloc_mov32t,
+	   "ARM_MOV32T",
+	   FALSE, 	/* partial_inplace.  */
+	   0x040f70ff040f70ffll,
+	   0x040f70ff040f70ffll,
+	   FALSE),
+    HOWTO (ARM_BRANCH20T,
+	   1,
+	   2,
+	   19,
+	   TRUE,
+	   0,
+	   complain_overflow_bitfield,
+	   bfd_coff_generic_reloc,
+	   "ARM_BRANCH20T",
+	   FALSE, 	/* partial_inplace.  */
+	   0x043f2fff,
+	   0x043f2fff,
+	   PCRELOFFSET),
+    EMPTY_HOWTO (-1), /* unallocated */
+    HOWTO (ARM_BRANCH24T,
+	   1,
+	   2,
+	   24,
+	   TRUE,
+	   0,
+	   complain_overflow_bitfield,
+	   bfd_coff_generic_reloc,
+	   "ARM_BRANCH24T",
+	   FALSE, 	/* partial_inplace.  */
+	   0x07ff2fff,
+	   0x07ff2fff,
+	   PCRELOFFSET),
+    HOWTO (ARM_BLX23T,
+	   2,
+	   2,
+	   24,
+	   TRUE,
+	   0,
+	   complain_overflow_bitfield,
+	   bfd_coff_generic_reloc,
+	   "ARM_BLX23T",
+	   FALSE, 	/* partial_inplace.  */
+	   0x07ff2fff,
+	   0x07ff2fff,
+	   PCRELOFFSET),
+#endif
 #ifdef ARM_WINCE
     HOWTO (ARM_26D,
 	   2,
@@ -309,7 +478,8 @@
 	   0xffffffff,
 	   0xffffffff,
 	   PCRELOFFSET),
-#else /* not ARM_WINCE */
+#endif
+#if ! defined(ARM_WINCE) && ! defined(ARM_WINNT)
     HOWTO (ARM_8,
 	   0,
 	   0,
@@ -494,7 +664,7 @@
 	   0x07ff07ff,
 	   0x07ff07ff,
 	   PCRELOFFSET)
-#endif /* not ARM_WINCE */
+#endif
   };
 
 #define NUM_RELOCS NUM_ELEM (aoutarm_std_reloc_howto)
@@ -537,7 +707,7 @@
   if (rel->r_type == ARM_RVA32)
     *addendp -= pe_data (sec->output_section->owner)->pe_opthdr.ImageBase;
 
-#if defined COFF_WITH_PE && defined ARM_WINCE
+#if defined COFF_WITH_PE && (defined(ARM_WINCE) || defined(ARM_WINNT))
   if (rel->r_type == ARM_SECREL)
     {
       bfd_vma osect_vma;
@@ -565,6 +735,22 @@
   return howto;
 }
 
+#ifdef ARM_WINNT
+/* Used by the assembler.  */
+
+static bfd_reloc_status_type
+coff_reloc_mov32t (bfd *abfd ATTRIBUTE_UNUSED,
+		   arelent *reloc_entry ATTRIBUTE_UNUSED,
+		   asymbol *symbol ATTRIBUTE_UNUSED,
+		   void * data ATTRIBUTE_UNUSED,
+		   asection *input_section ATTRIBUTE_UNUSED,
+		   bfd *output_bfd ATTRIBUTE_UNUSED,
+		   char **error_message ATTRIBUTE_UNUSED)
+{
+  /* This is dead simple at present.  */
+  return bfd_reloc_ok;
+}
+#else
 /* Used by the assembler.  */
 
 static bfd_reloc_status_type
@@ -808,6 +994,7 @@
                                   input_section, output_bfd, error_message,
 				  b12);
 }
+#endif /* not ARM_WINNT */
 
 static const struct reloc_howto_struct *
 coff_arm_reloc_type_lookup (bfd * abfd, bfd_reloc_code_real_type code)
@@ -826,10 +1013,20 @@
 
   switch (code)
     {
+#ifdef ARM_WINNT
+      ASTD (BFD_RELOC_THUMB_PCREL_BRANCH23, ARM_BLX23T);
+      ASTD (BFD_RELOC_THUMB_PCREL_BLX,      ARM_BLX23T);
+      ASTD (BFD_RELOC_THUMB_PCREL_BRANCH25, ARM_BRANCH24T);
+      ASTD (BFD_RELOC_THUMB_PCREL_BRANCH20, ARM_BRANCH20T);
+      ASTD (BFD_RELOC_ARM_THUMB_MOVW,       ARM_MOV32T);
+      ASTD (BFD_RELOC_ARM_PCREL_BRANCH,     ARM_BLX23T);
+#endif
 #ifdef ARM_WINCE
+      ASTD (BFD_RELOC_ARM_PCREL_BRANCH,     ARM_26);
+#endif
+#if defined(ARM_WINCE) || defined(ARM_WINNT)
       ASTD (BFD_RELOC_32,                   ARM_32);
       ASTD (BFD_RELOC_RVA,                  ARM_RVA32);
-      ASTD (BFD_RELOC_ARM_PCREL_BRANCH,     ARM_26);
       ASTD (BFD_RELOC_THUMB_PCREL_BRANCH12, ARM_THUMB12);
       ASTD (BFD_RELOC_32_SECREL,            ARM_SECREL);
 #else
@@ -876,7 +1073,7 @@
 #define BADMAG(x)             ARMBADMAG(x)
 #define ARM                   1			/* Customize coffcode.h.  */
 
-#ifndef ARM_WINCE
+#if ! defined(ARM_WINCE) && ! defined(ARM_WINNT)
 /* Make sure that the 'r_offset' field is copied properly
    so that identical binaries will compare the same.  */
 #define SWAP_IN_RELOC_OFFSET	H_GET_32
@@ -952,7 +1149,7 @@
   return FALSE;
 }
 
-#ifndef ARM_WINCE
+#if ! defined(ARM_WINCE) && ! defined(ARM_WINNT)
 /* The thumb form of a long branch is a bit finicky, because the offset
    encoding is split over two fields, each in it's own instruction. They
    can occur in any order. So given a thumb form of long branch, and an
@@ -1036,7 +1233,7 @@
 
   return myh;
 }
-#endif /* not ARM_WINCE */
+#endif /* not ARM_WINCE && not ARM_WINNT*/
 
 static struct coff_link_hash_entry *
 find_arm_glue (struct bfd_link_info *info,
@@ -1101,7 +1298,7 @@
 */
 
 #define THUMB2ARM_GLUE_SIZE (globals->support_old_code ? 20 : 8)
-#ifndef ARM_WINCE
+#if ! defined(ARM_WINCE) && ! defined(ARM_WINNT)
 static const insn16 t2a1_bx_pc_insn = 0x4778;
 static const insn16 t2a2_noop_insn  = 0x46c0;
 static const insn32 t2a3_b_insn     = 0xea000000;
@@ -1214,6 +1411,7 @@
       if (howto == NULL)
 	return FALSE;
 
+#ifndef ARM_WINNT
       /* The relocation_section function will skip pcrel_offset relocs
          when doing a relocatable link.  However, we want to convert
          ARM_26 to ARM_26D relocs if possible.  We return a fake howto in
@@ -1258,7 +1456,7 @@
       if (howto->pc_relative && !bfd_link_relocatable (info))
 	addend -= 8;
 #endif
-
+#endif
       /* If we are doing a relocatable link, then we can just ignore
          a PC relative reloc that is pcrel_offset.  It will already
          have the correct value.  If this is not a relocatable link,
@@ -1408,7 +1606,7 @@
 		    }
                 }
 
-#ifndef ARM_WINCE
+#if ! defined(ARM_WINCE) && ! defined(ARM_WINNT)
 	      /* Note: We used to check for ARM_THUMB9 and ARM_THUMB12.  */
               else if (howto->type == ARM_THUMB23)
                 {
@@ -1877,7 +2075,7 @@
   return;
 }
 
-#ifndef ARM_WINCE
+#if ! defined(ARM_WINCE) && ! defined(ARM_WINNT)
 static void
 record_thumb_to_arm_glue (struct bfd_link_info *        info,
 			  struct coff_link_hash_entry * h)
@@ -1952,7 +2150,7 @@
 
   return;
 }
-#endif /* not ARM_WINCE */
+#endif /* not ARM_WINCE && not ARM_WINNT */
 
 /* Select a BFD to be used to hold the sections used by the glue code.
    This function is called from the linker scripts in ld/emultempl/
@@ -2093,7 +2291,7 @@
 		record_arm_to_thumb_glue (info, h);
 	      break;
 
-#ifndef ARM_WINCE
+#if ! defined(ARM_WINCE) && ! defined(ARM_WINNT)
 	    case ARM_THUMB23:
 	      /* This one is a call from thumb code.  We used to look
 		 for ARM_THUMB9 and ARM_THUMB12 as well.  We need to look
diff -Naur binutils-2.26/bfd/coffcode.h binutils-2.26.0007/bfd/coffcode.h
--- binutils-2.26/bfd/coffcode.h	2015-11-13 09:27:40.000000000 +0100
+++ binutils-2.26.0007/bfd/coffcode.h	2016-03-10 17:02:24.180720021 +0100
@@ -2142,10 +2142,14 @@
     case ARMMAGIC:
     case ARMPEMAGIC:
     case THUMBPEMAGIC:
+    case ARMNTPEMAGIC:
       arch = bfd_arch_arm;
       machine = bfd_arm_get_mach_from_notes (abfd, ARM_NOTE_SECTION);
       if (machine == bfd_mach_arm_unknown)
 	{
+#ifdef ARM_WINNT
+	  machine = bfd_mach_arm_XScale;
+#else
 	  switch (internal_f->f_flags & F_ARM_ARCHITECTURE_MASK)
 	    {
 	    case F_ARM_2:  machine = bfd_mach_arm_2;  break;
@@ -2162,6 +2166,7 @@
 		 currently the XScale.  */
 	    case F_ARM_5:  machine = bfd_mach_arm_XScale;  break;
 	    }
+#endif
 	}
       break;
 #endif
@@ -2920,12 +2925,17 @@
 
 #ifdef ARMMAGIC
     case bfd_arch_arm:
+#ifdef ARM_WINNT
+      * magicp = ARMNTPEMAGIC;
+#endif
 #ifdef ARM_WINCE
       * magicp = ARMPEMAGIC;
-#else
+#endif
+#if ! defined(ARM_WINCE) && ! defined(ARM_WINNT)
       * magicp = ARMMAGIC;
 #endif
       * flagsp = 0;
+#ifndef ARM_WINNT
       if (APCS_SET (abfd))
 	{
 	  if (APCS_26_FLAG (abfd))
@@ -2954,6 +2964,7 @@
 	case bfd_mach_arm_5TE: * flagsp |= F_ARM_5; break;
 	case bfd_mach_arm_XScale: * flagsp |= F_ARM_5; break;
 	}
+#endif
       return TRUE;
 #endif
 
@@ -3165,8 +3176,12 @@
 #ifdef COFF_IMAGE_WITH_PE
   int page_size;
 
+#ifdef ARM_WINNT
+  if (coff_data (abfd)->link_info)
+#else 
   if (coff_data (abfd)->link_info
       || (pe_data (abfd) && pe_data (abfd)->pe_opthdr.FileAlignment))
+#endif
     {
       page_size = pe_data (abfd)->pe_opthdr.FileAlignment;
 
@@ -5445,6 +5460,10 @@
 }
 #endif
 
+#ifndef coff_bfd_link_hash_table_free
+#define coff_bfd_link_hash_table_free _bfd_generic_link_hash_table_free
+#endif
+
 /* If coff_relocate_section is defined, we can use the optimized COFF
    backend linker.  Otherwise we must continue to use the old linker.  */
 
diff -Naur binutils-2.26/bfd/coffcode.h.orig binutils-2.26.0007/bfd/coffcode.h.orig
--- binutils-2.26/bfd/coffcode.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.26.0007/bfd/coffcode.h.orig	2016-03-10 17:01:56.041339687 +0100
@@ -0,0 +1,6177 @@
+/* Support for the generic parts of most COFF variants, for BFD.
+   Copyright (C) 1990-2015 Free Software Foundation, Inc.
+   Written by Cygnus Support.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+/* Most of this hacked by  Steve Chamberlain,
+			sac@cygnus.com.  */
+/*
+SECTION
+	coff backends
+
+	BFD supports a number of different flavours of coff format.
+	The major differences between formats are the sizes and
+	alignments of fields in structures on disk, and the occasional
+	extra field.
+
+	Coff in all its varieties is implemented with a few common
+	files and a number of implementation specific files. For
+	example, The 88k bcs coff format is implemented in the file
+	@file{coff-m88k.c}. This file @code{#include}s
+	@file{coff/m88k.h} which defines the external structure of the
+	coff format for the 88k, and @file{coff/internal.h} which
+	defines the internal structure. @file{coff-m88k.c} also
+	defines the relocations used by the 88k format
+	@xref{Relocations}.
+
+	The Intel i960 processor version of coff is implemented in
+	@file{coff-i960.c}. This file has the same structure as
+	@file{coff-m88k.c}, except that it includes @file{coff/i960.h}
+	rather than @file{coff-m88k.h}.
+
+SUBSECTION
+	Porting to a new version of coff
+
+	The recommended method is to select from the existing
+	implementations the version of coff which is most like the one
+	you want to use.  For example, we'll say that i386 coff is
+	the one you select, and that your coff flavour is called foo.
+	Copy @file{i386coff.c} to @file{foocoff.c}, copy
+	@file{../include/coff/i386.h} to @file{../include/coff/foo.h},
+	and add the lines to @file{targets.c} and @file{Makefile.in}
+	so that your new back end is used. Alter the shapes of the
+	structures in @file{../include/coff/foo.h} so that they match
+	what you need. You will probably also have to add
+	@code{#ifdef}s to the code in @file{coff/internal.h} and
+	@file{coffcode.h} if your version of coff is too wild.
+
+	You can verify that your new BFD backend works quite simply by
+	building @file{objdump} from the @file{binutils} directory,
+	and making sure that its version of what's going on and your
+	host system's idea (assuming it has the pretty standard coff
+	dump utility, usually called @code{att-dump} or just
+	@code{dump}) are the same.  Then clean up your code, and send
+	what you've done to Cygnus. Then your stuff will be in the
+	next release, and you won't have to keep integrating it.
+
+SUBSECTION
+	How the coff backend works
+
+SUBSUBSECTION
+	File layout
+
+	The Coff backend is split into generic routines that are
+	applicable to any Coff target and routines that are specific
+	to a particular target.  The target-specific routines are
+	further split into ones which are basically the same for all
+	Coff targets except that they use the external symbol format
+	or use different values for certain constants.
+
+	The generic routines are in @file{coffgen.c}.  These routines
+	work for any Coff target.  They use some hooks into the target
+	specific code; the hooks are in a @code{bfd_coff_backend_data}
+	structure, one of which exists for each target.
+
+	The essentially similar target-specific routines are in
+	@file{coffcode.h}.  This header file includes executable C code.
+	The various Coff targets first include the appropriate Coff
+	header file, make any special defines that are needed, and
+	then include @file{coffcode.h}.
+
+	Some of the Coff targets then also have additional routines in
+	the target source file itself.
+
+	For example, @file{coff-i960.c} includes
+	@file{coff/internal.h} and @file{coff/i960.h}.  It then
+	defines a few constants, such as @code{I960}, and includes
+	@file{coffcode.h}.  Since the i960 has complex relocation
+	types, @file{coff-i960.c} also includes some code to
+	manipulate the i960 relocs.  This code is not in
+	@file{coffcode.h} because it would not be used by any other
+	target.
+
+SUBSUBSECTION
+	Coff long section names
+
+	In the standard Coff object format, section names are limited to
+	the eight bytes available in the @code{s_name} field of the
+	@code{SCNHDR} section header structure.  The format requires the
+	field to be NUL-padded, but not necessarily NUL-terminated, so
+	the longest section names permitted are a full eight characters.
+
+	The Microsoft PE variants of the Coff object file format add
+	an extension to support the use of long section names.  This
+	extension is defined in section 4 of the Microsoft PE/COFF
+	specification (rev 8.1).  If a section name is too long to fit
+	into the section header's @code{s_name} field, it is instead
+	placed into the string table, and the @code{s_name} field is
+	filled with a slash ("/") followed by the ASCII decimal
+	representation of the offset of the full name relative to the
+	string table base.
+
+	Note that this implies that the extension can only be used in object
+	files, as executables do not contain a string table.  The standard
+	specifies that long section names from objects emitted into executable
+	images are to be truncated.
+
+	However, as a GNU extension, BFD can generate executable images
+	that contain a string table and long section names.  This
+	would appear to be technically valid, as the standard only says
+	that Coff debugging information is deprecated, not forbidden,
+	and in practice it works, although some tools that parse PE files
+	expecting the MS standard format may become confused; @file{PEview} is
+	one known example.
+
+	The functionality is supported in BFD by code implemented under
+	the control of the macro @code{COFF_LONG_SECTION_NAMES}.  If not
+	defined, the format does not support long section names in any way.
+	If defined, it is used to initialise a flag,
+	@code{_bfd_coff_long_section_names}, and a hook function pointer,
+	@code{_bfd_coff_set_long_section_names}, in the Coff backend data
+	structure.  The flag controls the generation of long section names
+	in output BFDs at runtime; if it is false, as it will be by default
+	when generating an executable image, long section names are truncated;
+	if true, the long section names extension is employed.  The hook
+	points to a function that allows the value of the flag to be altered
+	at runtime, on formats that support long section names at all; on
+	other formats it points to a stub that returns an error indication.
+
+	With input BFDs, the flag is set according to whether any long section
+	names are detected while reading the section headers.  For a completely
+	new BFD, the flag is set to the default for the target format.  This
+	information can be used by a client of the BFD library when deciding
+	what output format to generate, and means that a BFD that is opened
+	for read and subsequently converted to a writeable BFD and modified
+	in-place will retain whatever format it had on input.
+
+	If @code{COFF_LONG_SECTION_NAMES} is simply defined (blank), or is
+	defined to the value "1", then long section names are enabled by
+	default; if it is defined to the value zero, they are disabled by
+	default (but still accepted in input BFDs).  The header @file{coffcode.h}
+	defines a macro, @code{COFF_DEFAULT_LONG_SECTION_NAMES}, which is
+	used in the backends to initialise the backend data structure fields
+	appropriately; see the comments for further detail.
+
+SUBSUBSECTION
+	Bit twiddling
+
+	Each flavour of coff supported in BFD has its own header file
+	describing the external layout of the structures. There is also
+	an internal description of the coff layout, in
+	@file{coff/internal.h}. A major function of the
+	coff backend is swapping the bytes and twiddling the bits to
+	translate the external form of the structures into the normal
+	internal form. This is all performed in the
+	@code{bfd_swap}_@i{thing}_@i{direction} routines. Some
+	elements are different sizes between different versions of
+	coff; it is the duty of the coff version specific include file
+	to override the definitions of various packing routines in
+	@file{coffcode.h}. E.g., the size of line number entry in coff is
+	sometimes 16 bits, and sometimes 32 bits. @code{#define}ing
+	@code{PUT_LNSZ_LNNO} and @code{GET_LNSZ_LNNO} will select the
+	correct one. No doubt, some day someone will find a version of
+	coff which has a varying field size not catered to at the
+	moment. To port BFD, that person will have to add more @code{#defines}.
+	Three of the bit twiddling routines are exported to
+	@code{gdb}; @code{coff_swap_aux_in}, @code{coff_swap_sym_in}
+	and @code{coff_swap_lineno_in}. @code{GDB} reads the symbol
+	table on its own, but uses BFD to fix things up.  More of the
+	bit twiddlers are exported for @code{gas};
+	@code{coff_swap_aux_out}, @code{coff_swap_sym_out},
+	@code{coff_swap_lineno_out}, @code{coff_swap_reloc_out},
+	@code{coff_swap_filehdr_out}, @code{coff_swap_aouthdr_out},
+	@code{coff_swap_scnhdr_out}. @code{Gas} currently keeps track
+	of all the symbol table and reloc drudgery itself, thereby
+	saving the internal BFD overhead, but uses BFD to swap things
+	on the way out, making cross ports much safer.  Doing so also
+	allows BFD (and thus the linker) to use the same header files
+	as @code{gas}, which makes one avenue to disaster disappear.
+
+SUBSUBSECTION
+	Symbol reading
+
+	The simple canonical form for symbols used by BFD is not rich
+	enough to keep all the information available in a coff symbol
+	table. The back end gets around this problem by keeping the original
+	symbol table around, "behind the scenes".
+
+	When a symbol table is requested (through a call to
+	@code{bfd_canonicalize_symtab}), a request gets through to
+	@code{coff_get_normalized_symtab}. This reads the symbol table from
+	the coff file and swaps all the structures inside into the
+	internal form. It also fixes up all the pointers in the table
+	(represented in the file by offsets from the first symbol in
+	the table) into physical pointers to elements in the new
+	internal table. This involves some work since the meanings of
+	fields change depending upon context: a field that is a
+	pointer to another structure in the symbol table at one moment
+	may be the size in bytes of a structure at the next.  Another
+	pass is made over the table. All symbols which mark file names
+	(<<C_FILE>> symbols) are modified so that the internal
+	string points to the value in the auxent (the real filename)
+	rather than the normal text associated with the symbol
+	(@code{".file"}).
+
+	At this time the symbol names are moved around. Coff stores
+	all symbols less than nine characters long physically
+	within the symbol table; longer strings are kept at the end of
+	the file in the string table. This pass moves all strings
+	into memory and replaces them with pointers to the strings.
+
+	The symbol table is massaged once again, this time to create
+	the canonical table used by the BFD application. Each symbol
+	is inspected in turn, and a decision made (using the
+	@code{sclass} field) about the various flags to set in the
+	@code{asymbol}.  @xref{Symbols}. The generated canonical table
+	shares strings with the hidden internal symbol table.
+
+	Any linenumbers are read from the coff file too, and attached
+	to the symbols which own the functions the linenumbers belong to.
+
+SUBSUBSECTION
+	Symbol writing
+
+	Writing a symbol to a coff file which didn't come from a coff
+	file will lose any debugging information. The @code{asymbol}
+	structure remembers the BFD from which the symbol was taken, and on
+	output the back end makes sure that the same destination target as
+	source target is present.
+
+	When the symbols have come from a coff file then all the
+	debugging information is preserved.
+
+	Symbol tables are provided for writing to the back end in a
+	vector of pointers to pointers. This allows applications like
+	the linker to accumulate and output large symbol tables
+	without having to do too much byte copying.
+
+	This function runs through the provided symbol table and
+	patches each symbol marked as a file place holder
+	(@code{C_FILE}) to point to the next file place holder in the
+	list. It also marks each @code{offset} field in the list with
+	the offset from the first symbol of the current symbol.
+
+	Another function of this procedure is to turn the canonical
+	value form of BFD into the form used by coff. Internally, BFD
+	expects symbol values to be offsets from a section base; so a
+	symbol physically at 0x120, but in a section starting at
+	0x100, would have the value 0x20. Coff expects symbols to
+	contain their final value, so symbols have their values
+	changed at this point to reflect their sum with their owning
+	section.  This transformation uses the
+	<<output_section>> field of the @code{asymbol}'s
+	@code{asection} @xref{Sections}.
+
+	o <<coff_mangle_symbols>>
+
+	This routine runs though the provided symbol table and uses
+	the offsets generated by the previous pass and the pointers
+	generated when the symbol table was read in to create the
+	structured hierarchy required by coff. It changes each pointer
+	to a symbol into the index into the symbol table of the asymbol.
+
+	o <<coff_write_symbols>>
+
+	This routine runs through the symbol table and patches up the
+	symbols from their internal form into the coff way, calls the
+	bit twiddlers, and writes out the table to the file.
+
+*/
+
+/*
+INTERNAL_DEFINITION
+	coff_symbol_type
+
+DESCRIPTION
+	The hidden information for an <<asymbol>> is described in a
+	<<combined_entry_type>>:
+
+CODE_FRAGMENT
+.
+.typedef struct coff_ptr_struct
+.{
+.  {* Remembers the offset from the first symbol in the file for
+.     this symbol. Generated by coff_renumber_symbols.  *}
+.  unsigned int offset;
+.
+.  {* Should the value of this symbol be renumbered.  Used for
+.     XCOFF C_BSTAT symbols.  Set by coff_slurp_symbol_table.  *}
+.  unsigned int fix_value : 1;
+.
+.  {* Should the tag field of this symbol be renumbered.
+.     Created by coff_pointerize_aux.  *}
+.  unsigned int fix_tag : 1;
+.
+.  {* Should the endidx field of this symbol be renumbered.
+.     Created by coff_pointerize_aux.  *}
+.  unsigned int fix_end : 1;
+.
+.  {* Should the x_csect.x_scnlen field be renumbered.
+.     Created by coff_pointerize_aux.  *}
+.  unsigned int fix_scnlen : 1;
+.
+.  {* Fix up an XCOFF C_BINCL/C_EINCL symbol.  The value is the
+.     index into the line number entries.  Set by coff_slurp_symbol_table.  *}
+.  unsigned int fix_line : 1;
+.
+.  {* The container for the symbol structure as read and translated
+.     from the file.  *}
+.  union
+.  {
+.    union internal_auxent auxent;
+.    struct internal_syment syment;
+.  } u;
+.
+. {* Selector for the union above.  *}
+. bfd_boolean is_sym;
+.} combined_entry_type;
+.
+.
+.{* Each canonical asymbol really looks like this: *}
+.
+.typedef struct coff_symbol_struct
+.{
+.  {* The actual symbol which the rest of BFD works with *}
+.  asymbol symbol;
+.
+.  {* A pointer to the hidden information for this symbol *}
+.  combined_entry_type *native;
+.
+.  {* A pointer to the linenumber information for this symbol *}
+.  struct lineno_cache_entry *lineno;
+.
+.  {* Have the line numbers been relocated yet ? *}
+.  bfd_boolean done_lineno;
+.} coff_symbol_type;
+
+*/
+
+#include "libiberty.h"
+
+#ifdef COFF_WITH_PE
+#include "peicode.h"
+#else
+#include "coffswap.h"
+#endif
+
+#define STRING_SIZE_SIZE 4
+
+#define DOT_DEBUG	".debug"
+#define DOT_ZDEBUG	".zdebug"
+#define GNU_LINKONCE_WI ".gnu.linkonce.wi."
+#define GNU_LINKONCE_WT ".gnu.linkonce.wt."
+#define DOT_RELOC	".reloc"
+
+#if defined (COFF_LONG_SECTION_NAMES)
+/* Needed to expand the inputs to BLANKOR1TOODD.  */
+#define COFFLONGSECTIONCATHELPER(x,y)    x ## y
+/* If the input macro Y is blank or '1', return an odd number; if it is
+   '0', return an even number.  Result undefined in all other cases.  */
+#define BLANKOR1TOODD(y)                 COFFLONGSECTIONCATHELPER(1,y)
+/* Defined to numerical 0 or 1 according to whether generation of long
+   section names is disabled or enabled by default.  */
+#define COFF_ENABLE_LONG_SECTION_NAMES   (BLANKOR1TOODD(COFF_LONG_SECTION_NAMES) & 1)
+/* Where long section names are supported, we allow them to be enabled
+   and disabled at runtime, so select an appropriate hook function for
+   _bfd_coff_set_long_section_names.  */
+#define COFF_LONG_SECTION_NAMES_SETTER   bfd_coff_set_long_section_names_allowed
+#else /* !defined (COFF_LONG_SECTION_NAMES) */
+/* If long section names are not supported, this stub disallows any
+   attempt to enable them at run-time.  */
+#define COFF_LONG_SECTION_NAMES_SETTER   bfd_coff_set_long_section_names_disallowed
+#endif /* defined (COFF_LONG_SECTION_NAMES) */
+
+/* Define a macro that can be used to initialise both the fields relating
+   to long section names in the backend data struct simultaneously.  */
+#if COFF_ENABLE_LONG_SECTION_NAMES
+#define COFF_DEFAULT_LONG_SECTION_NAMES  (TRUE), COFF_LONG_SECTION_NAMES_SETTER
+#else /* !COFF_ENABLE_LONG_SECTION_NAMES */
+#define COFF_DEFAULT_LONG_SECTION_NAMES  (FALSE), COFF_LONG_SECTION_NAMES_SETTER
+#endif /* COFF_ENABLE_LONG_SECTION_NAMES */
+
+#if defined (COFF_LONG_SECTION_NAMES)
+static bfd_boolean bfd_coff_set_long_section_names_allowed
+  (bfd *, int);
+#else /* !defined (COFF_LONG_SECTION_NAMES) */
+static bfd_boolean bfd_coff_set_long_section_names_disallowed
+  (bfd *, int);
+#endif /* defined (COFF_LONG_SECTION_NAMES) */
+static long sec_to_styp_flags
+  (const char *, flagword);
+static bfd_boolean styp_to_sec_flags
+  (bfd *, void *, const char *, asection *, flagword *);
+static bfd_boolean coff_bad_format_hook
+  (bfd *, void *);
+static void coff_set_custom_section_alignment
+  (bfd *, asection *, const struct coff_section_alignment_entry *,
+   const unsigned int);
+static bfd_boolean coff_new_section_hook
+  (bfd *, asection *);
+static bfd_boolean coff_set_arch_mach_hook
+  (bfd *, void *);
+static bfd_boolean coff_write_relocs
+  (bfd *, int);
+static bfd_boolean coff_set_flags
+  (bfd *, unsigned int *, unsigned short *);
+static bfd_boolean coff_set_arch_mach
+  (bfd *, enum bfd_architecture, unsigned long) ATTRIBUTE_UNUSED;
+static bfd_boolean coff_compute_section_file_positions
+  (bfd *);
+static bfd_boolean coff_write_object_contents
+  (bfd *) ATTRIBUTE_UNUSED;
+static bfd_boolean coff_set_section_contents
+  (bfd *, asection *, const void *, file_ptr, bfd_size_type);
+static void * buy_and_read
+  (bfd *, file_ptr, bfd_size_type);
+static bfd_boolean coff_slurp_line_table
+  (bfd *, asection *);
+static bfd_boolean coff_slurp_symbol_table
+  (bfd *);
+static enum coff_symbol_classification coff_classify_symbol
+  (bfd *, struct internal_syment *);
+static bfd_boolean coff_slurp_reloc_table
+  (bfd *, asection *, asymbol **);
+static long coff_canonicalize_reloc
+  (bfd *, asection *, arelent **, asymbol **);
+#ifndef coff_mkobject_hook
+static void * coff_mkobject_hook
+  (bfd *, void *,  void *);
+#endif
+#ifdef COFF_WITH_PE
+static flagword handle_COMDAT
+  (bfd *, flagword, void *, const char *, asection *);
+#endif
+#ifdef COFF_IMAGE_WITH_PE
+static bfd_boolean coff_read_word
+  (bfd *, unsigned int *);
+static unsigned int coff_compute_checksum
+  (bfd *);
+static bfd_boolean coff_apply_checksum
+  (bfd *);
+#endif
+#ifdef TICOFF
+static bfd_boolean ticoff0_bad_format_hook
+  (bfd *, void * );
+static bfd_boolean ticoff1_bad_format_hook
+  (bfd *, void * );
+#endif
+
+/* void warning(); */
+
+#if defined (COFF_LONG_SECTION_NAMES)
+static bfd_boolean
+bfd_coff_set_long_section_names_allowed (bfd *abfd, int enable)
+{
+  coff_backend_info (abfd)->_bfd_coff_long_section_names = enable;
+  return TRUE;
+}
+#else /* !defined (COFF_LONG_SECTION_NAMES) */
+static bfd_boolean
+bfd_coff_set_long_section_names_disallowed (bfd *abfd, int enable)
+{
+  (void) abfd;
+  (void) enable;
+  return FALSE;
+}
+#endif /* defined (COFF_LONG_SECTION_NAMES) */
+
+/* Return a word with STYP_* (scnhdr.s_flags) flags set to represent
+   the incoming SEC_* flags.  The inverse of this function is
+   styp_to_sec_flags().  NOTE: If you add to/change this routine, you
+   should probably mirror the changes in styp_to_sec_flags().  */
+
+#ifndef COFF_WITH_PE
+
+/* Macros for setting debugging flags.  */
+
+#ifdef STYP_DEBUG
+#define STYP_XCOFF_DEBUG STYP_DEBUG
+#else
+#define STYP_XCOFF_DEBUG STYP_INFO
+#endif
+
+#ifdef COFF_ALIGN_IN_S_FLAGS
+#define STYP_DEBUG_INFO STYP_DSECT
+#else
+#define STYP_DEBUG_INFO STYP_INFO
+#endif
+
+static long
+sec_to_styp_flags (const char *sec_name, flagword sec_flags)
+{
+  long styp_flags = 0;
+
+  if (!strcmp (sec_name, _TEXT))
+    {
+      styp_flags = STYP_TEXT;
+    }
+  else if (!strcmp (sec_name, _DATA))
+    {
+      styp_flags = STYP_DATA;
+    }
+  else if (!strcmp (sec_name, _BSS))
+    {
+      styp_flags = STYP_BSS;
+#ifdef _COMMENT
+    }
+  else if (!strcmp (sec_name, _COMMENT))
+    {
+      styp_flags = STYP_INFO;
+#endif /* _COMMENT */
+#ifdef _LIB
+    }
+  else if (!strcmp (sec_name, _LIB))
+    {
+      styp_flags = STYP_LIB;
+#endif /* _LIB */
+#ifdef _LIT
+    }
+  else if (!strcmp (sec_name, _LIT))
+    {
+      styp_flags = STYP_LIT;
+#endif /* _LIT */
+    }
+  else if (CONST_STRNEQ (sec_name, DOT_DEBUG)
+           || CONST_STRNEQ (sec_name, DOT_ZDEBUG))
+    {
+      /* Handle the XCOFF debug section and DWARF2 debug sections.  */
+      if (!sec_name[6])
+	styp_flags = STYP_XCOFF_DEBUG;
+      else
+	styp_flags = STYP_DEBUG_INFO;
+    }
+  else if (CONST_STRNEQ (sec_name, ".stab"))
+    {
+      styp_flags = STYP_DEBUG_INFO;
+    }
+#ifdef COFF_LONG_SECTION_NAMES
+  else if (CONST_STRNEQ (sec_name, GNU_LINKONCE_WI)
+  	   || CONST_STRNEQ (sec_name, GNU_LINKONCE_WT))
+    {
+      styp_flags = STYP_DEBUG_INFO;
+    }
+#endif
+#ifdef RS6000COFF_C
+  else if (!strcmp (sec_name, _PAD))
+    {
+      styp_flags = STYP_PAD;
+    }
+  else if (!strcmp (sec_name, _LOADER))
+    {
+      styp_flags = STYP_LOADER;
+    }
+  else if (!strcmp (sec_name, _EXCEPT))
+    {
+      styp_flags = STYP_EXCEPT;
+    }
+  else if (!strcmp (sec_name, _TYPCHK))
+    {
+      styp_flags = STYP_TYPCHK;
+    }
+  else if (sec_flags & SEC_DEBUGGING)
+    {
+      int i;
+
+      for (i = 0; i < XCOFF_DWSECT_NBR_NAMES; i++)
+        if (!strcmp (sec_name, xcoff_dwsect_names[i].name))
+          {
+            styp_flags = STYP_DWARF | xcoff_dwsect_names[i].flag;
+            break;
+          }
+    }
+#endif
+  /* Try and figure out what it should be */
+  else if (sec_flags & SEC_CODE)
+    {
+      styp_flags = STYP_TEXT;
+    }
+  else if (sec_flags & SEC_DATA)
+    {
+      styp_flags = STYP_DATA;
+    }
+  else if (sec_flags & SEC_READONLY)
+    {
+#ifdef STYP_LIT			/* 29k readonly text/data section */
+      styp_flags = STYP_LIT;
+#else
+      styp_flags = STYP_TEXT;
+#endif /* STYP_LIT */
+    }
+  else if (sec_flags & SEC_LOAD)
+    {
+      styp_flags = STYP_TEXT;
+    }
+  else if (sec_flags & SEC_ALLOC)
+    {
+      styp_flags = STYP_BSS;
+    }
+
+#ifdef STYP_CLINK
+  if (sec_flags & SEC_TIC54X_CLINK)
+    styp_flags |= STYP_CLINK;
+#endif
+
+#ifdef STYP_BLOCK
+  if (sec_flags & SEC_TIC54X_BLOCK)
+    styp_flags |= STYP_BLOCK;
+#endif
+
+#ifdef STYP_NOLOAD
+  if ((sec_flags & (SEC_NEVER_LOAD | SEC_COFF_SHARED_LIBRARY)) != 0)
+    styp_flags |= STYP_NOLOAD;
+#endif
+
+  return styp_flags;
+}
+
+#else /* COFF_WITH_PE */
+
+/* The PE version; see above for the general comments.  The non-PE
+   case seems to be more guessing, and breaks PE format; specifically,
+   .rdata is readonly, but it sure ain't text.  Really, all this
+   should be set up properly in gas (or whatever assembler is in use),
+   and honor whatever objcopy/strip, etc. sent us as input.  */
+
+static long
+sec_to_styp_flags (const char *sec_name, flagword sec_flags)
+{
+  long styp_flags = 0;
+  bfd_boolean is_dbg = FALSE;
+
+  if (CONST_STRNEQ (sec_name, DOT_DEBUG)
+      || CONST_STRNEQ (sec_name, DOT_ZDEBUG)
+#ifdef COFF_LONG_SECTION_NAMES
+      || CONST_STRNEQ (sec_name, GNU_LINKONCE_WI)
+      || CONST_STRNEQ (sec_name, GNU_LINKONCE_WT)
+#endif
+      || CONST_STRNEQ (sec_name, ".stab"))
+    is_dbg = TRUE;
+
+  /* caution: there are at least three groups of symbols that have
+     very similar bits and meanings: IMAGE_SCN*, SEC_*, and STYP_*.
+     SEC_* are the BFD internal flags, used for generic BFD
+     information.  STYP_* are the COFF section flags which appear in
+     COFF files.  IMAGE_SCN_* are the PE section flags which appear in
+     PE files.  The STYP_* flags and the IMAGE_SCN_* flags overlap,
+     but there are more IMAGE_SCN_* flags.  */
+
+  /* FIXME: There is no gas syntax to specify the debug section flag.  */
+  if (is_dbg)
+    {
+      sec_flags &= (SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD
+      		    | SEC_LINK_DUPLICATES_SAME_CONTENTS
+      		    | SEC_LINK_DUPLICATES_SAME_SIZE);
+      sec_flags |= SEC_DEBUGGING | SEC_READONLY;
+    }
+
+  /* skip LOAD */
+  /* READONLY later */
+  /* skip RELOC */
+  if ((sec_flags & SEC_CODE) != 0)
+    styp_flags |= IMAGE_SCN_CNT_CODE;
+  if ((sec_flags & (SEC_DATA | SEC_DEBUGGING)) != 0)
+    styp_flags |= IMAGE_SCN_CNT_INITIALIZED_DATA;
+  if ((sec_flags & SEC_ALLOC) != 0 && (sec_flags & SEC_LOAD) == 0)
+    styp_flags |= IMAGE_SCN_CNT_UNINITIALIZED_DATA;  /* ==STYP_BSS */
+  /* skip ROM */
+  /* skip constRUCTOR */
+  /* skip CONTENTS */
+  if ((sec_flags & SEC_IS_COMMON) != 0)
+    styp_flags |= IMAGE_SCN_LNK_COMDAT;
+  if ((sec_flags & SEC_DEBUGGING) != 0)
+    styp_flags |= IMAGE_SCN_MEM_DISCARDABLE;
+  if ((sec_flags & SEC_EXCLUDE) != 0 && !is_dbg)
+    styp_flags |= IMAGE_SCN_LNK_REMOVE;
+  if ((sec_flags & SEC_NEVER_LOAD) != 0 && !is_dbg)
+    styp_flags |= IMAGE_SCN_LNK_REMOVE;
+  /* skip IN_MEMORY */
+  /* skip SORT */
+  if (sec_flags & SEC_LINK_ONCE)
+    styp_flags |= IMAGE_SCN_LNK_COMDAT;
+  if ((sec_flags
+       & (SEC_LINK_DUPLICATES_DISCARD | SEC_LINK_DUPLICATES_SAME_CONTENTS
+          | SEC_LINK_DUPLICATES_SAME_SIZE)) != 0)
+    styp_flags |= IMAGE_SCN_LNK_COMDAT;
+
+  /* skip LINKER_CREATED */
+
+  if ((sec_flags & SEC_COFF_NOREAD) == 0)
+    styp_flags |= IMAGE_SCN_MEM_READ;     /* Invert NOREAD for read.  */
+  if ((sec_flags & SEC_READONLY) == 0)
+    styp_flags |= IMAGE_SCN_MEM_WRITE;    /* Invert READONLY for write.  */
+  if (sec_flags & SEC_CODE)
+    styp_flags |= IMAGE_SCN_MEM_EXECUTE;  /* CODE->EXECUTE.  */
+  if (sec_flags & SEC_COFF_SHARED)
+    styp_flags |= IMAGE_SCN_MEM_SHARED;   /* Shared remains meaningful.  */
+
+  return styp_flags;
+}
+
+#endif /* COFF_WITH_PE */
+
+/* Return a word with SEC_* flags set to represent the incoming STYP_*
+   flags (from scnhdr.s_flags).  The inverse of this function is
+   sec_to_styp_flags().  NOTE: If you add to/change this routine, you
+   should probably mirror the changes in sec_to_styp_flags().  */
+
+#ifndef COFF_WITH_PE
+
+static bfd_boolean
+styp_to_sec_flags (bfd *abfd ATTRIBUTE_UNUSED,
+		   void * hdr,
+		   const char *name,
+		   asection *section ATTRIBUTE_UNUSED,
+		   flagword *flags_ptr)
+{
+  struct internal_scnhdr *internal_s = (struct internal_scnhdr *) hdr;
+  long styp_flags = internal_s->s_flags;
+  flagword sec_flags = 0;
+
+#ifdef STYP_BLOCK
+  if (styp_flags & STYP_BLOCK)
+    sec_flags |= SEC_TIC54X_BLOCK;
+#endif
+
+#ifdef STYP_CLINK
+  if (styp_flags & STYP_CLINK)
+    sec_flags |= SEC_TIC54X_CLINK;
+#endif
+
+#ifdef STYP_NOLOAD
+  if (styp_flags & STYP_NOLOAD)
+    sec_flags |= SEC_NEVER_LOAD;
+#endif /* STYP_NOLOAD */
+
+  /* For 386 COFF, at least, an unloadable text or data section is
+     actually a shared library section.  */
+  if (styp_flags & STYP_TEXT)
+    {
+      if (sec_flags & SEC_NEVER_LOAD)
+	sec_flags |= SEC_CODE | SEC_COFF_SHARED_LIBRARY;
+      else
+	sec_flags |= SEC_CODE | SEC_LOAD | SEC_ALLOC;
+    }
+  else if (styp_flags & STYP_DATA)
+    {
+      if (sec_flags & SEC_NEVER_LOAD)
+	sec_flags |= SEC_DATA | SEC_COFF_SHARED_LIBRARY;
+      else
+	sec_flags |= SEC_DATA | SEC_LOAD | SEC_ALLOC;
+    }
+  else if (styp_flags & STYP_BSS)
+    {
+#ifdef BSS_NOLOAD_IS_SHARED_LIBRARY
+      if (sec_flags & SEC_NEVER_LOAD)
+	sec_flags |= SEC_ALLOC | SEC_COFF_SHARED_LIBRARY;
+      else
+#endif
+	sec_flags |= SEC_ALLOC;
+    }
+  else if (styp_flags & STYP_INFO)
+    {
+      /* We mark these as SEC_DEBUGGING, but only if COFF_PAGE_SIZE is
+	 defined.  coff_compute_section_file_positions uses
+	 COFF_PAGE_SIZE to ensure that the low order bits of the
+	 section VMA and the file offset match.  If we don't know
+	 COFF_PAGE_SIZE, we can't ensure the correct correspondence,
+	 and demand page loading of the file will fail.  */
+#if defined (COFF_PAGE_SIZE) && !defined (COFF_ALIGN_IN_S_FLAGS)
+      sec_flags |= SEC_DEBUGGING;
+#endif
+    }
+  else if (styp_flags & STYP_PAD)
+    sec_flags = 0;
+#ifdef RS6000COFF_C
+  else if (styp_flags & STYP_EXCEPT)
+    sec_flags |= SEC_LOAD;
+  else if (styp_flags & STYP_LOADER)
+    sec_flags |= SEC_LOAD;
+  else if (styp_flags & STYP_TYPCHK)
+    sec_flags |= SEC_LOAD;
+  else if (styp_flags & STYP_DWARF)
+    sec_flags |= SEC_DEBUGGING;
+#endif
+  else if (strcmp (name, _TEXT) == 0)
+    {
+      if (sec_flags & SEC_NEVER_LOAD)
+	sec_flags |= SEC_CODE | SEC_COFF_SHARED_LIBRARY;
+      else
+	sec_flags |= SEC_CODE | SEC_LOAD | SEC_ALLOC;
+    }
+  else if (strcmp (name, _DATA) == 0)
+    {
+      if (sec_flags & SEC_NEVER_LOAD)
+	sec_flags |= SEC_DATA | SEC_COFF_SHARED_LIBRARY;
+      else
+	sec_flags |= SEC_DATA | SEC_LOAD | SEC_ALLOC;
+    }
+  else if (strcmp (name, _BSS) == 0)
+    {
+#ifdef BSS_NOLOAD_IS_SHARED_LIBRARY
+      if (sec_flags & SEC_NEVER_LOAD)
+	sec_flags |= SEC_ALLOC | SEC_COFF_SHARED_LIBRARY;
+      else
+#endif
+	sec_flags |= SEC_ALLOC;
+    }
+  else if (CONST_STRNEQ (name, DOT_DEBUG)
+	   || CONST_STRNEQ (name, DOT_ZDEBUG)
+#ifdef _COMMENT
+	   || strcmp (name, _COMMENT) == 0
+#endif
+#ifdef COFF_LONG_SECTION_NAMES
+	   || CONST_STRNEQ (name, GNU_LINKONCE_WI)
+	   || CONST_STRNEQ (name, GNU_LINKONCE_WT)
+#endif
+	   || CONST_STRNEQ (name, ".stab"))
+    {
+#ifdef COFF_PAGE_SIZE
+      sec_flags |= SEC_DEBUGGING;
+#endif
+    }
+#ifdef _LIB
+  else if (strcmp (name, _LIB) == 0)
+    ;
+#endif
+#ifdef _LIT
+  else if (strcmp (name, _LIT) == 0)
+    sec_flags = SEC_LOAD | SEC_ALLOC | SEC_READONLY;
+#endif
+  else
+    sec_flags |= SEC_ALLOC | SEC_LOAD;
+
+#ifdef STYP_LIT			/* A29k readonly text/data section type.  */
+  if ((styp_flags & STYP_LIT) == STYP_LIT)
+    sec_flags = (SEC_LOAD | SEC_ALLOC | SEC_READONLY);
+#endif /* STYP_LIT */
+
+#ifdef STYP_OTHER_LOAD		/* Other loaded sections.  */
+  if (styp_flags & STYP_OTHER_LOAD)
+    sec_flags = (SEC_LOAD | SEC_ALLOC);
+#endif /* STYP_SDATA */
+
+#if defined (COFF_LONG_SECTION_NAMES) && defined (COFF_SUPPORT_GNU_LINKONCE)
+  /* As a GNU extension, if the name begins with .gnu.linkonce, we
+     only link a single copy of the section.  This is used to support
+     g++.  g++ will emit each template expansion in its own section.
+     The symbols will be defined as weak, so that multiple definitions
+     are permitted.  The GNU linker extension is to actually discard
+     all but one of the sections.  */
+  if (CONST_STRNEQ (name, ".gnu.linkonce"))
+    sec_flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
+#endif
+
+  if (flags_ptr == NULL)
+    return FALSE;
+
+  * flags_ptr = sec_flags;
+  return TRUE;
+}
+
+#else /* COFF_WITH_PE */
+
+static flagword
+handle_COMDAT (bfd * abfd,
+	       flagword sec_flags,
+	       void * hdr,
+	       const char *name,
+	       asection *section)
+{
+  struct internal_scnhdr *internal_s = (struct internal_scnhdr *) hdr;
+  bfd_byte *esymstart, *esym, *esymend;
+  int seen_state = 0;
+  char *target_name = NULL;
+
+  sec_flags |= SEC_LINK_ONCE;
+
+  /* Unfortunately, the PE format stores essential information in
+     the symbol table, of all places.  We need to extract that
+     information now, so that objdump and the linker will know how
+     to handle the section without worrying about the symbols.  We
+     can't call slurp_symtab, because the linker doesn't want the
+     swapped symbols.  */
+
+  /* COMDAT sections are special.  The first symbol is the section
+     symbol, which tells what kind of COMDAT section it is.  The
+     second symbol is the "comdat symbol" - the one with the
+     unique name.  GNU uses the section symbol for the unique
+     name; MS uses ".text" for every comdat section.  Sigh.  - DJ */
+
+  /* This is not mirrored in sec_to_styp_flags(), but there
+     doesn't seem to be a need to, either, and it would at best be
+     rather messy.  */
+
+  if (! _bfd_coff_get_external_symbols (abfd))
+    return sec_flags;
+
+  esymstart = esym = (bfd_byte *) obj_coff_external_syms (abfd);
+  esymend = esym + obj_raw_syment_count (abfd) * bfd_coff_symesz (abfd);
+
+  while (esym < esymend)
+    {
+      struct internal_syment isym;
+      char buf[SYMNMLEN + 1];
+      const char *symname;
+
+      bfd_coff_swap_sym_in (abfd, esym, & isym);
+
+      BFD_ASSERT (sizeof (internal_s->s_name) <= SYMNMLEN);
+
+      if (isym.n_scnum == section->target_index)
+	{
+	  /* According to the MSVC documentation, the first
+	     TWO entries with the section # are both of
+	     interest to us.  The first one is the "section
+	     symbol" (section name).  The second is the comdat
+	     symbol name.  Here, we've found the first
+	     qualifying entry; we distinguish it from the
+	     second with a state flag.
+
+	     In the case of gas-generated (at least until that
+	     is fixed) .o files, it isn't necessarily the
+	     second one.  It may be some other later symbol.
+
+	     Since gas also doesn't follow MS conventions and
+	     emits the section similar to .text$<name>, where
+	     <something> is the name we're looking for, we
+	     distinguish the two as follows:
+
+	     If the section name is simply a section name (no
+	     $) we presume it's MS-generated, and look at
+	     precisely the second symbol for the comdat name.
+	     If the section name has a $, we assume it's
+	     gas-generated, and look for <something> (whatever
+	     follows the $) as the comdat symbol.  */
+
+	  /* All 3 branches use this.  */
+	  symname = _bfd_coff_internal_syment_name (abfd, &isym, buf);
+
+	  /* PR 17512 file: 078-11867-0.004  */
+	  if (symname == NULL)
+	    {
+	      _bfd_error_handler (_("%B: unable to load COMDAT section name"), abfd);
+	      break;
+	    }
+
+	  switch (seen_state)
+	    {
+	    case 0:
+	      {
+		/* The first time we've seen the symbol.  */
+		union internal_auxent aux;
+
+		/* If it isn't the stuff we're expecting, die;
+		   The MS documentation is vague, but it
+		   appears that the second entry serves BOTH
+		   as the comdat symbol and the defining
+		   symbol record (either C_STAT or C_EXT,
+		   possibly with an aux entry with debug
+		   information if it's a function.)  It
+		   appears the only way to find the second one
+		   is to count.  (On Intel, they appear to be
+		   adjacent, but on Alpha, they have been
+		   found separated.)
+
+		   Here, we think we've found the first one,
+		   but there's some checking we can do to be
+		   sure.  */
+
+		if (! ((isym.n_sclass == C_STAT
+			|| isym.n_sclass == C_EXT)
+		       && BTYPE (isym.n_type) == T_NULL
+		       && isym.n_value == 0))
+		  abort ();
+
+		/* FIXME LATER: MSVC generates section names
+		   like .text for comdats.  Gas generates
+		   names like .text$foo__Fv (in the case of a
+		   function).  See comment above for more.  */
+
+		if (isym.n_sclass == C_STAT && strcmp (name, symname) != 0)
+		  _bfd_error_handler (_("%B: warning: COMDAT symbol '%s' does not match section name '%s'"),
+				      abfd, symname, name);
+
+		seen_state = 1;
+
+		/* PR 17512: file: e2cfe54f.  */
+		if (esym + bfd_coff_symesz (abfd) >= esymend)
+		  {
+		    _bfd_error_handler (_("%B: warning: No symbol for section '%s' found"),
+					abfd, symname);
+		    break;
+		  }
+		/* This is the section symbol.  */
+		bfd_coff_swap_aux_in (abfd, (esym + bfd_coff_symesz (abfd)),
+				      isym.n_type, isym.n_sclass,
+				      0, isym.n_numaux, & aux);
+
+		target_name = strchr (name, '$');
+		if (target_name != NULL)
+		  {
+		    /* Gas mode.  */
+		    seen_state = 2;
+		    /* Skip the `$'.  */
+		    target_name += 1;
+		  }
+
+		/* FIXME: Microsoft uses NODUPLICATES and
+		   ASSOCIATIVE, but gnu uses ANY and
+		   SAME_SIZE.  Unfortunately, gnu doesn't do
+		   the comdat symbols right.  So, until we can
+		   fix it to do the right thing, we are
+		   temporarily disabling comdats for the MS
+		   types (they're used in DLLs and C++, but we
+		   don't support *their* C++ libraries anyway
+		   - DJ.  */
+
+		/* Cygwin does not follow the MS style, and
+		   uses ANY and SAME_SIZE where NODUPLICATES
+		   and ASSOCIATIVE should be used.  For
+		   Interix, we just do the right thing up
+		   front.  */
+
+		switch (aux.x_scn.x_comdat)
+		  {
+		  case IMAGE_COMDAT_SELECT_NODUPLICATES:
+#ifdef STRICT_PE_FORMAT
+		    sec_flags |= SEC_LINK_DUPLICATES_ONE_ONLY;
+#else
+		    sec_flags &= ~SEC_LINK_ONCE;
+#endif
+		    break;
+
+		  case IMAGE_COMDAT_SELECT_ANY:
+		    sec_flags |= SEC_LINK_DUPLICATES_DISCARD;
+		    break;
+
+		  case IMAGE_COMDAT_SELECT_SAME_SIZE:
+		    sec_flags |= SEC_LINK_DUPLICATES_SAME_SIZE;
+		    break;
+
+		  case IMAGE_COMDAT_SELECT_EXACT_MATCH:
+		    /* Not yet fully implemented ??? */
+		    sec_flags |= SEC_LINK_DUPLICATES_SAME_CONTENTS;
+		    break;
+
+		    /* debug$S gets this case; other
+		       implications ??? */
+
+		    /* There may be no symbol... we'll search
+		       the whole table... Is this the right
+		       place to play this game? Or should we do
+		       it when reading it in.  */
+		  case IMAGE_COMDAT_SELECT_ASSOCIATIVE:
+#ifdef STRICT_PE_FORMAT
+		    /* FIXME: This is not currently implemented.  */
+		    sec_flags |= SEC_LINK_DUPLICATES_DISCARD;
+#else
+		    sec_flags &= ~SEC_LINK_ONCE;
+#endif
+		    break;
+
+		  default:  /* 0 means "no symbol" */
+		    /* debug$F gets this case; other
+		       implications ??? */
+		    sec_flags |= SEC_LINK_DUPLICATES_DISCARD;
+		    break;
+		  }
+	      }
+	      break;
+
+	    case 2:
+	      /* Gas mode: the first matching on partial name.  */
+
+#ifndef TARGET_UNDERSCORE
+#define TARGET_UNDERSCORE 0
+#endif
+	      /* Is this the name we're looking for ?  */
+	      if (strcmp (target_name,
+			  symname + (TARGET_UNDERSCORE ? 1 : 0)) != 0)
+		{
+		  /* Not the name we're looking for */
+		  esym += (isym.n_numaux + 1) * bfd_coff_symesz (abfd);
+		  continue;
+		}
+	      /* Fall through.  */
+	    case 1:
+	      /* MSVC mode: the lexically second symbol (or
+		 drop through from the above).  */
+	      {
+		char *newname;
+		bfd_size_type amt;
+
+		/* This must the second symbol with the
+		   section #.  It is the actual symbol name.
+		   Intel puts the two adjacent, but Alpha (at
+		   least) spreads them out.  */
+
+		amt = sizeof (struct coff_comdat_info);
+		coff_section_data (abfd, section)->comdat
+		  = (struct coff_comdat_info *) bfd_alloc (abfd, amt);
+		if (coff_section_data (abfd, section)->comdat == NULL)
+		  abort ();
+
+		coff_section_data (abfd, section)->comdat->symbol =
+		  (esym - esymstart) / bfd_coff_symesz (abfd);
+
+		amt = strlen (symname) + 1;
+		newname = (char *) bfd_alloc (abfd, amt);
+		if (newname == NULL)
+		  abort ();
+
+		strcpy (newname, symname);
+		coff_section_data (abfd, section)->comdat->name
+		  = newname;
+	      }
+
+	      goto breakloop;
+	    }
+	}
+
+      esym += (isym.n_numaux + 1) * bfd_coff_symesz (abfd);
+    }
+
+ breakloop:
+  return sec_flags;
+}
+
+
+/* The PE version; see above for the general comments.
+
+   Since to set the SEC_LINK_ONCE and associated flags, we have to
+   look at the symbol table anyway, we return the symbol table index
+   of the symbol being used as the COMDAT symbol.  This is admittedly
+   ugly, but there's really nowhere else that we have access to the
+   required information.  FIXME: Is the COMDAT symbol index used for
+   any purpose other than objdump?  */
+
+static bfd_boolean
+styp_to_sec_flags (bfd *abfd,
+		   void * hdr,
+		   const char *name,
+		   asection *section,
+		   flagword *flags_ptr)
+{
+  struct internal_scnhdr *internal_s = (struct internal_scnhdr *) hdr;
+  unsigned long styp_flags = internal_s->s_flags;
+  flagword sec_flags;
+  bfd_boolean result = TRUE;
+  bfd_boolean is_dbg = FALSE;
+
+  if (CONST_STRNEQ (name, DOT_DEBUG)
+      || CONST_STRNEQ (name, DOT_ZDEBUG)
+#ifdef COFF_LONG_SECTION_NAMES
+      || CONST_STRNEQ (name, GNU_LINKONCE_WI)
+      || CONST_STRNEQ (name, GNU_LINKONCE_WT)
+#endif
+      || CONST_STRNEQ (name, ".stab"))
+    is_dbg = TRUE;
+  /* Assume read only unless IMAGE_SCN_MEM_WRITE is specified.  */
+  sec_flags = SEC_READONLY;
+
+  /* If section disallows read, then set the NOREAD flag. */
+  if ((styp_flags & IMAGE_SCN_MEM_READ) == 0)
+    sec_flags |= SEC_COFF_NOREAD;
+
+  /* Process each flag bit in styp_flags in turn.  */
+  while (styp_flags)
+    {
+      unsigned long flag = styp_flags & - styp_flags;
+      char * unhandled = NULL;
+
+      styp_flags &= ~ flag;
+
+      /* We infer from the distinct read/write/execute bits the settings
+	 of some of the bfd flags; the actual values, should we need them,
+	 are also in pei_section_data (abfd, section)->pe_flags.  */
+
+      switch (flag)
+	{
+	case STYP_DSECT:
+	  unhandled = "STYP_DSECT";
+	  break;
+	case STYP_GROUP:
+	  unhandled = "STYP_GROUP";
+	  break;
+	case STYP_COPY:
+	  unhandled = "STYP_COPY";
+	  break;
+	case STYP_OVER:
+	  unhandled = "STYP_OVER";
+	  break;
+#ifdef SEC_NEVER_LOAD
+	case STYP_NOLOAD:
+	  sec_flags |= SEC_NEVER_LOAD;
+	  break;
+#endif
+	case IMAGE_SCN_MEM_READ:
+	  sec_flags &= ~SEC_COFF_NOREAD;
+	  break;
+	case IMAGE_SCN_TYPE_NO_PAD:
+	  /* Skip.  */
+	  break;
+	case IMAGE_SCN_LNK_OTHER:
+	  unhandled = "IMAGE_SCN_LNK_OTHER";
+	  break;
+	case IMAGE_SCN_MEM_NOT_CACHED:
+	  unhandled = "IMAGE_SCN_MEM_NOT_CACHED";
+	  break;
+	case IMAGE_SCN_MEM_NOT_PAGED:
+	  /* Generate a warning message rather using the 'unhandled'
+	     variable as this will allow some .sys files generate by
+	     other toolchains to be processed.  See bugzilla issue 196.  */
+	  _bfd_error_handler (_("%B: Warning: Ignoring section flag IMAGE_SCN_MEM_NOT_PAGED in section %s"),
+			      abfd, name);
+	  break;
+	case IMAGE_SCN_MEM_EXECUTE:
+	  sec_flags |= SEC_CODE;
+	  break;
+	case IMAGE_SCN_MEM_WRITE:
+	  sec_flags &= ~ SEC_READONLY;
+	  break;
+	case IMAGE_SCN_MEM_DISCARDABLE:
+	  /* The MS PE spec says that debug sections are DISCARDABLE,
+	     but the presence of a DISCARDABLE flag does not necessarily
+	     mean that a given section contains debug information.  Thus
+	     we only set the SEC_DEBUGGING flag on sections that we
+	     recognise as containing debug information.  */
+	     if (is_dbg
+#ifdef _COMMENT
+	      || strcmp (name, _COMMENT) == 0
+#endif
+	      )
+	    {
+	      sec_flags |= SEC_DEBUGGING | SEC_READONLY;
+	    }
+	  break;
+	case IMAGE_SCN_MEM_SHARED:
+	  sec_flags |= SEC_COFF_SHARED;
+	  break;
+	case IMAGE_SCN_LNK_REMOVE:
+	  if (!is_dbg)
+	    sec_flags |= SEC_EXCLUDE;
+	  break;
+	case IMAGE_SCN_CNT_CODE:
+	  sec_flags |= SEC_CODE | SEC_ALLOC | SEC_LOAD;
+	  break;
+	case IMAGE_SCN_CNT_INITIALIZED_DATA:
+	  if (is_dbg)
+	    sec_flags |= SEC_DEBUGGING;
+	  else
+	    sec_flags |= SEC_DATA | SEC_ALLOC | SEC_LOAD;
+	  break;
+	case IMAGE_SCN_CNT_UNINITIALIZED_DATA:
+	  sec_flags |= SEC_ALLOC;
+	  break;
+	case IMAGE_SCN_LNK_INFO:
+	  /* We mark these as SEC_DEBUGGING, but only if COFF_PAGE_SIZE is
+	     defined.  coff_compute_section_file_positions uses
+	     COFF_PAGE_SIZE to ensure that the low order bits of the
+	     section VMA and the file offset match.  If we don't know
+	     COFF_PAGE_SIZE, we can't ensure the correct correspondence,
+	     and demand page loading of the file will fail.  */
+#ifdef COFF_PAGE_SIZE
+	  sec_flags |= SEC_DEBUGGING;
+#endif
+	  break;
+	case IMAGE_SCN_LNK_COMDAT:
+	  /* COMDAT gets very special treatment.  */
+	  sec_flags = handle_COMDAT (abfd, sec_flags, hdr, name, section);
+	  break;
+	default:
+	  /* Silently ignore for now.  */
+	  break;
+	}
+
+      /* If the section flag was not handled, report it here.  */
+      if (unhandled != NULL)
+	{
+	  (*_bfd_error_handler)
+	    (_("%B (%s): Section flag %s (0x%x) ignored"),
+	     abfd, name, unhandled, flag);
+	  result = FALSE;
+	}
+    }
+
+#if defined (COFF_LONG_SECTION_NAMES) && defined (COFF_SUPPORT_GNU_LINKONCE)
+  /* As a GNU extension, if the name begins with .gnu.linkonce, we
+     only link a single copy of the section.  This is used to support
+     g++.  g++ will emit each template expansion in its own section.
+     The symbols will be defined as weak, so that multiple definitions
+     are permitted.  The GNU linker extension is to actually discard
+     all but one of the sections.  */
+  if (CONST_STRNEQ (name, ".gnu.linkonce"))
+    sec_flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
+#endif
+
+  if (flags_ptr)
+    * flags_ptr = sec_flags;
+
+  return result;
+}
+
+#endif /* COFF_WITH_PE */
+
+#define	get_index(symbol)	((symbol)->udata.i)
+
+/*
+INTERNAL_DEFINITION
+	bfd_coff_backend_data
+
+CODE_FRAGMENT
+
+.{* COFF symbol classifications.  *}
+.
+.enum coff_symbol_classification
+.{
+.  {* Global symbol.  *}
+.  COFF_SYMBOL_GLOBAL,
+.  {* Common symbol.  *}
+.  COFF_SYMBOL_COMMON,
+.  {* Undefined symbol.  *}
+.  COFF_SYMBOL_UNDEFINED,
+.  {* Local symbol.  *}
+.  COFF_SYMBOL_LOCAL,
+.  {* PE section symbol.  *}
+.  COFF_SYMBOL_PE_SECTION
+.};
+.
+.typedef asection * (*coff_gc_mark_hook_fn)
+.  (asection *, struct bfd_link_info *, struct internal_reloc *,
+.   struct coff_link_hash_entry *, struct internal_syment *);
+.
+Special entry points for gdb to swap in coff symbol table parts:
+.typedef struct
+.{
+.  void (*_bfd_coff_swap_aux_in)
+.    (bfd *, void *, int, int, int, int, void *);
+.
+.  void (*_bfd_coff_swap_sym_in)
+.    (bfd *, void *, void *);
+.
+.  void (*_bfd_coff_swap_lineno_in)
+.    (bfd *, void *, void *);
+.
+.  unsigned int (*_bfd_coff_swap_aux_out)
+.    (bfd *, void *, int, int, int, int, void *);
+.
+.  unsigned int (*_bfd_coff_swap_sym_out)
+.    (bfd *, void *, void *);
+.
+.  unsigned int (*_bfd_coff_swap_lineno_out)
+.    (bfd *, void *, void *);
+.
+.  unsigned int (*_bfd_coff_swap_reloc_out)
+.    (bfd *, void *, void *);
+.
+.  unsigned int (*_bfd_coff_swap_filehdr_out)
+.    (bfd *, void *, void *);
+.
+.  unsigned int (*_bfd_coff_swap_aouthdr_out)
+.    (bfd *, void *, void *);
+.
+.  unsigned int (*_bfd_coff_swap_scnhdr_out)
+.    (bfd *, void *, void *);
+.
+.  unsigned int _bfd_filhsz;
+.  unsigned int _bfd_aoutsz;
+.  unsigned int _bfd_scnhsz;
+.  unsigned int _bfd_symesz;
+.  unsigned int _bfd_auxesz;
+.  unsigned int _bfd_relsz;
+.  unsigned int _bfd_linesz;
+.  unsigned int _bfd_filnmlen;
+.  bfd_boolean _bfd_coff_long_filenames;
+.
+.  bfd_boolean _bfd_coff_long_section_names;
+.  bfd_boolean (*_bfd_coff_set_long_section_names)
+.    (bfd *, int);
+.
+.  unsigned int _bfd_coff_default_section_alignment_power;
+.  bfd_boolean _bfd_coff_force_symnames_in_strings;
+.  unsigned int _bfd_coff_debug_string_prefix_length;
+.  unsigned int _bfd_coff_max_nscns;
+.
+.  void (*_bfd_coff_swap_filehdr_in)
+.    (bfd *, void *, void *);
+.
+.  void (*_bfd_coff_swap_aouthdr_in)
+.    (bfd *, void *, void *);
+.
+.  void (*_bfd_coff_swap_scnhdr_in)
+.    (bfd *, void *, void *);
+.
+.  void (*_bfd_coff_swap_reloc_in)
+.    (bfd *abfd, void *, void *);
+.
+.  bfd_boolean (*_bfd_coff_bad_format_hook)
+.    (bfd *, void *);
+.
+.  bfd_boolean (*_bfd_coff_set_arch_mach_hook)
+.    (bfd *, void *);
+.
+.  void * (*_bfd_coff_mkobject_hook)
+.    (bfd *, void *, void *);
+.
+.  bfd_boolean (*_bfd_styp_to_sec_flags_hook)
+.    (bfd *, void *, const char *, asection *, flagword *);
+.
+.  void (*_bfd_set_alignment_hook)
+.    (bfd *, asection *, void *);
+.
+.  bfd_boolean (*_bfd_coff_slurp_symbol_table)
+.    (bfd *);
+.
+.  bfd_boolean (*_bfd_coff_symname_in_debug)
+.    (bfd *, struct internal_syment *);
+.
+.  bfd_boolean (*_bfd_coff_pointerize_aux_hook)
+.    (bfd *, combined_entry_type *, combined_entry_type *,
+.	     unsigned int, combined_entry_type *);
+.
+.  bfd_boolean (*_bfd_coff_print_aux)
+.    (bfd *, FILE *, combined_entry_type *, combined_entry_type *,
+.	     combined_entry_type *, unsigned int);
+.
+.  void (*_bfd_coff_reloc16_extra_cases)
+.    (bfd *, struct bfd_link_info *, struct bfd_link_order *, arelent *,
+.	    bfd_byte *, unsigned int *, unsigned int *);
+.
+.  int (*_bfd_coff_reloc16_estimate)
+.    (bfd *, asection *, arelent *, unsigned int,
+.	     struct bfd_link_info *);
+.
+.  enum coff_symbol_classification (*_bfd_coff_classify_symbol)
+.    (bfd *, struct internal_syment *);
+.
+.  bfd_boolean (*_bfd_coff_compute_section_file_positions)
+.    (bfd *);
+.
+.  bfd_boolean (*_bfd_coff_start_final_link)
+.    (bfd *, struct bfd_link_info *);
+.
+.  bfd_boolean (*_bfd_coff_relocate_section)
+.    (bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
+.	     struct internal_reloc *, struct internal_syment *, asection **);
+.
+.  reloc_howto_type *(*_bfd_coff_rtype_to_howto)
+.    (bfd *, asection *, struct internal_reloc *,
+.	     struct coff_link_hash_entry *, struct internal_syment *,
+.	     bfd_vma *);
+.
+.  bfd_boolean (*_bfd_coff_adjust_symndx)
+.    (bfd *, struct bfd_link_info *, bfd *, asection *,
+.	     struct internal_reloc *, bfd_boolean *);
+.
+.  bfd_boolean (*_bfd_coff_link_add_one_symbol)
+.    (struct bfd_link_info *, bfd *, const char *, flagword,
+.	     asection *, bfd_vma, const char *, bfd_boolean, bfd_boolean,
+.	     struct bfd_link_hash_entry **);
+.
+.  bfd_boolean (*_bfd_coff_link_output_has_begun)
+.    (bfd *, struct coff_final_link_info *);
+.
+.  bfd_boolean (*_bfd_coff_final_link_postscript)
+.    (bfd *, struct coff_final_link_info *);
+.
+.  bfd_boolean (*_bfd_coff_print_pdata)
+.    (bfd *, void *);
+.
+.} bfd_coff_backend_data;
+.
+.#define coff_backend_info(abfd) \
+.  ((bfd_coff_backend_data *) (abfd)->xvec->backend_data)
+.
+.#define bfd_coff_swap_aux_in(a,e,t,c,ind,num,i) \
+.  ((coff_backend_info (a)->_bfd_coff_swap_aux_in) (a,e,t,c,ind,num,i))
+.
+.#define bfd_coff_swap_sym_in(a,e,i) \
+.  ((coff_backend_info (a)->_bfd_coff_swap_sym_in) (a,e,i))
+.
+.#define bfd_coff_swap_lineno_in(a,e,i) \
+.  ((coff_backend_info ( a)->_bfd_coff_swap_lineno_in) (a,e,i))
+.
+.#define bfd_coff_swap_reloc_out(abfd, i, o) \
+.  ((coff_backend_info (abfd)->_bfd_coff_swap_reloc_out) (abfd, i, o))
+.
+.#define bfd_coff_swap_lineno_out(abfd, i, o) \
+.  ((coff_backend_info (abfd)->_bfd_coff_swap_lineno_out) (abfd, i, o))
+.
+.#define bfd_coff_swap_aux_out(a,i,t,c,ind,num,o) \
+.  ((coff_backend_info (a)->_bfd_coff_swap_aux_out) (a,i,t,c,ind,num,o))
+.
+.#define bfd_coff_swap_sym_out(abfd, i,o) \
+.  ((coff_backend_info (abfd)->_bfd_coff_swap_sym_out) (abfd, i, o))
+.
+.#define bfd_coff_swap_scnhdr_out(abfd, i,o) \
+.  ((coff_backend_info (abfd)->_bfd_coff_swap_scnhdr_out) (abfd, i, o))
+.
+.#define bfd_coff_swap_filehdr_out(abfd, i,o) \
+.  ((coff_backend_info (abfd)->_bfd_coff_swap_filehdr_out) (abfd, i, o))
+.
+.#define bfd_coff_swap_aouthdr_out(abfd, i,o) \
+.  ((coff_backend_info (abfd)->_bfd_coff_swap_aouthdr_out) (abfd, i, o))
+.
+.#define bfd_coff_filhsz(abfd) (coff_backend_info (abfd)->_bfd_filhsz)
+.#define bfd_coff_aoutsz(abfd) (coff_backend_info (abfd)->_bfd_aoutsz)
+.#define bfd_coff_scnhsz(abfd) (coff_backend_info (abfd)->_bfd_scnhsz)
+.#define bfd_coff_symesz(abfd) (coff_backend_info (abfd)->_bfd_symesz)
+.#define bfd_coff_auxesz(abfd) (coff_backend_info (abfd)->_bfd_auxesz)
+.#define bfd_coff_relsz(abfd)  (coff_backend_info (abfd)->_bfd_relsz)
+.#define bfd_coff_linesz(abfd) (coff_backend_info (abfd)->_bfd_linesz)
+.#define bfd_coff_filnmlen(abfd) (coff_backend_info (abfd)->_bfd_filnmlen)
+.#define bfd_coff_long_filenames(abfd) \
+.  (coff_backend_info (abfd)->_bfd_coff_long_filenames)
+.#define bfd_coff_long_section_names(abfd) \
+.  (coff_backend_info (abfd)->_bfd_coff_long_section_names)
+.#define bfd_coff_set_long_section_names(abfd, enable) \
+.  ((coff_backend_info (abfd)->_bfd_coff_set_long_section_names) (abfd, enable))
+.#define bfd_coff_default_section_alignment_power(abfd) \
+.  (coff_backend_info (abfd)->_bfd_coff_default_section_alignment_power)
+.#define bfd_coff_max_nscns(abfd) \
+.  (coff_backend_info (abfd)->_bfd_coff_max_nscns)
+.
+.#define bfd_coff_swap_filehdr_in(abfd, i,o) \
+.  ((coff_backend_info (abfd)->_bfd_coff_swap_filehdr_in) (abfd, i, o))
+.
+.#define bfd_coff_swap_aouthdr_in(abfd, i,o) \
+.  ((coff_backend_info (abfd)->_bfd_coff_swap_aouthdr_in) (abfd, i, o))
+.
+.#define bfd_coff_swap_scnhdr_in(abfd, i,o) \
+.  ((coff_backend_info (abfd)->_bfd_coff_swap_scnhdr_in) (abfd, i, o))
+.
+.#define bfd_coff_swap_reloc_in(abfd, i, o) \
+.  ((coff_backend_info (abfd)->_bfd_coff_swap_reloc_in) (abfd, i, o))
+.
+.#define bfd_coff_bad_format_hook(abfd, filehdr) \
+.  ((coff_backend_info (abfd)->_bfd_coff_bad_format_hook) (abfd, filehdr))
+.
+.#define bfd_coff_set_arch_mach_hook(abfd, filehdr)\
+.  ((coff_backend_info (abfd)->_bfd_coff_set_arch_mach_hook) (abfd, filehdr))
+.#define bfd_coff_mkobject_hook(abfd, filehdr, aouthdr)\
+.  ((coff_backend_info (abfd)->_bfd_coff_mkobject_hook)\
+.   (abfd, filehdr, aouthdr))
+.
+.#define bfd_coff_styp_to_sec_flags_hook(abfd, scnhdr, name, section, flags_ptr)\
+.  ((coff_backend_info (abfd)->_bfd_styp_to_sec_flags_hook)\
+.   (abfd, scnhdr, name, section, flags_ptr))
+.
+.#define bfd_coff_set_alignment_hook(abfd, sec, scnhdr)\
+.  ((coff_backend_info (abfd)->_bfd_set_alignment_hook) (abfd, sec, scnhdr))
+.
+.#define bfd_coff_slurp_symbol_table(abfd)\
+.  ((coff_backend_info (abfd)->_bfd_coff_slurp_symbol_table) (abfd))
+.
+.#define bfd_coff_symname_in_debug(abfd, sym)\
+.  ((coff_backend_info (abfd)->_bfd_coff_symname_in_debug) (abfd, sym))
+.
+.#define bfd_coff_force_symnames_in_strings(abfd)\
+.  (coff_backend_info (abfd)->_bfd_coff_force_symnames_in_strings)
+.
+.#define bfd_coff_debug_string_prefix_length(abfd)\
+.  (coff_backend_info (abfd)->_bfd_coff_debug_string_prefix_length)
+.
+.#define bfd_coff_print_aux(abfd, file, base, symbol, aux, indaux)\
+.  ((coff_backend_info (abfd)->_bfd_coff_print_aux)\
+.   (abfd, file, base, symbol, aux, indaux))
+.
+.#define bfd_coff_reloc16_extra_cases(abfd, link_info, link_order,\
+.                                     reloc, data, src_ptr, dst_ptr)\
+.  ((coff_backend_info (abfd)->_bfd_coff_reloc16_extra_cases)\
+.   (abfd, link_info, link_order, reloc, data, src_ptr, dst_ptr))
+.
+.#define bfd_coff_reloc16_estimate(abfd, section, reloc, shrink, link_info)\
+.  ((coff_backend_info (abfd)->_bfd_coff_reloc16_estimate)\
+.   (abfd, section, reloc, shrink, link_info))
+.
+.#define bfd_coff_classify_symbol(abfd, sym)\
+.  ((coff_backend_info (abfd)->_bfd_coff_classify_symbol)\
+.   (abfd, sym))
+.
+.#define bfd_coff_compute_section_file_positions(abfd)\
+.  ((coff_backend_info (abfd)->_bfd_coff_compute_section_file_positions)\
+.   (abfd))
+.
+.#define bfd_coff_start_final_link(obfd, info)\
+.  ((coff_backend_info (obfd)->_bfd_coff_start_final_link)\
+.   (obfd, info))
+.#define bfd_coff_relocate_section(obfd,info,ibfd,o,con,rel,isyms,secs)\
+.  ((coff_backend_info (ibfd)->_bfd_coff_relocate_section)\
+.   (obfd, info, ibfd, o, con, rel, isyms, secs))
+.#define bfd_coff_rtype_to_howto(abfd, sec, rel, h, sym, addendp)\
+.  ((coff_backend_info (abfd)->_bfd_coff_rtype_to_howto)\
+.   (abfd, sec, rel, h, sym, addendp))
+.#define bfd_coff_adjust_symndx(obfd, info, ibfd, sec, rel, adjustedp)\
+.  ((coff_backend_info (abfd)->_bfd_coff_adjust_symndx)\
+.   (obfd, info, ibfd, sec, rel, adjustedp))
+.#define bfd_coff_link_add_one_symbol(info, abfd, name, flags, section,\
+.                                     value, string, cp, coll, hashp)\
+.  ((coff_backend_info (abfd)->_bfd_coff_link_add_one_symbol)\
+.   (info, abfd, name, flags, section, value, string, cp, coll, hashp))
+.
+.#define bfd_coff_link_output_has_begun(a,p) \
+.  ((coff_backend_info (a)->_bfd_coff_link_output_has_begun) (a, p))
+.#define bfd_coff_final_link_postscript(a,p) \
+.  ((coff_backend_info (a)->_bfd_coff_final_link_postscript) (a, p))
+.
+.#define bfd_coff_have_print_pdata(a) \
+.  (coff_backend_info (a)->_bfd_coff_print_pdata)
+.#define bfd_coff_print_pdata(a,p) \
+.  ((coff_backend_info (a)->_bfd_coff_print_pdata) (a, p))
+.
+.{* Macro: Returns true if the bfd is a PE executable as opposed to a
+.   PE object file.  *}
+.#define bfd_pei_p(abfd) \
+.  (CONST_STRNEQ ((abfd)->xvec->name, "pei-"))
+*/
+
+/* See whether the magic number matches.  */
+
+static bfd_boolean
+coff_bad_format_hook (bfd * abfd ATTRIBUTE_UNUSED, void * filehdr)
+{
+  struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;
+
+  if (BADMAG (*internal_f))
+    return FALSE;
+
+  /* If the optional header is NULL or not the correct size then
+     quit; the only difference I can see between m88k dgux headers (MC88DMAGIC)
+     and Intel 960 readwrite headers (I960WRMAGIC) is that the
+     optional header is of a different size.
+
+     But the mips keeps extra stuff in it's opthdr, so dont check
+     when doing that.  */
+
+#if defined(M88) || defined(I960)
+  if (internal_f->f_opthdr != 0 && bfd_coff_aoutsz (abfd) != internal_f->f_opthdr)
+    return FALSE;
+#endif
+
+  return TRUE;
+}
+
+#ifdef TICOFF
+static bfd_boolean
+ticoff0_bad_format_hook (bfd *abfd ATTRIBUTE_UNUSED, void * filehdr)
+{
+  struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;
+
+  if (COFF0_BADMAG (*internal_f))
+    return FALSE;
+
+  return TRUE;
+}
+#endif
+
+#ifdef TICOFF
+static bfd_boolean
+ticoff1_bad_format_hook (bfd *abfd ATTRIBUTE_UNUSED, void * filehdr)
+{
+  struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;
+
+  if (COFF1_BADMAG (*internal_f))
+    return FALSE;
+
+  return TRUE;
+}
+#endif
+
+/* Check whether this section uses an alignment other than the
+   default.  */
+
+static void
+coff_set_custom_section_alignment (bfd *abfd ATTRIBUTE_UNUSED,
+				   asection *section,
+				   const struct coff_section_alignment_entry *alignment_table,
+				   const unsigned int table_size)
+{
+  const unsigned int default_alignment = COFF_DEFAULT_SECTION_ALIGNMENT_POWER;
+  unsigned int i;
+
+  for (i = 0; i < table_size; ++i)
+    {
+      const char *secname = bfd_get_section_name (abfd, section);
+
+      if (alignment_table[i].comparison_length == (unsigned int) -1
+	  ? strcmp (alignment_table[i].name, secname) == 0
+	  : strncmp (alignment_table[i].name, secname,
+		     alignment_table[i].comparison_length) == 0)
+	break;
+    }
+  if (i >= table_size)
+    return;
+
+  if (alignment_table[i].default_alignment_min != COFF_ALIGNMENT_FIELD_EMPTY
+      && default_alignment < alignment_table[i].default_alignment_min)
+    return;
+
+  if (alignment_table[i].default_alignment_max != COFF_ALIGNMENT_FIELD_EMPTY
+#if COFF_DEFAULT_SECTION_ALIGNMENT_POWER != 0
+      && default_alignment > alignment_table[i].default_alignment_max
+#endif
+      )
+    return;
+
+  section->alignment_power = alignment_table[i].alignment_power;
+}
+
+/* Custom section alignment records.  */
+
+static const struct coff_section_alignment_entry
+coff_section_alignment_table[] =
+{
+#ifdef COFF_SECTION_ALIGNMENT_ENTRIES
+  COFF_SECTION_ALIGNMENT_ENTRIES,
+#endif
+  /* There must not be any gaps between .stabstr sections.  */
+  { COFF_SECTION_NAME_PARTIAL_MATCH (".stabstr"),
+    1, COFF_ALIGNMENT_FIELD_EMPTY, 0 },
+  /* The .stab section must be aligned to 2**2 at most, to avoid gaps.  */
+  { COFF_SECTION_NAME_PARTIAL_MATCH (".stab"),
+    3, COFF_ALIGNMENT_FIELD_EMPTY, 2 },
+  /* Similarly for the .ctors and .dtors sections.  */
+  { COFF_SECTION_NAME_EXACT_MATCH (".ctors"),
+    3, COFF_ALIGNMENT_FIELD_EMPTY, 2 },
+  { COFF_SECTION_NAME_EXACT_MATCH (".dtors"),
+    3, COFF_ALIGNMENT_FIELD_EMPTY, 2 }
+};
+
+static const unsigned int coff_section_alignment_table_size =
+  sizeof coff_section_alignment_table / sizeof coff_section_alignment_table[0];
+
+/* Initialize a section structure with information peculiar to this
+   particular implementation of COFF.  */
+
+static bfd_boolean
+coff_new_section_hook (bfd * abfd, asection * section)
+{
+  combined_entry_type *native;
+  bfd_size_type amt;
+  unsigned char sclass = C_STAT;
+
+  section->alignment_power = COFF_DEFAULT_SECTION_ALIGNMENT_POWER;
+
+#ifdef RS6000COFF_C
+  if (bfd_xcoff_text_align_power (abfd) != 0
+      && strcmp (bfd_get_section_name (abfd, section), ".text") == 0)
+    section->alignment_power = bfd_xcoff_text_align_power (abfd);
+  else if (bfd_xcoff_data_align_power (abfd) != 0
+      && strcmp (bfd_get_section_name (abfd, section), ".data") == 0)
+    section->alignment_power = bfd_xcoff_data_align_power (abfd);
+  else
+    {
+      int i;
+
+      for (i = 0; i < XCOFF_DWSECT_NBR_NAMES; i++)
+        if (strcmp (bfd_get_section_name (abfd, section),
+                    xcoff_dwsect_names[i].name) == 0)
+          {
+            section->alignment_power = 0;
+            sclass = C_DWARF;
+            break;
+          }
+    }
+#endif
+
+  /* Set up the section symbol.  */
+  if (!_bfd_generic_new_section_hook (abfd, section))
+    return FALSE;
+
+  /* Allocate aux records for section symbols, to store size and
+     related info.
+
+     @@ The 10 is a guess at a plausible maximum number of aux entries
+     (but shouldn't be a constant).  */
+  amt = sizeof (combined_entry_type) * 10;
+  native = (combined_entry_type *) bfd_zalloc (abfd, amt);
+  if (native == NULL)
+    return FALSE;
+
+  /* We don't need to set up n_name, n_value, or n_scnum in the native
+     symbol information, since they'll be overridden by the BFD symbol
+     anyhow.  However, we do need to set the type and storage class,
+     in case this symbol winds up getting written out.  The value 0
+     for n_numaux is already correct.  */
+
+  native->is_sym = TRUE;
+  native->u.syment.n_type = T_NULL;
+  native->u.syment.n_sclass = sclass;
+
+  coffsymbol (section->symbol)->native = native;
+
+  coff_set_custom_section_alignment (abfd, section,
+				     coff_section_alignment_table,
+				     coff_section_alignment_table_size);
+
+  return TRUE;
+}
+
+#ifdef COFF_ALIGN_IN_SECTION_HEADER
+
+/* Set the alignment of a BFD section.  */
+
+static void
+coff_set_alignment_hook (bfd * abfd ATTRIBUTE_UNUSED,
+			 asection * section,
+			 void * scnhdr)
+{
+  struct internal_scnhdr *hdr = (struct internal_scnhdr *) scnhdr;
+  unsigned int i;
+
+#ifdef I960
+  /* Extract ALIGN from 2**ALIGN stored in section header.  */
+  for (i = 0; i < 32; i++)
+    if ((1 << i) >= hdr->s_align)
+      break;
+#endif
+#ifdef TIC80COFF
+  /* TI tools puts the alignment power in bits 8-11.  */
+  i = (hdr->s_flags >> 8) & 0xF ;
+#endif
+#ifdef COFF_DECODE_ALIGNMENT
+  i = COFF_DECODE_ALIGNMENT(hdr->s_flags);
+#endif
+  section->alignment_power = i;
+
+#ifdef coff_set_section_load_page
+  coff_set_section_load_page (section, hdr->s_page);
+#endif
+}
+
+#else /* ! COFF_ALIGN_IN_SECTION_HEADER */
+#ifdef COFF_WITH_PE
+
+static void
+coff_set_alignment_hook (bfd * abfd ATTRIBUTE_UNUSED,
+			 asection * section,
+			 void * scnhdr)
+{
+  struct internal_scnhdr *hdr = (struct internal_scnhdr *) scnhdr;
+  bfd_size_type amt;
+  unsigned int alignment_power_const
+    = hdr->s_flags & IMAGE_SCN_ALIGN_POWER_BIT_MASK;
+
+  switch (alignment_power_const)
+    {
+    case IMAGE_SCN_ALIGN_8192BYTES:
+    case IMAGE_SCN_ALIGN_4096BYTES:
+    case IMAGE_SCN_ALIGN_2048BYTES:
+    case IMAGE_SCN_ALIGN_1024BYTES:
+    case IMAGE_SCN_ALIGN_512BYTES:
+    case IMAGE_SCN_ALIGN_256BYTES:
+    case IMAGE_SCN_ALIGN_128BYTES:
+    case IMAGE_SCN_ALIGN_64BYTES:
+    case IMAGE_SCN_ALIGN_32BYTES:
+    case IMAGE_SCN_ALIGN_16BYTES:
+    case IMAGE_SCN_ALIGN_8BYTES:
+    case IMAGE_SCN_ALIGN_4BYTES:
+    case IMAGE_SCN_ALIGN_2BYTES:
+    case IMAGE_SCN_ALIGN_1BYTES:
+      section->alignment_power
+	= IMAGE_SCN_ALIGN_POWER_NUM (alignment_power_const);
+      break;
+    default:
+      break;
+    }
+
+  /* In a PE image file, the s_paddr field holds the virtual size of a
+     section, while the s_size field holds the raw size.  We also keep
+     the original section flag value, since not every bit can be
+     mapped onto a generic BFD section bit.  */
+  if (coff_section_data (abfd, section) == NULL)
+    {
+      amt = sizeof (struct coff_section_tdata);
+      section->used_by_bfd = bfd_zalloc (abfd, amt);
+      if (section->used_by_bfd == NULL)
+	/* FIXME: Return error.  */
+	abort ();
+    }
+
+  if (pei_section_data (abfd, section) == NULL)
+    {
+      amt = sizeof (struct pei_section_tdata);
+      coff_section_data (abfd, section)->tdata = bfd_zalloc (abfd, amt);
+      if (coff_section_data (abfd, section)->tdata == NULL)
+	/* FIXME: Return error.  */
+	abort ();
+    }
+  pei_section_data (abfd, section)->virt_size = hdr->s_paddr;
+  pei_section_data (abfd, section)->pe_flags = hdr->s_flags;
+
+  section->lma = hdr->s_vaddr;
+
+  /* Check for extended relocs.  */
+  if (hdr->s_flags & IMAGE_SCN_LNK_NRELOC_OVFL)
+    {
+      struct external_reloc dst;
+      struct internal_reloc n;
+      file_ptr oldpos = bfd_tell (abfd);
+      bfd_size_type relsz = bfd_coff_relsz (abfd);
+
+      if (bfd_seek (abfd, (file_ptr) hdr->s_relptr, 0) != 0)
+	return;
+      if (bfd_bread (& dst, relsz, abfd) != relsz)
+	return;
+
+      coff_swap_reloc_in (abfd, &dst, &n);
+      if (bfd_seek (abfd, oldpos, 0) != 0)
+	return;
+      section->reloc_count = hdr->s_nreloc = n.r_vaddr - 1;
+      section->rel_filepos += relsz;
+    }
+  else if (hdr->s_nreloc == 0xffff)
+    (*_bfd_error_handler)
+      ("%s: warning: claims to have 0xffff relocs, without overflow",
+       bfd_get_filename (abfd));
+}
+#undef ALIGN_SET
+#undef ELIFALIGN_SET
+
+#else /* ! COFF_WITH_PE */
+#ifdef RS6000COFF_C
+
+/* We grossly abuse this function to handle XCOFF overflow headers.
+   When we see one, we correct the reloc and line number counts in the
+   real header, and remove the section we just created.  */
+
+static void
+coff_set_alignment_hook (bfd *abfd, asection *section, void * scnhdr)
+{
+  struct internal_scnhdr *hdr = (struct internal_scnhdr *) scnhdr;
+  asection *real_sec;
+
+  if ((hdr->s_flags & STYP_OVRFLO) == 0)
+    return;
+
+  real_sec = coff_section_from_bfd_index (abfd, (int) hdr->s_nreloc);
+  if (real_sec == NULL)
+    return;
+
+  real_sec->reloc_count = hdr->s_paddr;
+  real_sec->lineno_count = hdr->s_vaddr;
+
+  if (!bfd_section_removed_from_list (abfd, section))
+    {
+      bfd_section_list_remove (abfd, section);
+      --abfd->section_count;
+    }
+}
+
+#else /* ! RS6000COFF_C */
+
+#define coff_set_alignment_hook \
+  ((void (*) (bfd *, asection *, void *)) bfd_void)
+
+#endif /* ! RS6000COFF_C */
+#endif /* ! COFF_WITH_PE */
+#endif /* ! COFF_ALIGN_IN_SECTION_HEADER */
+
+#ifndef coff_mkobject
+
+static bfd_boolean
+coff_mkobject (bfd * abfd)
+{
+  coff_data_type *coff;
+  bfd_size_type amt = sizeof (coff_data_type);
+
+  abfd->tdata.coff_obj_data = bfd_zalloc (abfd, amt);
+  if (abfd->tdata.coff_obj_data == NULL)
+    return FALSE;
+  coff = coff_data (abfd);
+  coff->symbols = NULL;
+  coff->conversion_table = NULL;
+  coff->raw_syments = NULL;
+  coff->relocbase = 0;
+  coff->local_toc_sym_map = 0;
+
+/*  make_abs_section(abfd);*/
+
+  return TRUE;
+}
+#endif
+
+/* Create the COFF backend specific information.  */
+
+#ifndef coff_mkobject_hook
+static void *
+coff_mkobject_hook (bfd * abfd,
+		    void * filehdr,
+		    void * aouthdr ATTRIBUTE_UNUSED)
+{
+  struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;
+  coff_data_type *coff;
+
+  if (! coff_mkobject (abfd))
+    return NULL;
+
+  coff = coff_data (abfd);
+
+  coff->sym_filepos = internal_f->f_symptr;
+
+  /* These members communicate important constants about the symbol
+     table to GDB's symbol-reading code.  These `constants'
+     unfortunately vary among coff implementations...  */
+  coff->local_n_btmask = N_BTMASK;
+  coff->local_n_btshft = N_BTSHFT;
+  coff->local_n_tmask = N_TMASK;
+  coff->local_n_tshift = N_TSHIFT;
+  coff->local_symesz = bfd_coff_symesz (abfd);
+  coff->local_auxesz = bfd_coff_auxesz (abfd);
+  coff->local_linesz = bfd_coff_linesz (abfd);
+
+  coff->timestamp = internal_f->f_timdat;
+
+  obj_raw_syment_count (abfd) =
+    obj_conv_table_size (abfd) =
+      internal_f->f_nsyms;
+
+#ifdef RS6000COFF_C
+  if ((internal_f->f_flags & F_SHROBJ) != 0)
+    abfd->flags |= DYNAMIC;
+  if (aouthdr != NULL && internal_f->f_opthdr >= bfd_coff_aoutsz (abfd))
+    {
+      struct internal_aouthdr *internal_a =
+	(struct internal_aouthdr *) aouthdr;
+      struct xcoff_tdata *xcoff;
+
+      xcoff = xcoff_data (abfd);
+# ifdef U803XTOCMAGIC
+      xcoff->xcoff64 = internal_f->f_magic == U803XTOCMAGIC;
+# else
+      xcoff->xcoff64 = 0;
+# endif
+      xcoff->full_aouthdr = TRUE;
+      xcoff->toc = internal_a->o_toc;
+      xcoff->sntoc = internal_a->o_sntoc;
+      xcoff->snentry = internal_a->o_snentry;
+      bfd_xcoff_text_align_power (abfd) = internal_a->o_algntext;
+      bfd_xcoff_data_align_power (abfd) = internal_a->o_algndata;
+      xcoff->modtype = internal_a->o_modtype;
+      xcoff->cputype = internal_a->o_cputype;
+      xcoff->maxdata = internal_a->o_maxdata;
+      xcoff->maxstack = internal_a->o_maxstack;
+    }
+#endif
+
+#ifdef ARM
+  /* Set the flags field from the COFF header read in.  */
+  if (! _bfd_coff_arm_set_private_flags (abfd, internal_f->f_flags))
+    coff->flags = 0;
+#endif
+
+#ifdef COFF_WITH_PE
+  /* FIXME: I'm not sure this is ever executed, since peicode.h
+     defines coff_mkobject_hook.  */
+  if ((internal_f->f_flags & IMAGE_FILE_DEBUG_STRIPPED) == 0)
+    abfd->flags |= HAS_DEBUG;
+#endif
+
+  if ((internal_f->f_flags & F_GO32STUB) != 0)
+    {
+      coff->go32stub = (char *) bfd_alloc (abfd, (bfd_size_type) GO32_STUBSIZE);
+      if (coff->go32stub == NULL)
+	return NULL;
+    }
+  if (coff->go32stub != NULL)
+    memcpy (coff->go32stub, internal_f->go32stub, GO32_STUBSIZE);
+
+  return coff;
+}
+#endif
+
+/* Determine the machine architecture and type.  FIXME: This is target
+   dependent because the magic numbers are defined in the target
+   dependent header files.  But there is no particular need for this.
+   If the magic numbers were moved to a separate file, this function
+   would be target independent and would also be much more successful
+   at linking together COFF files for different architectures.  */
+
+static bfd_boolean
+coff_set_arch_mach_hook (bfd *abfd, void * filehdr)
+{
+  unsigned long machine;
+  enum bfd_architecture arch;
+  struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;
+
+  /* Zero selects the default machine for an arch.  */
+  machine = 0;
+  switch (internal_f->f_magic)
+    {
+#ifdef PPCMAGIC
+    case PPCMAGIC:
+      arch = bfd_arch_powerpc;
+      break;
+#endif
+#ifdef I386MAGIC
+    case I386MAGIC:
+    case I386PTXMAGIC:
+    case I386AIXMAGIC:		/* Danbury PS/2 AIX C Compiler.  */
+    case LYNXCOFFMAGIC:		/* Shadows the m68k Lynx number below, sigh.  */
+      arch = bfd_arch_i386;
+      break;
+#endif
+#ifdef AMD64MAGIC
+    case AMD64MAGIC:
+      arch = bfd_arch_i386;
+      machine = bfd_mach_x86_64;
+      break;
+#endif
+#ifdef IA64MAGIC
+    case IA64MAGIC:
+      arch = bfd_arch_ia64;
+      break;
+#endif
+#ifdef ARMMAGIC
+    case ARMMAGIC:
+    case ARMPEMAGIC:
+    case THUMBPEMAGIC:
+      arch = bfd_arch_arm;
+      machine = bfd_arm_get_mach_from_notes (abfd, ARM_NOTE_SECTION);
+      if (machine == bfd_mach_arm_unknown)
+	{
+	  switch (internal_f->f_flags & F_ARM_ARCHITECTURE_MASK)
+	    {
+	    case F_ARM_2:  machine = bfd_mach_arm_2;  break;
+	    case F_ARM_2a: machine = bfd_mach_arm_2a; break;
+	    case F_ARM_3:  machine = bfd_mach_arm_3;  break;
+	    default:
+	    case F_ARM_3M: machine = bfd_mach_arm_3M; break;
+	    case F_ARM_4:  machine = bfd_mach_arm_4;  break;
+	    case F_ARM_4T: machine = bfd_mach_arm_4T; break;
+	      /* The COFF header does not have enough bits available
+		 to cover all the different ARM architectures.  So
+		 we interpret F_ARM_5, the highest flag value to mean
+		 "the highest ARM architecture known to BFD" which is
+		 currently the XScale.  */
+	    case F_ARM_5:  machine = bfd_mach_arm_XScale;  break;
+	    }
+	}
+      break;
+#endif
+#ifdef MC68MAGIC
+    case MC68MAGIC:
+    case M68MAGIC:
+#ifdef MC68KBCSMAGIC
+    case MC68KBCSMAGIC:
+#endif
+#ifdef APOLLOM68KMAGIC
+    case APOLLOM68KMAGIC:
+#endif
+#ifdef LYNXCOFFMAGIC
+    case LYNXCOFFMAGIC:
+#endif
+      arch = bfd_arch_m68k;
+      machine = bfd_mach_m68020;
+      break;
+#endif
+#ifdef MC88MAGIC
+    case MC88MAGIC:
+    case MC88DMAGIC:
+    case MC88OMAGIC:
+      arch = bfd_arch_m88k;
+      machine = 88100;
+      break;
+#endif
+#ifdef Z80MAGIC
+    case Z80MAGIC:
+      arch = bfd_arch_z80;
+      switch (internal_f->f_flags & F_MACHMASK)
+	{
+	case 0:
+	case bfd_mach_z80strict << 12:
+	case bfd_mach_z80 << 12:
+	case bfd_mach_z80full << 12:
+	case bfd_mach_r800 << 12:
+	  machine = ((unsigned)internal_f->f_flags & F_MACHMASK) >> 12;
+	  break;
+	default:
+	  return FALSE;
+	}
+      break;
+#endif
+#ifdef Z8KMAGIC
+    case Z8KMAGIC:
+      arch = bfd_arch_z8k;
+      switch (internal_f->f_flags & F_MACHMASK)
+	{
+	case F_Z8001:
+	  machine = bfd_mach_z8001;
+	  break;
+	case F_Z8002:
+	  machine = bfd_mach_z8002;
+	  break;
+	default:
+	  return FALSE;
+	}
+      break;
+#endif
+#ifdef I860
+    case I860MAGIC:
+      arch = bfd_arch_i860;
+      break;
+#endif
+#ifdef I960
+#ifdef I960ROMAGIC
+    case I960ROMAGIC:
+    case I960RWMAGIC:
+      arch = bfd_arch_i960;
+      switch (F_I960TYPE & internal_f->f_flags)
+	{
+	default:
+	case F_I960CORE:
+	  machine = bfd_mach_i960_core;
+	  break;
+	case F_I960KB:
+	  machine = bfd_mach_i960_kb_sb;
+	  break;
+	case F_I960MC:
+	  machine = bfd_mach_i960_mc;
+	  break;
+	case F_I960XA:
+	  machine = bfd_mach_i960_xa;
+	  break;
+	case F_I960CA:
+	  machine = bfd_mach_i960_ca;
+	  break;
+	case F_I960KA:
+	  machine = bfd_mach_i960_ka_sa;
+	  break;
+	case F_I960JX:
+	  machine = bfd_mach_i960_jx;
+	  break;
+	case F_I960HX:
+	  machine = bfd_mach_i960_hx;
+	  break;
+	}
+      break;
+#endif
+#endif
+
+#ifdef RS6000COFF_C
+#ifdef XCOFF64
+    case U64_TOCMAGIC:
+    case U803XTOCMAGIC:
+#else
+    case U802ROMAGIC:
+    case U802WRMAGIC:
+    case U802TOCMAGIC:
+#endif
+      {
+	int cputype;
+
+	if (xcoff_data (abfd)->cputype != -1)
+	  cputype = xcoff_data (abfd)->cputype & 0xff;
+	else
+	  {
+	    /* We did not get a value from the a.out header.  If the
+	       file has not been stripped, we may be able to get the
+	       architecture information from the first symbol, if it
+	       is a .file symbol.  */
+	    if (obj_raw_syment_count (abfd) == 0)
+	      cputype = 0;
+	    else
+	      {
+		bfd_byte *buf;
+		struct internal_syment sym;
+		bfd_size_type amt = bfd_coff_symesz (abfd);
+
+		buf = bfd_malloc (amt);
+		if (buf == NULL)
+		  return FALSE;
+		if (bfd_seek (abfd, obj_sym_filepos (abfd), SEEK_SET) != 0
+		    || bfd_bread (buf, amt, abfd) != amt)
+		  {
+		    free (buf);
+		    return FALSE;
+		  }
+		bfd_coff_swap_sym_in (abfd, buf, & sym);
+		if (sym.n_sclass == C_FILE)
+		  cputype = sym.n_type & 0xff;
+		else
+		  cputype = 0;
+		free (buf);
+	      }
+	  }
+
+	/* FIXME: We don't handle all cases here.  */
+	switch (cputype)
+	  {
+	  default:
+	  case 0:
+	    arch = bfd_xcoff_architecture (abfd);
+	    machine = bfd_xcoff_machine (abfd);
+	    break;
+
+	  case 1:
+	    arch = bfd_arch_powerpc;
+	    machine = bfd_mach_ppc_601;
+	    break;
+	  case 2: /* 64 bit PowerPC */
+	    arch = bfd_arch_powerpc;
+	    machine = bfd_mach_ppc_620;
+	    break;
+	  case 3:
+	    arch = bfd_arch_powerpc;
+	    machine = bfd_mach_ppc;
+	    break;
+	  case 4:
+	    arch = bfd_arch_rs6000;
+	    machine = bfd_mach_rs6k;
+	    break;
+	  }
+      }
+      break;
+#endif
+
+#ifdef WE32KMAGIC
+    case WE32KMAGIC:
+      arch = bfd_arch_we32k;
+      break;
+#endif
+
+#ifdef H8300MAGIC
+    case H8300MAGIC:
+      arch = bfd_arch_h8300;
+      machine = bfd_mach_h8300;
+      /* !! FIXME this probably isn't the right place for this.  */
+      abfd->flags |= BFD_IS_RELAXABLE;
+      break;
+#endif
+
+#ifdef H8300HMAGIC
+    case H8300HMAGIC:
+      arch = bfd_arch_h8300;
+      machine = bfd_mach_h8300h;
+      /* !! FIXME this probably isn't the right place for this.  */
+      abfd->flags |= BFD_IS_RELAXABLE;
+      break;
+#endif
+
+#ifdef H8300SMAGIC
+    case H8300SMAGIC:
+      arch = bfd_arch_h8300;
+      machine = bfd_mach_h8300s;
+      /* !! FIXME this probably isn't the right place for this.  */
+      abfd->flags |= BFD_IS_RELAXABLE;
+      break;
+#endif
+
+#ifdef H8300HNMAGIC
+    case H8300HNMAGIC:
+      arch = bfd_arch_h8300;
+      machine = bfd_mach_h8300hn;
+      /* !! FIXME this probably isn't the right place for this.  */
+      abfd->flags |= BFD_IS_RELAXABLE;
+      break;
+#endif
+
+#ifdef H8300SNMAGIC
+    case H8300SNMAGIC:
+      arch = bfd_arch_h8300;
+      machine = bfd_mach_h8300sn;
+      /* !! FIXME this probably isn't the right place for this.  */
+      abfd->flags |= BFD_IS_RELAXABLE;
+      break;
+#endif
+
+#ifdef SH_ARCH_MAGIC_BIG
+    case SH_ARCH_MAGIC_BIG:
+    case SH_ARCH_MAGIC_LITTLE:
+#ifdef COFF_WITH_PE
+    case SH_ARCH_MAGIC_WINCE:
+#endif
+      arch = bfd_arch_sh;
+      break;
+#endif
+
+#ifdef MIPS_ARCH_MAGIC_WINCE
+    case MIPS_ARCH_MAGIC_WINCE:
+      arch = bfd_arch_mips;
+      break;
+#endif
+
+#ifdef H8500MAGIC
+    case H8500MAGIC:
+      arch = bfd_arch_h8500;
+      break;
+#endif
+
+#ifdef SPARCMAGIC
+    case SPARCMAGIC:
+#ifdef LYNXCOFFMAGIC
+    case LYNXCOFFMAGIC:
+#endif
+      arch = bfd_arch_sparc;
+      break;
+#endif
+
+#ifdef TIC30MAGIC
+    case TIC30MAGIC:
+      arch = bfd_arch_tic30;
+      break;
+#endif
+
+#ifdef TICOFF0MAGIC
+#ifdef TICOFF_TARGET_ARCH
+      /* This TI COFF section should be used by all new TI COFF v0 targets.  */
+    case TICOFF0MAGIC:
+      arch = TICOFF_TARGET_ARCH;
+      machine = TICOFF_TARGET_MACHINE_GET (internal_f->f_flags);
+      break;
+#endif
+#endif
+
+#ifdef TICOFF1MAGIC
+      /* This TI COFF section should be used by all new TI COFF v1/2 targets.  */
+      /* TI COFF1 and COFF2 use the target_id field to specify which arch.  */
+    case TICOFF1MAGIC:
+    case TICOFF2MAGIC:
+      switch (internal_f->f_target_id)
+	{
+#ifdef TI_TARGET_ID
+	case TI_TARGET_ID:
+	  arch = TICOFF_TARGET_ARCH;
+	  machine = TICOFF_TARGET_MACHINE_GET (internal_f->f_flags);
+	  break;
+#endif
+	default:
+	  arch = bfd_arch_obscure;
+	  (*_bfd_error_handler)
+	    (_("Unrecognized TI COFF target id '0x%x'"),
+	     internal_f->f_target_id);
+	  break;
+	}
+      break;
+#endif
+
+#ifdef TIC80_ARCH_MAGIC
+    case TIC80_ARCH_MAGIC:
+      arch = bfd_arch_tic80;
+      break;
+#endif
+
+#ifdef MCOREMAGIC
+    case MCOREMAGIC:
+      arch = bfd_arch_mcore;
+      break;
+#endif
+
+#ifdef W65MAGIC
+    case W65MAGIC:
+      arch = bfd_arch_w65;
+      break;
+#endif
+
+    default:			/* Unreadable input file type.  */
+      arch = bfd_arch_obscure;
+      break;
+    }
+
+  bfd_default_set_arch_mach (abfd, arch, machine);
+  return TRUE;
+}
+
+#ifdef SYMNAME_IN_DEBUG
+
+static bfd_boolean
+symname_in_debug_hook (bfd * abfd ATTRIBUTE_UNUSED, struct internal_syment *sym)
+{
+  return SYMNAME_IN_DEBUG (sym) != 0;
+}
+
+#else
+
+#define symname_in_debug_hook \
+  (bfd_boolean (*) (bfd *, struct internal_syment *)) bfd_false
+
+#endif
+
+#ifdef RS6000COFF_C
+
+#ifdef XCOFF64
+#define FORCE_SYMNAMES_IN_STRINGS
+#endif
+
+/* Handle the csect auxent of a C_EXT, C_AIX_WEAKEXT or C_HIDEXT symbol.  */
+
+static bfd_boolean
+coff_pointerize_aux_hook (bfd *abfd ATTRIBUTE_UNUSED,
+			  combined_entry_type *table_base,
+			  combined_entry_type *symbol,
+			  unsigned int indaux,
+			  combined_entry_type *aux)
+{
+  BFD_ASSERT (symbol->is_sym);
+  int n_sclass = symbol->u.syment.n_sclass;
+
+  if (CSECT_SYM_P (n_sclass)
+      && indaux + 1 == symbol->u.syment.n_numaux)
+    {
+      BFD_ASSERT (! aux->is_sym);
+      if (SMTYP_SMTYP (aux->u.auxent.x_csect.x_smtyp) == XTY_LD)
+	{
+	  aux->u.auxent.x_csect.x_scnlen.p =
+	    table_base + aux->u.auxent.x_csect.x_scnlen.l;
+	  aux->fix_scnlen = 1;
+	}
+
+      /* Return TRUE to indicate that the caller should not do any
+	 further work on this auxent.  */
+      return TRUE;
+    }
+
+  /* Return FALSE to indicate that this auxent should be handled by
+     the caller.  */
+  return FALSE;
+}
+
+#else
+#ifdef I960
+
+/* We don't want to pointerize bal entries.  */
+
+static bfd_boolean
+coff_pointerize_aux_hook (bfd *abfd ATTRIBUTE_UNUSED,
+			  combined_entry_type *table_base ATTRIBUTE_UNUSED,
+			  combined_entry_type *symbol,
+			  unsigned int indaux,
+			  combined_entry_type *aux ATTRIBUTE_UNUSED)
+{
+  /* Return TRUE if we don't want to pointerize this aux entry, which
+     is the case for the lastfirst aux entry for a C_LEAFPROC symbol.  */
+  return (indaux == 1
+	  && symbol->is_sym
+	  && (symbol->u.syment.n_sclass == C_LEAFPROC
+	      || symbol->u.syment.n_sclass == C_LEAFSTAT
+	      || symbol->u.syment.n_sclass == C_LEAFEXT));
+}
+
+#else /* ! I960 */
+
+#define coff_pointerize_aux_hook 0
+
+#endif /* ! I960 */
+#endif /* ! RS6000COFF_C */
+
+/* Print an aux entry.  This returns TRUE if it has printed it.  */
+
+static bfd_boolean
+coff_print_aux (bfd *abfd ATTRIBUTE_UNUSED,
+		FILE *file ATTRIBUTE_UNUSED,
+		combined_entry_type *table_base ATTRIBUTE_UNUSED,
+		combined_entry_type *symbol ATTRIBUTE_UNUSED,
+		combined_entry_type *aux ATTRIBUTE_UNUSED,
+		unsigned int indaux ATTRIBUTE_UNUSED)
+{
+  BFD_ASSERT (symbol->is_sym);
+  BFD_ASSERT (! aux->is_sym);
+#ifdef RS6000COFF_C
+  if (CSECT_SYM_P (symbol->u.syment.n_sclass)
+      && indaux + 1 == symbol->u.syment.n_numaux)
+    {
+      /* This is a csect entry.  */
+      fprintf (file, "AUX ");
+      if (SMTYP_SMTYP (aux->u.auxent.x_csect.x_smtyp) != XTY_LD)
+	{
+	  BFD_ASSERT (! aux->fix_scnlen);
+#ifdef XCOFF64
+	  fprintf (file, "val %5lld",
+		   (long long) aux->u.auxent.x_csect.x_scnlen.l);
+#else
+	  fprintf (file, "val %5ld", (long) aux->u.auxent.x_csect.x_scnlen.l);
+#endif
+	}
+      else
+	{
+	  fprintf (file, "indx ");
+	  if (! aux->fix_scnlen)
+#ifdef XCOFF64
+	    fprintf (file, "%4lld",
+		     (long long) aux->u.auxent.x_csect.x_scnlen.l);
+#else
+	    fprintf (file, "%4ld", (long) aux->u.auxent.x_csect.x_scnlen.l);
+#endif
+	  else
+	    fprintf (file, "%4ld",
+		     (long) (aux->u.auxent.x_csect.x_scnlen.p - table_base));
+	}
+      fprintf (file,
+	       " prmhsh %ld snhsh %u typ %d algn %d clss %u stb %ld snstb %u",
+	       aux->u.auxent.x_csect.x_parmhash,
+	       (unsigned int) aux->u.auxent.x_csect.x_snhash,
+	       SMTYP_SMTYP (aux->u.auxent.x_csect.x_smtyp),
+	       SMTYP_ALIGN (aux->u.auxent.x_csect.x_smtyp),
+	       (unsigned int) aux->u.auxent.x_csect.x_smclas,
+	       aux->u.auxent.x_csect.x_stab,
+	       (unsigned int) aux->u.auxent.x_csect.x_snstab);
+      return TRUE;
+    }
+#endif
+
+  /* Return FALSE to indicate that no special action was taken.  */
+  return FALSE;
+}
+
+/*
+SUBSUBSECTION
+	Writing relocations
+
+	To write relocations, the back end steps though the
+	canonical relocation table and create an
+	@code{internal_reloc}. The symbol index to use is removed from
+	the @code{offset} field in the symbol table supplied.  The
+	address comes directly from the sum of the section base
+	address and the relocation offset; the type is dug directly
+	from the howto field.  Then the @code{internal_reloc} is
+	swapped into the shape of an @code{external_reloc} and written
+	out to disk.
+
+*/
+
+#ifdef TARG_AUX
+
+
+/* AUX's ld wants relocations to be sorted.  */
+static int
+compare_arelent_ptr (const void * x, const void * y)
+{
+  const arelent **a = (const arelent **) x;
+  const arelent **b = (const arelent **) y;
+  bfd_size_type aadr = (*a)->address;
+  bfd_size_type badr = (*b)->address;
+
+  return (aadr < badr ? -1 : badr < aadr ? 1 : 0);
+}
+
+#endif /* TARG_AUX */
+
+static bfd_boolean
+coff_write_relocs (bfd * abfd, int first_undef)
+{
+  asection *s;
+
+  for (s = abfd->sections; s != NULL; s = s->next)
+    {
+      unsigned int i;
+      struct external_reloc dst;
+      arelent **p;
+
+#ifndef TARG_AUX
+      p = s->orelocation;
+#else
+      {
+	/* Sort relocations before we write them out.  */
+	bfd_size_type amt;
+
+	amt = s->reloc_count;
+	amt *= sizeof (arelent *);
+	p = bfd_malloc (amt);
+	if (p == NULL)
+	  {
+	    if (s->reloc_count > 0)
+	      return FALSE;
+	  }
+	else
+	  {
+	    memcpy (p, s->orelocation, (size_t) amt);
+	    qsort (p, s->reloc_count, sizeof (arelent *), compare_arelent_ptr);
+	  }
+      }
+#endif
+
+      if (bfd_seek (abfd, s->rel_filepos, SEEK_SET) != 0)
+	return FALSE;
+
+#ifdef COFF_WITH_PE
+      if (obj_pe (abfd) && s->reloc_count >= 0xffff)
+	{
+	  /* Encode real count here as first reloc.  */
+	  struct internal_reloc n;
+
+	  memset (& n, 0, sizeof (n));
+	  /* Add one to count *this* reloc (grr).  */
+	  n.r_vaddr = s->reloc_count + 1;
+	  coff_swap_reloc_out (abfd, &n, &dst);
+	  if (bfd_bwrite (& dst, (bfd_size_type) bfd_coff_relsz (abfd),
+			  abfd) != bfd_coff_relsz (abfd))
+	    return FALSE;
+	}
+#endif
+
+      for (i = 0; i < s->reloc_count; i++)
+	{
+	  struct internal_reloc n;
+	  arelent *q = p[i];
+
+	  memset (& n, 0, sizeof (n));
+
+	  /* Now we've renumbered the symbols we know where the
+	     undefined symbols live in the table.  Check the reloc
+	     entries for symbols who's output bfd isn't the right one.
+	     This is because the symbol was undefined (which means
+	     that all the pointers are never made to point to the same
+	     place). This is a bad thing,'cause the symbols attached
+	     to the output bfd are indexed, so that the relocation
+	     entries know which symbol index they point to.  So we
+	     have to look up the output symbol here.  */
+
+	  if (q->sym_ptr_ptr[0] != NULL && q->sym_ptr_ptr[0]->the_bfd != abfd)
+	    {
+	      int j;
+	      const char *sname = q->sym_ptr_ptr[0]->name;
+	      asymbol **outsyms = abfd->outsymbols;
+
+	      for (j = first_undef; outsyms[j]; j++)
+		{
+		  const char *intable = outsyms[j]->name;
+
+		  if (strcmp (intable, sname) == 0)
+		    {
+		      /* Got a hit, so repoint the reloc.  */
+		      q->sym_ptr_ptr = outsyms + j;
+		      break;
+		    }
+		}
+	    }
+
+	  n.r_vaddr = q->address + s->vma;
+
+#ifdef R_IHCONST
+	  /* The 29k const/consth reloc pair is a real kludge.  The consth
+	     part doesn't have a symbol; it has an offset.  So rebuilt
+	     that here.  */
+	  if (q->howto->type == R_IHCONST)
+	    n.r_symndx = q->addend;
+	  else
+#endif
+	    if (q->sym_ptr_ptr && q->sym_ptr_ptr[0] != NULL)
+	      {
+#ifdef SECTION_RELATIVE_ABSOLUTE_SYMBOL_P
+		if (SECTION_RELATIVE_ABSOLUTE_SYMBOL_P (q, s))
+#else
+		if ((*q->sym_ptr_ptr)->section == bfd_abs_section_ptr
+		    && ((*q->sym_ptr_ptr)->flags & BSF_SECTION_SYM) != 0)
+#endif
+		  /* This is a relocation relative to the absolute symbol.  */
+		  n.r_symndx = -1;
+		else
+		  {
+		    n.r_symndx = get_index ((*(q->sym_ptr_ptr)));
+		    /* Check to see if the symbol reloc points to a symbol
+		       we don't have in our symbol table.  */
+		    if (n.r_symndx > obj_conv_table_size (abfd))
+		      {
+			bfd_set_error (bfd_error_bad_value);
+			_bfd_error_handler (_("%B: reloc against a non-existant symbol index: %ld"),
+					    abfd, n.r_symndx);
+			return FALSE;
+		      }
+		  }
+	      }
+
+#ifdef SWAP_OUT_RELOC_OFFSET
+	  n.r_offset = q->addend;
+#endif
+
+#ifdef SELECT_RELOC
+	  /* Work out reloc type from what is required.  */
+	  SELECT_RELOC (n, q->howto);
+#else
+	  n.r_type = q->howto->type;
+#endif
+	  coff_swap_reloc_out (abfd, &n, &dst);
+
+	  if (bfd_bwrite (& dst, (bfd_size_type) bfd_coff_relsz (abfd),
+			 abfd) != bfd_coff_relsz (abfd))
+	    return FALSE;
+	}
+
+#ifdef TARG_AUX
+      if (p != NULL)
+	free (p);
+#endif
+    }
+
+  return TRUE;
+}
+
+/* Set flags and magic number of a coff file from architecture and machine
+   type.  Result is TRUE if we can represent the arch&type, FALSE if not.  */
+
+static bfd_boolean
+coff_set_flags (bfd * abfd,
+		unsigned int *magicp ATTRIBUTE_UNUSED,
+		unsigned short *flagsp ATTRIBUTE_UNUSED)
+{
+  switch (bfd_get_arch (abfd))
+    {
+#ifdef Z80MAGIC
+    case bfd_arch_z80:
+      *magicp = Z80MAGIC;
+      switch (bfd_get_mach (abfd))
+	{
+	case 0:
+	case bfd_mach_z80strict:
+	case bfd_mach_z80:
+	case bfd_mach_z80full:
+	case bfd_mach_r800:
+	  *flagsp = bfd_get_mach (abfd) << 12;
+	  break;
+	default:
+	  return FALSE;
+	}
+      return TRUE;
+#endif
+
+#ifdef Z8KMAGIC
+    case bfd_arch_z8k:
+      *magicp = Z8KMAGIC;
+
+      switch (bfd_get_mach (abfd))
+	{
+	case bfd_mach_z8001: *flagsp = F_Z8001;	break;
+	case bfd_mach_z8002: *flagsp = F_Z8002;	break;
+	default:	     return FALSE;
+	}
+      return TRUE;
+#endif
+
+#ifdef I960ROMAGIC
+    case bfd_arch_i960:
+
+      {
+	unsigned flags;
+
+	*magicp = I960ROMAGIC;
+
+	switch (bfd_get_mach (abfd))
+	  {
+	  case bfd_mach_i960_core:  flags = F_I960CORE; break;
+	  case bfd_mach_i960_kb_sb: flags = F_I960KB;	break;
+	  case bfd_mach_i960_mc:    flags = F_I960MC;	break;
+	  case bfd_mach_i960_xa:    flags = F_I960XA;	break;
+	  case bfd_mach_i960_ca:    flags = F_I960CA;	break;
+	  case bfd_mach_i960_ka_sa: flags = F_I960KA;	break;
+	  case bfd_mach_i960_jx:    flags = F_I960JX;	break;
+	  case bfd_mach_i960_hx:    flags = F_I960HX;	break;
+	  default:		    return FALSE;
+	  }
+	*flagsp = flags;
+	return TRUE;
+      }
+      break;
+#endif
+
+#ifdef TIC30MAGIC
+    case bfd_arch_tic30:
+      *magicp = TIC30MAGIC;
+      return TRUE;
+#endif
+
+#ifdef TICOFF_DEFAULT_MAGIC
+    case TICOFF_TARGET_ARCH:
+      /* If there's no indication of which version we want, use the default.  */
+      if (!abfd->xvec )
+	*magicp = TICOFF_DEFAULT_MAGIC;
+      else
+	{
+	  /* We may want to output in a different COFF version.  */
+	  switch (abfd->xvec->name[4])
+	    {
+	    case '0':
+	      *magicp = TICOFF0MAGIC;
+	      break;
+	    case '1':
+	      *magicp = TICOFF1MAGIC;
+	      break;
+	    case '2':
+	      *magicp = TICOFF2MAGIC;
+	      break;
+	    default:
+	      return FALSE;
+	    }
+	}
+      TICOFF_TARGET_MACHINE_SET (flagsp, bfd_get_mach (abfd));
+      return TRUE;
+#endif
+
+#ifdef TIC80_ARCH_MAGIC
+    case bfd_arch_tic80:
+      *magicp = TIC80_ARCH_MAGIC;
+      return TRUE;
+#endif
+
+#ifdef ARMMAGIC
+    case bfd_arch_arm:
+#ifdef ARM_WINCE
+      * magicp = ARMPEMAGIC;
+#else
+      * magicp = ARMMAGIC;
+#endif
+      * flagsp = 0;
+      if (APCS_SET (abfd))
+	{
+	  if (APCS_26_FLAG (abfd))
+	    * flagsp |= F_APCS26;
+
+	  if (APCS_FLOAT_FLAG (abfd))
+	    * flagsp |= F_APCS_FLOAT;
+
+	  if (PIC_FLAG (abfd))
+	    * flagsp |= F_PIC;
+	}
+      if (INTERWORK_SET (abfd) && INTERWORK_FLAG (abfd))
+	* flagsp |= F_INTERWORK;
+      switch (bfd_get_mach (abfd))
+	{
+	case bfd_mach_arm_2:  * flagsp |= F_ARM_2;  break;
+	case bfd_mach_arm_2a: * flagsp |= F_ARM_2a; break;
+	case bfd_mach_arm_3:  * flagsp |= F_ARM_3;  break;
+	case bfd_mach_arm_3M: * flagsp |= F_ARM_3M; break;
+	case bfd_mach_arm_4:  * flagsp |= F_ARM_4;  break;
+	case bfd_mach_arm_4T: * flagsp |= F_ARM_4T; break;
+	case bfd_mach_arm_5:  * flagsp |= F_ARM_5;  break;
+	  /* FIXME: we do not have F_ARM vaues greater than F_ARM_5.
+	     See also the comment in coff_set_arch_mach_hook().  */
+	case bfd_mach_arm_5T: * flagsp |= F_ARM_5;  break;
+	case bfd_mach_arm_5TE: * flagsp |= F_ARM_5; break;
+	case bfd_mach_arm_XScale: * flagsp |= F_ARM_5; break;
+	}
+      return TRUE;
+#endif
+
+#ifdef PPCMAGIC
+    case bfd_arch_powerpc:
+      *magicp = PPCMAGIC;
+      return TRUE;
+#endif
+
+#if defined(I386MAGIC) || defined(AMD64MAGIC)
+    case bfd_arch_i386:
+#if defined(I386MAGIC)
+      *magicp = I386MAGIC;
+#endif
+#if defined LYNXOS
+      /* Just overwrite the usual value if we're doing Lynx.  */
+      *magicp = LYNXCOFFMAGIC;
+#endif
+#if defined AMD64MAGIC
+      *magicp = AMD64MAGIC;
+#endif
+      return TRUE;
+#endif
+
+#ifdef I860MAGIC
+    case bfd_arch_i860:
+      *magicp = I860MAGIC;
+      return TRUE;
+#endif
+
+#ifdef IA64MAGIC
+    case bfd_arch_ia64:
+      *magicp = IA64MAGIC;
+      return TRUE;
+#endif
+
+#ifdef MC68MAGIC
+    case bfd_arch_m68k:
+#ifdef APOLLOM68KMAGIC
+      *magicp = APOLLO_COFF_VERSION_NUMBER;
+#else
+      /* NAMES_HAVE_UNDERSCORE may be defined by coff-u68k.c.  */
+#ifdef NAMES_HAVE_UNDERSCORE
+      *magicp = MC68KBCSMAGIC;
+#else
+      *magicp = MC68MAGIC;
+#endif
+#endif
+#ifdef LYNXOS
+      /* Just overwrite the usual value if we're doing Lynx.  */
+      *magicp = LYNXCOFFMAGIC;
+#endif
+      return TRUE;
+#endif
+
+#ifdef MC88MAGIC
+    case bfd_arch_m88k:
+      *magicp = MC88OMAGIC;
+      return TRUE;
+#endif
+
+#ifdef H8300MAGIC
+    case bfd_arch_h8300:
+      switch (bfd_get_mach (abfd))
+	{
+	case bfd_mach_h8300:   *magicp = H8300MAGIC;   return TRUE;
+	case bfd_mach_h8300h:  *magicp = H8300HMAGIC;  return TRUE;
+	case bfd_mach_h8300s:  *magicp = H8300SMAGIC;  return TRUE;
+	case bfd_mach_h8300hn: *magicp = H8300HNMAGIC; return TRUE;
+	case bfd_mach_h8300sn: *magicp = H8300SNMAGIC; return TRUE;
+	default: break;
+	}
+      break;
+#endif
+
+#ifdef SH_ARCH_MAGIC_BIG
+    case bfd_arch_sh:
+#ifdef COFF_IMAGE_WITH_PE
+      *magicp = SH_ARCH_MAGIC_WINCE;
+#else
+      if (bfd_big_endian (abfd))
+	*magicp = SH_ARCH_MAGIC_BIG;
+      else
+	*magicp = SH_ARCH_MAGIC_LITTLE;
+#endif
+      return TRUE;
+#endif
+
+#ifdef MIPS_ARCH_MAGIC_WINCE
+    case bfd_arch_mips:
+      *magicp = MIPS_ARCH_MAGIC_WINCE;
+      return TRUE;
+#endif
+
+#ifdef SPARCMAGIC
+    case bfd_arch_sparc:
+      *magicp = SPARCMAGIC;
+#ifdef LYNXOS
+      /* Just overwrite the usual value if we're doing Lynx.  */
+      *magicp = LYNXCOFFMAGIC;
+#endif
+      return TRUE;
+#endif
+
+#ifdef H8500MAGIC
+    case bfd_arch_h8500:
+      *magicp = H8500MAGIC;
+      return TRUE;
+      break;
+#endif
+
+#ifdef WE32KMAGIC
+    case bfd_arch_we32k:
+      *magicp = WE32KMAGIC;
+      return TRUE;
+#endif
+
+#ifdef RS6000COFF_C
+    case bfd_arch_rs6000:
+#ifndef PPCMAGIC
+    case bfd_arch_powerpc:
+#endif
+      BFD_ASSERT (bfd_get_flavour (abfd) == bfd_target_xcoff_flavour);
+      *magicp = bfd_xcoff_magic_number (abfd);
+      return TRUE;
+#endif
+
+#ifdef MCOREMAGIC
+    case bfd_arch_mcore:
+      * magicp = MCOREMAGIC;
+      return TRUE;
+#endif
+
+#ifdef W65MAGIC
+    case bfd_arch_w65:
+      *magicp = W65MAGIC;
+      return TRUE;
+#endif
+
+    default:			/* Unknown architecture.  */
+      /* Fall through to "return FALSE" below, to avoid
+	 "statement never reached" errors on the one below.  */
+      break;
+    }
+
+  return FALSE;
+}
+
+static bfd_boolean
+coff_set_arch_mach (bfd * abfd,
+		    enum bfd_architecture arch,
+		    unsigned long machine)
+{
+  unsigned dummy1;
+  unsigned short dummy2;
+
+  if (! bfd_default_set_arch_mach (abfd, arch, machine))
+    return FALSE;
+
+  if (arch != bfd_arch_unknown
+      && ! coff_set_flags (abfd, &dummy1, &dummy2))
+    return FALSE;		/* We can't represent this type.  */
+
+  return TRUE;			/* We're easy...  */
+}
+
+#ifdef COFF_IMAGE_WITH_PE
+
+/* This is used to sort sections by VMA, as required by PE image
+   files.  */
+
+static int
+sort_by_secaddr (const void * arg1, const void * arg2)
+{
+  const asection *a = *(const asection **) arg1;
+  const asection *b = *(const asection **) arg2;
+
+  if (a->vma < b->vma)
+    return -1;
+  else if (a->vma > b->vma)
+    return 1;
+
+  return 0;
+}
+
+#endif /* COFF_IMAGE_WITH_PE */
+
+/* Calculate the file position for each section.  */
+
+#ifndef I960
+#define ALIGN_SECTIONS_IN_FILE
+#endif
+#if defined(TIC80COFF) || defined(TICOFF)
+#undef ALIGN_SECTIONS_IN_FILE
+#endif
+
+static bfd_boolean
+coff_compute_section_file_positions (bfd * abfd)
+{
+  asection *current;
+  file_ptr sofar = bfd_coff_filhsz (abfd);
+  bfd_boolean align_adjust;
+  unsigned int target_index;
+#ifdef ALIGN_SECTIONS_IN_FILE
+  asection *previous = NULL;
+  file_ptr old_sofar;
+#endif
+
+#ifdef COFF_IMAGE_WITH_PE
+  int page_size;
+
+  if (coff_data (abfd)->link_info
+      || (pe_data (abfd) && pe_data (abfd)->pe_opthdr.FileAlignment))
+    {
+      page_size = pe_data (abfd)->pe_opthdr.FileAlignment;
+
+      /* If no file alignment has been set, default to one.
+	 This repairs 'ld -r' for arm-wince-pe target.  */
+      if (page_size == 0)
+	page_size = 1;
+
+      /* PR 17512: file: 0ac816d3.  */
+      if (page_size < 0)
+	{
+	  bfd_set_error (bfd_error_file_too_big);
+	  (*_bfd_error_handler)
+	    (_("%B: page size is too large (0x%x)"), abfd, page_size);
+	  return FALSE;
+	}
+    }
+  else
+    page_size = PE_DEF_FILE_ALIGNMENT;
+#else
+#ifdef COFF_PAGE_SIZE
+  int page_size = COFF_PAGE_SIZE;
+#endif
+#endif
+
+#ifdef RS6000COFF_C
+  /* On XCOFF, if we have symbols, set up the .debug section.  */
+  if (bfd_get_symcount (abfd) > 0)
+    {
+      bfd_size_type sz;
+      bfd_size_type i, symcount;
+      asymbol **symp;
+
+      sz = 0;
+      symcount = bfd_get_symcount (abfd);
+      for (symp = abfd->outsymbols, i = 0; i < symcount; symp++, i++)
+	{
+	  coff_symbol_type *cf;
+
+	  cf = coff_symbol_from (*symp);
+	  if (cf != NULL
+	      && cf->native != NULL
+	      && cf->native->is_sym
+	      && SYMNAME_IN_DEBUG (&cf->native->u.syment))
+	    {
+	      size_t len;
+
+	      len = strlen (bfd_asymbol_name (*symp));
+	      if (len > SYMNMLEN || bfd_coff_force_symnames_in_strings (abfd))
+		sz += len + 1 + bfd_coff_debug_string_prefix_length (abfd);
+	    }
+	}
+      if (sz > 0)
+	{
+	  asection *dsec;
+
+	  dsec = bfd_make_section_old_way (abfd, DOT_DEBUG);
+	  if (dsec == NULL)
+	    abort ();
+	  dsec->size = sz;
+	  dsec->flags |= SEC_HAS_CONTENTS;
+	}
+    }
+#endif
+
+  if (bfd_get_start_address (abfd))
+    /*  A start address may have been added to the original file. In this
+	case it will need an optional header to record it.  */
+    abfd->flags |= EXEC_P;
+
+  if (abfd->flags & EXEC_P)
+    sofar += bfd_coff_aoutsz (abfd);
+#ifdef RS6000COFF_C
+  else if (xcoff_data (abfd)->full_aouthdr)
+    sofar += bfd_coff_aoutsz (abfd);
+  else
+    sofar += SMALL_AOUTSZ;
+#endif
+
+  sofar += abfd->section_count * bfd_coff_scnhsz (abfd);
+
+#ifdef RS6000COFF_C
+  /* XCOFF handles overflows in the reloc and line number count fields
+     by allocating a new section header to hold the correct counts.  */
+  for (current = abfd->sections; current != NULL; current = current->next)
+    if (current->reloc_count >= 0xffff || current->lineno_count >= 0xffff)
+      sofar += bfd_coff_scnhsz (abfd);
+#endif
+
+#ifdef COFF_IMAGE_WITH_PE
+  {
+    /* PE requires the sections to be in memory order when listed in
+       the section headers.  It also does not like empty loadable
+       sections.  The sections apparently do not have to be in the
+       right order in the image file itself, but we do need to get the
+       target_index values right.  */
+
+    unsigned int count;
+    asection **section_list;
+    unsigned int i;
+    bfd_size_type amt;
+
+#ifdef COFF_PAGE_SIZE
+    /* Clear D_PAGED if section alignment is smaller than
+       COFF_PAGE_SIZE.  */
+   if (pe_data (abfd)->pe_opthdr.SectionAlignment < COFF_PAGE_SIZE)
+     abfd->flags &= ~D_PAGED;
+#endif
+
+    count = 0;
+    for (current = abfd->sections; current != NULL; current = current->next)
+      ++count;
+
+    /* We allocate an extra cell to simplify the final loop.  */
+    amt = sizeof (struct asection *) * (count + 1);
+    section_list = (asection **) bfd_malloc (amt);
+    if (section_list == NULL)
+      return FALSE;
+
+    i = 0;
+    for (current = abfd->sections; current != NULL; current = current->next)
+      {
+	section_list[i] = current;
+	++i;
+      }
+    section_list[i] = NULL;
+
+    qsort (section_list, count, sizeof (asection *), sort_by_secaddr);
+
+    /* Rethread the linked list into sorted order; at the same time,
+       assign target_index values.  */
+    target_index = 1;
+    abfd->sections = NULL;
+    abfd->section_last = NULL;
+    for (i = 0; i < count; i++)
+      {
+	current = section_list[i];
+	bfd_section_list_append (abfd, current);
+
+	/* Later, if the section has zero size, we'll be throwing it
+	   away, so we don't want to number it now.  Note that having
+	   a zero size and having real contents are different
+	   concepts: .bss has no contents, but (usually) non-zero
+	   size.  */
+	if (current->size == 0)
+	  {
+	    /* Discard.  However, it still might have (valid) symbols
+	       in it, so arbitrarily set it to section 1 (indexing is
+	       1-based here; usually .text).  __end__ and other
+	       contents of .endsection really have this happen.
+	       FIXME: This seems somewhat dubious.  */
+	    current->target_index = 1;
+	  }
+	else
+	  current->target_index = target_index++;
+      }
+
+    free (section_list);
+  }
+#else /* ! COFF_IMAGE_WITH_PE */
+  {
+    /* Set the target_index field.  */
+    target_index = 1;
+    for (current = abfd->sections; current != NULL; current = current->next)
+      current->target_index = target_index++;
+  }
+#endif /* ! COFF_IMAGE_WITH_PE */
+
+  if (target_index >= bfd_coff_max_nscns (abfd))
+    {
+      bfd_set_error (bfd_error_file_too_big);
+      (*_bfd_error_handler)
+	(_("%B: too many sections (%d)"), abfd, target_index);
+      return FALSE;
+    }
+
+  align_adjust = FALSE;
+  for (current = abfd->sections;
+       current != NULL;
+       current = current->next)
+    {
+#ifdef COFF_IMAGE_WITH_PE
+      /* With PE we have to pad each section to be a multiple of its
+	 page size too, and remember both sizes.  */
+      if (coff_section_data (abfd, current) == NULL)
+	{
+	  bfd_size_type amt = sizeof (struct coff_section_tdata);
+
+	  current->used_by_bfd = bfd_zalloc (abfd, amt);
+	  if (current->used_by_bfd == NULL)
+	    return FALSE;
+	}
+      if (pei_section_data (abfd, current) == NULL)
+	{
+	  bfd_size_type amt = sizeof (struct pei_section_tdata);
+
+	  coff_section_data (abfd, current)->tdata = bfd_zalloc (abfd, amt);
+	  if (coff_section_data (abfd, current)->tdata == NULL)
+	    return FALSE;
+	}
+      if (pei_section_data (abfd, current)->virt_size == 0)
+	pei_section_data (abfd, current)->virt_size = current->size;
+#endif
+
+      /* Only deal with sections which have contents.  */
+      if (!(current->flags & SEC_HAS_CONTENTS))
+	continue;
+
+      current->rawsize = current->size;
+
+#ifdef COFF_IMAGE_WITH_PE
+      /* Make sure we skip empty sections in a PE image.  */
+      if (current->size == 0)
+	continue;
+#endif
+
+      /* Align the sections in the file to the same boundary on
+	 which they are aligned in virtual memory.  I960 doesn't
+	 do this (FIXME) so we can stay in sync with Intel.  960
+	 doesn't yet page from files...  */
+#ifdef ALIGN_SECTIONS_IN_FILE
+      if ((abfd->flags & EXEC_P) != 0)
+	{
+	  /* Make sure this section is aligned on the right boundary - by
+	     padding the previous section up if necessary.  */
+	  old_sofar = sofar;
+
+	  sofar = BFD_ALIGN (sofar, 1 << current->alignment_power);
+
+#ifdef RS6000COFF_C
+	  /* Make sure the file offset and the vma of .text/.data are at the
+	     same page offset, so that the file can be mmap'ed without being
+	     relocated.  Failing that, AIX is able to load and execute the
+	     program, but it will be silently relocated (possible as
+	     executables are PIE).  But the relocation is slightly costly and
+	     complexify the use of addr2line or gdb.  So better to avoid it,
+	     like does the native linker.  Usually gnu ld makes sure that
+	     the vma of .text is the file offset so this issue shouldn't
+	     appear unless you are stripping such an executable.
+
+	     AIX loader checks the text section alignment of (vma - filepos),
+	     and the native linker doesn't try to align the text sections.
+	     For example:
+
+	     0 .text         000054cc  10000128  10000128  00000128  2**5
+                             CONTENTS, ALLOC, LOAD, CODE
+	  */
+
+	  if (!strcmp (current->name, _TEXT)
+	      || !strcmp (current->name, _DATA))
+	    {
+	      bfd_vma align = 4096;
+	      bfd_vma sofar_off = sofar % align;
+	      bfd_vma vma_off = current->vma % align;
+
+	      if (vma_off > sofar_off)
+		sofar += vma_off - sofar_off;
+	      else if (vma_off < sofar_off)
+		sofar += align + vma_off - sofar_off;
+	    }
+#endif
+	  if (previous != NULL)
+	    previous->size += sofar - old_sofar;
+	}
+
+#endif
+
+      /* In demand paged files the low order bits of the file offset
+	 must match the low order bits of the virtual address.  */
+#ifdef COFF_PAGE_SIZE
+      if ((abfd->flags & D_PAGED) != 0
+	  && (current->flags & SEC_ALLOC) != 0)
+	sofar += (current->vma - (bfd_vma) sofar) % page_size;
+#endif
+      current->filepos = sofar;
+
+#ifdef COFF_IMAGE_WITH_PE
+      /* Set the padded size.  */
+      current->size = (current->size + page_size - 1) & -page_size;
+#endif
+
+      sofar += current->size;
+
+#ifdef ALIGN_SECTIONS_IN_FILE
+      /* Make sure that this section is of the right size too.  */
+      if ((abfd->flags & EXEC_P) == 0)
+	{
+	  bfd_size_type old_size;
+
+	  old_size = current->size;
+	  current->size = BFD_ALIGN (current->size,
+				     1 << current->alignment_power);
+	  align_adjust = current->size != old_size;
+	  sofar += current->size - old_size;
+	}
+      else
+	{
+	  old_sofar = sofar;
+	  sofar = BFD_ALIGN (sofar, 1 << current->alignment_power);
+	  align_adjust = sofar != old_sofar;
+	  current->size += sofar - old_sofar;
+	}
+#endif
+
+#ifdef COFF_IMAGE_WITH_PE
+      /* For PE we need to make sure we pad out to the aligned
+	 size, in case the caller only writes out data to the
+	 unaligned size.  */
+      if (pei_section_data (abfd, current)->virt_size < current->size)
+	align_adjust = TRUE;
+#endif
+
+#ifdef _LIB
+      /* Force .lib sections to start at zero.  The vma is then
+	 incremented in coff_set_section_contents.  This is right for
+	 SVR3.2.  */
+      if (strcmp (current->name, _LIB) == 0)
+	(void) bfd_set_section_vma (abfd, current, 0);
+#endif
+
+#ifdef ALIGN_SECTIONS_IN_FILE
+      previous = current;
+#endif
+    }
+
+  /* It is now safe to write to the output file.  If we needed an
+     alignment adjustment for the last section, then make sure that
+     there is a byte at offset sofar.  If there are no symbols and no
+     relocs, then nothing follows the last section.  If we don't force
+     the last byte out, then the file may appear to be truncated.  */
+  if (align_adjust)
+    {
+      bfd_byte b;
+
+      b = 0;
+      if (bfd_seek (abfd, sofar - 1, SEEK_SET) != 0
+	  || bfd_bwrite (&b, (bfd_size_type) 1, abfd) != 1)
+	return FALSE;
+    }
+
+  /* Make sure the relocations are aligned.  We don't need to make
+     sure that this byte exists, because it will only matter if there
+     really are relocs.  */
+  sofar = BFD_ALIGN (sofar, 1 << COFF_DEFAULT_SECTION_ALIGNMENT_POWER);
+
+  obj_relocbase (abfd) = sofar;
+  abfd->output_has_begun = TRUE;
+
+  return TRUE;
+}
+
+#ifdef COFF_IMAGE_WITH_PE
+
+static unsigned int pelength;
+static unsigned int peheader;
+
+static bfd_boolean
+coff_read_word (bfd *abfd, unsigned int *value)
+{
+  unsigned char b[2];
+  int status;
+
+  status = bfd_bread (b, (bfd_size_type) 2, abfd);
+  if (status < 1)
+    {
+      *value = 0;
+      return FALSE;
+    }
+
+  if (status == 1)
+    *value = (unsigned int) b[0];
+  else
+    *value = (unsigned int) (b[0] + (b[1] << 8));
+
+  pelength += (unsigned int) status;
+
+  return TRUE;
+}
+
+static unsigned int
+coff_compute_checksum (bfd *abfd)
+{
+  bfd_boolean more_data;
+  file_ptr filepos;
+  unsigned int value;
+  unsigned int total;
+
+  total = 0;
+  pelength = 0;
+  filepos = (file_ptr) 0;
+
+  do
+    {
+      if (bfd_seek (abfd, filepos, SEEK_SET) != 0)
+	return 0;
+
+      more_data = coff_read_word (abfd, &value);
+      total += value;
+      total = 0xffff & (total + (total >> 0x10));
+      filepos += 2;
+    }
+  while (more_data);
+
+  return (0xffff & (total + (total >> 0x10)));
+}
+
+static bfd_boolean
+coff_apply_checksum (bfd *abfd)
+{
+  unsigned int computed;
+  unsigned int checksum = 0;
+
+  if (bfd_seek (abfd, 0x3c, SEEK_SET) != 0)
+    return FALSE;
+
+  if (!coff_read_word (abfd, &peheader))
+    return FALSE;
+
+  if (bfd_seek (abfd, peheader + 0x58, SEEK_SET) != 0)
+    return FALSE;
+
+  checksum = 0;
+  bfd_bwrite (&checksum, (bfd_size_type) 4, abfd);
+
+  if (bfd_seek (abfd, peheader, SEEK_SET) != 0)
+    return FALSE;
+
+  computed = coff_compute_checksum (abfd);
+
+  checksum = computed + pelength;
+
+  if (bfd_seek (abfd, peheader + 0x58, SEEK_SET) != 0)
+    return FALSE;
+
+  bfd_bwrite (&checksum, (bfd_size_type) 4, abfd);
+
+  return TRUE;
+}
+
+#endif /* COFF_IMAGE_WITH_PE */
+
+static bfd_boolean
+coff_write_object_contents (bfd * abfd)
+{
+  asection *current;
+  bfd_boolean hasrelocs = FALSE;
+  bfd_boolean haslinno = FALSE;
+#ifdef COFF_IMAGE_WITH_PE
+  bfd_boolean hasdebug = FALSE;
+#endif
+  file_ptr scn_base;
+  file_ptr reloc_base;
+  file_ptr lineno_base;
+  file_ptr sym_base;
+  unsigned long reloc_size = 0, reloc_count = 0;
+  unsigned long lnno_size = 0;
+  bfd_boolean long_section_names;
+  asection *text_sec = NULL;
+  asection *data_sec = NULL;
+  asection *bss_sec = NULL;
+  struct internal_filehdr internal_f;
+  struct internal_aouthdr internal_a;
+#ifdef COFF_LONG_SECTION_NAMES
+  size_t string_size = STRING_SIZE_SIZE;
+#endif
+
+  bfd_set_error (bfd_error_system_call);
+
+  /* Make a pass through the symbol table to count line number entries and
+     put them into the correct asections.  */
+  lnno_size = coff_count_linenumbers (abfd) * bfd_coff_linesz (abfd);
+
+  if (! abfd->output_has_begun)
+    {
+      if (! coff_compute_section_file_positions (abfd))
+	return FALSE;
+    }
+
+  reloc_base = obj_relocbase (abfd);
+
+  /* Work out the size of the reloc and linno areas.  */
+
+  for (current = abfd->sections; current != NULL; current =
+       current->next)
+    {
+#ifdef COFF_WITH_PE
+      /* We store the actual reloc count in the first reloc's addr.  */
+      if (obj_pe (abfd) && current->reloc_count >= 0xffff)
+	reloc_count ++;
+#endif
+      reloc_count += current->reloc_count;
+    }
+
+  reloc_size = reloc_count * bfd_coff_relsz (abfd);
+
+  lineno_base = reloc_base + reloc_size;
+  sym_base = lineno_base + lnno_size;
+
+  /* Indicate in each section->line_filepos its actual file address.  */
+  for (current = abfd->sections; current != NULL; current =
+       current->next)
+    {
+      if (current->lineno_count)
+	{
+	  current->line_filepos = lineno_base;
+	  current->moving_line_filepos = lineno_base;
+	  lineno_base += current->lineno_count * bfd_coff_linesz (abfd);
+	}
+      else
+	current->line_filepos = 0;
+
+      if (current->reloc_count)
+	{
+	  current->rel_filepos = reloc_base;
+	  reloc_base += current->reloc_count * bfd_coff_relsz (abfd);
+#ifdef COFF_WITH_PE
+	  /* Extra reloc to hold real count.  */
+	  if (obj_pe (abfd) && current->reloc_count >= 0xffff)
+	    reloc_base += bfd_coff_relsz (abfd);
+#endif
+	}
+      else
+	current->rel_filepos = 0;
+    }
+
+  /* Write section headers to the file.  */
+  internal_f.f_nscns = 0;
+
+  if ((abfd->flags & EXEC_P) != 0)
+    scn_base = bfd_coff_filhsz (abfd) + bfd_coff_aoutsz (abfd);
+  else
+    {
+      scn_base = bfd_coff_filhsz (abfd);
+#ifdef RS6000COFF_C
+#ifndef XCOFF64
+      if (xcoff_data (abfd)->full_aouthdr)
+	scn_base += bfd_coff_aoutsz (abfd);
+      else
+	scn_base += SMALL_AOUTSZ;
+#endif
+#endif
+    }
+
+  if (bfd_seek (abfd, scn_base, SEEK_SET) != 0)
+    return FALSE;
+
+  long_section_names = FALSE;
+  for (current = abfd->sections;
+       current != NULL;
+       current = current->next)
+    {
+      struct internal_scnhdr section;
+#ifdef COFF_IMAGE_WITH_PE
+      bfd_boolean is_reloc_section = FALSE;
+
+      if (strcmp (current->name, DOT_RELOC) == 0)
+	{
+	  is_reloc_section = TRUE;
+	  hasrelocs = TRUE;
+	  pe_data (abfd)->has_reloc_section = 1;
+	}
+#endif
+
+      internal_f.f_nscns++;
+
+      strncpy (section.s_name, current->name, SCNNMLEN);
+
+#ifdef COFF_LONG_SECTION_NAMES
+      /* Handle long section names as in PE.  This must be compatible
+	 with the code in coff_write_symbols and _bfd_coff_final_link.  */
+      if (bfd_coff_long_section_names (abfd))
+	{
+	  size_t len;
+
+	  len = strlen (current->name);
+	  if (len > SCNNMLEN)
+	    {
+	      /* The s_name field is defined to be NUL-padded but need not be
+		 NUL-terminated.  We use a temporary buffer so that we can still
+		 sprintf all eight chars without splatting a terminating NUL
+		 over the first byte of the following member (s_paddr).  */
+	      char s_name_buf[SCNNMLEN + 1];
+
+	      /* An inherent limitation of the /nnnnnnn notation used to indicate
+		 the offset of the long name in the string table is that we
+		 cannot address entries beyone the ten million byte boundary.  */
+	      if (string_size >= 10000000)
+		{
+		  bfd_set_error (bfd_error_file_too_big);
+		  (*_bfd_error_handler)
+		    (_("%B: section %s: string table overflow at offset %ld"),
+		    abfd, current->name, string_size);
+		  return FALSE;
+		}
+
+	      /* snprintf not strictly necessary now we've verified the value
+		 has less than eight ASCII digits, but never mind.  */
+	      snprintf (s_name_buf, SCNNMLEN + 1, "/%lu", (unsigned long) string_size);
+	      /* Then strncpy takes care of any padding for us.  */
+	      strncpy (section.s_name, s_name_buf, SCNNMLEN);
+	      string_size += len + 1;
+	      long_section_names = TRUE;
+	    }
+	}
+#endif
+
+#ifdef _LIB
+      /* Always set s_vaddr of .lib to 0.  This is right for SVR3.2
+	 Ian Taylor <ian@cygnus.com>.  */
+      if (strcmp (current->name, _LIB) == 0)
+	section.s_vaddr = 0;
+      else
+#endif
+      section.s_vaddr = current->vma;
+      section.s_paddr = current->lma;
+      section.s_size =  current->size;
+#ifdef coff_get_section_load_page
+      section.s_page = coff_get_section_load_page (current);
+#else
+      section.s_page = 0;
+#endif
+
+#ifdef COFF_WITH_PE
+      section.s_paddr = 0;
+#endif
+#ifdef COFF_IMAGE_WITH_PE
+      /* Reminder: s_paddr holds the virtual size of the section.  */
+      if (coff_section_data (abfd, current) != NULL
+	  && pei_section_data (abfd, current) != NULL)
+	section.s_paddr = pei_section_data (abfd, current)->virt_size;
+      else
+	section.s_paddr = 0;
+#endif
+
+      /* If this section has no size or is unloadable then the scnptr
+	 will be 0 too.  */
+      if (current->size == 0
+	  || (current->flags & (SEC_LOAD | SEC_HAS_CONTENTS)) == 0)
+	section.s_scnptr = 0;
+      else
+	section.s_scnptr = current->filepos;
+
+      section.s_relptr = current->rel_filepos;
+      section.s_lnnoptr = current->line_filepos;
+      section.s_nreloc = current->reloc_count;
+      section.s_nlnno = current->lineno_count;
+#ifndef COFF_IMAGE_WITH_PE
+      /* In PEI, relocs come in the .reloc section.  */
+      if (current->reloc_count != 0)
+	hasrelocs = TRUE;
+#endif
+      if (current->lineno_count != 0)
+	haslinno = TRUE;
+#ifdef COFF_IMAGE_WITH_PE
+      if ((current->flags & SEC_DEBUGGING) != 0
+	  && ! is_reloc_section)
+	hasdebug = TRUE;
+#endif
+
+#ifdef RS6000COFF_C
+#ifndef XCOFF64
+      /* Indicate the use of an XCOFF overflow section header.  */
+      if (current->reloc_count >= 0xffff || current->lineno_count >= 0xffff)
+	{
+	  section.s_nreloc = 0xffff;
+	  section.s_nlnno = 0xffff;
+	}
+#endif
+#endif
+
+      section.s_flags = sec_to_styp_flags (current->name, current->flags);
+
+      if (!strcmp (current->name, _TEXT))
+	text_sec = current;
+      else if (!strcmp (current->name, _DATA))
+	data_sec = current;
+      else if (!strcmp (current->name, _BSS))
+	bss_sec = current;
+
+#ifdef I960
+      section.s_align = (current->alignment_power
+			 ? 1 << current->alignment_power
+			 : 0);
+#endif
+#ifdef TIC80COFF
+      /* TI COFF puts the alignment power in bits 8-11 of the flags.  */
+      section.s_flags |= (current->alignment_power & 0xF) << 8;
+#endif
+#ifdef COFF_ENCODE_ALIGNMENT
+      COFF_ENCODE_ALIGNMENT(section, current->alignment_power);
+#endif
+
+#ifdef COFF_IMAGE_WITH_PE
+      /* Suppress output of the sections if they are null.  ld
+	 includes the bss and data sections even if there is no size
+	 assigned to them.  NT loader doesn't like it if these section
+	 headers are included if the sections themselves are not
+	 needed.  See also coff_compute_section_file_positions.  */
+      if (section.s_size == 0)
+	internal_f.f_nscns--;
+      else
+#endif
+	{
+	  SCNHDR buff;
+	  bfd_size_type amt = bfd_coff_scnhsz (abfd);
+
+	  if (coff_swap_scnhdr_out (abfd, &section, &buff) == 0
+	      || bfd_bwrite (& buff, amt, abfd) != amt)
+	    return FALSE;
+	}
+
+#ifdef COFF_WITH_PE
+      /* PE stores COMDAT section information in the symbol table.  If
+	 this section is supposed to have some COMDAT info, track down
+	 the symbol in the symbol table and modify it.  */
+      if ((current->flags & SEC_LINK_ONCE) != 0)
+	{
+	  unsigned int i, count;
+	  asymbol **psym;
+	  coff_symbol_type *csym = NULL;
+	  asymbol **psymsec;
+
+	  psymsec = NULL;
+	  count = bfd_get_symcount (abfd);
+	  for (i = 0, psym = abfd->outsymbols; i < count; i++, psym++)
+	    {
+	      if ((*psym)->section != current)
+		continue;
+
+	      /* Remember the location of the first symbol in this
+		 section.  */
+	      if (psymsec == NULL)
+		psymsec = psym;
+
+	      /* See if this is the section symbol.  */
+	      if (strcmp ((*psym)->name, current->name) == 0)
+		{
+		  csym = coff_symbol_from (*psym);
+		  if (csym == NULL
+		      || csym->native == NULL
+		      || ! csym->native->is_sym
+		      || csym->native->u.syment.n_numaux < 1
+		      || csym->native->u.syment.n_sclass != C_STAT
+		      || csym->native->u.syment.n_type != T_NULL)
+		    continue;
+
+		  /* Here *PSYM is the section symbol for CURRENT.  */
+
+		  break;
+		}
+	    }
+
+	  /* Did we find it?
+	     Note that we might not if we're converting the file from
+	     some other object file format.  */
+	  if (i < count)
+	    {
+	      combined_entry_type *aux;
+
+	      /* We don't touch the x_checksum field.  The
+		 x_associated field is not currently supported.  */
+
+	      aux = csym->native + 1;
+	      BFD_ASSERT (! aux->is_sym);
+	      switch (current->flags & SEC_LINK_DUPLICATES)
+		{
+		case SEC_LINK_DUPLICATES_DISCARD:
+		  aux->u.auxent.x_scn.x_comdat = IMAGE_COMDAT_SELECT_ANY;
+		  break;
+
+		case SEC_LINK_DUPLICATES_ONE_ONLY:
+		  aux->u.auxent.x_scn.x_comdat =
+		    IMAGE_COMDAT_SELECT_NODUPLICATES;
+		  break;
+
+		case SEC_LINK_DUPLICATES_SAME_SIZE:
+		  aux->u.auxent.x_scn.x_comdat =
+		    IMAGE_COMDAT_SELECT_SAME_SIZE;
+		  break;
+
+		case SEC_LINK_DUPLICATES_SAME_CONTENTS:
+		  aux->u.auxent.x_scn.x_comdat =
+		    IMAGE_COMDAT_SELECT_EXACT_MATCH;
+		  break;
+		}
+
+	      /* The COMDAT symbol must be the first symbol from this
+		 section in the symbol table.  In order to make this
+		 work, we move the COMDAT symbol before the first
+		 symbol we found in the search above.  It's OK to
+		 rearrange the symbol table at this point, because
+		 coff_renumber_symbols is going to rearrange it
+		 further and fix up all the aux entries.  */
+	      if (psym != psymsec)
+		{
+		  asymbol *hold;
+		  asymbol **pcopy;
+
+		  hold = *psym;
+		  for (pcopy = psym; pcopy > psymsec; pcopy--)
+		    pcopy[0] = pcopy[-1];
+		  *psymsec = hold;
+		}
+	    }
+	}
+#endif /* COFF_WITH_PE */
+    }
+
+#ifdef RS6000COFF_C
+#ifndef XCOFF64
+  /* XCOFF handles overflows in the reloc and line number count fields
+     by creating a new section header to hold the correct values.  */
+  for (current = abfd->sections; current != NULL; current = current->next)
+    {
+      if (current->reloc_count >= 0xffff || current->lineno_count >= 0xffff)
+	{
+	  struct internal_scnhdr scnhdr;
+	  SCNHDR buff;
+	  bfd_size_type amt;
+
+	  internal_f.f_nscns++;
+	  memcpy (scnhdr.s_name, ".ovrflo", 8);
+	  scnhdr.s_paddr = current->reloc_count;
+	  scnhdr.s_vaddr = current->lineno_count;
+	  scnhdr.s_size = 0;
+	  scnhdr.s_scnptr = 0;
+	  scnhdr.s_relptr = current->rel_filepos;
+	  scnhdr.s_lnnoptr = current->line_filepos;
+	  scnhdr.s_nreloc = current->target_index;
+	  scnhdr.s_nlnno = current->target_index;
+	  scnhdr.s_flags = STYP_OVRFLO;
+	  amt = bfd_coff_scnhsz (abfd);
+	  if (coff_swap_scnhdr_out (abfd, &scnhdr, &buff) == 0
+	      || bfd_bwrite (& buff, amt, abfd) != amt)
+	    return FALSE;
+	}
+    }
+#endif
+#endif
+
+  /* OK, now set up the filehdr...  */
+
+  /* Don't include the internal abs section in the section count */
+
+  /* We will NOT put a fucking timestamp in the header here. Every time you
+     put it back, I will come in and take it out again.  I'm sorry.  This
+     field does not belong here.  We fill it with a 0 so it compares the
+     same but is not a reasonable time. -- gnu@cygnus.com  */
+  internal_f.f_timdat = 0;
+  internal_f.f_flags = 0;
+
+  if (abfd->flags & EXEC_P)
+    internal_f.f_opthdr = bfd_coff_aoutsz (abfd);
+  else
+    {
+      internal_f.f_opthdr = 0;
+#ifdef RS6000COFF_C
+#ifndef XCOFF64
+      if (xcoff_data (abfd)->full_aouthdr)
+	internal_f.f_opthdr = bfd_coff_aoutsz (abfd);
+      else
+	internal_f.f_opthdr = SMALL_AOUTSZ;
+#endif
+#endif
+    }
+
+  if (!hasrelocs)
+    internal_f.f_flags |= F_RELFLG;
+  if (!haslinno)
+    internal_f.f_flags |= F_LNNO;
+  if (abfd->flags & EXEC_P)
+    internal_f.f_flags |= F_EXEC;
+#ifdef COFF_IMAGE_WITH_PE
+  if (! hasdebug)
+    internal_f.f_flags |= IMAGE_FILE_DEBUG_STRIPPED;
+  if (pe_data (abfd)->real_flags & IMAGE_FILE_LARGE_ADDRESS_AWARE)
+    internal_f.f_flags |= IMAGE_FILE_LARGE_ADDRESS_AWARE;
+#endif
+
+#ifndef COFF_WITH_pex64
+#ifdef COFF_WITH_PE
+  internal_f.f_flags |= IMAGE_FILE_32BIT_MACHINE;
+#else
+  if (bfd_little_endian (abfd))
+    internal_f.f_flags |= F_AR32WR;
+  else
+    internal_f.f_flags |= F_AR32W;
+#endif
+#endif
+
+#ifdef TI_TARGET_ID
+  /* Target id is used in TI COFF v1 and later; COFF0 won't use this field,
+     but it doesn't hurt to set it internally.  */
+  internal_f.f_target_id = TI_TARGET_ID;
+#endif
+#ifdef TIC80_TARGET_ID
+  internal_f.f_target_id = TIC80_TARGET_ID;
+#endif
+
+  /* FIXME, should do something about the other byte orders and
+     architectures.  */
+
+#ifdef RS6000COFF_C
+  if ((abfd->flags & DYNAMIC) != 0)
+    internal_f.f_flags |= F_SHROBJ;
+  if (bfd_get_section_by_name (abfd, _LOADER) != NULL)
+    internal_f.f_flags |= F_DYNLOAD;
+#endif
+
+  /* Set up architecture-dependent stuff.  */
+  {
+    unsigned int magic = 0;
+    unsigned short flags = 0;
+
+    coff_set_flags (abfd, &magic, &flags);
+    internal_f.f_magic = magic;
+    internal_f.f_flags |= flags;
+    /* ...and the "opt"hdr...  */
+
+#ifdef TICOFF_AOUT_MAGIC
+    internal_a.magic = TICOFF_AOUT_MAGIC;
+#define __A_MAGIC_SET__
+#endif
+#ifdef TIC80COFF
+    internal_a.magic = TIC80_ARCH_MAGIC;
+#define __A_MAGIC_SET__
+#endif /* TIC80 */
+#ifdef I860
+    /* FIXME: What are the a.out magic numbers for the i860?  */
+    internal_a.magic = 0;
+#define __A_MAGIC_SET__
+#endif /* I860 */
+#ifdef I960
+    internal_a.magic = (magic == I960ROMAGIC ? NMAGIC : OMAGIC);
+#define __A_MAGIC_SET__
+#endif /* I960 */
+#if M88
+#define __A_MAGIC_SET__
+    internal_a.magic = PAGEMAGICBCS;
+#endif /* M88 */
+
+#if APOLLO_M68
+#define __A_MAGIC_SET__
+    internal_a.magic = APOLLO_COFF_VERSION_NUMBER;
+#endif
+
+#if defined(M68) || defined(WE32K) || defined(M68K)
+#define __A_MAGIC_SET__
+#if defined(LYNXOS)
+    internal_a.magic = LYNXCOFFMAGIC;
+#else
+#if defined(TARG_AUX)
+    internal_a.magic = (abfd->flags & D_PAGED ? PAGEMAGICPEXECPAGED :
+			abfd->flags & WP_TEXT ? PAGEMAGICPEXECSWAPPED :
+			PAGEMAGICEXECSWAPPED);
+#else
+#if defined (PAGEMAGICPEXECPAGED)
+    internal_a.magic = PAGEMAGICPEXECPAGED;
+#endif
+#endif /* TARG_AUX */
+#endif /* LYNXOS */
+#endif /* M68 || WE32K || M68K */
+
+#if defined(ARM)
+#define __A_MAGIC_SET__
+    internal_a.magic = ZMAGIC;
+#endif
+
+#if defined(PPC_PE)
+#define __A_MAGIC_SET__
+    internal_a.magic = IMAGE_NT_OPTIONAL_HDR_MAGIC;
+#endif
+
+#if defined MCORE_PE
+#define __A_MAGIC_SET__
+    internal_a.magic = IMAGE_NT_OPTIONAL_HDR_MAGIC;
+#endif
+
+#if defined(I386)
+#define __A_MAGIC_SET__
+#if defined LYNXOS
+    internal_a.magic = LYNXCOFFMAGIC;
+#elif defined AMD64
+    internal_a.magic = IMAGE_NT_OPTIONAL_HDR64_MAGIC;
+#else
+    internal_a.magic = ZMAGIC;
+#endif
+#endif /* I386 */
+
+#if defined(IA64)
+#define __A_MAGIC_SET__
+    internal_a.magic = PE32PMAGIC;
+#endif /* IA64 */
+
+#if defined(SPARC)
+#define __A_MAGIC_SET__
+#if defined(LYNXOS)
+    internal_a.magic = LYNXCOFFMAGIC;
+#endif /* LYNXOS */
+#endif /* SPARC */
+
+#ifdef RS6000COFF_C
+#define __A_MAGIC_SET__
+    internal_a.magic = (abfd->flags & D_PAGED) ? RS6K_AOUTHDR_ZMAGIC :
+    (abfd->flags & WP_TEXT) ? RS6K_AOUTHDR_NMAGIC :
+    RS6K_AOUTHDR_OMAGIC;
+#endif
+
+#if defined(SH) && defined(COFF_WITH_PE)
+#define __A_MAGIC_SET__
+    internal_a.magic = SH_PE_MAGIC;
+#endif
+
+#if defined(MIPS) && defined(COFF_WITH_PE)
+#define __A_MAGIC_SET__
+    internal_a.magic = MIPS_PE_MAGIC;
+#endif
+
+#ifndef __A_MAGIC_SET__
+#include "Your aouthdr magic number is not being set!"
+#else
+#undef __A_MAGIC_SET__
+#endif
+  }
+
+  /* FIXME: Does anybody ever set this to another value?  */
+  internal_a.vstamp = 0;
+
+  /* Now should write relocs, strings, syms.  */
+  obj_sym_filepos (abfd) = sym_base;
+
+  if (bfd_get_symcount (abfd) != 0)
+    {
+      int firstundef;
+
+      if (!coff_renumber_symbols (abfd, &firstundef))
+	return FALSE;
+      coff_mangle_symbols (abfd);
+      if (! coff_write_symbols (abfd))
+	return FALSE;
+      if (! coff_write_linenumbers (abfd))
+	return FALSE;
+      if (! coff_write_relocs (abfd, firstundef))
+	return FALSE;
+    }
+#ifdef COFF_LONG_SECTION_NAMES
+  else if (long_section_names && ! obj_coff_strings_written (abfd))
+    {
+      /* If we have long section names we have to write out the string
+	 table even if there are no symbols.  */
+      if (! coff_write_symbols (abfd))
+	return FALSE;
+    }
+#endif
+#ifdef COFF_IMAGE_WITH_PE
+#ifdef PPC_PE
+  else if ((abfd->flags & EXEC_P) != 0)
+    {
+      bfd_byte b;
+
+      /* PowerPC PE appears to require that all executable files be
+	 rounded up to the page size.  */
+      b = 0;
+      if (bfd_seek (abfd,
+		    (file_ptr) BFD_ALIGN (sym_base, COFF_PAGE_SIZE) - 1,
+		    SEEK_SET) != 0
+	  || bfd_bwrite (&b, (bfd_size_type) 1, abfd) != 1)
+	return FALSE;
+    }
+#endif
+#endif
+
+  /* If bfd_get_symcount (abfd) != 0, then we are not using the COFF
+     backend linker, and obj_raw_syment_count is not valid until after
+     coff_write_symbols is called.  */
+  if (obj_raw_syment_count (abfd) != 0)
+    {
+      internal_f.f_symptr = sym_base;
+#ifdef RS6000COFF_C
+      /* AIX appears to require that F_RELFLG not be set if there are
+	 local symbols but no relocations.  */
+      internal_f.f_flags &=~ F_RELFLG;
+#endif
+    }
+  else
+    {
+      if (long_section_names)
+	internal_f.f_symptr = sym_base;
+      else
+	internal_f.f_symptr = 0;
+      internal_f.f_flags |= F_LSYMS;
+    }
+
+  if (text_sec)
+    {
+      internal_a.tsize = text_sec->size;
+      internal_a.text_start = internal_a.tsize ? text_sec->vma : 0;
+    }
+  if (data_sec)
+    {
+      internal_a.dsize = data_sec->size;
+      internal_a.data_start = internal_a.dsize ? data_sec->vma : 0;
+    }
+  if (bss_sec)
+    {
+      internal_a.bsize = bss_sec->size;
+      if (internal_a.bsize && bss_sec->vma < internal_a.data_start)
+	internal_a.data_start = bss_sec->vma;
+    }
+
+  internal_a.entry = bfd_get_start_address (abfd);
+  internal_f.f_nsyms = obj_raw_syment_count (abfd);
+
+#ifdef RS6000COFF_C
+  if (xcoff_data (abfd)->full_aouthdr)
+    {
+      bfd_vma toc;
+      asection *loader_sec;
+
+      internal_a.vstamp = 1;
+
+      internal_a.o_snentry = xcoff_data (abfd)->snentry;
+      if (internal_a.o_snentry == 0)
+	internal_a.entry = (bfd_vma) -1;
+
+      if (text_sec != NULL)
+	{
+	  internal_a.o_sntext = text_sec->target_index;
+	  internal_a.o_algntext = bfd_get_section_alignment (abfd, text_sec);
+	}
+      else
+	{
+	  internal_a.o_sntext = 0;
+	  internal_a.o_algntext = 0;
+	}
+      if (data_sec != NULL)
+	{
+	  internal_a.o_sndata = data_sec->target_index;
+	  internal_a.o_algndata = bfd_get_section_alignment (abfd, data_sec);
+	}
+      else
+	{
+	  internal_a.o_sndata = 0;
+	  internal_a.o_algndata = 0;
+	}
+      loader_sec = bfd_get_section_by_name (abfd, ".loader");
+      if (loader_sec != NULL)
+	internal_a.o_snloader = loader_sec->target_index;
+      else
+	internal_a.o_snloader = 0;
+      if (bss_sec != NULL)
+	internal_a.o_snbss = bss_sec->target_index;
+      else
+	internal_a.o_snbss = 0;
+
+      toc = xcoff_data (abfd)->toc;
+      internal_a.o_toc = toc;
+      internal_a.o_sntoc = xcoff_data (abfd)->sntoc;
+
+      internal_a.o_modtype = xcoff_data (abfd)->modtype;
+      if (xcoff_data (abfd)->cputype != -1)
+	internal_a.o_cputype = xcoff_data (abfd)->cputype;
+      else
+	{
+	  switch (bfd_get_arch (abfd))
+	    {
+	    case bfd_arch_rs6000:
+	      internal_a.o_cputype = 4;
+	      break;
+	    case bfd_arch_powerpc:
+	      if (bfd_get_mach (abfd) == bfd_mach_ppc)
+		internal_a.o_cputype = 3;
+	      else
+		internal_a.o_cputype = 1;
+	      break;
+	    default:
+	      abort ();
+	    }
+	}
+      internal_a.o_maxstack = xcoff_data (abfd)->maxstack;
+      internal_a.o_maxdata = xcoff_data (abfd)->maxdata;
+    }
+#endif
+
+#ifdef COFF_WITH_PE
+  {
+    /* After object contents are finalized so we can compute a reasonable hash,
+       but before header is written so we can update it to point to debug directory.  */
+    struct pe_tdata *pe = pe_data (abfd);
+
+    if (pe->build_id.after_write_object_contents != NULL)
+      (*pe->build_id.after_write_object_contents) (abfd);
+  }
+#endif
+
+  /* Now write header.  */
+  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
+    return FALSE;
+
+  {
+    char * buff;
+    bfd_size_type amount = bfd_coff_filhsz (abfd);
+
+    buff = (char *) bfd_malloc (amount);
+    if (buff == NULL)
+      return FALSE;
+
+    bfd_coff_swap_filehdr_out (abfd, & internal_f, buff);
+    amount = bfd_bwrite (buff, amount, abfd);
+
+    free (buff);
+
+    if (amount != bfd_coff_filhsz (abfd))
+      return FALSE;
+  }
+
+  if (abfd->flags & EXEC_P)
+    {
+      /* Note that peicode.h fills in a PEAOUTHDR, not an AOUTHDR.
+	 include/coff/pe.h sets AOUTSZ == sizeof (PEAOUTHDR)).  */
+      char * buff;
+      bfd_size_type amount = bfd_coff_aoutsz (abfd);
+
+      buff = (char *) bfd_malloc (amount);
+      if (buff == NULL)
+	return FALSE;
+
+      coff_swap_aouthdr_out (abfd, & internal_a, buff);
+      amount = bfd_bwrite (buff, amount, abfd);
+
+      free (buff);
+
+      if (amount != bfd_coff_aoutsz (abfd))
+	return FALSE;
+
+#ifdef COFF_IMAGE_WITH_PE
+      if (! coff_apply_checksum (abfd))
+	return FALSE;
+#endif
+    }
+#ifdef RS6000COFF_C
+  else
+    {
+      AOUTHDR buff;
+      size_t size;
+
+      /* XCOFF seems to always write at least a small a.out header.  */
+      coff_swap_aouthdr_out (abfd, & internal_a, & buff);
+      if (xcoff_data (abfd)->full_aouthdr)
+	size = bfd_coff_aoutsz (abfd);
+      else
+	size = SMALL_AOUTSZ;
+      if (bfd_bwrite (& buff, (bfd_size_type) size, abfd) != size)
+	return FALSE;
+    }
+#endif
+
+  return TRUE;
+}
+
+static bfd_boolean
+coff_set_section_contents (bfd * abfd,
+			   sec_ptr section,
+			   const void * location,
+			   file_ptr offset,
+			   bfd_size_type count)
+{
+  if (! abfd->output_has_begun)	/* Set by bfd.c handler.  */
+    {
+      if (! coff_compute_section_file_positions (abfd))
+	return FALSE;
+    }
+
+#if defined(_LIB) && !defined(TARG_AUX)
+   /* The physical address field of a .lib section is used to hold the
+      number of shared libraries in the section.  This code counts the
+      number of sections being written, and increments the lma field
+      with the number.
+
+      I have found no documentation on the contents of this section.
+      Experimentation indicates that the section contains zero or more
+      records, each of which has the following structure:
+
+      - a (four byte) word holding the length of this record, in words,
+      - a word that always seems to be set to "2",
+      - the path to a shared library, null-terminated and then padded
+        to a whole word boundary.
+
+      bfd_assert calls have been added to alert if an attempt is made
+      to write a section which doesn't follow these assumptions.  The
+      code has been tested on ISC 4.1 by me, and on SCO by Robert Lipe
+      <robertl@arnet.com> (Thanks!).
+
+      Gvran Uddeborg <gvran@uddeborg.pp.se>.  */
+    if (strcmp (section->name, _LIB) == 0)
+      {
+	bfd_byte *rec, *recend;
+
+	rec = (bfd_byte *) location;
+	recend = rec + count;
+	while (rec < recend)
+	  {
+	    ++section->lma;
+	    rec += bfd_get_32 (abfd, rec) * 4;
+	  }
+
+	BFD_ASSERT (rec == recend);
+      }
+#endif
+
+  /* Don't write out bss sections - one way to do this is to
+       see if the filepos has not been set.  */
+  if (section->filepos == 0)
+    return TRUE;
+
+  if (bfd_seek (abfd, section->filepos + offset, SEEK_SET) != 0)
+    return FALSE;
+
+  if (count == 0)
+    return TRUE;
+
+  return bfd_bwrite (location, count, abfd) == count;
+}
+
+static void *
+buy_and_read (bfd *abfd, file_ptr where, bfd_size_type size)
+{
+  void * area = bfd_alloc (abfd, size);
+
+  if (!area)
+    return NULL;
+  if (bfd_seek (abfd, where, SEEK_SET) != 0
+      || bfd_bread (area, size, abfd) != size)
+    return NULL;
+  return area;
+}
+
+/*
+SUBSUBSECTION
+	Reading linenumbers
+
+	Creating the linenumber table is done by reading in the entire
+	coff linenumber table, and creating another table for internal use.
+
+	A coff linenumber table is structured so that each function
+	is marked as having a line number of 0. Each line within the
+	function is an offset from the first line in the function. The
+	base of the line number information for the table is stored in
+	the symbol associated with the function.
+
+	Note: The PE format uses line number 0 for a flag indicating a
+	new source file.
+
+	The information is copied from the external to the internal
+	table, and each symbol which marks a function is marked by
+	pointing its...
+
+	How does this work ?
+*/
+
+static int
+coff_sort_func_alent (const void * arg1, const void * arg2)
+{
+  const alent *al1 = *(const alent **) arg1;
+  const alent *al2 = *(const alent **) arg2;
+  const coff_symbol_type *s1 = (const coff_symbol_type *) (al1->u.sym);
+  const coff_symbol_type *s2 = (const coff_symbol_type *) (al2->u.sym);
+
+  if (s1 == NULL || s2 == NULL)
+    return 0;
+  if (s1->symbol.value < s2->symbol.value)
+    return -1;
+  else if (s1->symbol.value > s2->symbol.value)
+    return 1;
+
+  return 0;
+}
+
+static bfd_boolean
+coff_slurp_line_table (bfd *abfd, asection *asect)
+{
+  LINENO *native_lineno;
+  alent *lineno_cache;
+  bfd_size_type amt;
+  unsigned int counter;
+  alent *cache_ptr;
+  bfd_vma prev_offset = 0;
+  bfd_boolean ordered = TRUE;
+  unsigned int nbr_func;
+  LINENO *src;
+  bfd_boolean have_func;
+  bfd_boolean ret = TRUE;
+
+  BFD_ASSERT (asect->lineno == NULL);
+
+  amt = ((bfd_size_type) asect->lineno_count + 1) * sizeof (alent);
+  lineno_cache = (alent *) bfd_alloc (abfd, amt);
+  if (lineno_cache == NULL)
+    return FALSE;
+
+  amt = (bfd_size_type) bfd_coff_linesz (abfd) * asect->lineno_count;
+  native_lineno = (LINENO *) buy_and_read (abfd, asect->line_filepos, amt);
+  if (native_lineno == NULL)
+    {
+      (*_bfd_error_handler)
+	(_("%B: warning: line number table read failed"), abfd);
+      bfd_release (abfd, lineno_cache);
+      return FALSE;
+    }
+
+  cache_ptr = lineno_cache;
+  asect->lineno = lineno_cache;
+  src = native_lineno;
+  nbr_func = 0;
+  have_func = FALSE;
+
+  for (counter = 0; counter < asect->lineno_count; counter++, src++)
+    {
+      struct internal_lineno dst;
+
+      bfd_coff_swap_lineno_in (abfd, src, &dst);
+      cache_ptr->line_number = dst.l_lnno;
+      /* Appease memory checkers that get all excited about
+	 uninitialised memory when copying alents if u.offset is
+	 larger than u.sym.  (64-bit BFD on 32-bit host.)  */
+      memset (&cache_ptr->u, 0, sizeof (cache_ptr->u));
+
+      if (cache_ptr->line_number == 0)
+	{
+	  combined_entry_type * ent;
+	  bfd_vma symndx;
+	  coff_symbol_type *sym;
+
+	  have_func = FALSE;
+	  symndx = dst.l_addr.l_symndx;
+	  if (symndx >= obj_raw_syment_count (abfd))
+	    {
+	      (*_bfd_error_handler)
+		(_("%B: warning: illegal symbol index 0x%lx in line number entry %d"),
+		 abfd, (long) symndx, counter);
+	      cache_ptr->line_number = -1;
+	      ret = FALSE;
+	      continue;
+	    }
+
+	  ent = obj_raw_syments (abfd) + symndx;
+	  /* FIXME: We should not be casting between ints and
+	     pointers like this.  */
+	  if (! ent->is_sym)
+	    {
+	      (*_bfd_error_handler)
+		(_("%B: warning: illegal symbol index 0x%lx in line number entry %d"),
+		 abfd, (long) symndx, counter);
+	      cache_ptr->line_number = -1;
+	      ret = FALSE;
+	      continue;
+	    }
+	  sym = (coff_symbol_type *) (ent->u.syment._n._n_n._n_zeroes);
+
+	  /* PR 17512 file: 078-10659-0.004  */
+	  if (sym < obj_symbols (abfd)
+	      || sym >= obj_symbols (abfd) + bfd_get_symcount (abfd))
+	    {
+	      (*_bfd_error_handler)
+		(_("%B: warning: illegal symbol in line number entry %d"),
+		 abfd, counter);
+	      cache_ptr->line_number = -1;
+	      ret = FALSE;
+	      continue;
+	    }
+
+	  have_func = TRUE;
+	  nbr_func++;
+	  cache_ptr->u.sym = (asymbol *) sym;
+	  if (sym->lineno != NULL)
+	    (*_bfd_error_handler)
+	      (_("%B: warning: duplicate line number information for `%s'"),
+	       abfd, bfd_asymbol_name (&sym->symbol));
+
+	  sym->lineno = cache_ptr;
+	  if (sym->symbol.value < prev_offset)
+	    ordered = FALSE;
+	  prev_offset = sym->symbol.value;
+	}
+      else if (!have_func)
+	/* Drop line information that has no associated function.
+	   PR 17521: file: 078-10659-0.004.  */
+	continue;
+      else
+	cache_ptr->u.offset = (dst.l_addr.l_paddr
+			       - bfd_section_vma (abfd, asect));
+      cache_ptr++;
+    }
+
+  asect->lineno_count = cache_ptr - lineno_cache;
+  memset (cache_ptr, 0, sizeof (*cache_ptr));
+  bfd_release (abfd, native_lineno);
+
+  /* On some systems (eg AIX5.3) the lineno table may not be sorted.  */
+  if (!ordered)
+    {
+      /* Sort the table.  */
+      alent **func_table;
+      alent *n_lineno_cache;
+
+      /* Create a table of functions.  */
+      func_table = (alent **) bfd_alloc (abfd, nbr_func * sizeof (alent *));
+      if (func_table != NULL)
+	{
+	  alent **p = func_table;
+	  unsigned int i;
+
+	  for (i = 0; i < asect->lineno_count; i++)
+	    if (lineno_cache[i].line_number == 0)
+	      *p++ = &lineno_cache[i];
+
+	  BFD_ASSERT ((unsigned int) (p - func_table) == nbr_func);
+
+	  /* Sort by functions.  */
+	  qsort (func_table, nbr_func, sizeof (alent *), coff_sort_func_alent);
+
+	  /* Create the new sorted table.  */
+	  amt = (bfd_size_type) asect->lineno_count * sizeof (alent);
+	  n_lineno_cache = (alent *) bfd_alloc (abfd, amt);
+	  if (n_lineno_cache != NULL)
+	    {
+	      alent *n_cache_ptr = n_lineno_cache;
+
+	      for (i = 0; i < nbr_func; i++)
+		{
+		  coff_symbol_type *sym;
+		  alent *old_ptr = func_table[i];
+
+		  /* Update the function entry.  */
+		  sym = (coff_symbol_type *) old_ptr->u.sym;
+		  /* PR binutils/17512: Point the lineno to where
+		     this entry will be after the memcpy below.  */
+		  sym->lineno = lineno_cache + (n_cache_ptr - n_lineno_cache);
+		  /* Copy the function and line number entries.  */
+		  do
+		    *n_cache_ptr++ = *old_ptr++;
+		  while (old_ptr->line_number != 0);
+		}
+	      BFD_ASSERT ((bfd_size_type) (n_cache_ptr - n_lineno_cache) == (amt / sizeof (alent)));
+
+	      memcpy (lineno_cache, n_lineno_cache, amt);
+	    }
+	  else
+	    ret = FALSE;
+	  bfd_release (abfd, func_table);
+	}
+      else
+	ret = FALSE;
+    }
+
+  return ret;
+}
+
+/* Slurp in the symbol table, converting it to generic form.  Note
+   that if coff_relocate_section is defined, the linker will read
+   symbols via coff_link_add_symbols, rather than via this routine.  */
+
+static bfd_boolean
+coff_slurp_symbol_table (bfd * abfd)
+{
+  combined_entry_type *native_symbols;
+  coff_symbol_type *cached_area;
+  unsigned int *table_ptr;
+  bfd_size_type amt;
+  unsigned int number_of_symbols = 0;
+  bfd_boolean ret = TRUE;
+
+  if (obj_symbols (abfd))
+    return TRUE;
+
+  /* Read in the symbol table.  */
+  if ((native_symbols = coff_get_normalized_symtab (abfd)) == NULL)
+    return FALSE;
+
+  /* Allocate enough room for all the symbols in cached form.  */
+  amt = obj_raw_syment_count (abfd);
+  amt *= sizeof (coff_symbol_type);
+  cached_area = (coff_symbol_type *) bfd_alloc (abfd, amt);
+  if (cached_area == NULL)
+    return FALSE;
+
+  amt = obj_raw_syment_count (abfd);
+  amt *= sizeof (unsigned int);
+  table_ptr = (unsigned int *) bfd_zalloc (abfd, amt);
+
+  if (table_ptr == NULL)
+    return FALSE;
+  else
+    {
+      coff_symbol_type *dst = cached_area;
+      unsigned int last_native_index = obj_raw_syment_count (abfd);
+      unsigned int this_index = 0;
+
+      while (this_index < last_native_index)
+	{
+	  combined_entry_type *src = native_symbols + this_index;
+	  table_ptr[this_index] = number_of_symbols;
+
+	  dst->symbol.the_bfd = abfd;
+	  BFD_ASSERT (src->is_sym);
+	  dst->symbol.name = (char *) (src->u.syment._n._n_n._n_offset);
+	  /* We use the native name field to point to the cached field.  */
+	  src->u.syment._n._n_n._n_zeroes = (bfd_hostptr_t) dst;
+	  dst->symbol.section = coff_section_from_bfd_index (abfd,
+						     src->u.syment.n_scnum);
+	  dst->symbol.flags = 0;
+	  /* PR 17512: file: 079-7098-0.001:0.1.  */
+	  dst->symbol.value = 0;
+	  dst->done_lineno = FALSE;
+
+	  switch (src->u.syment.n_sclass)
+	    {
+#ifdef I960
+	    case C_LEAFEXT:
+	      /* Fall through to next case.  */
+#endif
+
+	    case C_EXT:
+	    case C_WEAKEXT:
+#if defined ARM
+	    case C_THUMBEXT:
+	    case C_THUMBEXTFUNC:
+#endif
+#ifdef RS6000COFF_C
+	    case C_HIDEXT:
+#endif
+#ifdef C_SYSTEM
+	    case C_SYSTEM:	/* System Wide variable.  */
+#endif
+#ifdef COFF_WITH_PE
+	    /* In PE, 0x68 (104) denotes a section symbol.  */
+	    case C_SECTION:
+	    /* In PE, 0x69 (105) denotes a weak external symbol.  */
+	    case C_NT_WEAK:
+#endif
+	      switch (coff_classify_symbol (abfd, &src->u.syment))
+		{
+		case COFF_SYMBOL_GLOBAL:
+		  dst->symbol.flags = BSF_EXPORT | BSF_GLOBAL;
+#if defined COFF_WITH_PE
+		  /* PE sets the symbol to a value relative to the
+		     start of the section.  */
+		  dst->symbol.value = src->u.syment.n_value;
+#else
+		  dst->symbol.value = (src->u.syment.n_value
+				       - dst->symbol.section->vma);
+#endif
+		  if (ISFCN ((src->u.syment.n_type)))
+		    /* A function ext does not go at the end of a
+		       file.  */
+		    dst->symbol.flags |= BSF_NOT_AT_END | BSF_FUNCTION;
+		  break;
+
+		case COFF_SYMBOL_COMMON:
+		  dst->symbol.section = bfd_com_section_ptr;
+		  dst->symbol.value = src->u.syment.n_value;
+		  break;
+
+		case COFF_SYMBOL_UNDEFINED:
+		  dst->symbol.section = bfd_und_section_ptr;
+		  dst->symbol.value = 0;
+		  break;
+
+		case COFF_SYMBOL_PE_SECTION:
+		  dst->symbol.flags |= BSF_EXPORT | BSF_SECTION_SYM;
+		  dst->symbol.value = 0;
+		  break;
+
+		case COFF_SYMBOL_LOCAL:
+		  dst->symbol.flags = BSF_LOCAL;
+#if defined COFF_WITH_PE
+		  /* PE sets the symbol to a value relative to the
+		     start of the section.  */
+		  dst->symbol.value = src->u.syment.n_value;
+#else
+		  dst->symbol.value = (src->u.syment.n_value
+				       - dst->symbol.section->vma);
+#endif
+		  if (ISFCN ((src->u.syment.n_type)))
+		    dst->symbol.flags |= BSF_NOT_AT_END | BSF_FUNCTION;
+		  break;
+		}
+
+#ifdef RS6000COFF_C
+	      /* A symbol with a csect entry should not go at the end.  */
+	      if (src->u.syment.n_numaux > 0)
+		dst->symbol.flags |= BSF_NOT_AT_END;
+#endif
+
+#ifdef COFF_WITH_PE
+	      if (src->u.syment.n_sclass == C_NT_WEAK)
+		dst->symbol.flags |= BSF_WEAK;
+
+	      if (src->u.syment.n_sclass == C_SECTION
+		  && src->u.syment.n_scnum > 0)
+		dst->symbol.flags = BSF_LOCAL;
+#endif
+	      if (src->u.syment.n_sclass == C_WEAKEXT)
+		dst->symbol.flags |= BSF_WEAK;
+
+	      break;
+
+	    case C_STAT:	 /* Static.  */
+#ifdef I960
+	    case C_LEAFSTAT:	 /* Static leaf procedure.  */
+#endif
+#if defined ARM
+	    case C_THUMBSTAT:    /* Thumb static.  */
+	    case C_THUMBLABEL:   /* Thumb label.  */
+	    case C_THUMBSTATFUNC:/* Thumb static function.  */
+#endif
+#ifdef RS6000COFF_C
+            case C_DWARF:	 /* A label in a dwarf section.  */
+            case C_INFO:	 /* A label in a comment section.  */
+#endif
+	    case C_LABEL:	 /* Label.  */
+	      if (src->u.syment.n_scnum == N_DEBUG)
+		dst->symbol.flags = BSF_DEBUGGING;
+	      else
+		dst->symbol.flags = BSF_LOCAL;
+
+	      /* Base the value as an index from the base of the
+		 section, if there is one.  */
+	      if (dst->symbol.section)
+		{
+#if defined COFF_WITH_PE
+		  /* PE sets the symbol to a value relative to the
+		     start of the section.  */
+		  dst->symbol.value = src->u.syment.n_value;
+#else
+		  dst->symbol.value = (src->u.syment.n_value
+				       - dst->symbol.section->vma);
+#endif
+		}
+	      else
+		dst->symbol.value = src->u.syment.n_value;
+	      break;
+
+	    case C_MOS:		/* Member of structure.  */
+	    case C_EOS:		/* End of structure.  */
+	    case C_REGPARM:	/* Register parameter.  */
+	    case C_REG:		/* register variable.  */
+	      /* C_AUTOARG conflicts with TI COFF C_UEXT.  */
+#if !defined (TIC80COFF) && !defined (TICOFF)
+#ifdef C_AUTOARG
+	    case C_AUTOARG:	/* 960-specific storage class.  */
+#endif
+#endif
+	    case C_TPDEF:	/* Type definition.  */
+	    case C_ARG:
+	    case C_AUTO:	/* Automatic variable.  */
+	    case C_FIELD:	/* Bit field.  */
+	    case C_ENTAG:	/* Enumeration tag.  */
+	    case C_MOE:		/* Member of enumeration.  */
+	    case C_MOU:		/* Member of union.  */
+	    case C_UNTAG:	/* Union tag.  */
+	      dst->symbol.flags = BSF_DEBUGGING;
+	      dst->symbol.value = (src->u.syment.n_value);
+	      break;
+
+	    case C_FILE:	/* File name.  */
+	    case C_STRTAG:	/* Structure tag.  */
+#ifdef RS6000COFF_C
+	    case C_GSYM:
+	    case C_LSYM:
+	    case C_PSYM:
+	    case C_RSYM:
+	    case C_RPSYM:
+	    case C_STSYM:
+	    case C_TCSYM:
+	    case C_BCOMM:
+	    case C_ECOML:
+	    case C_ECOMM:
+	    case C_DECL:
+	    case C_ENTRY:
+	    case C_FUN:
+	    case C_ESTAT:
+#endif
+	      dst->symbol.flags = BSF_DEBUGGING;
+	      dst->symbol.value = (src->u.syment.n_value);
+	      break;
+
+#ifdef RS6000COFF_C
+	    case C_BINCL:	/* Beginning of include file.  */
+	    case C_EINCL:	/* Ending of include file.  */
+	      /* The value is actually a pointer into the line numbers
+		 of the file.  We locate the line number entry, and
+		 set the section to the section which contains it, and
+		 the value to the index in that section.  */
+	      {
+		asection *sec;
+
+		dst->symbol.flags = BSF_DEBUGGING;
+		for (sec = abfd->sections; sec != NULL; sec = sec->next)
+		  if (sec->line_filepos <= (file_ptr) src->u.syment.n_value
+		      && ((file_ptr) (sec->line_filepos
+				      + sec->lineno_count * bfd_coff_linesz (abfd))
+			  > (file_ptr) src->u.syment.n_value))
+		    break;
+		if (sec == NULL)
+		  dst->symbol.value = 0;
+		else
+		  {
+		    dst->symbol.section = sec;
+		    dst->symbol.value = ((src->u.syment.n_value
+					  - sec->line_filepos)
+					 / bfd_coff_linesz (abfd));
+		    src->fix_line = 1;
+		  }
+	      }
+	      break;
+
+	    case C_BSTAT:
+	      dst->symbol.flags = BSF_DEBUGGING;
+
+	      /* The value is actually a symbol index.  Save a pointer
+		 to the symbol instead of the index.  FIXME: This
+		 should use a union.  */
+	      src->u.syment.n_value =
+		(long) (intptr_t) (native_symbols + src->u.syment.n_value);
+	      dst->symbol.value = src->u.syment.n_value;
+	      src->fix_value = 1;
+	      break;
+#endif
+
+	    case C_BLOCK:	/* ".bb" or ".eb".  */
+	    case C_FCN:		/* ".bf" or ".ef" (or PE ".lf").  */
+	    case C_EFCN:	/* Physical end of function.  */
+#if defined COFF_WITH_PE
+	      /* PE sets the symbol to a value relative to the start
+		 of the section.  */
+	      dst->symbol.value = src->u.syment.n_value;
+	      if (strcmp (dst->symbol.name, ".bf") != 0)
+		{
+		  /* PE uses funny values for .ef and .lf; don't
+		     relocate them.  */
+		  dst->symbol.flags = BSF_DEBUGGING;
+		}
+	      else
+		dst->symbol.flags = BSF_DEBUGGING | BSF_DEBUGGING_RELOC;
+#else
+	      /* Base the value as an index from the base of the
+		 section.  */
+	      dst->symbol.flags = BSF_LOCAL;
+	      dst->symbol.value = (src->u.syment.n_value
+				   - dst->symbol.section->vma);
+#endif
+	      break;
+
+	    case C_STATLAB:	/* Static load time label.  */
+	      dst->symbol.value = src->u.syment.n_value;
+	      dst->symbol.flags = BSF_GLOBAL;
+	      break;
+
+	    case C_NULL:
+	      /* PE DLLs sometimes have zeroed out symbols for some
+		 reason.  Just ignore them without a warning.  */
+	      if (src->u.syment.n_type == 0
+		  && src->u.syment.n_value == 0
+		  && src->u.syment.n_scnum == 0)
+		break;
+#ifdef RS6000COFF_C
+              /* XCOFF specific: deleted entry.  */
+              if (src->u.syment.n_value == C_NULL_VALUE)
+                break;
+#endif
+	      /* Fall through.  */
+	    case C_EXTDEF:	/* External definition.  */
+	    case C_ULABEL:	/* Undefined label.  */
+	    case C_USTATIC:	/* Undefined static.  */
+#ifndef COFF_WITH_PE
+	    /* C_LINE in regular coff is 0x68.  NT has taken over this storage
+	       class to represent a section symbol.  */
+	    case C_LINE:	/* line # reformatted as symbol table entry.  */
+	      /* NT uses 0x67 for a weak symbol, not C_ALIAS.  */
+	    case C_ALIAS:	/* Duplicate tag.  */
+#endif
+	      /* New storage classes for TI COFF.  */
+#if defined(TIC80COFF) || defined(TICOFF)
+	    case C_UEXT:	/* Tentative external definition.  */
+#endif
+	    default:
+	      (*_bfd_error_handler)
+		(_("%B: Unrecognized storage class %d for %s symbol `%s'"),
+		 abfd, src->u.syment.n_sclass,
+		 dst->symbol.section->name, dst->symbol.name);
+	      ret = FALSE;
+	    case C_EXTLAB:	/* External load time label.  */
+	    case C_HIDDEN:	/* Ext symbol in dmert public lib.  */
+	      dst->symbol.flags = BSF_DEBUGGING;
+	      dst->symbol.value = (src->u.syment.n_value);
+	      break;
+	    }
+
+	  dst->native = src;
+	  dst->symbol.udata.i = 0;
+	  dst->lineno = NULL;
+
+	  this_index += (src->u.syment.n_numaux) + 1;
+	  dst++;
+	  number_of_symbols++;
+	}
+    }
+
+  obj_symbols (abfd) = cached_area;
+  obj_raw_syments (abfd) = native_symbols;
+
+  bfd_get_symcount (abfd) = number_of_symbols;
+  obj_convert (abfd) = table_ptr;
+  /* Slurp the line tables for each section too.  */
+  {
+    asection *p;
+
+    p = abfd->sections;
+    while (p)
+      {
+	if (! coff_slurp_line_table (abfd, p))
+	  return FALSE;
+	p = p->next;
+      }
+  }
+
+  return ret;
+}
+
+/* Classify a COFF symbol.  A couple of targets have globally visible
+   symbols which are not class C_EXT, and this handles those.  It also
+   recognizes some special PE cases.  */
+
+static enum coff_symbol_classification
+coff_classify_symbol (bfd *abfd,
+		      struct internal_syment *syment)
+{
+  /* FIXME: This partially duplicates the switch in
+     coff_slurp_symbol_table.  */
+  switch (syment->n_sclass)
+    {
+    case C_EXT:
+    case C_WEAKEXT:
+#ifdef I960
+    case C_LEAFEXT:
+#endif
+#ifdef ARM
+    case C_THUMBEXT:
+    case C_THUMBEXTFUNC:
+#endif
+#ifdef C_SYSTEM
+    case C_SYSTEM:
+#endif
+#ifdef COFF_WITH_PE
+    case C_NT_WEAK:
+#endif
+      if (syment->n_scnum == 0)
+	{
+	  if (syment->n_value == 0)
+	    return COFF_SYMBOL_UNDEFINED;
+	  else
+	    return COFF_SYMBOL_COMMON;
+	}
+      return COFF_SYMBOL_GLOBAL;
+
+    default:
+      break;
+    }
+
+#ifdef COFF_WITH_PE
+  if (syment->n_sclass == C_STAT)
+    {
+      if (syment->n_scnum == 0)
+	/* The Microsoft compiler sometimes generates these if a
+	   small static function is inlined every time it is used.
+	   The function is discarded, but the symbol table entry
+	   remains.  */
+	return COFF_SYMBOL_LOCAL;
+
+#ifdef STRICT_PE_FORMAT
+      /* This is correct for Microsoft generated objects, but it
+	 breaks gas generated objects.  */
+      if (syment->n_value == 0)
+	{
+	  asection *sec;
+	  char * name;
+ 	  char buf[SYMNMLEN + 1];
+
+	  name = _bfd_coff_internal_syment_name (abfd, syment, buf)
+ 	  sec = coff_section_from_bfd_index (abfd, syment->n_scnum);
+	  if (sec != NULL && name != NULL
+	      && (strcmp (bfd_get_section_name (abfd, sec), name) == 0))
+	    return COFF_SYMBOL_PE_SECTION;
+	}
+#endif
+
+      return COFF_SYMBOL_LOCAL;
+    }
+
+  if (syment->n_sclass == C_SECTION)
+    {
+      /* In some cases in a DLL generated by the Microsoft linker, the
+	 n_value field will contain garbage.  FIXME: This should
+	 probably be handled by the swapping function instead.  */
+      syment->n_value = 0;
+      if (syment->n_scnum == 0)
+	return COFF_SYMBOL_UNDEFINED;
+      return COFF_SYMBOL_PE_SECTION;
+    }
+#endif /* COFF_WITH_PE */
+
+  /* If it is not a global symbol, we presume it is a local symbol.  */
+  if (syment->n_scnum == 0)
+    {
+      char buf[SYMNMLEN + 1];
+
+      (*_bfd_error_handler)
+	(_("warning: %B: local symbol `%s' has no section"),
+	 abfd, _bfd_coff_internal_syment_name (abfd, syment, buf));
+    }
+
+  return COFF_SYMBOL_LOCAL;
+}
+
+/*
+SUBSUBSECTION
+	Reading relocations
+
+	Coff relocations are easily transformed into the internal BFD form
+	(@code{arelent}).
+
+	Reading a coff relocation table is done in the following stages:
+
+	o Read the entire coff relocation table into memory.
+
+	o Process each relocation in turn; first swap it from the
+	external to the internal form.
+
+	o Turn the symbol referenced in the relocation's symbol index
+	into a pointer into the canonical symbol table.
+	This table is the same as the one returned by a call to
+	@code{bfd_canonicalize_symtab}. The back end will call that
+	routine and save the result if a canonicalization hasn't been done.
+
+	o The reloc index is turned into a pointer to a howto
+	structure, in a back end specific way. For instance, the 386
+	and 960 use the @code{r_type} to directly produce an index
+	into a howto table vector; the 88k subtracts a number from the
+	@code{r_type} field and creates an addend field.
+*/
+
+#ifndef CALC_ADDEND
+#define CALC_ADDEND(abfd, ptr, reloc, cache_ptr)		\
+  {								\
+    coff_symbol_type *coffsym = NULL;				\
+								\
+    if (ptr && bfd_asymbol_bfd (ptr) != abfd)			\
+      coffsym = (obj_symbols (abfd)				\
+		 + (cache_ptr->sym_ptr_ptr - symbols));		\
+    else if (ptr)						\
+      coffsym = coff_symbol_from (ptr);				\
+    if (coffsym != NULL						\
+	&& coffsym->native->is_sym				\
+	&& coffsym->native->u.syment.n_scnum == 0)		\
+      cache_ptr->addend = 0;					\
+    else if (ptr && bfd_asymbol_bfd (ptr) == abfd		\
+	     && ptr->section != NULL)				\
+      cache_ptr->addend = - (ptr->section->vma + ptr->value);	\
+    else							\
+      cache_ptr->addend = 0;					\
+  }
+#endif
+
+static bfd_boolean
+coff_slurp_reloc_table (bfd * abfd, sec_ptr asect, asymbol ** symbols)
+{
+  RELOC *native_relocs;
+  arelent *reloc_cache;
+  arelent *cache_ptr;
+  unsigned int idx;
+  bfd_size_type amt;
+
+  if (asect->relocation)
+    return TRUE;
+  if (asect->reloc_count == 0)
+    return TRUE;
+  if (asect->flags & SEC_CONSTRUCTOR)
+    return TRUE;
+  if (!coff_slurp_symbol_table (abfd))
+    return FALSE;
+
+  amt = (bfd_size_type) bfd_coff_relsz (abfd) * asect->reloc_count;
+  native_relocs = (RELOC *) buy_and_read (abfd, asect->rel_filepos, amt);
+  amt = (bfd_size_type) asect->reloc_count * sizeof (arelent);
+  reloc_cache = (arelent *) bfd_alloc (abfd, amt);
+
+  if (reloc_cache == NULL || native_relocs == NULL)
+    return FALSE;
+
+  for (idx = 0; idx < asect->reloc_count; idx++)
+    {
+      struct internal_reloc dst;
+      struct external_reloc *src;
+#ifndef RELOC_PROCESSING
+      asymbol *ptr;
+#endif
+
+      cache_ptr = reloc_cache + idx;
+      src = native_relocs + idx;
+
+      dst.r_offset = 0;
+      coff_swap_reloc_in (abfd, src, &dst);
+
+#ifdef RELOC_PROCESSING
+      RELOC_PROCESSING (cache_ptr, &dst, symbols, abfd, asect);
+#else
+      cache_ptr->address = dst.r_vaddr;
+
+      if (dst.r_symndx != -1)
+	{
+	  if (dst.r_symndx < 0 || dst.r_symndx >= obj_conv_table_size (abfd))
+	    {
+	      (*_bfd_error_handler)
+		(_("%B: warning: illegal symbol index %ld in relocs"),
+		 abfd, (long) dst.r_symndx);
+	      cache_ptr->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
+	      ptr = NULL;
+	    }
+	  else
+	    {
+	      cache_ptr->sym_ptr_ptr = (symbols
+					+ obj_convert (abfd)[dst.r_symndx]);
+	      ptr = *(cache_ptr->sym_ptr_ptr);
+	    }
+	}
+      else
+	{
+	  cache_ptr->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
+	  ptr = NULL;
+	}
+
+      /* The symbols definitions that we have read in have been
+	 relocated as if their sections started at 0. But the offsets
+	 refering to the symbols in the raw data have not been
+	 modified, so we have to have a negative addend to compensate.
+
+	 Note that symbols which used to be common must be left alone.  */
+
+      /* Calculate any reloc addend by looking at the symbol.  */
+      CALC_ADDEND (abfd, ptr, dst, cache_ptr);
+      (void) ptr;
+
+      cache_ptr->address -= asect->vma;
+      /* !! cache_ptr->section = NULL;*/
+
+      /* Fill in the cache_ptr->howto field from dst.r_type.  */
+      RTYPE2HOWTO (cache_ptr, &dst);
+#endif	/* RELOC_PROCESSING */
+
+      if (cache_ptr->howto == NULL)
+	{
+	  (*_bfd_error_handler)
+	    (_("%B: illegal relocation type %d at address 0x%lx"),
+	     abfd, dst.r_type, (long) dst.r_vaddr);
+	  bfd_set_error (bfd_error_bad_value);
+	  return FALSE;
+	}
+    }
+
+  asect->relocation = reloc_cache;
+  return TRUE;
+}
+
+#ifndef coff_rtype_to_howto
+#ifdef RTYPE2HOWTO
+
+/* Get the howto structure for a reloc.  This is only used if the file
+   including this one defines coff_relocate_section to be
+   _bfd_coff_generic_relocate_section, so it is OK if it does not
+   always work.  It is the responsibility of the including file to
+   make sure it is reasonable if it is needed.  */
+
+static reloc_howto_type *
+coff_rtype_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
+		     asection *sec ATTRIBUTE_UNUSED,
+		     struct internal_reloc *rel ATTRIBUTE_UNUSED,
+		     struct coff_link_hash_entry *h ATTRIBUTE_UNUSED,
+		     struct internal_syment *sym ATTRIBUTE_UNUSED,
+		     bfd_vma *addendp ATTRIBUTE_UNUSED)
+{
+  arelent genrel;
+
+  genrel.howto = NULL;
+  RTYPE2HOWTO (&genrel, rel);
+  return genrel.howto;
+}
+
+#else /* ! defined (RTYPE2HOWTO) */
+
+#define coff_rtype_to_howto NULL
+
+#endif /* ! defined (RTYPE2HOWTO) */
+#endif /* ! defined (coff_rtype_to_howto) */
+
+/* This is stupid.  This function should be a boolean predicate.  */
+
+static long
+coff_canonicalize_reloc (bfd * abfd,
+			 sec_ptr section,
+			 arelent ** relptr,
+			 asymbol ** symbols)
+{
+  arelent *tblptr = section->relocation;
+  unsigned int count = 0;
+
+  if (section->flags & SEC_CONSTRUCTOR)
+    {
+      /* This section has relocs made up by us, they are not in the
+	 file, so take them out of their chain and place them into
+	 the data area provided.  */
+      arelent_chain *chain = section->constructor_chain;
+
+      for (count = 0; count < section->reloc_count; count++)
+	{
+	  *relptr++ = &chain->relent;
+	  chain = chain->next;
+	}
+    }
+  else
+    {
+      if (! coff_slurp_reloc_table (abfd, section, symbols))
+	return -1;
+
+      tblptr = section->relocation;
+
+      for (; count++ < section->reloc_count;)
+	*relptr++ = tblptr++;
+    }
+  *relptr = 0;
+  return section->reloc_count;
+}
+
+#ifndef coff_reloc16_estimate
+#define coff_reloc16_estimate dummy_reloc16_estimate
+
+static int
+dummy_reloc16_estimate (bfd *abfd ATTRIBUTE_UNUSED,
+			asection *input_section ATTRIBUTE_UNUSED,
+			arelent *reloc ATTRIBUTE_UNUSED,
+			unsigned int shrink ATTRIBUTE_UNUSED,
+			struct bfd_link_info *link_info ATTRIBUTE_UNUSED)
+{
+  abort ();
+  return 0;
+}
+
+#endif
+
+#ifndef coff_reloc16_extra_cases
+
+#define coff_reloc16_extra_cases dummy_reloc16_extra_cases
+
+/* This works even if abort is not declared in any header file.  */
+
+static void
+dummy_reloc16_extra_cases (bfd *abfd ATTRIBUTE_UNUSED,
+			   struct bfd_link_info *link_info ATTRIBUTE_UNUSED,
+			   struct bfd_link_order *link_order ATTRIBUTE_UNUSED,
+			   arelent *reloc ATTRIBUTE_UNUSED,
+			   bfd_byte *data ATTRIBUTE_UNUSED,
+			   unsigned int *src_ptr ATTRIBUTE_UNUSED,
+			   unsigned int *dst_ptr ATTRIBUTE_UNUSED)
+{
+  abort ();
+}
+#endif
+
+/* If coff_relocate_section is defined, we can use the optimized COFF
+   backend linker.  Otherwise we must continue to use the old linker.  */
+
+#ifdef coff_relocate_section
+
+#ifndef coff_bfd_link_hash_table_create
+#define coff_bfd_link_hash_table_create _bfd_coff_link_hash_table_create
+#endif
+#ifndef coff_bfd_link_add_symbols
+#define coff_bfd_link_add_symbols _bfd_coff_link_add_symbols
+#endif
+#ifndef coff_bfd_final_link
+#define coff_bfd_final_link _bfd_coff_final_link
+#endif
+
+#else /* ! defined (coff_relocate_section) */
+
+#define coff_relocate_section NULL
+#ifndef coff_bfd_link_hash_table_create
+#define coff_bfd_link_hash_table_create _bfd_generic_link_hash_table_create
+#endif
+#ifndef coff_bfd_link_add_symbols
+#define coff_bfd_link_add_symbols _bfd_generic_link_add_symbols
+#endif
+#define coff_bfd_final_link _bfd_generic_final_link
+
+#endif /* ! defined (coff_relocate_section) */
+
+#define coff_bfd_link_just_syms      _bfd_generic_link_just_syms
+#define coff_bfd_copy_link_hash_symbol_type \
+  _bfd_generic_copy_link_hash_symbol_type
+#define coff_bfd_link_split_section  _bfd_generic_link_split_section
+
+#ifndef coff_start_final_link
+#define coff_start_final_link NULL
+#endif
+
+#ifndef coff_adjust_symndx
+#define coff_adjust_symndx NULL
+#endif
+
+#ifndef coff_link_add_one_symbol
+#define coff_link_add_one_symbol _bfd_generic_link_add_one_symbol
+#endif
+
+#ifndef coff_link_output_has_begun
+
+static bfd_boolean
+coff_link_output_has_begun (bfd * abfd,
+			    struct coff_final_link_info * info ATTRIBUTE_UNUSED)
+{
+  return abfd->output_has_begun;
+}
+#endif
+
+#ifndef coff_final_link_postscript
+
+static bfd_boolean
+coff_final_link_postscript (bfd * abfd ATTRIBUTE_UNUSED,
+			    struct coff_final_link_info * pfinfo ATTRIBUTE_UNUSED)
+{
+  return TRUE;
+}
+#endif
+
+#ifndef coff_SWAP_aux_in
+#define coff_SWAP_aux_in coff_swap_aux_in
+#endif
+#ifndef coff_SWAP_sym_in
+#define coff_SWAP_sym_in coff_swap_sym_in
+#endif
+#ifndef coff_SWAP_lineno_in
+#define coff_SWAP_lineno_in coff_swap_lineno_in
+#endif
+#ifndef coff_SWAP_aux_out
+#define coff_SWAP_aux_out coff_swap_aux_out
+#endif
+#ifndef coff_SWAP_sym_out
+#define coff_SWAP_sym_out coff_swap_sym_out
+#endif
+#ifndef coff_SWAP_lineno_out
+#define coff_SWAP_lineno_out coff_swap_lineno_out
+#endif
+#ifndef coff_SWAP_reloc_out
+#define coff_SWAP_reloc_out coff_swap_reloc_out
+#endif
+#ifndef coff_SWAP_filehdr_out
+#define coff_SWAP_filehdr_out coff_swap_filehdr_out
+#endif
+#ifndef coff_SWAP_aouthdr_out
+#define coff_SWAP_aouthdr_out coff_swap_aouthdr_out
+#endif
+#ifndef coff_SWAP_scnhdr_out
+#define coff_SWAP_scnhdr_out coff_swap_scnhdr_out
+#endif
+#ifndef coff_SWAP_reloc_in
+#define coff_SWAP_reloc_in coff_swap_reloc_in
+#endif
+#ifndef coff_SWAP_filehdr_in
+#define coff_SWAP_filehdr_in coff_swap_filehdr_in
+#endif
+#ifndef coff_SWAP_aouthdr_in
+#define coff_SWAP_aouthdr_in coff_swap_aouthdr_in
+#endif
+#ifndef coff_SWAP_scnhdr_in
+#define coff_SWAP_scnhdr_in coff_swap_scnhdr_in
+#endif
+
+static bfd_coff_backend_data bfd_coff_std_swap_table ATTRIBUTE_UNUSED =
+{
+  coff_SWAP_aux_in, coff_SWAP_sym_in, coff_SWAP_lineno_in,
+  coff_SWAP_aux_out, coff_SWAP_sym_out,
+  coff_SWAP_lineno_out, coff_SWAP_reloc_out,
+  coff_SWAP_filehdr_out, coff_SWAP_aouthdr_out,
+  coff_SWAP_scnhdr_out,
+  FILHSZ, AOUTSZ, SCNHSZ, SYMESZ, AUXESZ, RELSZ, LINESZ, FILNMLEN,
+#ifdef COFF_LONG_FILENAMES
+  TRUE,
+#else
+  FALSE,
+#endif
+  COFF_DEFAULT_LONG_SECTION_NAMES,
+  COFF_DEFAULT_SECTION_ALIGNMENT_POWER,
+#ifdef COFF_FORCE_SYMBOLS_IN_STRINGS
+  TRUE,
+#else
+  FALSE,
+#endif
+#ifdef COFF_DEBUG_STRING_WIDE_PREFIX
+  4,
+#else
+  2,
+#endif
+  32768,
+  coff_SWAP_filehdr_in, coff_SWAP_aouthdr_in, coff_SWAP_scnhdr_in,
+  coff_SWAP_reloc_in, coff_bad_format_hook, coff_set_arch_mach_hook,
+  coff_mkobject_hook, styp_to_sec_flags, coff_set_alignment_hook,
+  coff_slurp_symbol_table, symname_in_debug_hook, coff_pointerize_aux_hook,
+  coff_print_aux, coff_reloc16_extra_cases, coff_reloc16_estimate,
+  coff_classify_symbol, coff_compute_section_file_positions,
+  coff_start_final_link, coff_relocate_section, coff_rtype_to_howto,
+  coff_adjust_symndx, coff_link_add_one_symbol,
+  coff_link_output_has_begun, coff_final_link_postscript,
+  bfd_pe_print_pdata
+};
+
+#ifdef TICOFF
+/* COFF0 differs in file/section header size and relocation entry size.  */
+
+static bfd_coff_backend_data ticoff0_swap_table =
+{
+  coff_SWAP_aux_in, coff_SWAP_sym_in, coff_SWAP_lineno_in,
+  coff_SWAP_aux_out, coff_SWAP_sym_out,
+  coff_SWAP_lineno_out, coff_SWAP_reloc_out,
+  coff_SWAP_filehdr_out, coff_SWAP_aouthdr_out,
+  coff_SWAP_scnhdr_out,
+  FILHSZ_V0, AOUTSZ, SCNHSZ_V01, SYMESZ, AUXESZ, RELSZ_V0, LINESZ, FILNMLEN,
+#ifdef COFF_LONG_FILENAMES
+  TRUE,
+#else
+  FALSE,
+#endif
+  COFF_DEFAULT_LONG_SECTION_NAMES,
+  COFF_DEFAULT_SECTION_ALIGNMENT_POWER,
+#ifdef COFF_FORCE_SYMBOLS_IN_STRINGS
+  TRUE,
+#else
+  FALSE,
+#endif
+#ifdef COFF_DEBUG_STRING_WIDE_PREFIX
+  4,
+#else
+  2,
+#endif
+  32768,
+  coff_SWAP_filehdr_in, coff_SWAP_aouthdr_in, coff_SWAP_scnhdr_in,
+  coff_SWAP_reloc_in, ticoff0_bad_format_hook, coff_set_arch_mach_hook,
+  coff_mkobject_hook, styp_to_sec_flags, coff_set_alignment_hook,
+  coff_slurp_symbol_table, symname_in_debug_hook, coff_pointerize_aux_hook,
+  coff_print_aux, coff_reloc16_extra_cases, coff_reloc16_estimate,
+  coff_classify_symbol, coff_compute_section_file_positions,
+  coff_start_final_link, coff_relocate_section, coff_rtype_to_howto,
+  coff_adjust_symndx, coff_link_add_one_symbol,
+  coff_link_output_has_begun, coff_final_link_postscript,
+  bfd_pe_print_pdata
+};
+#endif
+
+#ifdef TICOFF
+/* COFF1 differs in section header size.  */
+
+static bfd_coff_backend_data ticoff1_swap_table =
+{
+  coff_SWAP_aux_in, coff_SWAP_sym_in, coff_SWAP_lineno_in,
+  coff_SWAP_aux_out, coff_SWAP_sym_out,
+  coff_SWAP_lineno_out, coff_SWAP_reloc_out,
+  coff_SWAP_filehdr_out, coff_SWAP_aouthdr_out,
+  coff_SWAP_scnhdr_out,
+  FILHSZ, AOUTSZ, SCNHSZ_V01, SYMESZ, AUXESZ, RELSZ, LINESZ, FILNMLEN,
+#ifdef COFF_LONG_FILENAMES
+  TRUE,
+#else
+  FALSE,
+#endif
+  COFF_DEFAULT_LONG_SECTION_NAMES,
+  COFF_DEFAULT_SECTION_ALIGNMENT_POWER,
+#ifdef COFF_FORCE_SYMBOLS_IN_STRINGS
+  TRUE,
+#else
+  FALSE,
+#endif
+#ifdef COFF_DEBUG_STRING_WIDE_PREFIX
+  4,
+#else
+  2,
+#endif
+  32768,
+  coff_SWAP_filehdr_in, coff_SWAP_aouthdr_in, coff_SWAP_scnhdr_in,
+  coff_SWAP_reloc_in, ticoff1_bad_format_hook, coff_set_arch_mach_hook,
+  coff_mkobject_hook, styp_to_sec_flags, coff_set_alignment_hook,
+  coff_slurp_symbol_table, symname_in_debug_hook, coff_pointerize_aux_hook,
+  coff_print_aux, coff_reloc16_extra_cases, coff_reloc16_estimate,
+  coff_classify_symbol, coff_compute_section_file_positions,
+  coff_start_final_link, coff_relocate_section, coff_rtype_to_howto,
+  coff_adjust_symndx, coff_link_add_one_symbol,
+  coff_link_output_has_begun, coff_final_link_postscript,
+  bfd_pe_print_pdata	/* huh */
+};
+#endif
+
+#ifdef COFF_WITH_PE_BIGOBJ
+/* The UID for bigobj files.  */
+
+static const char header_bigobj_classid[16] =
+{
+  0xC7, 0xA1, 0xBA, 0xD1,
+  0xEE, 0xBA,
+  0xa9, 0x4b,
+  0xAF, 0x20,
+  0xFA, 0xF6, 0x6A, 0xA4, 0xDC, 0xB8
+};
+
+/* Swap routines.  */
+
+static void
+coff_bigobj_swap_filehdr_in (bfd * abfd, void * src, void * dst)
+{
+  struct external_ANON_OBJECT_HEADER_BIGOBJ *filehdr_src =
+    (struct external_ANON_OBJECT_HEADER_BIGOBJ *) src;
+  struct internal_filehdr *filehdr_dst = (struct internal_filehdr *) dst;
+
+  filehdr_dst->f_magic  = H_GET_16 (abfd, filehdr_src->Machine);
+  filehdr_dst->f_nscns  = H_GET_32 (abfd, filehdr_src->NumberOfSections);
+  filehdr_dst->f_timdat = H_GET_32 (abfd, filehdr_src->TimeDateStamp);
+  filehdr_dst->f_symptr =
+    GET_FILEHDR_SYMPTR (abfd, filehdr_src->PointerToSymbolTable);
+  filehdr_dst->f_nsyms  = H_GET_32 (abfd, filehdr_src->NumberOfSymbols);
+  filehdr_dst->f_opthdr = 0;
+  filehdr_dst->f_flags  = 0;
+
+  /* Check other magic numbers.  */
+  if (H_GET_16 (abfd, filehdr_src->Sig1) != IMAGE_FILE_MACHINE_UNKNOWN
+      || H_GET_16 (abfd, filehdr_src->Sig2) != 0xffff
+      || H_GET_16 (abfd, filehdr_src->Version) != 2
+      || memcmp (filehdr_src->ClassID, header_bigobj_classid, 16) != 0)
+    filehdr_dst->f_opthdr = 0xffff;
+
+  /* Note that CLR metadata are ignored.  */
+}
+
+static unsigned int
+coff_bigobj_swap_filehdr_out (bfd *abfd, void * in, void * out)
+{
+  struct internal_filehdr *filehdr_in = (struct internal_filehdr *) in;
+  struct external_ANON_OBJECT_HEADER_BIGOBJ *filehdr_out =
+    (struct external_ANON_OBJECT_HEADER_BIGOBJ *) out;
+
+  memset (filehdr_out, 0, sizeof (*filehdr_out));
+
+  H_PUT_16 (abfd, IMAGE_FILE_MACHINE_UNKNOWN, filehdr_out->Sig1);
+  H_PUT_16 (abfd, 0xffff, filehdr_out->Sig2);
+  H_PUT_16 (abfd, 2, filehdr_out->Version);
+  memcpy (filehdr_out->ClassID, header_bigobj_classid, 16);
+  H_PUT_16 (abfd, filehdr_in->f_magic, filehdr_out->Machine);
+  H_PUT_32 (abfd, filehdr_in->f_nscns, filehdr_out->NumberOfSections);
+  H_PUT_32 (abfd, filehdr_in->f_timdat, filehdr_out->TimeDateStamp);
+  PUT_FILEHDR_SYMPTR (abfd, filehdr_in->f_symptr,
+		      filehdr_out->PointerToSymbolTable);
+  H_PUT_32 (abfd, filehdr_in->f_nsyms, filehdr_out->NumberOfSymbols);
+
+  return bfd_coff_filhsz (abfd);
+}
+
+static void
+coff_bigobj_swap_sym_in (bfd * abfd, void * ext1, void * in1)
+{
+  SYMENT_BIGOBJ *ext = (SYMENT_BIGOBJ *) ext1;
+  struct internal_syment *in = (struct internal_syment *) in1;
+
+  if (ext->e.e_name[0] == 0)
+    {
+      in->_n._n_n._n_zeroes = 0;
+      in->_n._n_n._n_offset = H_GET_32 (abfd, ext->e.e.e_offset);
+    }
+  else
+    {
+#if SYMNMLEN != E_SYMNMLEN
+#error we need to cope with truncating or extending SYMNMLEN
+#else
+      memcpy (in->_n._n_name, ext->e.e_name, SYMNMLEN);
+#endif
+    }
+
+  in->n_value = H_GET_32 (abfd, ext->e_value);
+  in->n_scnum = H_GET_32 (abfd, ext->e_scnum);
+  in->n_type = H_GET_16 (abfd, ext->e_type);
+  in->n_sclass = H_GET_8 (abfd, ext->e_sclass);
+  in->n_numaux = H_GET_8 (abfd, ext->e_numaux);
+}
+
+static unsigned int
+coff_bigobj_swap_sym_out (bfd * abfd, void * inp, void * extp)
+{
+  struct internal_syment *in = (struct internal_syment *) inp;
+  SYMENT_BIGOBJ *ext = (SYMENT_BIGOBJ *) extp;
+
+  if (in->_n._n_name[0] == 0)
+    {
+      H_PUT_32 (abfd, 0, ext->e.e.e_zeroes);
+      H_PUT_32 (abfd, in->_n._n_n._n_offset, ext->e.e.e_offset);
+    }
+  else
+    {
+#if SYMNMLEN != E_SYMNMLEN
+#error we need to cope with truncating or extending SYMNMLEN
+#else
+      memcpy (ext->e.e_name, in->_n._n_name, SYMNMLEN);
+#endif
+    }
+
+  H_PUT_32 (abfd, in->n_value, ext->e_value);
+  H_PUT_32 (abfd, in->n_scnum, ext->e_scnum);
+
+  H_PUT_16 (abfd, in->n_type, ext->e_type);
+  H_PUT_8 (abfd, in->n_sclass, ext->e_sclass);
+  H_PUT_8 (abfd, in->n_numaux, ext->e_numaux);
+
+  return SYMESZ_BIGOBJ;
+}
+
+static void
+coff_bigobj_swap_aux_in (bfd *abfd,
+			 void * ext1,
+			 int type,
+			 int in_class,
+			 int indx,
+			 int numaux,
+			 void * in1)
+{
+  AUXENT_BIGOBJ *ext = (AUXENT_BIGOBJ *) ext1;
+  union internal_auxent *in = (union internal_auxent *) in1;
+
+  switch (in_class)
+    {
+    case C_FILE:
+      if (numaux > 1)
+	{
+	  if (indx == 0)
+	    memcpy (in->x_file.x_fname, ext->File.Name,
+		    numaux * sizeof (AUXENT_BIGOBJ));
+	}
+      else
+	memcpy (in->x_file.x_fname, ext->File.Name, sizeof (ext->File.Name));
+      break;
+
+    case C_STAT:
+    case C_LEAFSTAT:
+    case C_HIDDEN:
+      if (type == T_NULL)
+	{
+	  in->x_scn.x_scnlen = H_GET_32 (abfd, ext->Section.Length);
+	  in->x_scn.x_nreloc =
+	    H_GET_16 (abfd, ext->Section.NumberOfRelocations);
+	  in->x_scn.x_nlinno =
+	    H_GET_16 (abfd, ext->Section.NumberOfLinenumbers);
+	  in->x_scn.x_checksum = H_GET_32 (abfd, ext->Section.Checksum);
+	  in->x_scn.x_associated = H_GET_16 (abfd, ext->Section.Number)
+	    | (H_GET_16 (abfd, ext->Section.HighNumber) << 16);
+	  in->x_scn.x_comdat = H_GET_8 (abfd, ext->Section.Selection);
+	  return;
+	}
+      break;
+
+    default:
+      in->x_sym.x_tagndx.l = H_GET_32 (abfd, ext->Sym.WeakDefaultSymIndex);
+      /* Characteristics is ignored.  */
+      break;
+    }
+}
+
+static unsigned int
+coff_bigobj_swap_aux_out (bfd * abfd,
+			  void * inp,
+			  int type,
+			  int in_class,
+			  int indx ATTRIBUTE_UNUSED,
+			  int numaux ATTRIBUTE_UNUSED,
+			  void * extp)
+{
+  union internal_auxent * in = (union internal_auxent *) inp;
+  AUXENT_BIGOBJ *ext = (AUXENT_BIGOBJ *) extp;
+
+  memset (ext, 0, AUXESZ);
+
+  switch (in_class)
+    {
+    case C_FILE:
+      memcpy (ext->File.Name, in->x_file.x_fname, sizeof (ext->File.Name));
+
+      return AUXESZ;
+
+    case C_STAT:
+    case C_LEAFSTAT:
+    case C_HIDDEN:
+      if (type == T_NULL)
+	{
+	  H_PUT_32 (abfd, in->x_scn.x_scnlen, ext->Section.Length);
+	  H_PUT_16 (abfd, in->x_scn.x_nreloc,
+		    ext->Section.NumberOfRelocations);
+	  H_PUT_16 (abfd, in->x_scn.x_nlinno,
+		    ext->Section.NumberOfLinenumbers);
+	  H_PUT_32 (abfd, in->x_scn.x_checksum, ext->Section.Checksum);
+	  H_PUT_16 (abfd, in->x_scn.x_associated & 0xffff,
+		    ext->Section.Number);
+	  H_PUT_16 (abfd, (in->x_scn.x_associated >> 16),
+		    ext->Section.HighNumber);
+	  H_PUT_8 (abfd, in->x_scn.x_comdat, ext->Section.Selection);
+	  return AUXESZ;
+	}
+      break;
+    }
+
+  H_PUT_32 (abfd, in->x_sym.x_tagndx.l, ext->Sym.WeakDefaultSymIndex);
+  H_PUT_32 (abfd, 1, ext->Sym.WeakSearchType);
+
+  return AUXESZ;
+}
+
+static bfd_coff_backend_data bigobj_swap_table =
+{
+  coff_bigobj_swap_aux_in, coff_bigobj_swap_sym_in, coff_SWAP_lineno_in,
+  coff_bigobj_swap_aux_out, coff_bigobj_swap_sym_out,
+  coff_SWAP_lineno_out, coff_SWAP_reloc_out,
+  coff_bigobj_swap_filehdr_out, coff_SWAP_aouthdr_out,
+  coff_SWAP_scnhdr_out,
+  FILHSZ_BIGOBJ, AOUTSZ, SCNHSZ, SYMESZ_BIGOBJ, AUXESZ_BIGOBJ,
+   RELSZ, LINESZ, FILNMLEN_BIGOBJ,
+  TRUE,
+  COFF_DEFAULT_LONG_SECTION_NAMES,
+  COFF_DEFAULT_SECTION_ALIGNMENT_POWER,
+  FALSE,
+  2,
+  1U << 31,
+  coff_bigobj_swap_filehdr_in, coff_SWAP_aouthdr_in, coff_SWAP_scnhdr_in,
+  coff_SWAP_reloc_in, coff_bad_format_hook, coff_set_arch_mach_hook,
+  coff_mkobject_hook, styp_to_sec_flags, coff_set_alignment_hook,
+  coff_slurp_symbol_table, symname_in_debug_hook, coff_pointerize_aux_hook,
+  coff_print_aux, coff_reloc16_extra_cases, coff_reloc16_estimate,
+  coff_classify_symbol, coff_compute_section_file_positions,
+  coff_start_final_link, coff_relocate_section, coff_rtype_to_howto,
+  coff_adjust_symndx, coff_link_add_one_symbol,
+  coff_link_output_has_begun, coff_final_link_postscript,
+  bfd_pe_print_pdata	/* huh */
+};
+
+#endif /* COFF_WITH_PE_BIGOBJ */
+
+#ifndef coff_close_and_cleanup
+#define coff_close_and_cleanup		    _bfd_generic_close_and_cleanup
+#endif
+
+#ifndef coff_bfd_free_cached_info
+#define coff_bfd_free_cached_info	    _bfd_generic_bfd_free_cached_info
+#endif
+
+#ifndef coff_get_section_contents
+#define coff_get_section_contents	    _bfd_generic_get_section_contents
+#endif
+
+#ifndef coff_bfd_copy_private_symbol_data
+#define coff_bfd_copy_private_symbol_data   _bfd_generic_bfd_copy_private_symbol_data
+#endif
+
+#ifndef coff_bfd_copy_private_header_data
+#define coff_bfd_copy_private_header_data   _bfd_generic_bfd_copy_private_header_data
+#endif
+
+#ifndef coff_bfd_copy_private_section_data
+#define coff_bfd_copy_private_section_data  _bfd_generic_bfd_copy_private_section_data
+#endif
+
+#ifndef coff_bfd_copy_private_bfd_data
+#define coff_bfd_copy_private_bfd_data      _bfd_generic_bfd_copy_private_bfd_data
+#endif
+
+#ifndef coff_bfd_merge_private_bfd_data
+#define coff_bfd_merge_private_bfd_data     _bfd_generic_bfd_merge_private_bfd_data
+#endif
+
+#ifndef coff_bfd_set_private_flags
+#define coff_bfd_set_private_flags	    _bfd_generic_bfd_set_private_flags
+#endif
+
+#ifndef coff_bfd_print_private_bfd_data
+#define coff_bfd_print_private_bfd_data     _bfd_generic_bfd_print_private_bfd_data
+#endif
+
+#ifndef coff_bfd_is_local_label_name
+#define coff_bfd_is_local_label_name	    _bfd_coff_is_local_label_name
+#endif
+
+#ifndef coff_bfd_is_target_special_symbol
+#define coff_bfd_is_target_special_symbol   ((bfd_boolean (*) (bfd *, asymbol *)) bfd_false)
+#endif
+
+#ifndef coff_read_minisymbols
+#define coff_read_minisymbols		    _bfd_generic_read_minisymbols
+#endif
+
+#ifndef coff_minisymbol_to_symbol
+#define coff_minisymbol_to_symbol	    _bfd_generic_minisymbol_to_symbol
+#endif
+
+/* The reloc lookup routine must be supplied by each individual COFF
+   backend.  */
+#ifndef coff_bfd_reloc_type_lookup
+#define coff_bfd_reloc_type_lookup	    _bfd_norelocs_bfd_reloc_type_lookup
+#endif
+#ifndef coff_bfd_reloc_name_lookup
+#define coff_bfd_reloc_name_lookup    _bfd_norelocs_bfd_reloc_name_lookup
+#endif
+
+#ifndef coff_bfd_get_relocated_section_contents
+#define coff_bfd_get_relocated_section_contents \
+  bfd_generic_get_relocated_section_contents
+#endif
+
+#ifndef coff_bfd_relax_section
+#define coff_bfd_relax_section		    bfd_generic_relax_section
+#endif
+
+#ifndef coff_bfd_gc_sections
+#define coff_bfd_gc_sections		    bfd_coff_gc_sections
+#endif
+
+#ifndef coff_bfd_lookup_section_flags
+#define coff_bfd_lookup_section_flags	    bfd_generic_lookup_section_flags
+#endif
+
+#ifndef coff_bfd_merge_sections
+#define coff_bfd_merge_sections		    bfd_generic_merge_sections
+#endif
+
+#ifndef coff_bfd_is_group_section
+#define coff_bfd_is_group_section	    bfd_generic_is_group_section
+#endif
+
+#ifndef coff_bfd_discard_group
+#define coff_bfd_discard_group		    bfd_generic_discard_group
+#endif
+
+#ifndef coff_section_already_linked
+#define coff_section_already_linked \
+  _bfd_coff_section_already_linked
+#endif
+
+#ifndef coff_bfd_define_common_symbol
+#define coff_bfd_define_common_symbol	    bfd_generic_define_common_symbol
+#endif
+
+#define CREATE_BIG_COFF_TARGET_VEC(VAR, NAME, EXTRA_O_FLAGS, EXTRA_S_FLAGS, UNDER, ALTERNATIVE, SWAP_TABLE)	\
+const bfd_target VAR =							\
+{									\
+  NAME ,								\
+  bfd_target_coff_flavour,						\
+  BFD_ENDIAN_BIG,		/* Data byte order is big.  */		\
+  BFD_ENDIAN_BIG,		/* Header byte order is big.  */	\
+  /* object flags */							\
+  (HAS_RELOC | EXEC_P | HAS_LINENO | HAS_DEBUG |			\
+   HAS_SYMS | HAS_LOCALS | WP_TEXT | EXTRA_O_FLAGS),			\
+  /* section flags */							\
+  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | EXTRA_S_FLAGS),\
+  UNDER,			/* Leading symbol underscore.  */	\
+  '/',				/* AR_pad_char.  */			\
+  15,				/* AR_max_namelen.  */			\
+  0,				/* match priority.  */			\
+									\
+  /* Data conversion functions.  */					\
+  bfd_getb64, bfd_getb_signed_64, bfd_putb64,				\
+  bfd_getb32, bfd_getb_signed_32, bfd_putb32,				\
+  bfd_getb16, bfd_getb_signed_16, bfd_putb16,				\
+									\
+  /* Header conversion functions.  */					\
+  bfd_getb64, bfd_getb_signed_64, bfd_putb64,				\
+  bfd_getb32, bfd_getb_signed_32, bfd_putb32,				\
+  bfd_getb16, bfd_getb_signed_16, bfd_putb16,				\
+									\
+	/* bfd_check_format.  */					\
+  { _bfd_dummy_target, coff_object_p, bfd_generic_archive_p,		\
+    _bfd_dummy_target },						\
+	/* bfd_set_format.  */						\
+  { bfd_false, coff_mkobject, _bfd_generic_mkarchive, bfd_false },	\
+	/* bfd_write_contents.  */					\
+  { bfd_false, coff_write_object_contents, _bfd_write_archive_contents,	\
+    bfd_false },							\
+									\
+  BFD_JUMP_TABLE_GENERIC (coff),					\
+  BFD_JUMP_TABLE_COPY (coff),						\
+  BFD_JUMP_TABLE_CORE (_bfd_nocore),					\
+  BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),				\
+  BFD_JUMP_TABLE_SYMBOLS (coff),					\
+  BFD_JUMP_TABLE_RELOCS (coff),						\
+  BFD_JUMP_TABLE_WRITE (coff),						\
+  BFD_JUMP_TABLE_LINK (coff),						\
+  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),				\
+									\
+  ALTERNATIVE,								\
+									\
+  SWAP_TABLE								\
+};
+
+#define CREATE_BIGHDR_COFF_TARGET_VEC(VAR, NAME, EXTRA_O_FLAGS, EXTRA_S_FLAGS, UNDER, ALTERNATIVE, SWAP_TABLE)	\
+const bfd_target VAR =							\
+{									\
+  NAME ,								\
+  bfd_target_coff_flavour,						\
+  BFD_ENDIAN_LITTLE,		/* Data byte order is little.  */	\
+  BFD_ENDIAN_BIG,		/* Header byte order is big.  */	\
+  /* object flags */							\
+  (HAS_RELOC | EXEC_P | HAS_LINENO | HAS_DEBUG |			\
+   HAS_SYMS | HAS_LOCALS | WP_TEXT | EXTRA_O_FLAGS),			\
+  /* section flags */							\
+  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | EXTRA_S_FLAGS),\
+  UNDER,			/* Leading symbol underscore.  */	\
+  '/',				/* AR_pad_char.  */			\
+  15,				/* AR_max_namelen.  */			\
+  0,				/* match priority.  */			\
+									\
+  /* Data conversion functions.  */					\
+  bfd_getb64, bfd_getb_signed_64, bfd_putb64,				\
+  bfd_getb32, bfd_getb_signed_32, bfd_putb32,				\
+  bfd_getb16, bfd_getb_signed_16, bfd_putb16,				\
+									\
+  /* Header conversion functions.  */					\
+  bfd_getb64, bfd_getb_signed_64, bfd_putb64,				\
+  bfd_getb32, bfd_getb_signed_32, bfd_putb32,				\
+  bfd_getb16, bfd_getb_signed_16, bfd_putb16,				\
+									\
+	/* bfd_check_format.  */					\
+  { _bfd_dummy_target, coff_object_p, bfd_generic_archive_p,		\
+    _bfd_dummy_target },						\
+	/* bfd_set_format.  */						\
+  { bfd_false, coff_mkobject, _bfd_generic_mkarchive, bfd_false },	\
+	/* bfd_write_contents.  */					\
+  { bfd_false, coff_write_object_contents, _bfd_write_archive_contents,	\
+    bfd_false },							\
+									\
+  BFD_JUMP_TABLE_GENERIC (coff),					\
+  BFD_JUMP_TABLE_COPY (coff),						\
+  BFD_JUMP_TABLE_CORE (_bfd_nocore),					\
+  BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),				\
+  BFD_JUMP_TABLE_SYMBOLS (coff),					\
+  BFD_JUMP_TABLE_RELOCS (coff),						\
+  BFD_JUMP_TABLE_WRITE (coff),						\
+  BFD_JUMP_TABLE_LINK (coff),						\
+  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),				\
+									\
+  ALTERNATIVE,								\
+									\
+  SWAP_TABLE								\
+};
+
+#define CREATE_LITTLE_COFF_TARGET_VEC(VAR, NAME, EXTRA_O_FLAGS, EXTRA_S_FLAGS, UNDER, ALTERNATIVE, SWAP_TABLE)	\
+const bfd_target VAR =							\
+{									\
+  NAME ,								\
+  bfd_target_coff_flavour,						\
+  BFD_ENDIAN_LITTLE,		/* Data byte order is little.  */	\
+  BFD_ENDIAN_LITTLE,		/* Header byte order is little.  */	\
+	/* object flags */						\
+  (HAS_RELOC | EXEC_P | HAS_LINENO | HAS_DEBUG |			\
+   HAS_SYMS | HAS_LOCALS | WP_TEXT | EXTRA_O_FLAGS),			\
+	/* section flags */						\
+  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | EXTRA_S_FLAGS),\
+  UNDER,			/* Leading symbol underscore.  */	\
+  '/',				/* AR_pad_char.  */			\
+  15,				/* AR_max_namelen.  */			\
+  0,				/* match priority.  */			\
+									\
+  /* Data conversion functions.  */					\
+  bfd_getl64, bfd_getl_signed_64, bfd_putl64,				\
+  bfd_getl32, bfd_getl_signed_32, bfd_putl32,				\
+  bfd_getl16, bfd_getl_signed_16, bfd_putl16,				\
+  /* Header conversion functions.  */					\
+  bfd_getl64, bfd_getl_signed_64, bfd_putl64,				\
+  bfd_getl32, bfd_getl_signed_32, bfd_putl32,				\
+  bfd_getl16, bfd_getl_signed_16, bfd_putl16,				\
+	/* bfd_check_format.  */					\
+  { _bfd_dummy_target, coff_object_p, bfd_generic_archive_p,		\
+    _bfd_dummy_target },						\
+       /* bfd_set_format.  */						\
+  { bfd_false, coff_mkobject, _bfd_generic_mkarchive, bfd_false },	\
+	/* bfd_write_contents.  */					\
+  { bfd_false, coff_write_object_contents, _bfd_write_archive_contents,	\
+    bfd_false },							\
+									\
+  BFD_JUMP_TABLE_GENERIC (coff),					\
+  BFD_JUMP_TABLE_COPY (coff),						\
+  BFD_JUMP_TABLE_CORE (_bfd_nocore),					\
+  BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),				\
+  BFD_JUMP_TABLE_SYMBOLS (coff),					\
+  BFD_JUMP_TABLE_RELOCS (coff),						\
+  BFD_JUMP_TABLE_WRITE (coff),						\
+  BFD_JUMP_TABLE_LINK (coff),						\
+  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),				\
+									\
+  ALTERNATIVE,								\
+									\
+  SWAP_TABLE								\
+};
diff -Naur binutils-2.26/bfd/config.bfd binutils-2.26.0007/bfd/config.bfd
--- binutils-2.26/bfd/config.bfd	2015-11-13 09:27:40.000000000 +0100
+++ binutils-2.26.0007/bfd/config.bfd	2016-03-10 17:02:24.180720021 +0100
@@ -318,6 +318,12 @@
     targ_underscore=no
     targ_cflags="-DARM_WINCE -DARM_COFF_BUGFIX"
     ;;
+  arm*-*-mingw32* | arm*-*-cygwin*)
+    targ_defvec=arm_pe_winnt_le_vec
+    targ_selvecs="arm_pe_winnt_le_vec arm_pe_winnt_be_vec arm_pei_winnt_le_vec arm_pei_winnt_be_vec"
+    targ_underscore=no
+    targ_cflags="-DARM_WINNT -DARM_COFF_BUGFIX"
+    ;;
   arm-*-pe*)
     targ_defvec=arm_pe_le_vec
     targ_selvecs="arm_pe_le_vec arm_pe_be_vec arm_pei_le_vec arm_pei_be_vec"
diff -Naur binutils-2.26/bfd/config.bfd.orig binutils-2.26.0007/bfd/config.bfd.orig
--- binutils-2.26/bfd/config.bfd.orig	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.26.0007/bfd/config.bfd.orig	2016-03-10 17:01:57.664637348 +0100
@@ -0,0 +1,1802 @@
+# config.bfd
+#
+#   Copyright (C) 2012-2015 Free Software Foundation, Inc.
+#
+# This file is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+#
+# Convert a canonical host type into a BFD host type.
+# Set shell variable targ to canonical target name, and run
+# using ``. config.bfd''.
+# Sets the following shell variables:
+#  targ_defvec		Default vector for this target
+#  targ_selvecs		Vectors to build for this target
+#  targ64_selvecs	Vectors to build if --enable-64-bit-bfd is given
+#			or if host is 64 bit.
+#  targ_archs		Architectures for this target
+#  targ_cflags		$(CFLAGS) for this target (FIXME: pretty bogus)
+#  targ_underscore	Whether underscores are used: yes or no
+
+# Part of this file is processed by targmatch.sed to generate the
+# targmatch.h file.  The #ifdef and #endif lines that appear below are
+# copied directly into targmatch.h.
+
+# The binutils c++filt program wants to know whether underscores are
+# stripped or not.  That is why we set targ_underscore.  c++filt uses
+# this information to choose a default.  This information is
+# duplicated in the symbol_leading_char field of the BFD target
+# vector, but c++filt does not deal with object files and is not
+# linked against libbfd.a.  It is not terribly important that c++filt
+# get this right; it is just convenient.
+
+targ_defvec=
+targ_selvecs=
+targ64_selvecs=
+targ_cflags=
+targ_underscore=no
+
+# Catch obsolete configurations.
+case $targ in
+ openrisc-*-* | or32-*-*)
+    echo "*** Configuration $targ is obsolete." >&2
+    echo "*** Use or1k-*-elf or or1k-*-linux as the target instead" >&2
+    exit 1
+    ;;
+ null)
+    if test "x$enable_obsolete" != xyes; then
+      echo "*** Configuration $targ is obsolete." >&2
+      echo "*** Specify --enable-obsolete to build it anyway." >&2
+      echo "*** Support will be REMOVED in the next major release of BINUTILS," >&2
+      echo "*** unless a maintainer comes forward." >&2
+      exit 1
+    fi;;
+esac
+
+case $targ in
+ *-go32-rtems* | \
+ a29k-* | \
+ arm-*-oabi | \
+ hppa*-*-rtems* | \
+ i960-*-rtems* | \
+ i[3-7]86*-*-rtemscoff* | \
+ m68*-*-lynxos* | \
+ m68*-*-rtemscoff* | \
+ m68*-apollo-* | \
+ m68*-apple-aux* | \
+ m68*-bull-sysv* | \
+ maxq-*-coff | \
+ mips*el-*-rtems* | \
+ powerpcle-*-rtems* | \
+ sparc*-*-rtemsaout* | \
+ sparc-*-lynxos* | \
+ vax-*-vms* | \
+ null)
+    echo "*** Configuration $targ is obsolete." >&2
+    echo "*** Support has been REMOVED." >&2
+    exit 1
+    ;;
+esac
+
+targ_cpu=`echo $targ | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+case "${targ_cpu}" in
+aarch64*)	 targ_archs="bfd_aarch64_arch bfd_arm_arch";;
+alpha*)		 targ_archs=bfd_alpha_arch ;;
+am34*|am33_2.0*) targ_archs=bfd_mn10300_arch ;;
+arc*)		 targ_archs=bfd_arc_arch ;;
+arm*)		 targ_archs=bfd_arm_arch ;;
+bfin*)		 targ_archs=bfd_bfin_arch ;;
+c30*)		 targ_archs=bfd_tic30_arch ;;
+c4x*)		 targ_archs=bfd_tic4x_arch ;;
+c54x*)		 targ_archs=bfd_tic54x_arch ;;
+cr16*)		 targ_archs=bfd_cr16_arch ;;
+crisv32)	 targ_archs=bfd_cris_arch ;;
+crx*)		 targ_archs=bfd_crx_arch ;;
+dlx*)		 targ_archs=bfd_dlx_arch ;;
+fido*)		 targ_archs=bfd_m68k_arch ;;
+hppa*)		 targ_archs=bfd_hppa_arch ;;
+i[3-7]86)	 targ_archs=bfd_i386_arch ;;
+i370)		 targ_archs=bfd_i370_arch ;;
+lm32)	         targ_archs=bfd_lm32_arch ;;
+m6811*|m68hc11*) targ_archs="bfd_m68hc11_arch bfd_m68hc12_arch bfd_m9s12x_arch bfd_m9s12xg_arch" ;;
+m6812*|m68hc12*) targ_archs="bfd_m68hc12_arch bfd_m68hc11_arch bfd_m9s12x_arch bfd_m9s12xg_arch" ;;
+m68*)		 targ_archs=bfd_m68k_arch ;;
+m88*)		 targ_archs=bfd_m88k_arch ;;
+microblaze*)	 targ_archs=bfd_microblaze_arch ;;
+mips*)		 targ_archs=bfd_mips_arch ;;
+nds32*)		 targ_archs=bfd_nds32_arch ;;
+nios2*)          targ_archs=bfd_nios2_arch ;;
+or1k*|or1knd*)	 targ_archs=bfd_or1k_arch ;;
+pdp11*)		 targ_archs=bfd_pdp11_arch ;;
+pj*)		 targ_archs="bfd_pj_arch bfd_i386_arch";;
+powerpc*)	 targ_archs="bfd_rs6000_arch bfd_powerpc_arch" ;;
+rs6000)		 targ_archs="bfd_rs6000_arch bfd_powerpc_arch" ;;
+s390*)		 targ_archs=bfd_s390_arch ;;
+sh*)		 targ_archs=bfd_sh_arch ;;
+sparc*)		 targ_archs=bfd_sparc_arch ;;
+spu*)            targ_archs=bfd_spu_arch ;;
+tilegx*)	 targ_archs=bfd_tilegx_arch ;;
+tilepro*)	 targ_archs=bfd_tilepro_arch ;;
+v850*)		 targ_archs="bfd_v850_arch bfd_v850_rh850_arch" ;;
+visium*)	 targ_archs=bfd_visium_arch ;;
+x86_64*)	 targ_archs=bfd_i386_arch ;;
+xtensa*)	 targ_archs=bfd_xtensa_arch ;;
+xgate)		 targ_archs=bfd_xgate_arch ;;
+z80|r800)	 targ_archs=bfd_z80_arch ;;
+z8k*)		 targ_archs=bfd_z8k_arch ;;
+*)		 targ_archs=bfd_${targ_cpu}_arch ;;
+esac
+
+
+# WHEN ADDING ENTRIES TO THIS MATRIX:
+#  Make sure that the left side always has two dashes.  Otherwise you
+#  can get spurious matches.  Even for unambiguous cases, do this as a
+#  convention, else the table becomes a real mess to understand and maintain.
+#
+#  Keep obsolete entries above the START comment, to keep them out of
+#  targmatch.h.
+
+case "${targ}" in
+  mips*-dec-bsd*)
+    echo "This target is obsolete and has been removed."
+    exit 1
+    ;;
+
+  mips*-*-mach3*)
+    echo "This target is obsolete and has been removed."
+    exit 1
+    ;;
+
+  mips*-*-pe*)
+    echo "This target is obsolete and has been removed."
+    exit 1
+    ;;
+
+  plugin)
+    targ_defvec=plugin_vec
+    targ_selvecs="plugin_vec"
+    ;;
+
+# START OF targmatch.h
+#ifdef BFD64
+  aarch64-*-elf)
+    targ_defvec=aarch64_elf64_le_vec
+    targ_selvecs="aarch64_elf64_be_vec aarch64_elf32_le_vec aarch64_elf32_be_vec arm_elf32_le_vec arm_elf32_be_vec"
+    want64=true
+    ;;
+  aarch64_be-*-elf)
+    targ_defvec=aarch64_elf64_be_vec
+    targ_selvecs="aarch64_elf64_le_vec aarch64_elf32_le_vec aarch64_elf32_be_vec arm_elf32_be_vec arm_elf32_le_vec"
+    want64=true
+    ;;
+  aarch64-*-freebsd*)
+    targ_defvec=aarch64_elf64_le_vec
+    targ_selvecs="aarch64_elf64_be_vec arm_elf32_le_vec arm_elf32_be_vec"
+    want64=true
+    ;;
+  aarch64-*-cloudabi*)
+    targ_defvec=aarch64_elf64_le_cloudabi_vec
+    targ_selvecs=aarch64_elf64_be_cloudabi_vec
+    want64=true
+    ;;
+  aarch64-*-linux*)
+    targ_defvec=aarch64_elf64_le_vec
+    targ_selvecs="aarch64_elf64_be_vec aarch64_elf32_le_vec aarch64_elf32_be_vec arm_elf32_le_vec arm_elf32_be_vec"
+    want64=true
+    ;;
+  aarch64_be-*-linux*)
+    targ_defvec=aarch64_elf64_be_vec
+    targ_selvecs="aarch64_elf64_le_vec aarch64_elf32_le_vec aarch64_elf32_be_vec arm_elf32_be_vec arm_elf32_le_vec"
+    want64=true
+    ;;
+  alpha*-*-freebsd* | alpha*-*-kfreebsd*-gnu)
+    targ_defvec=alpha_elf64_fbsd_vec
+    targ_selvecs="alpha_elf64_vec alpha_ecoff_le_vec"
+    want64=true
+    # FreeBSD <= 4.0 supports only the old nonstandard way of ABI labelling.
+    case "${targ}" in
+      alpha*-*-freebsd3* | alpha*-*-freebsd4 | alpha*-*-freebsd4.0*)
+	targ_cflags=-DOLD_FREEBSD_ABI_LABEL ;;
+    esac
+    ;;
+  alpha*-*-netbsd* | alpha*-*-openbsd*)
+    targ_defvec=alpha_elf64_vec
+    targ_selvecs=alpha_ecoff_le_vec
+    want64=true
+    ;;
+  alpha*-*-netware*)
+    targ_defvec=alpha_ecoff_le_vec
+    targ_selvecs=alpha_nlm32_vec
+    want64=true
+    ;;
+  alpha*-*-linux*ecoff*)
+    targ_defvec=alpha_ecoff_le_vec
+    targ_selvecs=alpha_elf64_vec
+    want64=true
+    ;;
+  alpha*-*-linux-* | alpha*-*-elf*)
+    targ_defvec=alpha_elf64_vec
+    targ_selvecs=alpha_ecoff_le_vec
+    want64=true
+    ;;
+  alpha*-*-*vms*)
+    targ_defvec=alpha_vms_vec
+    targ_selvecs=alpha_vms_lib_txt_vec
+    want64=true
+    ;;
+  alpha*-*-*)
+    targ_defvec=alpha_ecoff_le_vec
+    want64=true
+    ;;
+  ia64*-*-freebsd* | ia64*-*-netbsd* | ia64*-*-linux-* | ia64*-*-elf* | ia64*-*-kfreebsd*-gnu)
+    targ_defvec=ia64_elf64_le_vec
+    targ_selvecs="ia64_elf64_be_vec ia64_pei_vec"
+    want64=true
+    ;;
+  ia64*-*-hpux*)
+    targ_defvec=ia64_elf32_hpux_be_vec
+    targ_selvecs="ia64_elf64_hpux_be_vec"
+    want64=true
+    ;;
+  ia64*-*-*vms*)
+    targ_defvec=ia64_elf64_vms_vec
+    targ_selvecs=alpha_vms_lib_txt_vec
+    want64=true
+    ;;
+  sparc64-*-freebsd* | sparc64-*-kfreebsd*-gnu)
+    targ_defvec=sparc_elf64_fbsd_vec
+    targ_selvecs="sparc_elf64_vec sparc_elf32_vec sparc_aout_sunos_be_vec"
+    ;;
+  sparc64-*-netbsd* | sparc64-*-openbsd*)
+    targ_defvec=sparc_elf64_vec
+    targ_selvecs="sparc_elf32_vec sparc_aout_sunos_be_vec"
+    want64=true
+    ;;
+#endif /* BFD64 */
+
+  am34-*-linux* | am33_2.0-*-linux*)
+    targ_defvec=am33_elf32_linux_vec
+    ;;
+
+  arc*-*-elf* | arc*-*-linux-uclibc*)
+    targ_defvec=arc_elf32_le_vec
+    targ_selvecs=arc_elf32_be_vec
+    ;;
+
+  arm-*-nacl*)
+    targ_defvec=arm_elf32_nacl_le_vec
+    targ_selvecs="arm_elf32_nacl_be_vec i386_elf32_nacl_vec"
+    targ64_selvecs="x86_64_elf32_nacl_vec x86_64_elf64_nacl_vec"
+    targ_archs="$targ_archs bfd_i386_arch"
+    ;;
+  armeb-*-nacl*)
+    targ_defvec=arm_elf32_nacl_be_vec
+    targ_selvecs="arm_elf32_nacl_le_vec i386_elf32_nacl_vec"
+    targ64_selvecs="x86_64_elf32_nacl_vec x86_64_elf64_nacl_vec"
+    targ_archs="$targ_archs bfd_i386_arch"
+    ;;
+  armeb-*-netbsdelf*)
+    targ_defvec=arm_elf32_be_vec
+    targ_selvecs="arm_elf32_le_vec arm_aout_nbsd_vec"
+    ;;
+  arm-*-netbsdelf*)
+    targ_defvec=arm_elf32_le_vec
+    targ_selvecs="arm_elf32_be_vec arm_aout_nbsd_vec"
+    ;;
+  arm-*-netbsd* | arm-*-openbsd*)
+    targ_defvec=arm_aout_nbsd_vec
+    targ_selvecs="arm_elf32_le_vec arm_elf32_be_vec"
+    targ_underscore=yes
+    ;;
+  arm-*-nto* | nto*arm*)
+    targ_defvec=arm_elf32_le_vec
+    targ_selvecs=arm_elf32_be_vec
+    targ_cflags=-D__QNXTARGET__
+    ;;
+  arm-*-riscix*)
+    targ_defvec=arm_aout_riscix_vec
+    ;;
+  arm-epoc-pe*)
+    targ_defvec=arm_pe_epoc_le_vec
+    targ_selvecs="arm_pe_epoc_le_vec arm_pe_epoc_be_vec arm_pei_epoc_le_vec arm_pei_epoc_be_vec"
+    targ_underscore=no
+    targ_cflags=-DARM_COFF_BUGFIX
+    ;;
+  arm-wince-pe | arm-*-wince | arm*-*-mingw32ce* | arm*-*-cegcc*)
+    targ_defvec=arm_pe_wince_le_vec
+    targ_selvecs="arm_pe_wince_le_vec arm_pe_wince_be_vec arm_pei_wince_le_vec arm_pei_wince_be_vec"
+    targ_underscore=no
+    targ_cflags="-DARM_WINCE -DARM_COFF_BUGFIX"
+    ;;
+  arm-*-pe*)
+    targ_defvec=arm_pe_le_vec
+    targ_selvecs="arm_pe_le_vec arm_pe_be_vec arm_pei_le_vec arm_pei_be_vec"
+    targ_underscore=yes
+    ;;
+  arm-*-aout | armel-*-aout)
+    targ_defvec=arm_aout_le_vec
+    targ_selvecs=arm_aout_be_vec
+    ;;
+  armeb-*-aout)
+    targ_defvec=arm_aout_be_vec
+    targ_selvecs=arm_aout_le_vec
+    ;;
+  arm-*-coff)
+    targ_defvec=arm_coff_le_vec
+    targ_selvecs=arm_coff_be_vec
+    targ_underscore=yes
+    ;;
+  arm-*-rtems*)
+    targ_defvec=arm_elf32_le_vec
+    targ_selvecs=arm_elf32_be_vec
+    ;;
+  armeb-*-elf | arm*b-*-freebsd* | arm*b-*-linux-* | armeb-*-eabi*)
+    targ_defvec=arm_elf32_be_vec
+    targ_selvecs=arm_elf32_le_vec
+    ;;
+  arm-*-kaos*)
+    targ_defvec=arm_elf32_le_vec
+    targ_selvecs=arm_elf32_be_vec
+    ;;
+  arm-*-elf | arm*-*-freebsd* | arm*-*-linux-* | arm*-*-conix* | \
+  arm*-*-uclinux* | arm-*-kfreebsd*-gnu | \
+  arm*-*-eabi* )
+    targ_defvec=arm_elf32_le_vec
+    targ_selvecs=arm_elf32_be_vec
+    ;;
+  arm*-*-vxworks | arm*-*-windiss)
+    targ_defvec=arm_elf32_vxworks_le_vec
+    targ_selvecs=arm_elf32_vxworks_be_vec
+    ;;
+  arm*-*-symbianelf*)
+    targ_defvec=arm_elf32_symbian_le_vec
+    targ_selvecs=arm_elf32_symbian_be_vec
+    ;;
+  arm9e-*-elf)
+    targ_defvec=arm_elf32_le_vec
+    targ_selvecs=arm_elf32_be_vec
+    ;;
+
+  avr-*-*)
+    targ_defvec=avr_elf32_vec
+    ;;
+
+  bfin-*-*)
+    targ_defvec=bfin_elf32_vec
+    targ_selvecs=bfin_elf32_fdpic_vec
+    targ_underscore=yes
+    ;;
+
+  c30-*-*aout* | tic30-*-*aout*)
+    targ_defvec=tic30_aout_vec
+    ;;
+  c30-*-*coff* | tic30-*-*coff*)
+    targ_defvec=tic30_coff_vec
+    ;;
+
+  c4x-*-*coff* | tic4x-*-*coff* | tic4x-*-rtems*)
+    targ_defvec=tic4x_coff1_vec
+    targ_selvecs="tic4x_coff1_beh_vec tic4x_coff2_vec tic4x_coff2_beh_vec tic4x_coff0_vec tic4x_coff0_beh_vec"
+    targ_underscore=yes
+    ;;
+
+  c54x*-*-*coff* | tic54x-*-*coff*)
+    targ_defvec=tic54x_coff1_vec
+    targ_selvecs="tic54x_coff1_beh_vec tic54x_coff2_vec tic54x_coff2_beh_vec tic54x_coff0_vec tic54x_coff0_beh_vec"
+    targ_underscore=yes
+    ;;
+
+  cr16-*-elf* | cr16*-*-uclinux*)
+    targ_defvec=cr16_elf32_vec
+    targ_underscore=yes
+    ;;
+
+  cr16c-*-elf*)
+    targ_defvec=cr16c_elf32_vec
+    targ_underscore=yes
+    ;;
+
+  cris-*-* | crisv32-*-*)
+    targ_defvec=cris_aout_vec
+    targ_selvecs="cris_elf32_us_vec cris_elf32_vec ieee_vec"
+    targ_underscore=yes # Note: not true for cris_elf32_vec.
+    ;;
+
+  crx-*-elf*)
+    targ_defvec=crx_elf32_vec
+    targ_underscore=yes
+    ;;
+
+  d10v-*-*)
+    targ_defvec=d10v_elf32_vec
+    ;;
+
+  dlx-*-elf*)
+    targ_defvec=dlx_elf32_be_vec
+    targ_selvecs="dlx_elf32_be_vec"
+    ;;
+
+  d30v-*-*)
+    targ_defvec=d30v_elf32_vec
+    ;;
+
+  epiphany-*-elf)
+    targ_defvec=epiphany_elf32_vec
+    ;;
+
+  fido-*-elf* )
+    targ_defvec=m68k_elf32_vec
+    targ_selvecs="m68k_coff_vec ieee_vec"
+    ;;
+
+  fr30-*-elf)
+    targ_defvec=fr30_elf32_vec
+    ;;
+
+  frv-*-elf)
+    targ_defvec=frv_elf32_vec
+    targ_selvecs=frv_elf32_fdpic_vec
+    ;;
+
+  frv-*-*linux*)
+    targ_defvec=frv_elf32_fdpic_vec
+    targ_selvecs=frv_elf32_vec
+    ;;
+
+  moxie-*-elf | moxie-*-rtems* | moxie-*-uclinux)
+    targ_defvec=moxie_elf32_be_vec
+    targ_selvecs=moxie_elf32_le_vec
+    ;;
+
+  moxie-*-moxiebox*)
+    targ_defvec=moxie_elf32_le_vec
+    ;;
+
+  h8300*-*-rtemscoff*)
+    targ_defvec=h8300_coff_vec
+    targ_underscore=yes
+    ;;
+
+  h8300*-*-elf | h8300*-*-rtems*)
+    targ_defvec=h8300_elf32_vec
+    targ_underscore=yes
+    ;;
+
+  h8300*-*-linux*)
+    targ_defvec=h8300_elf32_linux_vec
+    ;;
+
+  h8300*-*-*)
+    targ_defvec=h8300_coff_vec
+    targ_underscore=yes
+    ;;
+
+  h8500-*-*)
+    targ_defvec=h8500_coff_vec
+    targ_underscore=yes
+    ;;
+
+#ifdef BFD64
+  hppa*64*-*-linux-*)
+    targ_defvec=hppa_elf64_linux_vec
+    targ_selvecs=hppa_elf64_vec
+    want64=true
+    ;;
+  hppa*64*-*-hpux11*)
+    targ_defvec=hppa_elf64_vec
+    targ_selvecs=hppa_elf64_linux_vec
+    targ_cflags=-DHPUX_LARGE_AR_IDS
+    want64=true
+    ;;
+#endif
+
+  hppa*-*-linux-*)
+    targ_defvec=hppa_elf32_linux_vec
+    targ_selvecs=hppa_elf32_vec
+    ;;
+  hppa*-*-netbsd*)
+    targ_defvec=hppa_elf32_nbsd_vec
+    targ_selvecs="hppa_elf32_vec hppa_elf32_linux_vec"
+    ;;
+  hppa*-*-*elf* | hppa*-*-lites* | hppa*-*-sysv4* | hppa*-*-openbsd*)
+    targ_defvec=hppa_elf32_vec
+    targ_selvecs=hppa_elf32_linux_vec
+    ;;
+
+  hppa*-*-bsd*)
+    targ_defvec=hppa_som_vec
+    targ_selvecs=hppa_elf32_vec
+    ;;
+  hppa*-*-hpux* | hppa*-*-hiux* | hppa*-*-mpeix*)
+    targ_defvec=hppa_som_vec
+    ;;
+  hppa*-*-osf*)
+    targ_defvec=hppa_som_vec
+    targ_selvecs=hppa_elf32_vec
+    ;;
+
+  i370-*-*)
+    targ_defvec=i370_elf32_vec
+    targ_selvecs="i370_elf32_vec"
+    ;;
+  i[3-7]86-*-sco3.2v5*coff)
+    targ_defvec=i386_coff_vec
+    targ_selvecs=i386_elf32_vec
+    ;;
+  i[3-7]86-*-sysv4* | i[3-7]86-*-unixware* | \
+  i[3-7]86-*-elf* | i[3-7]86-*-sco3.2v5* | \
+  i[3-7]86-*-dgux* | i[3-7]86-*-sysv5*)
+    targ_defvec=i386_elf32_vec
+    targ_selvecs="iamcu_elf32_vec i386_coff_vec"
+    ;;
+  i[3-7]86-*-solaris2*)
+    targ_defvec=i386_elf32_sol2_vec
+    targ_selvecs="iamcu_elf32_vec i386_coff_vec i386_pei_vec"
+    targ64_selvecs="x86_64_elf64_sol2_vec l1om_elf64_vec k1om_elf64_vec x86_64_pei_vec"
+    want64=true
+    ;;
+#ifdef BFD64
+  x86_64-*-solaris2*)
+    targ_defvec=i386_elf32_sol2_vec
+    targ_selvecs="x86_64_elf64_sol2_vec l1om_elf64_vec k1om_elf64_vec iamcu_elf32_vec i386_coff_vec i386_pei_vec x86_64_pei_vec"
+    want64=true
+    ;;
+#endif
+  i[3-7]86-*-kaos*)
+    targ_defvec=i386_elf32_vec
+    targ_selvecs=i386_elf32_vec
+    ;;
+  i[3-7]86-*-nto*)
+    targ_defvec=i386_elf32_vec
+    targ_selvecs="iamcu_elf32_vec i386_coff_vec"
+    ;;
+  i[3-7]86-*-aros*)
+    targ_defvec=i386_elf32_vec
+    targ_selvecs=iamcu_elf32_vec
+    ;;
+  i[3-7]86-*-chorus*)
+    targ_defvec=i386_elf32_vec
+    targ_selvecs=iamcu_elf32_vec
+    ;;
+  i[3-7]86-*-dicos*)
+    targ_defvec=i386_elf32_vec
+    targ_selvecs=iamcu_elf32_vec
+    targ64_selvecs="x86_64_elf64_vec l1om_elf64_vec k1om_elf64_vec"
+    ;;
+  *-*-msdosdjgpp* | *-*-go32* )
+    targ_defvec=i386_coff_go32_vec
+    targ_selvecs="i386_coff_go32stubbed_vec i386_aout_vec"
+    ;;
+  i[3-7]86-*-sysv* | i[3-7]86-*-isc* | i[3-7]86-*-sco* | i[3-7]86-*-coff | \
+  i[3-7]86-*-aix*)
+    targ_defvec=i386_coff_vec
+    ;;
+  i[3-7]86-*-rtems*)
+    targ_defvec=i386_elf32_vec
+    targ_selvecs="iamcu_elf32_vec i386_coff_vec i386_aout_vec"
+    ;;
+  i[3-7]86-*-darwin* | i[3-7]86-*-macos10* | i[3-7]86-*-rhapsody*)
+    targ_defvec=i386_mach_o_vec
+    targ_selvecs="mach_o_le_vec mach_o_be_vec mach_o_fat_vec pef_vec pef_xlib_vec sym_vec"
+    targ64_selvecs=x86_64_mach_o_vec
+    targ_archs="$targ_archs bfd_powerpc_arch bfd_rs6000_arch"
+    ;;
+  i[3-7]86-sequent-bsd*)
+    targ_defvec=i386_aout_dynix_vec
+    targ_underscore=yes
+    ;;
+  i[3-7]86-*-bsd*)
+    targ_defvec=i386_aout_bsd_vec
+    targ_underscore=yes
+    ;;
+  i[3-7]86-*-dragonfly*)
+    targ_defvec=i386_elf32_vec
+    targ_selvecs=iamcu_elf32_vec
+    targ64_selvecs="x86_64_elf64_vec l1om_elf64_vec k1om_elf64_vec"
+    ;;
+  i[3-7]86-*-freebsdaout* | i[3-7]86-*-freebsd[12].* | \
+  i[3-7]86-*-freebsd[12])
+    targ_defvec=i386_aout_fbsd_vec
+    targ_selvecs=i386_aout_bsd_vec
+    targ_underscore=yes
+    ;;
+  i[3-7]86-*-freebsd* | i[3-7]86-*-kfreebsd*-gnu)
+    targ_defvec=i386_elf32_fbsd_vec
+    targ_selvecs="i386_elf32_vec iamcu_elf32_vec i386_pei_vec i386_coff_vec"
+    targ64_selvecs="x86_64_elf64_fbsd_vec x86_64_elf64_vec x86_64_pei_vec l1om_elf64_vec l1om_elf64_fbsd_vec k1om_elf64_vec k1om_elf64_fbsd_vec"
+    # FreeBSD <= 4.0 supports only the old nonstandard way of ABI labelling.
+    case "${targ}" in
+      i[3-7]86-*-freebsd3* | i[3-7]86-*-freebsd4 | i[3-7]86-*-freebsd4.0*)
+	targ_cflags=-DOLD_FREEBSD_ABI_LABEL ;;
+    esac
+    ;;
+  i[3-7]86-*-netbsdelf* | i[3-7]86-*-netbsd*-gnu* | i[3-7]86-*-knetbsd*-gnu)
+    targ_defvec=i386_elf32_vec
+    targ_selvecs="i386_aout_nbsd_vec iamcu_elf32_vec"
+    targ64_selvecs="x86_64_elf64_vec l1om_elf64_vec k1om_elf64_vec"
+    ;;
+  i[3-7]86-*-netbsdpe*)
+    targ_defvec=i386_pe_vec
+    targ_selvecs="i386_pe_vec i386_pei_vec i386_elf32_vec iamcu_elf32_vec"
+    ;;
+  i[3-7]86-*-netbsdaout* | i[3-7]86-*-netbsd* | \
+  i[3-7]86-*-openbsd[0-2].* | i[3-7]86-*-openbsd3.[0-3])
+    targ_defvec=i386_aout_nbsd_vec
+    targ_selvecs="i386_elf32_vec iamcu_elf32_vec i386_aout_bsd_vec"
+    targ_underscore=yes
+    ;;
+  i[3-7]86-*-openbsd*)
+    targ_defvec=i386_elf32_vec
+    targ_selvecs="iamcu_elf32_vec i386_aout_nbsd_vec"
+    ;;
+  i[3-7]86-*-netware*)
+    targ_defvec=i386_elf32_vec
+    targ_selvecs="iamcu_elf32_vec i386_nlm32_vec i386_coff_vec i386_aout_vec"
+    ;;
+  i[3-7]86-*-linux*aout*)
+    targ_defvec=i386_aout_linux_vec
+    targ_selvecs="i386_elf32_vec iamcu_elf32_vec"
+    targ_underscore=yes
+    ;;
+  i[3-7]86-*-linux-*)
+    targ_defvec=i386_elf32_vec
+    targ_selvecs="iamcu_elf32_vec i386_aout_linux_vec i386_pei_vec"
+    targ64_selvecs="x86_64_elf64_vec x86_64_elf32_vec x86_64_pei_vec l1om_elf64_vec k1om_elf64_vec"
+    ;;
+  i[3-7]86-*-nacl*)
+    targ_defvec=i386_elf32_nacl_vec
+    targ_selvecs="arm_elf32_nacl_be_vec arm_elf32_nacl_le_vec"
+    targ64_selvecs="x86_64_elf64_nacl_vec x86_64_elf32_nacl_vec"
+    targ_archs="$targ_archs bfd_arm_arch"
+    ;;
+#ifdef BFD64
+  x86_64-*-cloudabi*)
+    targ_defvec=x86_64_elf64_cloudabi_vec
+    want64=true
+    ;;
+  x86_64-*-darwin*)
+    targ_defvec=x86_64_mach_o_vec
+    targ_selvecs="i386_mach_o_vec mach_o_le_vec mach_o_be_vec mach_o_fat_vec pef_vec pef_xlib_vec sym_vec"
+    targ_archs="$targ_archs bfd_powerpc_arch bfd_rs6000_arch"
+    want64=true
+    ;;
+  x86_64-*-dicos*)
+    targ_defvec=x86_64_elf64_vec
+    targ_selvecs="i386_elf32_vec iamcu_elf32_vec l1om_elf64_vec k1om_elf64_vec"
+    want64=true
+    ;;
+  x86_64-*-elf*)
+    targ_defvec=x86_64_elf64_vec
+    targ_selvecs="i386_elf32_vec iamcu_elf32_vec x86_64_elf32_vec l1om_elf64_vec k1om_elf64_vec"
+    want64=true
+    ;;
+  x86_64-*-dragonfly*)
+    targ_defvec=x86_64_elf64_vec
+    targ_selvecs="i386_elf32_vec iamcu_elf32_vec l1om_elf64_vec k1om_elf64_vec"
+    want64=true
+    ;;
+  x86_64-*-freebsd* | x86_64-*-kfreebsd*-gnu)
+    targ_defvec=x86_64_elf64_fbsd_vec
+    targ_selvecs="i386_elf32_fbsd_vec iamcu_elf32_vec i386_coff_vec i386_pei_vec x86_64_pei_vec i386_elf32_vec x86_64_elf64_vec l1om_elf64_vec l1om_elf64_fbsd_vec k1om_elf64_vec k1om_elf64_fbsd_vec"
+    want64=true
+    ;;
+  x86_64-*-netbsd* | x86_64-*-openbsd*)
+    targ_defvec=x86_64_elf64_vec
+    targ_selvecs="i386_elf32_vec iamcu_elf32_vec i386_aout_nbsd_vec i386_coff_vec i386_pei_vec x86_64_pei_vec l1om_elf64_vec k1om_elf64_vec"
+    want64=true
+    ;;
+  x86_64-*-linux-*)
+    targ_defvec=x86_64_elf64_vec
+    targ_selvecs="i386_elf32_vec iamcu_elf32_vec x86_64_elf32_vec i386_aout_linux_vec i386_pei_vec x86_64_pei_vec l1om_elf64_vec k1om_elf64_vec"
+    want64=true
+    ;;
+  x86_64-*-nacl*)
+    targ_defvec=x86_64_elf32_nacl_vec
+    targ_selvecs="i386_elf32_nacl_vec x86_64_elf64_nacl_vec arm_elf32_nacl_be_vec arm_elf32_nacl_le_vec"
+    targ_archs="$targ_archs bfd_arm_arch"
+    want64=true
+    ;;
+  x86_64-*-mingw* | x86_64-*-pe | x86_64-*-pep | x86_64-*-cygwin)
+    targ_defvec=x86_64_pe_vec
+    targ_selvecs="x86_64_pe_vec x86_64_pei_vec x86_64_pe_be_vec x86_64_elf64_vec l1om_elf64_vec k1om_elf64_vec i386_pe_vec i386_pei_vec i386_elf32_vec iamcu_elf32_vec"
+    want64=true
+    targ_underscore=no
+    ;;
+  x86_64-*-rdos*)
+    targ_defvec=x86_64_elf64_vec
+    want64=true
+    ;;
+#endif
+  i[3-7]86-*-lynxos*)
+    targ_defvec=i386_elf32_vec
+    targ_selvecs="iamcu_elf32_vec i386_coff_lynx_vec i386_aout_lynx_vec"
+    ;;
+  i[3-7]86-*-gnu*)
+    targ_defvec=i386_elf32_vec
+    targ_selvecs=iamcu_elf32_vec
+    ;;
+  i[3-7]86-*-mach* | i[3-7]86-*-osf1mk*)
+    targ_defvec=i386_aout_mach3_vec
+    targ_cflags=-DSTAT_FOR_EXEC
+    targ_underscore=yes
+    ;;
+  i[3-7]86-*-os9k)
+    targ_defvec=i386_aout_os9k_vec
+    ;;
+  i[3-7]86-*-msdos*)
+    targ_defvec=i386_aout_vec
+    targ_selvecs=i386_msdos_vec
+    ;;
+  i[3-7]86-*-moss*)
+    targ_defvec=i386_elf32_vec
+    targ_selvecs="iamcu_elf32_vec i386_msdos_vec i386_aout_vec"
+    ;;
+  i[3-7]86-*-beospe*)
+    targ_defvec=i386_pe_vec
+    targ_selvecs="i386_pe_vec i386_pei_vec"
+    ;;
+  i[3-7]86-*-beoself* | i[3-7]86-*-beos*)
+    targ_defvec=i386_elf32_vec
+    targ_selvecs="iamcu_elf32_vec i386_pe_vec i386_pei_vec"
+    ;;
+  i[3-7]86-*-interix*)
+    targ_defvec=i386_pei_vec
+    targ_selvecs="i386_pe_vec"
+    # FIXME: This should eventually be checked at runtime.
+    targ_cflags=-DSTRICT_PE_FORMAT
+    ;;
+  i[3-7]86-*-rdos*)
+    targ_defvec=i386_elf32_vec
+    targ_selvecs="iamcu_elf32_vec i386_coff_vec"
+    ;;
+  i[3-7]86-*-mingw32* | i[3-7]86-*-cygwin* | i[3-7]86-*-winnt | i[3-7]86-*-pe)
+    targ_defvec=i386_pe_vec
+    targ_selvecs="i386_pe_vec i386_pei_vec i386_elf32_vec iamcu_elf32_vec"
+    targ_underscore=yes
+    ;;
+  i[3-7]86-none-*)
+    targ_defvec=i386_coff_vec
+    ;;
+  i[3-7]86-*-aout* | i[3-7]86*-*-vsta*)
+    targ_defvec=i386_aout_vec
+    ;;
+  i[3-7]86-*-vxworks*)
+    targ_defvec=i386_elf32_vxworks_vec
+    targ_underscore=yes
+    ;;
+  i[3-7]86-*-chaos)
+    targ_defvec=i386_elf32_vec
+    targ_selfvecs="iamcu_elf32_vec i386chaos_vec"
+    ;;
+
+  i860-*-mach3* | i860-*-osf1* | i860-*-coff*)
+    targ_defvec=i860_coff_vec
+    ;;
+  i860-stardent-sysv4* | i860-stardent-elf*)
+    targ_defvec=i860_elf32_le_vec
+    targ_selvecs="i860_elf32_vec i860_elf32_le_vec"
+    ;;
+  i860-*-sysv4* | i860-*-elf*)
+    targ_defvec=i860_elf32_vec
+    ;;
+
+  i960-*-vxworks4* | i960-*-vxworks5.0)
+    targ_defvec=bout_le_vec
+    targ_selvecs="bout_be_vec icoff_le_vec icoff_be_vec ieee_vec"
+    targ_underscore=yes
+    ;;
+  i960-*-vxworks5.* | i960-*-coff* | i960-*-sysv*)
+    targ_defvec=icoff_le_vec
+    targ_selvecs="icoff_be_vec bout_le_vec bout_be_vec ieee_vec"
+    targ_underscore=yes
+    ;;
+  i960-*-vxworks* | i960-*-aout* | i960-*-bout* | i960-*-nindy*)
+    targ_defvec=bout_le_vec
+    targ_selvecs="bout_be_vec icoff_le_vec icoff_be_vec ieee_vec"
+    targ_underscore=yes
+    ;;
+  i960-*-elf*)
+    targ_defvec=i960_elf32_vec
+    targ_selvecs="icoff_le_vec icoff_be_vec"
+    ;;
+
+  ip2k-*-elf)
+    targ_defvec=ip2k_elf32_vec
+    ;;
+
+  iq2000-*-elf)
+    targ_defvec=iq2000_elf32_vec
+    ;;
+
+  lm32-*-elf | lm32-*-rtems*)
+    targ_defvec=lm32_elf32_vec
+    targ_selvecs=lm32_elf32_fdpic_vec
+    ;;
+
+  lm32-*-*linux*)
+    targ_defvec=lm32_elf32_fdpic_vec
+    targ_selvecs=lm32_elf32_vec
+    ;;
+
+  m32c-*-elf | m32c-*-rtems*)
+    targ_defvec=m32c_elf32_vec
+    ;;
+
+  m32r*le-*-linux*)
+    targ_defvec=m32r_elf32_linux_le_vec
+    targ_selvecs="m32r_elf32_linux_vec  m32r_elf32_linux_le_vec"
+    ;;
+  m32r*-*-linux*)
+    targ_defvec=m32r_elf32_linux_vec
+    targ_selvecs="m32r_elf32_linux_vec  m32r_elf32_linux_le_vec"
+    ;;
+  m32r*le-*-*)
+    targ_defvec=m32r_elf32_le_vec
+    targ_selvecs="m32r_elf32_vec m32r_elf32_le_vec"
+    ;;
+  m32r-*-*)
+    targ_defvec=m32r_elf32_vec
+    ;;
+
+  m68hc11-*-* | m6811-*-*)
+    targ_defvec=m68hc11_elf32_vec
+    targ_selvecs="m68hc11_elf32_vec m68hc12_elf32_vec"
+    ;;
+  m68hc12-*-* | m6812-*-*)
+    targ_defvec=m68hc12_elf32_vec
+    targ_selvecs="m68hc11_elf32_vec m68hc12_elf32_vec"
+    ;;
+
+  m68*-motorola-sysv*)
+    targ_defvec=m68k_coff_sysv_vec
+    ;;
+  m68*-hp-bsd*)
+    targ_defvec=m68k_aout_hp300bsd_vec
+    targ_underscore=yes
+    ;;
+  m68*-*-aout*)
+    targ_defvec=aout0_be_vec
+    # We include core_cisco_be_vec here, rather than making a separate cisco
+    # configuration, so that cisco-core.c gets routinely tested at
+    # least for compilation.
+    targ_selvecs="core_cisco_be_vec ieee_vec"
+    targ_underscore=yes
+    ;;
+  m68*-*-elf* | m68*-*-sysv4* | m68*-*-uclinux*)
+    targ_defvec=m68k_elf32_vec
+    targ_selvecs="m68k_coff_vec ieee_vec"
+    ;;
+  m68*-*-rtems*)
+    targ_defvec=m68k_elf32_vec
+    targ_selvecs="m68k_coff_vec m68k_versados_vec ieee_vec aout0_be_vec"
+    ;;
+  m68*-*-coff* | m68*-*-sysv*)
+    targ_defvec=m68k_coff_vec
+    targ_selvecs="m68k_coff_vec m68k_versados_vec ieee_vec"
+    ;;
+  m68*-*-hpux*)
+    targ_defvec=m68k_aout_hp300hpux_vec
+    targ_underscore=yes
+    ;;
+  m68*-*-linux*aout*)
+    targ_defvec=m68k_aout_linux_vec
+    targ_selvecs=m68k_elf32_vec
+    targ_underscore=yes
+    ;;
+  m68*-*-linux-*)
+    targ_defvec=m68k_elf32_vec
+    targ_selvecs=m68k_aout_linux_vec
+    ;;
+  m68*-*-gnu*)
+    targ_defvec=m68k_elf32_vec
+    # targ_selvecs=m68kmach3_vec
+    # targ_cflags=-DSTAT_FOR_EXEC
+    ;;
+  m68*-hp*-netbsd*)
+    targ_defvec=m68k_aout_4knbsd_vec
+    targ_selvecs="m68k_aout_nbsd_vec m68k_aout_hp300bsd_vec sparc_aout_sunos_be_vec"
+    targ_underscore=yes
+    ;;
+  m68*-*-netbsdelf*)
+    targ_defvec=m68k_elf32_vec
+    targ_selvecs="m68k_aout_nbsd_vec m68k_aout_4knbsd_vec m68k_aout_hp300bsd_vec sparc_aout_sunos_be_vec"
+    ;;
+  m68*-*-netbsdaout* | m68*-*-netbsd*)
+    targ_defvec=m68k_aout_nbsd_vec
+    targ_selvecs="m68k_aout_4knbsd_vec m68k_elf32_vec m68k_aout_hp300bsd_vec sparc_aout_sunos_be_vec"
+    targ_underscore=yes
+    ;;
+  m68*-*-openbsd*)
+    targ_defvec=m68k_aout_nbsd_vec
+    targ_selvecs="m68k_aout_4knbsd_vec m68k_aout_hp300bsd_vec sparc_aout_sunos_be_vec"
+    targ_underscore=yes
+    ;;
+  m68*-*-sunos* | m68*-*-os68k* | m68*-*-vxworks* | m68*-netx-* | \
+  m68*-*-bsd* | m68*-*-vsta*)
+    targ_defvec=sparc_aout_sunos_be_vec
+    targ_underscore=yes
+    ;;
+  m68*-ericsson-*)
+    targ_defvec=sparc_aout_sunos_be_vec
+    targ_selvecs="m68k_coff_vec m68k_versados_vec tekhex_vec"
+    targ_underscore=yes
+    ;;
+  m68*-cbm-*)
+    targ_defvec=m68k_elf32_vec
+    targ_selvecs=m68k_coff_vec
+    ;;
+  m68*-*-psos*)
+    targ_defvec=m68k_elf32_vec
+    targ_selvecs=ieee_vec
+    targ_underscore=yes
+    ;;
+
+  m88*-harris-cxux* | m88*-*-dgux* | m88*-*-sysv4*)
+    targ_defvec=m88k_elf32_vec
+    targ_selvecs=m88k_coff_bcs_vec
+    ;;
+  m88*-*-mach3*)
+    targ_defvec=m88k_aout_mach3_vec
+    targ_cflags=-DSTAT_FOR_EXEC
+    ;;
+  m88*-*-openbsd*)
+   targ_defvec=m88k_aout_obsd_vec
+   targ_underscore=yes
+   ;;
+  m88*-*-*)
+    targ_defvec=m88k_coff_bcs_vec
+    targ_underscore=yes
+    ;;
+
+  mcore-*-elf)
+    targ_defvec=mcore_elf32_be_vec
+    targ_selvecs="mcore_elf32_be_vec mcore_elf32_le_vec"
+    ;;
+  mcore-*-pe)
+    targ_defvec=mcore_pe_be_vec
+    targ_selvecs="mcore_pe_be_vec mcore_pe_le_vec mcore_pei_be_vec mcore_pei_le_vec"
+    ;;
+
+  mep-*-elf)
+    targ_defvec=mep_elf32_vec
+    targ_selvecs=mep_elf32_le_vec
+    ;;
+
+  metag-*-*)
+    targ_defvec=metag_elf32_vec
+    targ_underscore=yes
+    ;;
+
+  microblazeel*-*)
+    targ_defvec=microblaze_elf32_le_vec
+    targ_selvecs=microblaze_elf32_vec
+    ;;
+
+  microblaze*-*)
+    targ_defvec=microblaze_elf32_vec
+    targ_selvecs=microblaze_elf32_le_vec
+    ;;
+
+  mips*-big-*)
+    targ_defvec=mips_ecoff_be_vec
+    targ_selvecs=mips_ecoff_le_vec
+    ;;
+#ifdef BFD64
+  mips*el-*-netbsd*)
+    targ_defvec=mips_elf32_trad_le_vec
+    targ_selvecs="mips_elf32_trad_be_vec mips_elf64_trad_be_vec mips_elf64_trad_le_vec mips_ecoff_le_vec mips_ecoff_be_vec"
+    ;;
+  mips*-*-netbsd*)
+    targ_defvec=mips_elf32_trad_be_vec
+    targ_selvecs="mips_elf32_trad_le_vec mips_elf64_trad_be_vec mips_elf64_trad_le_vec mips_ecoff_be_vec mips_ecoff_le_vec"
+    ;;
+#endif
+  mips*-dec-* | mips*el-*-ecoff*)
+    targ_defvec=mips_ecoff_le_vec
+    targ_selvecs=mips_ecoff_be_vec
+    ;;
+  mips*-*-ecoff*)
+    targ_defvec=mips_ecoff_be_vec
+    targ_selvecs=mips_ecoff_le_vec
+    ;;
+#ifdef BFD64
+  mips*-*-irix6*)
+    targ_defvec=mips_elf32_n_be_vec
+    targ_selvecs="mips_elf32_n_le_vec mips_elf32_be_vec mips_elf32_le_vec mips_elf64_be_vec mips_elf64_le_vec"
+    ;;
+  mips64*-ps2-elf*)
+    targ_defvec=mips_elf32_n_le_vec
+    targ_selvecs="mips_elf32_n_le_vec mips_elf32_n_be_vec mips_elf32_be_vec mips_elf32_le_vec mips_elf64_be_vec mips_elf64_le_vec"
+    ;;
+  mips*-ps2-elf*)
+    targ_defvec=mips_elf32_le_vec
+    targ_selvecs="mips_elf32_be_vec mips_elf32_le_vec mips_elf64_be_vec mips_elf64_le_vec"
+    ;;
+  mips*-*-irix5*)
+    targ_defvec=mips_elf32_be_vec
+    targ_selvecs="mips_elf32_le_vec mips_ecoff_be_vec mips_ecoff_le_vec"
+    ;;
+#endif
+  mips*-sgi-* | mips*-*-bsd*)
+    targ_defvec=mips_ecoff_be_vec
+    targ_selvecs=mips_ecoff_le_vec
+    ;;
+  mips*-*-lnews*)
+    targ_defvec=mips_ecoff_bele_vec
+    targ_selvecs="mips_ecoff_le_vec mips_ecoff_be_vec"
+    ;;
+#ifdef BFD64
+  mips*-*-sysv4*)
+    targ_defvec=mips_elf32_trad_be_vec
+    targ_selvecs="mips_elf32_trad_le_vec mips_ecoff_be_vec mips_ecoff_le_vec"
+    ;;
+#endif
+  mips*-*-sysv* | mips*-*-riscos*)
+    targ_defvec=mips_ecoff_be_vec
+    targ_selvecs=mips_ecoff_le_vec
+    ;;
+#ifdef BFD64
+  mips*el-*-vxworks*)
+    targ_defvec=mips_elf32_vxworks_le_vec
+    targ_selvecs="mips_elf32_le_vec mips_elf32_vxworks_be_vec mips_elf32_be_vec mips_elf64_be_vec mips_elf64_le_vec"
+    ;;
+  mips*-*-vxworks*)
+    targ_defvec=mips_elf32_vxworks_be_vec
+    targ_selvecs="mips_elf32_be_vec mips_elf32_vxworks_le_vec mips_elf32_be_vec mips_elf64_be_vec mips_elf64_le_vec"
+    ;;
+  mips*el-sde-elf*)
+    targ_defvec=mips_elf32_trad_le_vec
+    targ_selvecs="mips_elf32_trad_be_vec mips_elf32_ntrad_be_vec mips_elf32_ntrad_le_vec mips_elf64_trad_be_vec mips_elf64_trad_le_vec"
+    ;;
+  mips*-sde-elf* | mips*-mti-elf* | mips*-img-elf*)
+    targ_defvec=mips_elf32_trad_be_vec
+    targ_selvecs="mips_elf32_trad_le_vec mips_elf32_ntrad_be_vec mips_elf32_ntrad_le_vec mips_elf64_trad_be_vec mips_elf64_trad_le_vec"
+    ;;
+  mips*el-*-elf* | mips*el-*-vxworks* | mips*-*-chorus*)
+    targ_defvec=mips_elf32_le_vec
+    targ_selvecs="mips_elf32_be_vec mips_elf64_be_vec mips_elf64_le_vec"
+    ;;
+  mips*-*-elf* | mips*-*-rtems* | mips*-*-vxworks | mips*-*-windiss)
+    targ_defvec=mips_elf32_be_vec
+    targ_selvecs="mips_elf32_le_vec mips_elf64_be_vec mips_elf64_le_vec"
+    ;;
+  mips*-*-none)
+    targ_defvec=mips_elf32_be_vec
+    targ_selvecs="mips_elf32_le_vec mips_elf64_be_vec mips_elf64_le_vec"
+    ;;
+  mips64*-*-openbsd*)
+    targ_defvec=mips_elf64_trad_be_vec
+    targ_selvecs="mips_elf32_ntrad_le_vec mips_elf32_ntrad_be_vec mips_elf32_trad_le_vec mips_elf32_trad_be_vec mips_elf64_trad_le_vec"
+    ;;
+  mips*el-*-openbsd*)
+    targ_defvec=mips_elf32_le_vec
+    targ_selvecs="mips_elf32_be_vec mips_elf64_be_vec mips_elf64_le_vec mips_ecoff_le_vec mips_ecoff_be_vec"
+    ;;
+  mips*-*-openbsd*)
+    targ_defvec=mips_elf32_be_vec
+    targ_selvecs="mips_elf32_le_vec mips_elf64_be_vec mips_elf64_le_vec mips_ecoff_be_vec mips_ecoff_le_vec"
+    ;;
+  mips64*el-*-linux*)
+    targ_defvec=mips_elf32_ntrad_le_vec
+    targ_selvecs="mips_elf32_ntrad_be_vec mips_elf32_trad_le_vec mips_elf32_trad_be_vec mips_elf64_trad_le_vec mips_elf64_trad_be_vec"
+    ;;
+  mips64*-*-linux*)
+    targ_defvec=mips_elf32_ntrad_be_vec
+    targ_selvecs="mips_elf32_ntrad_le_vec mips_elf32_trad_be_vec mips_elf32_trad_le_vec mips_elf64_trad_be_vec mips_elf64_trad_le_vec"
+    ;;
+  mips*el-*-linux*)
+    targ_defvec=mips_elf32_trad_le_vec
+    targ_selvecs="mips_elf32_trad_be_vec mips_ecoff_le_vec mips_ecoff_be_vec mips_elf32_ntrad_le_vec mips_elf64_trad_le_vec mips_elf32_ntrad_be_vec mips_elf64_trad_be_vec"
+    ;;
+  mips*-*-linux*)
+    targ_defvec=mips_elf32_trad_be_vec
+    targ_selvecs="mips_elf32_trad_le_vec mips_ecoff_be_vec mips_ecoff_le_vec mips_elf32_ntrad_be_vec mips_elf64_trad_be_vec mips_elf32_ntrad_le_vec mips_elf64_trad_le_vec"
+    ;;
+  mips64*el-*-freebsd* | mips64*el-*-kfreebsd*-gnu)
+    # FreeBSD vectors
+    targ_defvec=mips_elf32_ntradfbsd_le_vec
+    targ_selvecs="mips_elf32_ntradfbsd_be_vec mips_elf32_tradfbsd_le_vec mips_elf32_tradfbsd_be_vec mips_elf64_tradfbsd_le_vec mips_elf64_tradfbsd_be_vec"
+    # Generic vectors
+    targ_selvecs="${targ_selvecs} mips_elf32_ntrad_le_vec mips_elf32_ntrad_be_vec mips_elf32_trad_le_vec mips_elf32_trad_be_vec mips_elf64_trad_le_vec mips_elf64_trad_be_vec"
+    ;;
+  mips64*-*-freebsd* | mips64*-*-kfreebsd*-gnu)
+    # FreeBSD vectors
+    targ_defvec=mips_elf32_ntradfbsd_be_vec
+    targ_selvecs="mips_elf32_ntradfbsd_le_vec mips_elf32_tradfbsd_be_vec mips_elf32_tradfbsd_le_vec mips_elf64_tradfbsd_be_vec mips_elf64_tradfbsd_le_vec"
+    # Generic vectors
+    targ_selvecs="${targ_selvecs} mips_elf32_ntrad_be_vec mips_elf32_ntrad_le_vec mips_elf32_trad_be_vec mips_elf32_trad_le_vec mips_elf64_trad_be_vec mips_elf64_trad_le_vec"
+    ;;
+  mips*el-*-freebsd* | mips*el-*-kfreebsd*-gnu)
+    # FreeBSD vectors
+    targ_defvec=mips_elf32_tradfbsd_le_vec
+    targ_selvecs="mips_elf32_tradfbsd_be_vec mips_elf32_ntradfbsd_le_vec mips_elf64_tradfbsd_le_vec mips_elf32_ntradfbsd_be_vec mips_elf64_tradfbsd_be_vec"
+    # Generic vectors
+    targ_selvecs="${targ_selvecs} mips_elf32_trad_le_vec mips_elf32_trad_be_vec mips_elf32_ntrad_le_vec mips_elf64_trad_le_vec mips_elf32_ntrad_be_vec mips_elf64_trad_be_vec"
+    ;;
+  mips*-*-freebsd* | mips*-*-kfreebsd*-gnu)
+    # FreeBSD vectors
+    targ_defvec=mips_elf32_tradfbsd_be_vec
+    targ_selvecs="mips_elf32_tradfbsd_le_vec mips_elf32_ntradfbsd_be_vec mips_elf64_tradfbsd_be_vec mips_elf32_ntradfbsd_le_vec mips_elf64_tradfbsd_le_vec"
+    # Generic vectors
+    targ_selvecs="${targ_selvecs} mips_elf32_trad_be_vec mips_elf32_trad_le_vec mips_elf32_ntrad_be_vec mips_elf64_trad_be_vec mips_elf32_ntrad_le_vec mips_elf64_trad_le_vec"
+    ;;
+  mmix-*-*)
+    targ_defvec=mmix_elf64_vec
+    targ_selvecs=mmix_mmo_vec
+    want64=true
+    ;;
+#endif
+  mn10200-*-*)
+    targ_defvec=mn10200_elf32_vec
+    ;;
+
+  mn10300-*-*)
+    targ_defvec=mn10300_elf32_vec
+    targ_underscore=yes
+    ;;
+
+  mt-*-elf)
+    targ_defvec=mt_elf32_vec
+    ;;
+
+  msp430-*-*)
+    targ_defvec=msp430_elf32_vec
+    targ_selvecs=msp430_elf32_ti_vec
+    ;;
+
+  nds32*le-*-linux*)
+    targ_defvec=nds32_elf32_linux_le_vec
+    targ_selvecs=nds32_elf32_linux_be_vec
+    ;;
+
+  nds32*be-*-linux*)
+    targ_defvec=nds32_elf32_linux_be_vec
+    targ_selvecs=nds32_elf32_linux_le_vec
+    ;;
+
+  nds32*le-*-*)
+    targ_defvec=nds32_elf32_le_vec
+    targ_selvecs=nds32_elf32_be_vec
+    ;;
+
+  nds32*be-*-*)
+    targ_defvec=nds32_elf32_be_vec
+    targ_selvecs=nds32_elf32_le_vec
+    ;;
+
+  ns32k-pc532-mach* | ns32k-pc532-ux*)
+    targ_defvec=ns32k_aout_pc532mach_vec
+    targ_underscore=yes
+    ;;
+  ns32k-*-netbsd* | ns32k-*-lites* | ns32k-*-openbsd*)
+    targ_defvec=ns32k_aout_pc532nbsd_vec
+    targ_underscore=yes
+    ;;
+
+  nios2eb-*-*)
+    targ_defvec=nios2_elf32_be_vec
+    targ_selvecs=nios2_elf32_le_vec
+    ;;
+
+  nios2el-*-*)
+    targ_defvec=nios2_elf32_le_vec
+    targ_selvecs=nios2_elf32_be_vec
+    ;;
+
+  nios2-*-*)
+    targ_defvec=nios2_elf32_le_vec
+    targ_selvecs=nios2_elf32_be_vec
+    ;;
+
+  or1k-*-elf | or1k-*-linux* | or1k-*-rtems*)
+    targ_defvec=or1k_elf32_vec
+    ;;
+
+  or1knd-*-elf | or1knd-*-linux* | or1knd-*-rtems*)
+    targ_defvec=or1k_elf32_vec
+    ;;
+
+  pdp11-*-*)
+    targ_defvec=pdp11_aout_vec
+    targ_underscore=yes
+    ;;
+
+  pj-*-*)
+    targ_defvec=pj_elf32_vec
+    targ_selvecs="pj_elf32_vec pj_elf32_le_vec"
+    ;;
+
+  pjl-*-*)
+    targ_defvec=pj_elf32_le_vec
+    targ_selvecs="pj_elf32_le_vec pj_elf32_vec i386_elf32_vec iamcu_elf32_vec"
+    ;;
+
+  powerpc-*-aix5.[01] | rs6000-*-aix5.[01])
+    targ_defvec=rs6000_xcoff_vec
+    targ_selvecs="rs6000_xcoff64_aix_vec"
+    want64=true
+    ;;
+#ifdef BFD64
+  powerpc64-*-aix5.[01] | rs6000-*-aix5.[01])
+    targ_defvec=rs6000_xcoff64_aix_vec
+    targ_selvecs="rs6000_xcoff_vec"
+    want64=true
+    ;;
+#endif
+  powerpc-*-aix[5-9]* | rs6000-*-aix[5-9]*)
+    targ_cflags=-DAIX_WEAK_SUPPORT
+    targ_defvec=rs6000_xcoff_vec
+    targ_selvecs="rs6000_xcoff64_aix_vec"
+    want64=true
+    ;;
+#ifdef BFD64
+  powerpc64-*-aix[5-9]* | rs6000-*-aix[5-9]*)
+    targ_cflags=-DAIX_WEAK_SUPPORT
+    targ_defvec=rs6000_xcoff64_aix_vec
+    targ_selvecs="rs6000_xcoff_vec"
+    want64=true
+    ;;
+#endif
+
+  powerpc-*-aix* | powerpc-*-beos* | rs6000-*-*)
+    targ_defvec=rs6000_xcoff_vec
+    targ64_selvecs=rs6000_xcoff64_vec
+    case "${targ}" in
+	*-*-aix4.[3456789]* | *-*-aix[56789]*)
+	want64=true;;
+	*)
+	targ_cflags=-DSMALL_ARCHIVE;;
+    esac
+    ;;
+#ifdef BFD64
+  powerpc64-*-aix*)
+    targ_defvec=rs6000_xcoff64_vec
+    targ_selvecs=rs6000_xcoff_vec
+    want64=true
+    ;;
+  powerpc64-*-freebsd*)
+    targ_defvec=powerpc_elf64_fbsd_vec
+    targ_selvecs="powerpc_elf64_vec powerpc_elf32_vec powerpc_elf32_fbsd_vec powerpc_elf32_le_vec rs6000_xcoff_vec rs6000_xcoff64_vec rs6000_xcoff64_aix_vec"
+    want64=true
+    ;;
+  powerpc64-*-elf* | powerpc-*-elf64* | powerpc64-*-linux* | \
+  powerpc64-*-*bsd*)
+    targ_defvec=powerpc_elf64_vec
+    targ_selvecs="powerpc_elf64_le_vec powerpc_elf32_vec powerpc_elf32_le_vec rs6000_xcoff_vec rs6000_xcoff64_vec rs6000_xcoff64_aix_vec"
+    want64=true
+    ;;
+  powerpc64le-*-elf* | powerpcle-*-elf64* | powerpc64le-*-linux* | \
+  powerpc64le-*-*bsd*)
+    targ_defvec=powerpc_elf64_le_vec
+    targ_selvecs="powerpc_elf64_vec powerpc_elf32_le_vec powerpc_elf32_vec rs6000_xcoff_vec rs6000_xcoff64_vec rs6000_xcoff64_aix_vec"
+    want64=true
+    ;;
+#endif
+  powerpc-*-*freebsd*)
+    targ_defvec=powerpc_elf32_fbsd_vec
+    targ_selvecs="rs6000_xcoff_vec powerpc_elf32_vec powerpc_elf32_le_vec powerpc_boot_vec"
+    targ64_selvecs="powerpc_elf64_vec powerpc_elf64_le_vec powerpc_elf64_fbsd_vec"
+    ;;
+  powerpc-*-*bsd* | powerpc-*-elf* | powerpc-*-sysv4* | powerpc-*-eabi* | \
+  powerpc-*-solaris2* | powerpc-*-linux-* | powerpc-*-rtems* | \
+  powerpc-*-chorus*)
+    targ_defvec=powerpc_elf32_vec
+    targ_selvecs="rs6000_xcoff_vec powerpc_elf32_le_vec powerpc_boot_vec"
+    targ64_selvecs="powerpc_elf64_vec powerpc_elf64_le_vec"
+    ;;
+  powerpc-*-kaos*)
+    targ_defvec=powerpc_elf32_vec
+    targ_selvecs="powerpc_elf32_le_vec powerpc_boot_vec"
+    targ64_selvecs="powerpc_elf64_vec powerpc_elf64_le_vec"
+    ;;
+  powerpc-*-darwin* | powerpc-*-macos10* | powerpc-*-rhapsody*)
+    targ_defvec=mach_o_be_vec
+    targ_selvecs="mach_o_be_vec mach_o_le_vec mach_o_fat_vec pef_vec pef_xlib_vec sym_vec"
+    targ_archs="$targ_archs bfd_i386_arch"
+    ;;
+  powerpc-*-macos*)
+    targ_defvec=powerpc_xcoff_vec
+    ;;
+  powerpc-*-lynxos*)
+    targ_defvec=powerpc_elf32_vec
+    targ_selvecs="rs6000_xcoff_vec"
+    targ_cflags=-DSMALL_ARCHIVE
+    ;;
+  powerpc-*-netware*)
+    targ_defvec=powerpc_elf32_vec
+    targ_selvecs="powerpc_nlm32_vec rs6000_xcoff_vec"
+    ;;
+  powerpc-*-nto*)
+    targ_defvec=powerpc_elf32_vec
+    targ_selvecs="rs6000_xcoff_vec powerpc_elf32_le_vec powerpc_boot_vec"
+    ;;
+  powerpc-*-vxworks* | powerpc-*-windiss*)
+    targ_defvec=powerpc_elf32_vxworks_vec
+    targ_selvecs="rs6000_xcoff_vec powerpc_elf32_vec powerpc_elf32_le_vec powerpc_boot_vec"
+    targ64_selvecs="powerpc_elf64_vec powerpc_elf64_le_vec"
+    ;;
+  powerpcle-*-nto*)
+    targ_defvec=powerpc_elf32_le_vec
+    targ_selvecs="rs6000_xcoff_vec powerpc_elf32_vec powerpc_boot_vec"
+    ;;
+  powerpcle-*-elf* | powerpcle-*-sysv4* | powerpcle-*-eabi* | \
+  powerpcle-*-solaris2* | powerpcle-*-linux-* | powerpcle-*-vxworks*)
+    targ_defvec=powerpc_elf32_le_vec
+    targ_selvecs="rs6000_xcoff_vec powerpc_elf32_vec powerpc_boot_vec"
+    targ64_selvecs="powerpc_elf64_vec powerpc_elf64_le_vec"
+    ;;
+  powerpcle-*-pe | powerpcle-*-winnt* | powerpcle-*-cygwin*)
+    targ_defvec=powerpc_pe_le_vec
+    targ_selvecs="powerpc_pei_le_vec powerpc_pei_vec powerpc_pe_le_vec powerpc_pe_vec"
+    ;;
+
+  rl78-*-elf)
+    targ_defvec=rl78_elf32_vec
+    ;;
+
+  rx-*-elf)
+    targ_defvec=rx_elf32_le_vec
+    targ_selvecs="rx_elf32_be_vec rx_elf32_le_vec rx_elf32_be_ns_vec"
+    ;;
+
+  s390-*-linux*)
+    targ_defvec=s390_elf32_vec
+    targ64_selvecs=s390_elf64_vec
+    want64=true
+    ;;
+#ifdef BFD64
+  s390x-*-linux*)
+    targ_defvec=s390_elf64_vec
+    targ_selvecs=s390_elf32_vec
+    want64=true
+    ;;
+  s390x-*-tpf*)
+    targ_defvec=s390_elf64_vec
+    want64=true
+    ;;
+
+  score*-*-elf*)
+    targ_defvec=score_elf32_be_vec
+    targ_selvecs=score_elf32_le_vec
+    ;;
+
+  sh64l*-*-elf*)
+    targ_defvec=sh64_elf32_le_vec
+    targ_selvecs="sh64_elf32_vec sh64_elf64_le_vec sh64_elf64_vec sh_elf32_le_vec sh_elf32_vec"
+    targ_underscore=yes
+    want64=true
+    ;;
+  sh64-*-elf*)
+    targ_defvec=sh64_elf32_vec
+    targ_selvecs="sh64_elf32_le_vec sh64_elf64_vec sh64_elf64_le_vec sh_elf32_vec sh_elf32_le_vec"
+    targ_underscore=yes
+    want64=true
+    ;;
+  sh64eb-*-linux*)
+    targ_defvec=sh64_elf32_linux_be_vec
+    targ_selvecs="sh64_elf32_linux_vec sh64_elf64_linux_be_vec sh64_elf64_linux_vec sh_elf32_linux_be_vec sh_elf32_linux_vec"
+    want64=true
+    ;;
+  sh64-*-linux*)
+    targ_defvec=sh64_elf32_linux_vec
+    targ_selvecs="sh64_elf32_linux_be_vec sh64_elf64_linux_vec sh64_elf64_linux_be_vec sh_elf32_linux_vec sh_elf32_linux_be_vec"
+    want64=true
+    ;;
+  sh-*-linux*)
+    targ_defvec=sh_elf32_linux_be_vec
+    targ_selvecs="sh_elf32_linux_vec sh64_elf32_linux_vec sh64_elf32_linux_be_vec sh64_elf64_linux_vec sh64_elf64_linux_be_vec"
+    targ_selvecs="${targ_selvecs} sh_elf32_fdpic_le_vec sh_elf32_fdpic_be_vec"
+    want64=true
+    ;;
+#endif /* BFD64 */
+
+  sh*eb-*-linux*)
+    targ_defvec=sh_elf32_linux_be_vec
+    targ_selvecs=sh_elf32_linux_vec
+    targ_selvecs="${targ_selvecs} sh_elf32_fdpic_le_vec sh_elf32_fdpic_be_vec"
+    ;;
+  sh*-*-linux*)
+    targ_defvec=sh_elf32_linux_vec
+    targ_selvecs=sh_elf32_linux_be_vec
+    targ_selvecs="${targ_selvecs} sh_elf32_fdpic_le_vec sh_elf32_fdpic_be_vec"
+    ;;
+
+  sh-*-uclinux* | sh[12]-*-uclinux*)
+    targ_defvec=sh_elf32_vec
+    targ_selvecs="sh_elf32_le_vec sh_elf32_linux_be_vec sh_elf32_linux_vec sh_elf32_fdpic_le_vec sh_elf32_fdpic_be_vec"
+#ifdef BFD64
+    targ_selvecs="${targ_selvecs} sh64_elf32_linux_vec sh64_elf32_linux_be_vec sh64_elf64_linux_vec sh64_elf64_linux_be_vec"
+#endif
+    ;;
+
+#ifdef BFD64
+  sh5le-*-netbsd*)
+    targ_defvec=sh64_elf32_nbsd_le_vec
+    targ_selvecs="sh64_elf32_nbsd_vec sh64_elf64_nbsd_le_vec sh64_elf64_nbsd_vec sh_elf32_nbsd_vec sh_elf32_nbsd_le_vec"
+    want64=true
+    ;;
+  sh5-*-netbsd*)
+    targ_defvec=sh64_elf32_nbsd_vec
+    targ_selvecs="sh64_elf32_nbsd_le_vec sh64_elf64_nbsd_le_vec sh64_elf64_nbsd_vec sh_elf32_nbsd_vec sh_elf32_nbsd_le_vec"
+    want64=true
+    ;;
+
+  sh64le-*-netbsd*)
+    targ_defvec=sh64_elf64_nbsd_le_vec
+    targ_selvecs="sh64_elf64_nbsd_vec sh64_elf32_nbsd_le_vec sh64_elf32_nbsd_vec sh_elf32_nbsd_vec sh_elf32_nbsd_le_vec"
+    want64=true
+    ;;
+  sh64-*-netbsd*)
+    targ_defvec=sh64_elf64_nbsd_vec
+    targ_selvecs="sh64_elf64_nbsd_le_vec sh64_elf32_nbsd_le_vec sh64_elf32_nbsd_vec sh_elf32_nbsd_vec sh_elf32_nbsd_le_vec"
+    want64=true
+    ;;
+
+  sh*l*-*-netbsdelf*)
+    targ_defvec=sh_elf32_nbsd_le_vec
+    targ_selvecs="sh_elf32_nbsd_vec sh_coff_vec sh_coff_le_vec sh64_elf32_nbsd_le_vec sh64_elf32_nbsd_vec sh64_elf64_nbsd_le_vec sh64_elf64_nbsd_vec"
+    want64=true
+    ;;
+  sh-*-netbsdelf*)
+    targ_defvec=sh_elf32_nbsd_vec
+    targ_selvecs="sh_elf32_nbsd_le_vec sh_coff_vec sh_coff_le_vec sh64_elf32_nbsd_le_vec sh64_elf32_nbsd_vec sh64_elf64_nbsd_le_vec sh64_elf64_nbsd_vec"
+    want64=true
+    ;;
+#endif
+
+  sh*-*-netbsdelf*)
+    targ_defvec=sh_elf32_nbsd_vec
+    targ_selvecs="sh_elf32_nbsd_le_vec sh_coff_vec sh_coff_le_vec"
+    ;;
+  sh*-*-symbianelf*)
+    targ_defvec=sh_elf32_symbian_le_vec
+    targ_selvecs="sh_coff_le_vec sh_coff_small_le_vec"
+    targ_underscore=yes
+    ;;
+
+#ifdef BFD64
+  shl*-*-elf* | sh[1234]l*-*-elf* | sh3el*-*-elf* | shl*-*-kaos*)
+    targ_defvec=sh_elf32_le_vec
+    targ_selvecs="sh_elf32_vec sh_coff_le_vec sh_coff_vec sh_coff_small_le_vec sh_coff_small_vec sh64_elf32_vec sh64_elf32_le_vec sh64_elf64_vec sh64_elf64_le_vec"
+    targ_underscore=yes
+    want64=true
+    ;;
+#endif
+
+  sh-*-rtemscoff*)
+    targ_defvec=sh_coff_vec
+    targ_selvecs="sh_coff_vec sh_coff_le_vec sh_coff_small_vec sh_coff_small_le_vec"
+    targ_underscore=yes
+    ;;
+
+#ifdef BFD64
+  sh-*-elf* | sh[1234]*-elf* | sh-*-rtems* | sh-*-kaos*)
+    targ_defvec=sh_elf32_vec
+    targ_selvecs="sh_elf32_le_vec sh_coff_vec sh_coff_le_vec sh_coff_small_vec sh_coff_small_le_vec sh64_elf32_vec sh64_elf32_le_vec sh64_elf64_vec sh64_elf64_le_vec"
+    targ_underscore=yes
+    want64=true
+    ;;
+#endif
+
+  sh-*-nto*)
+    targ_defvec=sh_elf32_vec
+    targ_selvecs="sh_elf32_le_vec sh_coff_vec sh_coff_le_vec sh_coff_small_vec sh_coff_small_le_vec"
+    targ_underscore=yes
+    ;;
+  sh*-*-openbsd*)
+    targ_defvec=sh_elf32_nbsd_le_vec
+    targ_selvecs="sh_elf32_nbsd_vec sh_coff_vec sh_coff_le_vec"
+    ;;
+  sh-*-pe)
+    targ_defvec=sh_pe_le_vec
+    targ_selvecs="sh_pe_le_vec sh_pei_le_vec"
+    targ_underscore=yes
+    ;;
+  sh-*-vxworks)
+    targ_defvec=sh_elf32_vxworks_vec
+    targ_selvecs="sh_elf32_vxworks_le_vec"
+    # FIXME None of the following are actually used on this target, but
+    # they're necessary for coff-sh.c (which is unconditionally used) to be
+    # compiled correctly.
+    targ_selvecs="$targ_selvecs sh_coff_vec sh_coff_le_vec sh_coff_small_vec sh_coff_small_le_vec"
+    targ_underscore=yes
+    ;;
+  sh-*-*)
+    targ_defvec=sh_coff_vec
+    targ_selvecs="sh_coff_vec sh_coff_le_vec sh_coff_small_vec sh_coff_small_le_vec"
+    targ_underscore=yes
+    ;;
+
+  sparclet-*-aout*)
+    targ_defvec=sparc_aout_sunos_be_vec
+    targ_selvecs=sparc_aout_le_vec
+    targ_underscore=yes
+    ;;
+  sparc86x-*-aout*)
+    targ_defvec=sparc_aout_sunos_be_vec
+    targ_underscore=yes
+    ;;
+  sparclite-*-elf* | sparc86x-*-elf*)
+    targ_defvec=sparc_elf32_vec
+    ;;
+  sparc*-*-chorus*)
+    targ_defvec=sparc_elf32_vec
+    ;;
+  sparc-*-linux*aout*)
+    targ_defvec=sparc_aout_linux_vec
+    targ_selvecs="sparc_elf32_vec sparc_aout_sunos_be_vec"
+    targ_underscore=yes
+    ;;
+  sparc-*-linux-* | sparcv*-*-linux-*)
+    targ_defvec=sparc_elf32_vec
+    targ_selvecs="sparc_aout_linux_vec sparc_elf64_vec sparc_aout_sunos_be_vec"
+    ;;
+  sparc-*-netbsdelf*)
+    targ_defvec=sparc_elf32_vec
+    targ_selvecs=sparc_aout_nbsd_vec
+    ;;
+  sparc-*-netbsdaout* | sparc-*-netbsd*)
+    targ_defvec=sparc_aout_nbsd_vec
+    targ_selvecs=sparc_elf32_vec
+    targ_underscore=yes
+    ;;
+  sparc-*-openbsd[0-2].* | sparc-*-openbsd3.[0-1])
+    targ_defvec=sparc_aout_nbsd_vec
+    targ_underscore=yes
+    ;;
+  sparc-*-openbsd*)
+    targ_defvec=sparc_elf32_vec
+    targ_selvecs=sparc_aout_nbsd_vec
+    ;;
+  sparc-*-elf*)
+    targ_defvec=sparc_elf32_vec
+    targ_selvecs=sparc_aout_sunos_be_vec
+    ;;
+  sparc-*-solaris2.[0-6] | sparc-*-solaris2.[0-6].*)
+    targ_defvec=sparc_elf32_sol2_vec
+    targ_selvecs=sparc_aout_sunos_be_vec
+    ;;
+#ifdef BFD64
+  sparc-*-solaris2* | sparcv9-*-solaris2* | sparc64-*-solaris2*)
+    targ_defvec=sparc_elf32_sol2_vec
+    targ_selvecs="sparc_elf64_sol2_vec sparc_aout_sunos_be_vec"
+    want64=true
+    ;;
+#endif
+  sparc-*-sysv4*)
+    targ_defvec=sparc_elf32_vec
+    ;;
+  sparc-*-vxworks*)
+    targ_defvec=sparc_elf32_vxworks_vec
+    targ_selvecs="sparc_elf32_vec sparc_aout_sunos_be_vec"
+    ;;
+  sparc-*-netware*)
+    targ_defvec=sparc_elf32_vec
+    targ_selvecs="sparc_nlm32_vec sparc_aout_sunos_be_vec"
+    ;;
+#ifdef BFD64
+  sparc64-*-aout*)
+    targ_defvec=sparc_aout_sunos_be_vec
+    targ_underscore=yes
+    want64=true
+    ;;
+  sparc64*-*-linux-*)
+    targ_defvec=sparc_elf64_vec
+    targ_selvecs="sparc_elf32_vec sparc_aout_linux_vec sparc_aout_sunos_be_vec"
+    want64=true
+    ;;
+  sparc64-*-elf* | sparc64-*-rtems* )
+    targ_defvec=sparc_elf64_vec
+    targ_selvecs=sparc_elf32_vec
+    want64=true
+    ;;
+#endif /* BFD64 */
+  sparc*-*-coff*)
+    targ_defvec=sparc_coff_vec
+    ;;
+  sparc-*-rtems*)
+    targ_defvec=sparc_elf32_vec
+    targ_selvecs="sparc_aout_sunos_be_vec sparc_coff_vec"
+    ;;
+  sparc*-*-*)
+    targ_defvec=sparc_aout_sunos_be_vec
+    targ_underscore=yes
+    ;;
+
+  spu-*-elf)
+    targ_defvec=spu_elf32_vec
+    want64=true
+    ;;
+
+#if HAVE_aout_vec
+  tahoe-*-*)
+    targ_defvec=aout_vec
+    targ_underscore=yes
+    ;;
+#endif
+
+  tic6x-*-elf)
+    targ_defvec=tic6x_elf32_c6000_le_vec
+    targ_selvecs="tic6x_elf32_c6000_be_vec tic6x_elf32_le_vec tic6x_elf32_be_vec"
+    ;;
+
+  tic6x-*-uclinux)
+    targ_defvec=tic6x_elf32_linux_le_vec
+    targ_selvecs="tic6x_elf32_linux_be_vec tic6x_elf32_le_vec tic6x_elf32_be_vec"
+    ;;
+
+  tic80*-*-*)
+    targ_defvec=tic80_coff_vec
+    targ_underscore=yes
+    ;;
+
+#ifdef BFD64
+  tilegx-*-*)
+    targ_defvec=tilegx_elf64_le_vec
+    targ_selvecs="tilegx_elf64_be_vec tilegx_elf32_be_vec tilegx_elf32_le_vec"
+    ;;
+  tilegxbe-*-*)
+    targ_defvec=tilegx_elf64_be_vec
+    targ_selvecs="tilegx_elf64_le_vec tilegx_elf32_be_vec tilegx_elf32_le_vec"
+    ;;
+#endif
+
+  tilepro-*-*)
+    targ_defvec=tilepro_elf32_vec
+    ;;
+
+  ft32*-*-*)
+    targ_defvec=ft32_elf32_vec
+    ;;
+
+  v850*-*-*)
+    targ_defvec=v850_elf32_vec
+    targ_selvecs="v800_elf32_vec"
+    ;;
+
+  vax-*-netbsdelf*)
+    targ_defvec=vax_elf32_vec
+    targ_selvecs="vax_aout_nbsd_vec vax_aout_1knbsd_vec"
+    ;;
+
+  vax-*-netbsdaout* | vax-*-netbsd*)
+    targ_defvec=vax_aout_nbsd_vec
+    targ_selvecs="vax_elf32_vec vax_aout_1knbsd_vec"
+    targ_underscore=yes
+    ;;
+
+  vax-*-bsd* | vax-*-ultrix*)
+    targ_defvec=vax_aout_bsd_vec
+    targ_underscore=yes
+    ;;
+
+  vax-*-openbsd*)
+    targ_defvec=vax_aout_nbsd_vec
+    targ_underscore=yes
+    ;;
+
+  vax-*-linux-*)
+    targ_defvec=vax_elf32_vec
+    ;;
+
+  visium-*-elf)
+    targ_defvec=visium_elf32_vec
+    ;;
+
+  we32k-*-*)
+    targ_defvec=we32k_coff_vec
+    ;;
+
+  w65-*-*)
+    targ_defvec=w65_coff_vec
+    ;;
+
+  xgate-*-*)
+    targ_defvec=xgate_elf32_vec
+    targ_selvecs="xgate_elf32_vec"
+    ;;
+
+  xstormy16-*-elf)
+    targ_defvec=xstormy16_elf32_vec
+    ;;
+
+  xtensa*-*-*)
+    targ_defvec=xtensa_elf32_le_vec
+    targ_selvecs=xtensa_elf32_be_vec
+    ;;
+ xc16x-*-elf)
+    targ_defvec=xc16x_elf32_vec
+    ;;
+
+  z80-*-*)
+    targ_defvec=z80_coff_vec
+    targ_underscore=no
+    ;;
+
+  z8k*-*-*)
+    targ_defvec=z8k_coff_vec
+    targ_underscore=yes
+    ;;
+
+  *-*-ieee*)
+    targ_defvec=ieee_vec
+    ;;
+
+  *-adobe-*)
+    targ_defvec=aout_adobe_vec
+    targ_underscore=yes
+    ;;
+
+  *-sony-*)
+    targ_defvec=m68k_aout_newsos3_vec
+    targ_underscore=yes
+    ;;
+
+  *-tandem-*)
+    targ_defvec=m68k_coff_vec
+    targ_selvecs=ieee_vec
+    ;;
+# END OF targmatch.h
+  *)
+    echo 1>&2 "*** BFD does not support target ${targ}."
+    echo 1>&2 "*** Look in bfd/config.bfd for supported targets."
+    exit 1
+    ;;
+esac
+
+# All MIPS ELF targets need a 64-bit bfd_vma.
+case "${targ_defvec} ${targ_selvecs}" in
+  *mips_elf*)
+    want64=true
+    ;;
+esac
+
+case "${host64}${want64}" in
+  *true*)
+    targ_selvecs="${targ_selvecs} ${targ64_selvecs}"
+    ;;
+esac
+
+# If we support any ELF target, then automatically add support for the
+# generic ELF targets.  This permits an objdump with some ELF support
+# to be used on an arbitrary ELF file for anything other than
+# relocation information.
+case "${targ_defvec} ${targ_selvecs}" in
+  *elf64* | *mips_elf32_n*)
+    targ_selvecs="${targ_selvecs} elf64_le_vec elf64_be_vec elf32_le_vec elf32_be_vec"
+    ;;
+  *elf32*)
+    targ_selvecs="${targ_selvecs} elf32_le_vec elf32_be_vec"
+    ;;
+esac
+
+# If we support Intel MCU target, then add support for bfd_iamcu_arch.
+case "${targ_defvec} ${targ_selvecs}" in
+  *iamcu_elf32*)
+    targ_archs="$targ_archs bfd_iamcu_arch"
+    ;;
+esac
+
+# If we support Intel L1OM target, then add support for bfd_l1om_arch.
+case "${targ_defvec} ${targ_selvecs}" in
+  *l1om_elf64*)
+    targ_archs="$targ_archs bfd_l1om_arch"
+    ;;
+esac
+
+# If we support Intel K1OM target, then add support for bfd_k1om_arch.
+case "${targ_defvec} ${targ_selvecs}" in
+  *k1om_elf64*)
+    targ_archs="$targ_archs bfd_k1om_arch"
+    ;;
+esac
diff -Naur binutils-2.26/bfd/configure binutils-2.26.0007/bfd/configure
--- binutils-2.26/bfd/configure	2016-01-25 09:54:07.000000000 +0100
+++ binutils-2.26.0007/bfd/configure	2016-03-10 17:14:55.006867816 +0100
@@ -15286,12 +15286,16 @@
     arm_pe_epoc_le_vec)		 tb="$tb epoc-pe-arm.lo peigen.lo $coff" ;;
     arm_pe_wince_be_vec)	 tb="$tb pe-arm-wince.lo pe-arm.lo peigen.lo $coff" ;;
     arm_pe_wince_le_vec)	 tb="$tb pe-arm-wince.lo pe-arm.lo peigen.lo $coff" ;;
+    arm_pe_winnt_be_vec)         tb="$tb pe-arm-winnt.lo pe-arm.lo peigen.lo cofflink.lo " ;;
+    arm_pe_winnt_le_vec)         tb="$tb pe-arm-winnt.lo pe-arm.lo peigen.lo cofflink.lo " ;;    
     arm_pei_be_vec)		 tb="$tb pei-arm.lo peigen.lo $coff" ;;
     arm_pei_le_vec)		 tb="$tb pei-arm.lo peigen.lo $coff" ;;
     arm_pei_epoc_be_vec)	 tb="$tb epoc-pei-arm.lo peigen.lo $coff" ;;
     arm_pei_epoc_le_vec)	 tb="$tb epoc-pei-arm.lo peigen.lo $coff" ;;
     arm_pei_wince_be_vec)	 tb="$tb pei-arm-wince.lo pei-arm.lo peigen.lo $coff" ;;
     arm_pei_wince_le_vec)	 tb="$tb pei-arm-wince.lo pei-arm.lo peigen.lo $coff" ;;
+    arm_pei_winnt_be_vec)  tb="$tb pei-arm-winnt.lo pei-arm.lo peigen.lo cofflink.lo " ;;
+    arm_pei_winnt_le_vec)  tb="$tb pei-arm-winnt.lo pei-arm.lo peigen.lo cofflink.lo " ;;
     avr_elf32_vec)		 tb="$tb elf32-avr.lo elf32.lo $elf" ;;
     bfin_elf32_vec)		 tb="$tb elf32-bfin.lo elf32.lo $elf" ;;
     bfin_elf32_fdpic_vec)	 tb="$tb elf32-bfin.lo elf32.lo $elf" ;;
diff -Naur binutils-2.26/bfd/configure.ac binutils-2.26.0007/bfd/configure.ac
--- binutils-2.26/bfd/configure.ac	2015-11-13 09:27:40.000000000 +0100
+++ binutils-2.26.0007/bfd/configure.ac	2016-03-10 17:17:25.946661894 +0100
@@ -732,12 +732,16 @@
     arm_pe_epoc_le_vec)		 tb="$tb epoc-pe-arm.lo peigen.lo $coff" ;;
     arm_pe_wince_be_vec)	 tb="$tb pe-arm-wince.lo pe-arm.lo peigen.lo $coff" ;;
     arm_pe_wince_le_vec)	 tb="$tb pe-arm-wince.lo pe-arm.lo peigen.lo $coff" ;;
+    arm_pe_winnt_be_vec)         tb="$tb pe-arm-winnt.lo pe-arm.lo peigen.lo cofflink.lo " ;;
+    arm_pe_winnt_le_vec)         tb="$tb pe-arm-winnt.lo pe-arm.lo peigen.lo cofflink.lo " ;;
     arm_pei_be_vec)		 tb="$tb pei-arm.lo peigen.lo $coff" ;;
     arm_pei_le_vec)		 tb="$tb pei-arm.lo peigen.lo $coff" ;;
     arm_pei_epoc_be_vec)	 tb="$tb epoc-pei-arm.lo peigen.lo $coff" ;;
     arm_pei_epoc_le_vec)	 tb="$tb epoc-pei-arm.lo peigen.lo $coff" ;;
     arm_pei_wince_be_vec)	 tb="$tb pei-arm-wince.lo pei-arm.lo peigen.lo $coff" ;;
     arm_pei_wince_le_vec)	 tb="$tb pei-arm-wince.lo pei-arm.lo peigen.lo $coff" ;;
+    arm_pei_winnt_be_vec)        tb="$tb pei-arm-winnt.lo pei-arm.lo peigen.lo cofflink.lo " ;;
+    arm_pei_winnt_le_vec)        tb="$tb pei-arm-winnt.lo pei-arm.lo peigen.lo cofflink.lo " ;;
     avr_elf32_vec)		 tb="$tb elf32-avr.lo elf32.lo $elf" ;;
     bfin_elf32_vec)		 tb="$tb elf32-bfin.lo elf32.lo $elf" ;;
     bfin_elf32_fdpic_vec)	 tb="$tb elf32-bfin.lo elf32.lo $elf" ;;
diff -Naur binutils-2.26/bfd/pe-arm-winnt.c binutils-2.26.0007/bfd/pe-arm-winnt.c
--- binutils-2.26/bfd/pe-arm-winnt.c	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.26.0007/bfd/pe-arm-winnt.c	2016-03-10 17:02:24.204052839 +0100
@@ -0,0 +1,45 @@
+/* BFD back-end for ARM WINNT PE files.
+   Copyright (C) 2006-2014 Free Software Foundation, Inc.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#define TARGET_UNDERSCORE    0
+#define USER_LABEL_PREFIX    ""
+
+#define TARGET_LITTLE_SYM    arm_pe_winnt_le_vec
+#define TARGET_LITTLE_NAME   "pe-arm-winnt-little"
+#define TARGET_BIG_SYM       arm_pe_winnt_be_vec
+#define TARGET_BIG_NAME      "pe-arm-winnt-big"
+
+#define bfd_arm_allocate_interworking_sections \
+  bfd_thumb2pe_allocate_interworking_sections
+#define bfd_arm_get_bfd_for_interworking \
+  bfd_thumb2pe_get_bfd_for_interworking
+#define bfd_arm_process_before_allocation \
+  bfd_thumb2pe_process_before_allocation
+
+#define LOCAL_LABEL_PREFIX "."
+
+#include "sysdep.h"
+#include "bfd.h"
+
+#undef  bfd_pe_print_pdata
+#define	bfd_pe_print_pdata   _bfd_pe_print_ce_compressed_pdata
+
+#include "pe-arm.c"
+
diff -Naur binutils-2.26/bfd/peXXigen.c binutils-2.26.0007/bfd/peXXigen.c
--- binutils-2.26/bfd/peXXigen.c	2015-11-13 09:27:40.000000000 +0100
+++ binutils-2.26.0007/bfd/peXXigen.c	2016-03-10 17:02:24.224052398 +0100
@@ -761,6 +761,10 @@
   PUT_AOUTHDR_TEXT_START (abfd, aouthdr_in->text_start,
 			  aouthdr_out->standard.text_start);
 
+#ifdef ARM_WINNT
+  aouthdr_out->standard.entry[0] |= 1;
+#endif
+
 #if !defined(COFF_WITH_pep) && !defined(COFF_WITH_pex64)
   /* PE32+ does not have data_start member!  */
   PUT_AOUTHDR_DATA_START (abfd, aouthdr_in->data_start,
@@ -786,6 +790,9 @@
   H_PUT_32 (abfd, extra->CheckSum, aouthdr_out->CheckSum);
   H_PUT_16 (abfd, extra->Subsystem, aouthdr_out->Subsystem);
   H_PUT_16 (abfd, extra->DllCharacteristics, aouthdr_out->DllCharacteristics);
+#ifdef ARM_WINNT
+  H_PUT_16 (abfd, 0x8540,aouthdr_out->DllCharacteristics);
+#endif
   PUT_OPTHDR_SIZE_OF_STACK_RESERVE (abfd, extra->SizeOfStackReserve,
 				    aouthdr_out->SizeOfStackReserve);
   PUT_OPTHDR_SIZE_OF_STACK_COMMIT (abfd, extra->SizeOfStackCommit,
@@ -885,6 +892,10 @@
   H_PUT_16 (abfd, filehdr_in->f_opthdr, filehdr_out->f_opthdr);
   H_PUT_16 (abfd, filehdr_in->f_flags, filehdr_out->f_flags);
 
+#ifdef ARM_WINNT
+  filehdr_out->f_flags[0] &= ~IMAGE_FILE_RELOCS_STRIPPED;
+#endif
+
   /* Put in extra dos header stuff.  This data remains essentially
      constant, it just has to be tacked on to the beginning of all exes
      for NT.  */
diff -Naur binutils-2.26/bfd/peXXigen.c.orig binutils-2.26.0007/bfd/peXXigen.c.orig
--- binutils-2.26/bfd/peXXigen.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.26.0007/bfd/peXXigen.c.orig	2016-03-10 17:02:00.394577337 +0100
@@ -0,0 +1,4543 @@
+/* Support for the generic parts of PE/PEI; the common executable parts.
+   Copyright (C) 1995-2015 Free Software Foundation, Inc.
+   Written by Cygnus Solutions.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+
+/* Most of this hacked by Steve Chamberlain <sac@cygnus.com>.
+
+   PE/PEI rearrangement (and code added): Donn Terry
+					  Softway Systems, Inc.  */
+
+/* Hey look, some documentation [and in a place you expect to find it]!
+
+   The main reference for the pei format is "Microsoft Portable Executable
+   and Common Object File Format Specification 4.1".  Get it if you need to
+   do some serious hacking on this code.
+
+   Another reference:
+   "Peering Inside the PE: A Tour of the Win32 Portable Executable
+   File Format", MSJ 1994, Volume 9.
+
+   The *sole* difference between the pe format and the pei format is that the
+   latter has an MSDOS 2.0 .exe header on the front that prints the message
+   "This app must be run under Windows." (or some such).
+   (FIXME: Whether that statement is *really* true or not is unknown.
+   Are there more subtle differences between pe and pei formats?
+   For now assume there aren't.  If you find one, then for God sakes
+   document it here!)
+
+   The Microsoft docs use the word "image" instead of "executable" because
+   the former can also refer to a DLL (shared library).  Confusion can arise
+   because the `i' in `pei' also refers to "image".  The `pe' format can
+   also create images (i.e. executables), it's just that to run on a win32
+   system you need to use the pei format.
+
+   FIXME: Please add more docs here so the next poor fool that has to hack
+   on this code has a chance of getting something accomplished without
+   wasting too much time.  */
+
+/* This expands into COFF_WITH_pe, COFF_WITH_pep, or COFF_WITH_pex64
+   depending on whether we're compiling for straight PE or PE+.  */
+#define COFF_WITH_XX
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+#include "coff/internal.h"
+#include "bfdver.h"
+#ifdef HAVE_WCHAR_H
+#include <wchar.h>
+#endif
+#ifdef HAVE_WCTYPE_H
+#include <wctype.h>
+#endif
+
+/* NOTE: it's strange to be including an architecture specific header
+   in what's supposed to be general (to PE/PEI) code.  However, that's
+   where the definitions are, and they don't vary per architecture
+   within PE/PEI, so we get them from there.  FIXME: The lack of
+   variance is an assumption which may prove to be incorrect if new
+   PE/PEI targets are created.  */
+#if defined COFF_WITH_pex64
+# include "coff/x86_64.h"
+#elif defined COFF_WITH_pep
+# include "coff/ia64.h"
+#else
+# include "coff/i386.h"
+#endif
+
+#include "coff/pe.h"
+#include "libcoff.h"
+#include "libpei.h"
+#include "safe-ctype.h"
+
+#if defined COFF_WITH_pep || defined COFF_WITH_pex64
+# undef AOUTSZ
+# define AOUTSZ		PEPAOUTSZ
+# define PEAOUTHDR	PEPAOUTHDR
+#endif
+
+#define HighBitSet(val)      ((val) & 0x80000000)
+#define SetHighBit(val)      ((val) | 0x80000000)
+#define WithoutHighBit(val)  ((val) & 0x7fffffff)
+
+/* FIXME: This file has various tests of POWERPC_LE_PE.  Those tests
+   worked when the code was in peicode.h, but no longer work now that
+   the code is in peigen.c.  PowerPC NT is said to be dead.  If
+   anybody wants to revive the code, you will have to figure out how
+   to handle those issues.  */
+
+void
+_bfd_XXi_swap_sym_in (bfd * abfd, void * ext1, void * in1)
+{
+  SYMENT *ext = (SYMENT *) ext1;
+  struct internal_syment *in = (struct internal_syment *) in1;
+
+  if (ext->e.e_name[0] == 0)
+    {
+      in->_n._n_n._n_zeroes = 0;
+      in->_n._n_n._n_offset = H_GET_32 (abfd, ext->e.e.e_offset);
+    }
+  else
+    memcpy (in->_n._n_name, ext->e.e_name, SYMNMLEN);
+
+  in->n_value = H_GET_32 (abfd, ext->e_value);
+  in->n_scnum = H_GET_16 (abfd, ext->e_scnum);
+
+  if (sizeof (ext->e_type) == 2)
+    in->n_type = H_GET_16 (abfd, ext->e_type);
+  else
+    in->n_type = H_GET_32 (abfd, ext->e_type);
+
+  in->n_sclass = H_GET_8 (abfd, ext->e_sclass);
+  in->n_numaux = H_GET_8 (abfd, ext->e_numaux);
+
+#ifndef STRICT_PE_FORMAT
+  /* This is for Gnu-created DLLs.  */
+
+  /* The section symbols for the .idata$ sections have class 0x68
+     (C_SECTION), which MS documentation indicates is a section
+     symbol.  Unfortunately, the value field in the symbol is simply a
+     copy of the .idata section's flags rather than something useful.
+     When these symbols are encountered, change the value to 0 so that
+     they will be handled somewhat correctly in the bfd code.  */
+  if (in->n_sclass == C_SECTION)
+    {
+      char namebuf[SYMNMLEN + 1];
+      const char *name = NULL;
+
+      in->n_value = 0x0;
+
+      /* Create synthetic empty sections as needed.  DJ */
+      if (in->n_scnum == 0)
+	{
+	  asection *sec;
+
+	  name = _bfd_coff_internal_syment_name (abfd, in, namebuf);
+	  if (name == NULL)
+	    {
+	      _bfd_error_handler (_("%B: unable to find name for empty section"),
+				  abfd);
+	      bfd_set_error (bfd_error_invalid_target);
+	      return;
+	    }
+
+	  sec = bfd_get_section_by_name (abfd, name);
+	  if (sec != NULL)
+	    in->n_scnum = sec->target_index;
+	}
+
+      if (in->n_scnum == 0)
+	{
+	  int unused_section_number = 0;
+	  asection *sec;
+	  flagword flags;
+
+	  for (sec = abfd->sections; sec; sec = sec->next)
+	    if (unused_section_number <= sec->target_index)
+	      unused_section_number = sec->target_index + 1;
+
+	  if (name == namebuf)
+	    {
+	      name = (const char *) bfd_alloc (abfd, strlen (namebuf) + 1);
+	      if (name == NULL)
+		{
+		  _bfd_error_handler (_("%B: out of memory creating name for empty section"),
+				      abfd);
+		  return;
+		}
+	      strcpy ((char *) name, namebuf);
+	    }
+
+	  flags = SEC_HAS_CONTENTS | SEC_ALLOC | SEC_DATA | SEC_LOAD;
+	  sec = bfd_make_section_anyway_with_flags (abfd, name, flags);
+	  if (sec == NULL)
+	    {
+	      _bfd_error_handler (_("%B: unable to create fake empty section"),
+				  abfd);
+	      return;
+	    }
+
+	  sec->vma = 0;
+	  sec->lma = 0;
+	  sec->size = 0;
+	  sec->filepos = 0;
+	  sec->rel_filepos = 0;
+	  sec->reloc_count = 0;
+	  sec->line_filepos = 0;
+	  sec->lineno_count = 0;
+	  sec->userdata = NULL;
+	  sec->next = NULL;
+	  sec->alignment_power = 2;
+
+	  sec->target_index = unused_section_number;
+
+	  in->n_scnum = unused_section_number;
+	}
+      in->n_sclass = C_STAT;
+    }
+#endif
+
+#ifdef coff_swap_sym_in_hook
+  /* This won't work in peigen.c, but since it's for PPC PE, it's not
+     worth fixing.  */
+  coff_swap_sym_in_hook (abfd, ext1, in1);
+#endif
+}
+
+static bfd_boolean
+abs_finder (bfd * abfd ATTRIBUTE_UNUSED, asection * sec, void * data)
+{
+  bfd_vma abs_val = * (bfd_vma *) data;
+
+  return (sec->vma <= abs_val) && ((sec->vma + (1ULL << 32)) > abs_val);
+}
+
+unsigned int
+_bfd_XXi_swap_sym_out (bfd * abfd, void * inp, void * extp)
+{
+  struct internal_syment *in = (struct internal_syment *) inp;
+  SYMENT *ext = (SYMENT *) extp;
+
+  if (in->_n._n_name[0] == 0)
+    {
+      H_PUT_32 (abfd, 0, ext->e.e.e_zeroes);
+      H_PUT_32 (abfd, in->_n._n_n._n_offset, ext->e.e.e_offset);
+    }
+  else
+    memcpy (ext->e.e_name, in->_n._n_name, SYMNMLEN);
+
+  /* The PE32 and PE32+ formats only use 4 bytes to hold the value of a
+     symbol.  This is a problem on 64-bit targets where we can generate
+     absolute symbols with values >= 1^32.  We try to work around this
+     problem by finding a section whose base address is sufficient to
+     reduce the absolute value to < 1^32, and then transforming the
+     symbol into a section relative symbol.  This of course is a hack.  */
+  if (sizeof (in->n_value) > 4
+      /* The strange computation of the shift amount is here in order to
+	 avoid a compile time warning about the comparison always being
+	 false.  It does not matter if this test fails to work as expected
+	 as the worst that can happen is that some absolute symbols are
+	 needlessly converted into section relative symbols.  */
+      && in->n_value > ((1ULL << (sizeof (in->n_value) > 4 ? 32 : 31)) - 1)
+      && in->n_scnum == -1)
+    {
+      asection * sec;
+
+      sec = bfd_sections_find_if (abfd, abs_finder, & in->n_value);
+      if (sec)
+	{
+	  in->n_value -= sec->vma;
+	  in->n_scnum = sec->target_index;
+	}
+      /* else: FIXME: The value is outside the range of any section.  This
+	 happens for __image_base__ and __ImageBase and maybe some other
+	 symbols as well.  We should find a way to handle these values.  */
+    }
+
+  H_PUT_32 (abfd, in->n_value, ext->e_value);
+  H_PUT_16 (abfd, in->n_scnum, ext->e_scnum);
+
+  if (sizeof (ext->e_type) == 2)
+    H_PUT_16 (abfd, in->n_type, ext->e_type);
+  else
+    H_PUT_32 (abfd, in->n_type, ext->e_type);
+
+  H_PUT_8 (abfd, in->n_sclass, ext->e_sclass);
+  H_PUT_8 (abfd, in->n_numaux, ext->e_numaux);
+
+  return SYMESZ;
+}
+
+void
+_bfd_XXi_swap_aux_in (bfd *	abfd,
+		      void *	ext1,
+		      int       type,
+		      int       in_class,
+		      int	indx ATTRIBUTE_UNUSED,
+		      int	numaux ATTRIBUTE_UNUSED,
+		      void * 	in1)
+{
+  AUXENT *ext = (AUXENT *) ext1;
+  union internal_auxent *in = (union internal_auxent *) in1;
+
+  /* PR 17521: Make sure that all fields in the aux structure
+     are initialised.  */
+  memset (in, 0, sizeof * in);
+  switch (in_class)
+    {
+    case C_FILE:
+      if (ext->x_file.x_fname[0] == 0)
+	{
+	  in->x_file.x_n.x_zeroes = 0;
+	  in->x_file.x_n.x_offset = H_GET_32 (abfd, ext->x_file.x_n.x_offset);
+	}
+      else
+	memcpy (in->x_file.x_fname, ext->x_file.x_fname, FILNMLEN);
+      return;
+
+    case C_STAT:
+    case C_LEAFSTAT:
+    case C_HIDDEN:
+      if (type == T_NULL)
+	{
+	  in->x_scn.x_scnlen = GET_SCN_SCNLEN (abfd, ext);
+	  in->x_scn.x_nreloc = GET_SCN_NRELOC (abfd, ext);
+	  in->x_scn.x_nlinno = GET_SCN_NLINNO (abfd, ext);
+	  in->x_scn.x_checksum = H_GET_32 (abfd, ext->x_scn.x_checksum);
+	  in->x_scn.x_associated = H_GET_16 (abfd, ext->x_scn.x_associated);
+	  in->x_scn.x_comdat = H_GET_8 (abfd, ext->x_scn.x_comdat);
+	  return;
+	}
+      break;
+    }
+
+  in->x_sym.x_tagndx.l = H_GET_32 (abfd, ext->x_sym.x_tagndx);
+  in->x_sym.x_tvndx = H_GET_16 (abfd, ext->x_sym.x_tvndx);
+
+  if (in_class == C_BLOCK || in_class == C_FCN || ISFCN (type)
+      || ISTAG (in_class))
+    {
+      in->x_sym.x_fcnary.x_fcn.x_lnnoptr = GET_FCN_LNNOPTR (abfd, ext);
+      in->x_sym.x_fcnary.x_fcn.x_endndx.l = GET_FCN_ENDNDX (abfd, ext);
+    }
+  else
+    {
+      in->x_sym.x_fcnary.x_ary.x_dimen[0] =
+	H_GET_16 (abfd, ext->x_sym.x_fcnary.x_ary.x_dimen[0]);
+      in->x_sym.x_fcnary.x_ary.x_dimen[1] =
+	H_GET_16 (abfd, ext->x_sym.x_fcnary.x_ary.x_dimen[1]);
+      in->x_sym.x_fcnary.x_ary.x_dimen[2] =
+	H_GET_16 (abfd, ext->x_sym.x_fcnary.x_ary.x_dimen[2]);
+      in->x_sym.x_fcnary.x_ary.x_dimen[3] =
+	H_GET_16 (abfd, ext->x_sym.x_fcnary.x_ary.x_dimen[3]);
+    }
+
+  if (ISFCN (type))
+    {
+      in->x_sym.x_misc.x_fsize = H_GET_32 (abfd, ext->x_sym.x_misc.x_fsize);
+    }
+  else
+    {
+      in->x_sym.x_misc.x_lnsz.x_lnno = GET_LNSZ_LNNO (abfd, ext);
+      in->x_sym.x_misc.x_lnsz.x_size = GET_LNSZ_SIZE (abfd, ext);
+    }
+}
+
+unsigned int
+_bfd_XXi_swap_aux_out (bfd *  abfd,
+		       void * inp,
+		       int    type,
+		       int    in_class,
+		       int    indx ATTRIBUTE_UNUSED,
+		       int    numaux ATTRIBUTE_UNUSED,
+		       void * extp)
+{
+  union internal_auxent *in = (union internal_auxent *) inp;
+  AUXENT *ext = (AUXENT *) extp;
+
+  memset (ext, 0, AUXESZ);
+
+  switch (in_class)
+    {
+    case C_FILE:
+      if (in->x_file.x_fname[0] == 0)
+	{
+	  H_PUT_32 (abfd, 0, ext->x_file.x_n.x_zeroes);
+	  H_PUT_32 (abfd, in->x_file.x_n.x_offset, ext->x_file.x_n.x_offset);
+	}
+      else
+	memcpy (ext->x_file.x_fname, in->x_file.x_fname, FILNMLEN);
+
+      return AUXESZ;
+
+    case C_STAT:
+    case C_LEAFSTAT:
+    case C_HIDDEN:
+      if (type == T_NULL)
+	{
+	  PUT_SCN_SCNLEN (abfd, in->x_scn.x_scnlen, ext);
+	  PUT_SCN_NRELOC (abfd, in->x_scn.x_nreloc, ext);
+	  PUT_SCN_NLINNO (abfd, in->x_scn.x_nlinno, ext);
+	  H_PUT_32 (abfd, in->x_scn.x_checksum, ext->x_scn.x_checksum);
+	  H_PUT_16 (abfd, in->x_scn.x_associated, ext->x_scn.x_associated);
+	  H_PUT_8 (abfd, in->x_scn.x_comdat, ext->x_scn.x_comdat);
+	  return AUXESZ;
+	}
+      break;
+    }
+
+  H_PUT_32 (abfd, in->x_sym.x_tagndx.l, ext->x_sym.x_tagndx);
+  H_PUT_16 (abfd, in->x_sym.x_tvndx, ext->x_sym.x_tvndx);
+
+  if (in_class == C_BLOCK || in_class == C_FCN || ISFCN (type)
+      || ISTAG (in_class))
+    {
+      PUT_FCN_LNNOPTR (abfd, in->x_sym.x_fcnary.x_fcn.x_lnnoptr,  ext);
+      PUT_FCN_ENDNDX  (abfd, in->x_sym.x_fcnary.x_fcn.x_endndx.l, ext);
+    }
+  else
+    {
+      H_PUT_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[0],
+		ext->x_sym.x_fcnary.x_ary.x_dimen[0]);
+      H_PUT_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[1],
+		ext->x_sym.x_fcnary.x_ary.x_dimen[1]);
+      H_PUT_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[2],
+		ext->x_sym.x_fcnary.x_ary.x_dimen[2]);
+      H_PUT_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[3],
+		ext->x_sym.x_fcnary.x_ary.x_dimen[3]);
+    }
+
+  if (ISFCN (type))
+    H_PUT_32 (abfd, in->x_sym.x_misc.x_fsize, ext->x_sym.x_misc.x_fsize);
+  else
+    {
+      PUT_LNSZ_LNNO (abfd, in->x_sym.x_misc.x_lnsz.x_lnno, ext);
+      PUT_LNSZ_SIZE (abfd, in->x_sym.x_misc.x_lnsz.x_size, ext);
+    }
+
+  return AUXESZ;
+}
+
+void
+_bfd_XXi_swap_lineno_in (bfd * abfd, void * ext1, void * in1)
+{
+  LINENO *ext = (LINENO *) ext1;
+  struct internal_lineno *in = (struct internal_lineno *) in1;
+
+  in->l_addr.l_symndx = H_GET_32 (abfd, ext->l_addr.l_symndx);
+  in->l_lnno = GET_LINENO_LNNO (abfd, ext);
+}
+
+unsigned int
+_bfd_XXi_swap_lineno_out (bfd * abfd, void * inp, void * outp)
+{
+  struct internal_lineno *in = (struct internal_lineno *) inp;
+  struct external_lineno *ext = (struct external_lineno *) outp;
+  H_PUT_32 (abfd, in->l_addr.l_symndx, ext->l_addr.l_symndx);
+
+  PUT_LINENO_LNNO (abfd, in->l_lnno, ext);
+  return LINESZ;
+}
+
+void
+_bfd_XXi_swap_aouthdr_in (bfd * abfd,
+			  void * aouthdr_ext1,
+			  void * aouthdr_int1)
+{
+  PEAOUTHDR * src = (PEAOUTHDR *) aouthdr_ext1;
+  AOUTHDR * aouthdr_ext = (AOUTHDR *) aouthdr_ext1;
+  struct internal_aouthdr *aouthdr_int
+    = (struct internal_aouthdr *) aouthdr_int1;
+  struct internal_extra_pe_aouthdr *a = &aouthdr_int->pe;
+
+  aouthdr_int->magic = H_GET_16 (abfd, aouthdr_ext->magic);
+  aouthdr_int->vstamp = H_GET_16 (abfd, aouthdr_ext->vstamp);
+  aouthdr_int->tsize = GET_AOUTHDR_TSIZE (abfd, aouthdr_ext->tsize);
+  aouthdr_int->dsize = GET_AOUTHDR_DSIZE (abfd, aouthdr_ext->dsize);
+  aouthdr_int->bsize = GET_AOUTHDR_BSIZE (abfd, aouthdr_ext->bsize);
+  aouthdr_int->entry = GET_AOUTHDR_ENTRY (abfd, aouthdr_ext->entry);
+  aouthdr_int->text_start =
+    GET_AOUTHDR_TEXT_START (abfd, aouthdr_ext->text_start);
+
+#if !defined(COFF_WITH_pep) && !defined(COFF_WITH_pex64)
+  /* PE32+ does not have data_start member!  */
+  aouthdr_int->data_start =
+    GET_AOUTHDR_DATA_START (abfd, aouthdr_ext->data_start);
+  a->BaseOfData = aouthdr_int->data_start;
+#endif
+
+  a->Magic = aouthdr_int->magic;
+  a->MajorLinkerVersion = H_GET_8 (abfd, aouthdr_ext->vstamp);
+  a->MinorLinkerVersion = H_GET_8 (abfd, aouthdr_ext->vstamp + 1);
+  a->SizeOfCode = aouthdr_int->tsize ;
+  a->SizeOfInitializedData = aouthdr_int->dsize ;
+  a->SizeOfUninitializedData = aouthdr_int->bsize ;
+  a->AddressOfEntryPoint = aouthdr_int->entry;
+  a->BaseOfCode = aouthdr_int->text_start;
+  a->ImageBase = GET_OPTHDR_IMAGE_BASE (abfd, src->ImageBase);
+  a->SectionAlignment = H_GET_32 (abfd, src->SectionAlignment);
+  a->FileAlignment = H_GET_32 (abfd, src->FileAlignment);
+  a->MajorOperatingSystemVersion =
+    H_GET_16 (abfd, src->MajorOperatingSystemVersion);
+  a->MinorOperatingSystemVersion =
+    H_GET_16 (abfd, src->MinorOperatingSystemVersion);
+  a->MajorImageVersion = H_GET_16 (abfd, src->MajorImageVersion);
+  a->MinorImageVersion = H_GET_16 (abfd, src->MinorImageVersion);
+  a->MajorSubsystemVersion = H_GET_16 (abfd, src->MajorSubsystemVersion);
+  a->MinorSubsystemVersion = H_GET_16 (abfd, src->MinorSubsystemVersion);
+  a->Reserved1 = H_GET_32 (abfd, src->Reserved1);
+  a->SizeOfImage = H_GET_32 (abfd, src->SizeOfImage);
+  a->SizeOfHeaders = H_GET_32 (abfd, src->SizeOfHeaders);
+  a->CheckSum = H_GET_32 (abfd, src->CheckSum);
+  a->Subsystem = H_GET_16 (abfd, src->Subsystem);
+  a->DllCharacteristics = H_GET_16 (abfd, src->DllCharacteristics);
+  a->SizeOfStackReserve =
+    GET_OPTHDR_SIZE_OF_STACK_RESERVE (abfd, src->SizeOfStackReserve);
+  a->SizeOfStackCommit =
+    GET_OPTHDR_SIZE_OF_STACK_COMMIT (abfd, src->SizeOfStackCommit);
+  a->SizeOfHeapReserve =
+    GET_OPTHDR_SIZE_OF_HEAP_RESERVE (abfd, src->SizeOfHeapReserve);
+  a->SizeOfHeapCommit =
+    GET_OPTHDR_SIZE_OF_HEAP_COMMIT (abfd, src->SizeOfHeapCommit);
+  a->LoaderFlags = H_GET_32 (abfd, src->LoaderFlags);
+  a->NumberOfRvaAndSizes = H_GET_32 (abfd, src->NumberOfRvaAndSizes);
+
+  {
+    int idx;
+
+    /* PR 17512: Corrupt PE binaries can cause seg-faults.  */
+    if (a->NumberOfRvaAndSizes > IMAGE_NUMBEROF_DIRECTORY_ENTRIES)
+      {
+	(*_bfd_error_handler)
+	  (_("%B: aout header specifies an invalid number of data-directory entries: %d"),
+	   abfd, a->NumberOfRvaAndSizes);
+	bfd_set_error (bfd_error_bad_value);
+
+	/* Paranoia: If the number is corrupt, then assume that the
+	   actual entries themselves might be corrupt as well.  */
+	a->NumberOfRvaAndSizes = 0;
+      }
+
+    for (idx = 0; idx < a->NumberOfRvaAndSizes; idx++)
+      {
+        /* If data directory is empty, rva also should be 0.  */
+	int size =
+	  H_GET_32 (abfd, src->DataDirectory[idx][1]);
+
+	a->DataDirectory[idx].Size = size;
+
+	if (size)
+	  a->DataDirectory[idx].VirtualAddress =
+	    H_GET_32 (abfd, src->DataDirectory[idx][0]);
+	else
+	  a->DataDirectory[idx].VirtualAddress = 0;
+      }
+
+    while (idx < IMAGE_NUMBEROF_DIRECTORY_ENTRIES)
+      {
+	a->DataDirectory[idx].Size = 0;
+	a->DataDirectory[idx].VirtualAddress = 0;
+	idx ++;
+      }
+  }
+
+  if (aouthdr_int->entry)
+    {
+      aouthdr_int->entry += a->ImageBase;
+#if !defined(COFF_WITH_pep) && !defined(COFF_WITH_pex64)
+      aouthdr_int->entry &= 0xffffffff;
+#endif
+    }
+
+  if (aouthdr_int->tsize)
+    {
+      aouthdr_int->text_start += a->ImageBase;
+#if !defined(COFF_WITH_pep) && !defined(COFF_WITH_pex64)
+      aouthdr_int->text_start &= 0xffffffff;
+#endif
+    }
+
+#if !defined(COFF_WITH_pep) && !defined(COFF_WITH_pex64)
+  /* PE32+ does not have data_start member!  */
+  if (aouthdr_int->dsize)
+    {
+      aouthdr_int->data_start += a->ImageBase;
+      aouthdr_int->data_start &= 0xffffffff;
+    }
+#endif
+
+#ifdef POWERPC_LE_PE
+  /* These three fields are normally set up by ppc_relocate_section.
+     In the case of reading a file in, we can pick them up from the
+     DataDirectory.  */
+  first_thunk_address = a->DataDirectory[PE_IMPORT_ADDRESS_TABLE].VirtualAddress;
+  thunk_size = a->DataDirectory[PE_IMPORT_ADDRESS_TABLE].Size;
+  import_table_size = a->DataDirectory[PE_IMPORT_TABLE].Size;
+#endif
+}
+
+/* A support function for below.  */
+
+static void
+add_data_entry (bfd * abfd,
+		struct internal_extra_pe_aouthdr *aout,
+		int idx,
+		char *name,
+		bfd_vma base)
+{
+  asection *sec = bfd_get_section_by_name (abfd, name);
+
+  /* Add import directory information if it exists.  */
+  if ((sec != NULL)
+      && (coff_section_data (abfd, sec) != NULL)
+      && (pei_section_data (abfd, sec) != NULL))
+    {
+      /* If data directory is empty, rva also should be 0.  */
+      int size = pei_section_data (abfd, sec)->virt_size;
+      aout->DataDirectory[idx].Size = size;
+
+      if (size)
+	{
+	  aout->DataDirectory[idx].VirtualAddress =
+	    (sec->vma - base) & 0xffffffff;
+	  sec->flags |= SEC_DATA;
+	}
+    }
+}
+
+unsigned int
+_bfd_XXi_swap_aouthdr_out (bfd * abfd, void * in, void * out)
+{
+  struct internal_aouthdr *aouthdr_in = (struct internal_aouthdr *) in;
+  pe_data_type *pe = pe_data (abfd);
+  struct internal_extra_pe_aouthdr *extra = &pe->pe_opthdr;
+  PEAOUTHDR *aouthdr_out = (PEAOUTHDR *) out;
+  bfd_vma sa, fa, ib;
+  IMAGE_DATA_DIRECTORY idata2, idata5, tls;
+
+  sa = extra->SectionAlignment;
+  fa = extra->FileAlignment;
+  ib = extra->ImageBase;
+
+  idata2 = pe->pe_opthdr.DataDirectory[PE_IMPORT_TABLE];
+  idata5 = pe->pe_opthdr.DataDirectory[PE_IMPORT_ADDRESS_TABLE];
+  tls = pe->pe_opthdr.DataDirectory[PE_TLS_TABLE];
+
+  if (aouthdr_in->tsize)
+    {
+      aouthdr_in->text_start -= ib;
+#if !defined(COFF_WITH_pep) && !defined(COFF_WITH_pex64)
+      aouthdr_in->text_start &= 0xffffffff;
+#endif
+    }
+
+  if (aouthdr_in->dsize)
+    {
+      aouthdr_in->data_start -= ib;
+#if !defined(COFF_WITH_pep) && !defined(COFF_WITH_pex64)
+      aouthdr_in->data_start &= 0xffffffff;
+#endif
+    }
+
+  if (aouthdr_in->entry)
+    {
+      aouthdr_in->entry -= ib;
+#if !defined(COFF_WITH_pep) && !defined(COFF_WITH_pex64)
+      aouthdr_in->entry &= 0xffffffff;
+#endif
+    }
+
+#define FA(x) (((x) + fa -1 ) & (- fa))
+#define SA(x) (((x) + sa -1 ) & (- sa))
+
+  /* We like to have the sizes aligned.  */
+  aouthdr_in->bsize = FA (aouthdr_in->bsize);
+
+  extra->NumberOfRvaAndSizes = IMAGE_NUMBEROF_DIRECTORY_ENTRIES;
+
+  add_data_entry (abfd, extra, 0, ".edata", ib);
+  add_data_entry (abfd, extra, 2, ".rsrc", ib);
+  add_data_entry (abfd, extra, 3, ".pdata", ib);
+
+  /* In theory we do not need to call add_data_entry for .idata$2 or
+     .idata$5.  It will be done in bfd_coff_final_link where all the
+     required information is available.  If however, we are not going
+     to perform a final link, eg because we have been invoked by objcopy
+     or strip, then we need to make sure that these Data Directory
+     entries are initialised properly.
+
+     So - we copy the input values into the output values, and then, if
+     a final link is going to be performed, it can overwrite them.  */
+  extra->DataDirectory[PE_IMPORT_TABLE]  = idata2;
+  extra->DataDirectory[PE_IMPORT_ADDRESS_TABLE] = idata5;
+  extra->DataDirectory[PE_TLS_TABLE] = tls;
+
+  if (extra->DataDirectory[PE_IMPORT_TABLE].VirtualAddress == 0)
+    /* Until other .idata fixes are made (pending patch), the entry for
+       .idata is needed for backwards compatibility.  FIXME.  */
+    add_data_entry (abfd, extra, 1, ".idata", ib);
+
+  /* For some reason, the virtual size (which is what's set by
+     add_data_entry) for .reloc is not the same as the size recorded
+     in this slot by MSVC; it doesn't seem to cause problems (so far),
+     but since it's the best we've got, use it.  It does do the right
+     thing for .pdata.  */
+  if (pe->has_reloc_section)
+    add_data_entry (abfd, extra, 5, ".reloc", ib);
+
+  {
+    asection *sec;
+    bfd_vma hsize = 0;
+    bfd_vma dsize = 0;
+    bfd_vma isize = 0;
+    bfd_vma tsize = 0;
+
+    for (sec = abfd->sections; sec; sec = sec->next)
+      {
+	int rounded = FA (sec->size);
+
+	/* The first non-zero section filepos is the header size.
+	   Sections without contents will have a filepos of 0.  */
+	if (hsize == 0)
+	  hsize = sec->filepos;
+	if (sec->flags & SEC_DATA)
+	  dsize += rounded;
+	if (sec->flags & SEC_CODE)
+	  tsize += rounded;
+	/* The image size is the total VIRTUAL size (which is what is
+	   in the virt_size field).  Files have been seen (from MSVC
+	   5.0 link.exe) where the file size of the .data segment is
+	   quite small compared to the virtual size.  Without this
+	   fix, strip munges the file.
+
+	   FIXME: We need to handle holes between sections, which may
+	   happpen when we covert from another format.  We just use
+	   the virtual address and virtual size of the last section
+	   for the image size.  */
+	if (coff_section_data (abfd, sec) != NULL
+	    && pei_section_data (abfd, sec) != NULL)
+	  isize = (sec->vma - extra->ImageBase
+		   + SA (FA (pei_section_data (abfd, sec)->virt_size)));
+      }
+
+    aouthdr_in->dsize = dsize;
+    aouthdr_in->tsize = tsize;
+    extra->SizeOfHeaders = hsize;
+    extra->SizeOfImage = isize;
+  }
+
+  H_PUT_16 (abfd, aouthdr_in->magic, aouthdr_out->standard.magic);
+
+/* e.g. 219510000 is linker version 2.19  */
+#define LINKER_VERSION ((short) (BFD_VERSION / 1000000))
+
+  /* This piece of magic sets the "linker version" field to
+     LINKER_VERSION.  */
+  H_PUT_16 (abfd, (LINKER_VERSION / 100 + (LINKER_VERSION % 100) * 256),
+	    aouthdr_out->standard.vstamp);
+
+  PUT_AOUTHDR_TSIZE (abfd, aouthdr_in->tsize, aouthdr_out->standard.tsize);
+  PUT_AOUTHDR_DSIZE (abfd, aouthdr_in->dsize, aouthdr_out->standard.dsize);
+  PUT_AOUTHDR_BSIZE (abfd, aouthdr_in->bsize, aouthdr_out->standard.bsize);
+  PUT_AOUTHDR_ENTRY (abfd, aouthdr_in->entry, aouthdr_out->standard.entry);
+  PUT_AOUTHDR_TEXT_START (abfd, aouthdr_in->text_start,
+			  aouthdr_out->standard.text_start);
+
+#if !defined(COFF_WITH_pep) && !defined(COFF_WITH_pex64)
+  /* PE32+ does not have data_start member!  */
+  PUT_AOUTHDR_DATA_START (abfd, aouthdr_in->data_start,
+			  aouthdr_out->standard.data_start);
+#endif
+
+  PUT_OPTHDR_IMAGE_BASE (abfd, extra->ImageBase, aouthdr_out->ImageBase);
+  H_PUT_32 (abfd, extra->SectionAlignment, aouthdr_out->SectionAlignment);
+  H_PUT_32 (abfd, extra->FileAlignment, aouthdr_out->FileAlignment);
+  H_PUT_16 (abfd, extra->MajorOperatingSystemVersion,
+	    aouthdr_out->MajorOperatingSystemVersion);
+  H_PUT_16 (abfd, extra->MinorOperatingSystemVersion,
+	    aouthdr_out->MinorOperatingSystemVersion);
+  H_PUT_16 (abfd, extra->MajorImageVersion, aouthdr_out->MajorImageVersion);
+  H_PUT_16 (abfd, extra->MinorImageVersion, aouthdr_out->MinorImageVersion);
+  H_PUT_16 (abfd, extra->MajorSubsystemVersion,
+	    aouthdr_out->MajorSubsystemVersion);
+  H_PUT_16 (abfd, extra->MinorSubsystemVersion,
+	    aouthdr_out->MinorSubsystemVersion);
+  H_PUT_32 (abfd, extra->Reserved1, aouthdr_out->Reserved1);
+  H_PUT_32 (abfd, extra->SizeOfImage, aouthdr_out->SizeOfImage);
+  H_PUT_32 (abfd, extra->SizeOfHeaders, aouthdr_out->SizeOfHeaders);
+  H_PUT_32 (abfd, extra->CheckSum, aouthdr_out->CheckSum);
+  H_PUT_16 (abfd, extra->Subsystem, aouthdr_out->Subsystem);
+  H_PUT_16 (abfd, extra->DllCharacteristics, aouthdr_out->DllCharacteristics);
+  PUT_OPTHDR_SIZE_OF_STACK_RESERVE (abfd, extra->SizeOfStackReserve,
+				    aouthdr_out->SizeOfStackReserve);
+  PUT_OPTHDR_SIZE_OF_STACK_COMMIT (abfd, extra->SizeOfStackCommit,
+				   aouthdr_out->SizeOfStackCommit);
+  PUT_OPTHDR_SIZE_OF_HEAP_RESERVE (abfd, extra->SizeOfHeapReserve,
+				   aouthdr_out->SizeOfHeapReserve);
+  PUT_OPTHDR_SIZE_OF_HEAP_COMMIT (abfd, extra->SizeOfHeapCommit,
+				  aouthdr_out->SizeOfHeapCommit);
+  H_PUT_32 (abfd, extra->LoaderFlags, aouthdr_out->LoaderFlags);
+  H_PUT_32 (abfd, extra->NumberOfRvaAndSizes,
+	    aouthdr_out->NumberOfRvaAndSizes);
+  {
+    int idx;
+
+    for (idx = 0; idx < IMAGE_NUMBEROF_DIRECTORY_ENTRIES; idx++)
+      {
+	H_PUT_32 (abfd, extra->DataDirectory[idx].VirtualAddress,
+		  aouthdr_out->DataDirectory[idx][0]);
+	H_PUT_32 (abfd, extra->DataDirectory[idx].Size,
+		  aouthdr_out->DataDirectory[idx][1]);
+      }
+  }
+
+  return AOUTSZ;
+}
+
+unsigned int
+_bfd_XXi_only_swap_filehdr_out (bfd * abfd, void * in, void * out)
+{
+  int idx;
+  struct internal_filehdr *filehdr_in = (struct internal_filehdr *) in;
+  struct external_PEI_filehdr *filehdr_out = (struct external_PEI_filehdr *) out;
+
+  if (pe_data (abfd)->has_reloc_section
+      || pe_data (abfd)->dont_strip_reloc)
+    filehdr_in->f_flags &= ~F_RELFLG;
+
+  if (pe_data (abfd)->dll)
+    filehdr_in->f_flags |= F_DLL;
+
+  filehdr_in->pe.e_magic    = DOSMAGIC;
+  filehdr_in->pe.e_cblp     = 0x90;
+  filehdr_in->pe.e_cp       = 0x3;
+  filehdr_in->pe.e_crlc     = 0x0;
+  filehdr_in->pe.e_cparhdr  = 0x4;
+  filehdr_in->pe.e_minalloc = 0x0;
+  filehdr_in->pe.e_maxalloc = 0xffff;
+  filehdr_in->pe.e_ss       = 0x0;
+  filehdr_in->pe.e_sp       = 0xb8;
+  filehdr_in->pe.e_csum     = 0x0;
+  filehdr_in->pe.e_ip       = 0x0;
+  filehdr_in->pe.e_cs       = 0x0;
+  filehdr_in->pe.e_lfarlc   = 0x40;
+  filehdr_in->pe.e_ovno     = 0x0;
+
+  for (idx = 0; idx < 4; idx++)
+    filehdr_in->pe.e_res[idx] = 0x0;
+
+  filehdr_in->pe.e_oemid   = 0x0;
+  filehdr_in->pe.e_oeminfo = 0x0;
+
+  for (idx = 0; idx < 10; idx++)
+    filehdr_in->pe.e_res2[idx] = 0x0;
+
+  filehdr_in->pe.e_lfanew = 0x80;
+
+  /* This next collection of data are mostly just characters.  It
+     appears to be constant within the headers put on NT exes.  */
+  filehdr_in->pe.dos_message[0]  = 0x0eba1f0e;
+  filehdr_in->pe.dos_message[1]  = 0xcd09b400;
+  filehdr_in->pe.dos_message[2]  = 0x4c01b821;
+  filehdr_in->pe.dos_message[3]  = 0x685421cd;
+  filehdr_in->pe.dos_message[4]  = 0x70207369;
+  filehdr_in->pe.dos_message[5]  = 0x72676f72;
+  filehdr_in->pe.dos_message[6]  = 0x63206d61;
+  filehdr_in->pe.dos_message[7]  = 0x6f6e6e61;
+  filehdr_in->pe.dos_message[8]  = 0x65622074;
+  filehdr_in->pe.dos_message[9]  = 0x6e757220;
+  filehdr_in->pe.dos_message[10] = 0x206e6920;
+  filehdr_in->pe.dos_message[11] = 0x20534f44;
+  filehdr_in->pe.dos_message[12] = 0x65646f6d;
+  filehdr_in->pe.dos_message[13] = 0x0a0d0d2e;
+  filehdr_in->pe.dos_message[14] = 0x24;
+  filehdr_in->pe.dos_message[15] = 0x0;
+  filehdr_in->pe.nt_signature = NT_SIGNATURE;
+
+  H_PUT_16 (abfd, filehdr_in->f_magic, filehdr_out->f_magic);
+  H_PUT_16 (abfd, filehdr_in->f_nscns, filehdr_out->f_nscns);
+
+  /* Only use a real timestamp if the option was chosen.  */
+  if ((pe_data (abfd)->insert_timestamp))
+    H_PUT_32 (abfd, time (0), filehdr_out->f_timdat);
+
+  PUT_FILEHDR_SYMPTR (abfd, filehdr_in->f_symptr,
+		      filehdr_out->f_symptr);
+  H_PUT_32 (abfd, filehdr_in->f_nsyms, filehdr_out->f_nsyms);
+  H_PUT_16 (abfd, filehdr_in->f_opthdr, filehdr_out->f_opthdr);
+  H_PUT_16 (abfd, filehdr_in->f_flags, filehdr_out->f_flags);
+
+  /* Put in extra dos header stuff.  This data remains essentially
+     constant, it just has to be tacked on to the beginning of all exes
+     for NT.  */
+  H_PUT_16 (abfd, filehdr_in->pe.e_magic, filehdr_out->e_magic);
+  H_PUT_16 (abfd, filehdr_in->pe.e_cblp, filehdr_out->e_cblp);
+  H_PUT_16 (abfd, filehdr_in->pe.e_cp, filehdr_out->e_cp);
+  H_PUT_16 (abfd, filehdr_in->pe.e_crlc, filehdr_out->e_crlc);
+  H_PUT_16 (abfd, filehdr_in->pe.e_cparhdr, filehdr_out->e_cparhdr);
+  H_PUT_16 (abfd, filehdr_in->pe.e_minalloc, filehdr_out->e_minalloc);
+  H_PUT_16 (abfd, filehdr_in->pe.e_maxalloc, filehdr_out->e_maxalloc);
+  H_PUT_16 (abfd, filehdr_in->pe.e_ss, filehdr_out->e_ss);
+  H_PUT_16 (abfd, filehdr_in->pe.e_sp, filehdr_out->e_sp);
+  H_PUT_16 (abfd, filehdr_in->pe.e_csum, filehdr_out->e_csum);
+  H_PUT_16 (abfd, filehdr_in->pe.e_ip, filehdr_out->e_ip);
+  H_PUT_16 (abfd, filehdr_in->pe.e_cs, filehdr_out->e_cs);
+  H_PUT_16 (abfd, filehdr_in->pe.e_lfarlc, filehdr_out->e_lfarlc);
+  H_PUT_16 (abfd, filehdr_in->pe.e_ovno, filehdr_out->e_ovno);
+
+  for (idx = 0; idx < 4; idx++)
+    H_PUT_16 (abfd, filehdr_in->pe.e_res[idx], filehdr_out->e_res[idx]);
+
+  H_PUT_16 (abfd, filehdr_in->pe.e_oemid, filehdr_out->e_oemid);
+  H_PUT_16 (abfd, filehdr_in->pe.e_oeminfo, filehdr_out->e_oeminfo);
+
+  for (idx = 0; idx < 10; idx++)
+    H_PUT_16 (abfd, filehdr_in->pe.e_res2[idx], filehdr_out->e_res2[idx]);
+
+  H_PUT_32 (abfd, filehdr_in->pe.e_lfanew, filehdr_out->e_lfanew);
+
+  for (idx = 0; idx < 16; idx++)
+    H_PUT_32 (abfd, filehdr_in->pe.dos_message[idx],
+	      filehdr_out->dos_message[idx]);
+
+  /* Also put in the NT signature.  */
+  H_PUT_32 (abfd, filehdr_in->pe.nt_signature, filehdr_out->nt_signature);
+
+  return FILHSZ;
+}
+
+unsigned int
+_bfd_XX_only_swap_filehdr_out (bfd * abfd, void * in, void * out)
+{
+  struct internal_filehdr *filehdr_in = (struct internal_filehdr *) in;
+  FILHDR *filehdr_out = (FILHDR *) out;
+
+  H_PUT_16 (abfd, filehdr_in->f_magic, filehdr_out->f_magic);
+  H_PUT_16 (abfd, filehdr_in->f_nscns, filehdr_out->f_nscns);
+  H_PUT_32 (abfd, filehdr_in->f_timdat, filehdr_out->f_timdat);
+  PUT_FILEHDR_SYMPTR (abfd, filehdr_in->f_symptr, filehdr_out->f_symptr);
+  H_PUT_32 (abfd, filehdr_in->f_nsyms, filehdr_out->f_nsyms);
+  H_PUT_16 (abfd, filehdr_in->f_opthdr, filehdr_out->f_opthdr);
+  H_PUT_16 (abfd, filehdr_in->f_flags, filehdr_out->f_flags);
+
+  return FILHSZ;
+}
+
+unsigned int
+_bfd_XXi_swap_scnhdr_out (bfd * abfd, void * in, void * out)
+{
+  struct internal_scnhdr *scnhdr_int = (struct internal_scnhdr *) in;
+  SCNHDR *scnhdr_ext = (SCNHDR *) out;
+  unsigned int ret = SCNHSZ;
+  bfd_vma ps;
+  bfd_vma ss;
+
+  memcpy (scnhdr_ext->s_name, scnhdr_int->s_name, sizeof (scnhdr_int->s_name));
+
+  PUT_SCNHDR_VADDR (abfd,
+		    ((scnhdr_int->s_vaddr
+		      - pe_data (abfd)->pe_opthdr.ImageBase)
+		     & 0xffffffff),
+		    scnhdr_ext->s_vaddr);
+
+  /* NT wants the size data to be rounded up to the next
+     NT_FILE_ALIGNMENT, but zero if it has no content (as in .bss,
+     sometimes).  */
+  if ((scnhdr_int->s_flags & IMAGE_SCN_CNT_UNINITIALIZED_DATA) != 0)
+    {
+      if (bfd_pei_p (abfd))
+	{
+	  ps = scnhdr_int->s_size;
+	  ss = 0;
+	}
+      else
+       {
+         ps = 0;
+         ss = scnhdr_int->s_size;
+       }
+    }
+  else
+    {
+      if (bfd_pei_p (abfd))
+	ps = scnhdr_int->s_paddr;
+      else
+	ps = 0;
+
+      ss = scnhdr_int->s_size;
+    }
+
+  PUT_SCNHDR_SIZE (abfd, ss,
+		   scnhdr_ext->s_size);
+
+  /* s_paddr in PE is really the virtual size.  */
+  PUT_SCNHDR_PADDR (abfd, ps, scnhdr_ext->s_paddr);
+
+  PUT_SCNHDR_SCNPTR (abfd, scnhdr_int->s_scnptr,
+		     scnhdr_ext->s_scnptr);
+  PUT_SCNHDR_RELPTR (abfd, scnhdr_int->s_relptr,
+		     scnhdr_ext->s_relptr);
+  PUT_SCNHDR_LNNOPTR (abfd, scnhdr_int->s_lnnoptr,
+		      scnhdr_ext->s_lnnoptr);
+
+  {
+    /* Extra flags must be set when dealing with PE.  All sections should also
+       have the IMAGE_SCN_MEM_READ (0x40000000) flag set.  In addition, the
+       .text section must have IMAGE_SCN_MEM_EXECUTE (0x20000000) and the data
+       sections (.idata, .data, .bss, .CRT) must have IMAGE_SCN_MEM_WRITE set
+       (this is especially important when dealing with the .idata section since
+       the addresses for routines from .dlls must be overwritten).  If .reloc
+       section data is ever generated, we must add IMAGE_SCN_MEM_DISCARDABLE
+       (0x02000000).  Also, the resource data should also be read and
+       writable.  */
+
+    /* FIXME: Alignment is also encoded in this field, at least on PPC and
+       ARM-WINCE.  Although - how do we get the original alignment field
+       back ?  */
+
+    typedef struct
+    {
+      const char * 	section_name;
+      unsigned long	must_have;
+    }
+    pe_required_section_flags;
+
+    pe_required_section_flags known_sections [] =
+      {
+	{ ".arch",  IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_DISCARDABLE | IMAGE_SCN_ALIGN_8BYTES },
+	{ ".bss",   IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_UNINITIALIZED_DATA | IMAGE_SCN_MEM_WRITE },
+	{ ".data",  IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_WRITE },
+	{ ".edata", IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA },
+	{ ".idata", IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_WRITE },
+	{ ".pdata", IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA },
+	{ ".rdata", IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA },
+	{ ".reloc", IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_DISCARDABLE },
+	{ ".rsrc",  IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_WRITE },
+	{ ".text" , IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE },
+	{ ".tls",   IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_WRITE },
+	{ ".xdata", IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA },
+	{ NULL, 0}
+      };
+
+    pe_required_section_flags * p;
+
+    /* We have defaulted to adding the IMAGE_SCN_MEM_WRITE flag, but now
+       we know exactly what this specific section wants so we remove it
+       and then allow the must_have field to add it back in if necessary.
+       However, we don't remove IMAGE_SCN_MEM_WRITE flag from .text if the
+       default WP_TEXT file flag has been cleared.  WP_TEXT may be cleared
+       by ld --enable-auto-import (if auto-import is actually needed),
+       by ld --omagic, or by obcopy --writable-text.  */
+
+    for (p = known_sections; p->section_name; p++)
+      if (strcmp (scnhdr_int->s_name, p->section_name) == 0)
+	{
+	  if (strcmp (scnhdr_int->s_name, ".text")
+	      || (bfd_get_file_flags (abfd) & WP_TEXT))
+	    scnhdr_int->s_flags &= ~IMAGE_SCN_MEM_WRITE;
+	  scnhdr_int->s_flags |= p->must_have;
+	  break;
+	}
+
+    H_PUT_32 (abfd, scnhdr_int->s_flags, scnhdr_ext->s_flags);
+  }
+
+  if (coff_data (abfd)->link_info
+      && ! bfd_link_relocatable (coff_data (abfd)->link_info)
+      && ! bfd_link_pic (coff_data (abfd)->link_info)
+      && strcmp (scnhdr_int->s_name, ".text") == 0)
+    {
+      /* By inference from looking at MS output, the 32 bit field
+	 which is the combination of the number_of_relocs and
+	 number_of_linenos is used for the line number count in
+	 executables.  A 16-bit field won't do for cc1.  The MS
+	 document says that the number of relocs is zero for
+	 executables, but the 17-th bit has been observed to be there.
+	 Overflow is not an issue: a 4G-line program will overflow a
+	 bunch of other fields long before this!  */
+      H_PUT_16 (abfd, (scnhdr_int->s_nlnno & 0xffff), scnhdr_ext->s_nlnno);
+      H_PUT_16 (abfd, (scnhdr_int->s_nlnno >> 16), scnhdr_ext->s_nreloc);
+    }
+  else
+    {
+      if (scnhdr_int->s_nlnno <= 0xffff)
+	H_PUT_16 (abfd, scnhdr_int->s_nlnno, scnhdr_ext->s_nlnno);
+      else
+	{
+	  (*_bfd_error_handler) (_("%s: line number overflow: 0x%lx > 0xffff"),
+				 bfd_get_filename (abfd),
+				 scnhdr_int->s_nlnno);
+	  bfd_set_error (bfd_error_file_truncated);
+	  H_PUT_16 (abfd, 0xffff, scnhdr_ext->s_nlnno);
+	  ret = 0;
+	}
+
+      /* Although we could encode 0xffff relocs here, we do not, to be
+         consistent with other parts of bfd. Also it lets us warn, as
+         we should never see 0xffff here w/o having the overflow flag
+         set.  */
+      if (scnhdr_int->s_nreloc < 0xffff)
+	H_PUT_16 (abfd, scnhdr_int->s_nreloc, scnhdr_ext->s_nreloc);
+      else
+	{
+	  /* PE can deal with large #s of relocs, but not here.  */
+	  H_PUT_16 (abfd, 0xffff, scnhdr_ext->s_nreloc);
+	  scnhdr_int->s_flags |= IMAGE_SCN_LNK_NRELOC_OVFL;
+	  H_PUT_32 (abfd, scnhdr_int->s_flags, scnhdr_ext->s_flags);
+	}
+    }
+  return ret;
+}
+
+void
+_bfd_XXi_swap_debugdir_in (bfd * abfd, void * ext1, void * in1)
+{
+  struct external_IMAGE_DEBUG_DIRECTORY *ext = (struct external_IMAGE_DEBUG_DIRECTORY *) ext1;
+  struct internal_IMAGE_DEBUG_DIRECTORY *in = (struct internal_IMAGE_DEBUG_DIRECTORY *) in1;
+
+  in->Characteristics = H_GET_32(abfd, ext->Characteristics);
+  in->TimeDateStamp = H_GET_32(abfd, ext->TimeDateStamp);
+  in->MajorVersion = H_GET_16(abfd, ext->MajorVersion);
+  in->MinorVersion = H_GET_16(abfd, ext->MinorVersion);
+  in->Type = H_GET_32(abfd, ext->Type);
+  in->SizeOfData = H_GET_32(abfd, ext->SizeOfData);
+  in->AddressOfRawData = H_GET_32(abfd, ext->AddressOfRawData);
+  in->PointerToRawData = H_GET_32(abfd, ext->PointerToRawData);
+}
+
+unsigned int
+_bfd_XXi_swap_debugdir_out (bfd * abfd, void * inp, void * extp)
+{
+  struct external_IMAGE_DEBUG_DIRECTORY *ext = (struct external_IMAGE_DEBUG_DIRECTORY *) extp;
+  struct internal_IMAGE_DEBUG_DIRECTORY *in = (struct internal_IMAGE_DEBUG_DIRECTORY *) inp;
+
+  H_PUT_32(abfd, in->Characteristics, ext->Characteristics);
+  H_PUT_32(abfd, in->TimeDateStamp, ext->TimeDateStamp);
+  H_PUT_16(abfd, in->MajorVersion, ext->MajorVersion);
+  H_PUT_16(abfd, in->MinorVersion, ext->MinorVersion);
+  H_PUT_32(abfd, in->Type, ext->Type);
+  H_PUT_32(abfd, in->SizeOfData, ext->SizeOfData);
+  H_PUT_32(abfd, in->AddressOfRawData, ext->AddressOfRawData);
+  H_PUT_32(abfd, in->PointerToRawData, ext->PointerToRawData);
+
+  return sizeof (struct external_IMAGE_DEBUG_DIRECTORY);
+}
+
+CODEVIEW_INFO *
+_bfd_XXi_slurp_codeview_record (bfd * abfd, file_ptr where, unsigned long length, CODEVIEW_INFO *cvinfo)
+{
+  char buffer[256+1];
+
+  if (bfd_seek (abfd, where, SEEK_SET) != 0)
+    return NULL;
+
+  if (bfd_bread (buffer, 256, abfd) < 4)
+    return NULL;
+
+  /* Ensure null termination of filename.  */
+  buffer[256] = '\0';
+
+  cvinfo->CVSignature = H_GET_32 (abfd, buffer);
+  cvinfo->Age = 0;
+
+  if ((cvinfo->CVSignature == CVINFO_PDB70_CVSIGNATURE)
+      && (length > sizeof (CV_INFO_PDB70)))
+    {
+      CV_INFO_PDB70 *cvinfo70 = (CV_INFO_PDB70 *)(buffer);
+
+      cvinfo->Age = H_GET_32(abfd, cvinfo70->Age);
+
+      /* A GUID consists of 4,2,2 byte values in little-endian order, followed
+         by 8 single bytes.  Byte swap them so we can conveniently treat the GUID
+         as 16 bytes in big-endian order.  */
+      bfd_putb32 (bfd_getl32 (cvinfo70->Signature), cvinfo->Signature);
+      bfd_putb16 (bfd_getl16 (&(cvinfo70->Signature[4])), &(cvinfo->Signature[4]));
+      bfd_putb16 (bfd_getl16 (&(cvinfo70->Signature[6])), &(cvinfo->Signature[6]));
+      memcpy (&(cvinfo->Signature[8]), &(cvinfo70->Signature[8]), 8);
+
+      cvinfo->SignatureLength = CV_INFO_SIGNATURE_LENGTH;
+      // cvinfo->PdbFileName = cvinfo70->PdbFileName;
+
+      return cvinfo;
+    }
+  else if ((cvinfo->CVSignature == CVINFO_PDB20_CVSIGNATURE)
+           && (length > sizeof (CV_INFO_PDB20)))
+    {
+      CV_INFO_PDB20 *cvinfo20 = (CV_INFO_PDB20 *)(buffer);
+      cvinfo->Age = H_GET_32(abfd, cvinfo20->Age);
+      memcpy (cvinfo->Signature, cvinfo20->Signature, 4);
+      cvinfo->SignatureLength = 4;
+      // cvinfo->PdbFileName = cvinfo20->PdbFileName;
+
+      return cvinfo;
+    }
+
+  return NULL;
+}
+
+unsigned int
+_bfd_XXi_write_codeview_record (bfd * abfd, file_ptr where, CODEVIEW_INFO *cvinfo)
+{
+  unsigned int size = sizeof (CV_INFO_PDB70) + 1;
+  CV_INFO_PDB70 *cvinfo70;
+  char buffer[size];
+
+  if (bfd_seek (abfd, where, SEEK_SET) != 0)
+    return 0;
+
+  cvinfo70 = (CV_INFO_PDB70 *) buffer;
+  H_PUT_32 (abfd, CVINFO_PDB70_CVSIGNATURE, cvinfo70->CvSignature);
+
+  /* Byte swap the GUID from 16 bytes in big-endian order to 4,2,2 byte values
+     in little-endian order, followed by 8 single bytes.  */
+  bfd_putl32 (bfd_getb32 (cvinfo->Signature), cvinfo70->Signature);
+  bfd_putl16 (bfd_getb16 (&(cvinfo->Signature[4])), &(cvinfo70->Signature[4]));
+  bfd_putl16 (bfd_getb16 (&(cvinfo->Signature[6])), &(cvinfo70->Signature[6]));
+  memcpy (&(cvinfo70->Signature[8]), &(cvinfo->Signature[8]), 8);
+
+  H_PUT_32 (abfd, cvinfo->Age, cvinfo70->Age);
+  cvinfo70->PdbFileName[0] = '\0';
+
+  if (bfd_bwrite (buffer, size, abfd) != size)
+    return 0;
+
+  return size;
+}
+
+static char * dir_names[IMAGE_NUMBEROF_DIRECTORY_ENTRIES] =
+{
+  N_("Export Directory [.edata (or where ever we found it)]"),
+  N_("Import Directory [parts of .idata]"),
+  N_("Resource Directory [.rsrc]"),
+  N_("Exception Directory [.pdata]"),
+  N_("Security Directory"),
+  N_("Base Relocation Directory [.reloc]"),
+  N_("Debug Directory"),
+  N_("Description Directory"),
+  N_("Special Directory"),
+  N_("Thread Storage Directory [.tls]"),
+  N_("Load Configuration Directory"),
+  N_("Bound Import Directory"),
+  N_("Import Address Table Directory"),
+  N_("Delay Import Directory"),
+  N_("CLR Runtime Header"),
+  N_("Reserved")
+};
+
+#ifdef POWERPC_LE_PE
+/* The code for the PPC really falls in the "architecture dependent"
+   category.  However, it's not clear that anyone will ever care, so
+   we're ignoring the issue for now; if/when PPC matters, some of this
+   may need to go into peicode.h, or arguments passed to enable the
+   PPC- specific code.  */
+#endif
+
+static bfd_boolean
+pe_print_idata (bfd * abfd, void * vfile)
+{
+  FILE *file = (FILE *) vfile;
+  bfd_byte *data;
+  asection *section;
+  bfd_signed_vma adj;
+
+#ifdef POWERPC_LE_PE
+  asection *rel_section = bfd_get_section_by_name (abfd, ".reldata");
+#endif
+
+  bfd_size_type datasize = 0;
+  bfd_size_type dataoff;
+  bfd_size_type i;
+  int onaline = 20;
+
+  pe_data_type *pe = pe_data (abfd);
+  struct internal_extra_pe_aouthdr *extra = &pe->pe_opthdr;
+
+  bfd_vma addr;
+
+  addr = extra->DataDirectory[PE_IMPORT_TABLE].VirtualAddress;
+
+  if (addr == 0 && extra->DataDirectory[PE_IMPORT_TABLE].Size == 0)
+    {
+      /* Maybe the extra header isn't there.  Look for the section.  */
+      section = bfd_get_section_by_name (abfd, ".idata");
+      if (section == NULL)
+	return TRUE;
+
+      addr = section->vma;
+      datasize = section->size;
+      if (datasize == 0)
+	return TRUE;
+    }
+  else
+    {
+      addr += extra->ImageBase;
+      for (section = abfd->sections; section != NULL; section = section->next)
+	{
+	  datasize = section->size;
+	  if (addr >= section->vma && addr < section->vma + datasize)
+	    break;
+	}
+
+      if (section == NULL)
+	{
+	  fprintf (file,
+		   _("\nThere is an import table, but the section containing it could not be found\n"));
+	  return TRUE;
+	}
+      else if (!(section->flags & SEC_HAS_CONTENTS))
+        {
+	  fprintf (file,
+		   _("\nThere is an import table in %s, but that section has no contents\n"),
+		   section->name);
+	  return TRUE;
+        }
+    }
+
+  fprintf (file, _("\nThere is an import table in %s at 0x%lx\n"),
+	   section->name, (unsigned long) addr);
+
+  dataoff = addr - section->vma;
+
+#ifdef POWERPC_LE_PE
+  if (rel_section != 0 && rel_section->size != 0)
+    {
+      /* The toc address can be found by taking the starting address,
+	 which on the PPC locates a function descriptor. The
+	 descriptor consists of the function code starting address
+	 followed by the address of the toc. The starting address we
+	 get from the bfd, and the descriptor is supposed to be in the
+	 .reldata section.  */
+
+      bfd_vma loadable_toc_address;
+      bfd_vma toc_address;
+      bfd_vma start_address;
+      bfd_byte *data;
+      bfd_vma offset;
+
+      if (!bfd_malloc_and_get_section (abfd, rel_section, &data))
+	{
+	  if (data != NULL)
+	    free (data);
+	  return FALSE;
+	}
+
+      offset = abfd->start_address - rel_section->vma;
+
+      if (offset >= rel_section->size || offset + 8 > rel_section->size)
+        {
+          if (data != NULL)
+            free (data);
+          return FALSE;
+        }
+
+      start_address = bfd_get_32 (abfd, data + offset);
+      loadable_toc_address = bfd_get_32 (abfd, data + offset + 4);
+      toc_address = loadable_toc_address - 32768;
+
+      fprintf (file,
+	       _("\nFunction descriptor located at the start address: %04lx\n"),
+	       (unsigned long int) (abfd->start_address));
+      fprintf (file,
+	       _("\tcode-base %08lx toc (loadable/actual) %08lx/%08lx\n"),
+	       start_address, loadable_toc_address, toc_address);
+      if (data != NULL)
+	free (data);
+    }
+  else
+    {
+      fprintf (file,
+	       _("\nNo reldata section! Function descriptor not decoded.\n"));
+    }
+#endif
+
+  fprintf (file,
+	   _("\nThe Import Tables (interpreted %s section contents)\n"),
+	   section->name);
+  fprintf (file,
+	   _("\
+ vma:            Hint    Time      Forward  DLL       First\n\
+                 Table   Stamp     Chain    Name      Thunk\n"));
+
+  /* Read the whole section.  Some of the fields might be before dataoff.  */
+  if (!bfd_malloc_and_get_section (abfd, section, &data))
+    {
+      if (data != NULL)
+	free (data);
+      return FALSE;
+    }
+
+  adj = section->vma - extra->ImageBase;
+
+  /* Print all image import descriptors.  */
+  for (i = dataoff; i + onaline <= datasize; i += onaline)
+    {
+      bfd_vma hint_addr;
+      bfd_vma time_stamp;
+      bfd_vma forward_chain;
+      bfd_vma dll_name;
+      bfd_vma first_thunk;
+      int idx = 0;
+      bfd_size_type j;
+      char *dll;
+
+      /* Print (i + extra->DataDirectory[PE_IMPORT_TABLE].VirtualAddress).  */
+      fprintf (file, " %08lx\t", (unsigned long) (i + adj));
+      hint_addr = bfd_get_32 (abfd, data + i);
+      time_stamp = bfd_get_32 (abfd, data + i + 4);
+      forward_chain = bfd_get_32 (abfd, data + i + 8);
+      dll_name = bfd_get_32 (abfd, data + i + 12);
+      first_thunk = bfd_get_32 (abfd, data + i + 16);
+
+      fprintf (file, "%08lx %08lx %08lx %08lx %08lx\n",
+	       (unsigned long) hint_addr,
+	       (unsigned long) time_stamp,
+	       (unsigned long) forward_chain,
+	       (unsigned long) dll_name,
+	       (unsigned long) first_thunk);
+
+      if (hint_addr == 0 && first_thunk == 0)
+	break;
+
+      if (dll_name - adj >= section->size)
+        break;
+
+      dll = (char *) data + dll_name - adj;
+      /* PR 17512 file: 078-12277-0.004.  */
+      bfd_size_type maxlen = (char *)(data + datasize) - dll - 1;
+      fprintf (file, _("\n\tDLL Name: %.*s\n"), (int) maxlen, dll);
+
+      if (hint_addr != 0)
+	{
+	  bfd_byte *ft_data;
+	  asection *ft_section;
+	  bfd_vma ft_addr;
+	  bfd_size_type ft_datasize;
+	  int ft_idx;
+	  int ft_allocated;
+
+	  fprintf (file, _("\tvma:  Hint/Ord Member-Name Bound-To\n"));
+
+	  idx = hint_addr - adj;
+
+	  ft_addr = first_thunk + extra->ImageBase;
+	  ft_idx = first_thunk - adj;
+	  ft_data = data + ft_idx;
+	  ft_datasize = datasize - ft_idx;
+	  ft_allocated = 0;
+
+	  if (first_thunk != hint_addr)
+	    {
+	      /* Find the section which contains the first thunk.  */
+	      for (ft_section = abfd->sections;
+		   ft_section != NULL;
+		   ft_section = ft_section->next)
+		{
+		  if (ft_addr >= ft_section->vma
+		      && ft_addr < ft_section->vma + ft_section->size)
+		    break;
+		}
+
+	      if (ft_section == NULL)
+		{
+		  fprintf (file,
+		       _("\nThere is a first thunk, but the section containing it could not be found\n"));
+		  continue;
+		}
+
+	      /* Now check to see if this section is the same as our current
+		 section.  If it is not then we will have to load its data in.  */
+	      if (ft_section != section)
+		{
+		  ft_idx = first_thunk - (ft_section->vma - extra->ImageBase);
+		  ft_datasize = ft_section->size - ft_idx;
+		  ft_data = (bfd_byte *) bfd_malloc (ft_datasize);
+		  if (ft_data == NULL)
+		    continue;
+
+		  /* Read ft_datasize bytes starting at offset ft_idx.  */
+		  if (!bfd_get_section_contents (abfd, ft_section, ft_data,
+						 (bfd_vma) ft_idx, ft_datasize))
+		    {
+		      free (ft_data);
+		      continue;
+		    }
+		  ft_allocated = 1;
+		}
+	    }
+
+	  /* Print HintName vector entries.  */
+#ifdef COFF_WITH_pex64
+	  for (j = 0; idx + j + 8 <= datasize; j += 8)
+	    {
+	      bfd_size_type amt;
+	      unsigned long member = bfd_get_32 (abfd, data + idx + j);
+	      unsigned long member_high = bfd_get_32 (abfd, data + idx + j + 4);
+
+	      if (!member && !member_high)
+		break;
+
+	      amt = member - adj;
+
+	      if (HighBitSet (member_high))
+		fprintf (file, "\t%lx%08lx\t %4lx%08lx  <none>",
+			 member_high, member,
+			 WithoutHighBit (member_high), member);
+	      /* PR binutils/17512: Handle corrupt PE data.  */
+	      else if (amt + 2 >= datasize)
+		fprintf (file, _("\t<corrupt: 0x%04lx>"), member);
+	      else
+		{
+		  int ordinal;
+		  char *member_name;
+
+		  ordinal = bfd_get_16 (abfd, data + amt);
+		  member_name = (char *) data + amt + 2;
+		  fprintf (file, "\t%04lx\t %4d  %.*s",member, ordinal,
+			   (int) (datasize - (amt + 2)), member_name);
+		}
+
+	      /* If the time stamp is not zero, the import address
+		 table holds actual addresses.  */
+	      if (time_stamp != 0
+		  && first_thunk != 0
+		  && first_thunk != hint_addr
+		  && j + 4 <= ft_datasize)
+		fprintf (file, "\t%04lx",
+			 (unsigned long) bfd_get_32 (abfd, ft_data + j));
+	      fprintf (file, "\n");
+	    }
+#else
+	  for (j = 0; idx + j + 4 <= datasize; j += 4)
+	    {
+	      bfd_size_type amt;
+	      unsigned long member = bfd_get_32 (abfd, data + idx + j);
+
+	      /* Print single IMAGE_IMPORT_BY_NAME vector.  */
+	      if (member == 0)
+		break;
+
+	      amt = member - adj;
+	      if (HighBitSet (member))
+		fprintf (file, "\t%04lx\t %4lu  <none>",
+			 member, WithoutHighBit (member));
+	      /* PR binutils/17512: Handle corrupt PE data.  */
+	      else if (amt + 2 >= datasize)
+		fprintf (file, _("\t<corrupt: 0x%04lx>"), member);
+	      else
+		{
+		  int ordinal;
+		  char *member_name;
+
+		  ordinal = bfd_get_16 (abfd, data + amt);
+		  member_name = (char *) data + amt + 2;
+		  fprintf (file, "\t%04lx\t %4d  %.*s",
+			   member, ordinal,
+			   (int) (datasize - (amt + 2)), member_name);
+		}
+
+	      /* If the time stamp is not zero, the import address
+		 table holds actual addresses.  */
+	      if (time_stamp != 0
+		  && first_thunk != 0
+		  && first_thunk != hint_addr
+		  && j + 4 <= ft_datasize)
+		fprintf (file, "\t%04lx",
+			 (unsigned long) bfd_get_32 (abfd, ft_data + j));
+
+	      fprintf (file, "\n");
+	    }
+#endif
+	  if (ft_allocated)
+	    free (ft_data);
+	}
+
+      fprintf (file, "\n");
+    }
+
+  free (data);
+
+  return TRUE;
+}
+
+static bfd_boolean
+pe_print_edata (bfd * abfd, void * vfile)
+{
+  FILE *file = (FILE *) vfile;
+  bfd_byte *data;
+  asection *section;
+  bfd_size_type datasize = 0;
+  bfd_size_type dataoff;
+  bfd_size_type i;
+  bfd_vma       adj;
+  struct EDT_type
+  {
+    long export_flags;          /* Reserved - should be zero.  */
+    long time_stamp;
+    short major_ver;
+    short minor_ver;
+    bfd_vma name;               /* RVA - relative to image base.  */
+    long base;                  /* Ordinal base.  */
+    unsigned long num_functions;/* Number in the export address table.  */
+    unsigned long num_names;    /* Number in the name pointer table.  */
+    bfd_vma eat_addr;		/* RVA to the export address table.  */
+    bfd_vma npt_addr;		/* RVA to the Export Name Pointer Table.  */
+    bfd_vma ot_addr;		/* RVA to the Ordinal Table.  */
+  } edt;
+
+  pe_data_type *pe = pe_data (abfd);
+  struct internal_extra_pe_aouthdr *extra = &pe->pe_opthdr;
+
+  bfd_vma addr;
+
+  addr = extra->DataDirectory[PE_EXPORT_TABLE].VirtualAddress;
+
+  if (addr == 0 && extra->DataDirectory[PE_EXPORT_TABLE].Size == 0)
+    {
+      /* Maybe the extra header isn't there.  Look for the section.  */
+      section = bfd_get_section_by_name (abfd, ".edata");
+      if (section == NULL)
+	return TRUE;
+
+      addr = section->vma;
+      dataoff = 0;
+      datasize = section->size;
+      if (datasize == 0)
+	return TRUE;
+    }
+  else
+    {
+      addr += extra->ImageBase;
+
+      for (section = abfd->sections; section != NULL; section = section->next)
+	if (addr >= section->vma && addr < section->vma + section->size)
+	  break;
+
+      if (section == NULL)
+	{
+	  fprintf (file,
+		   _("\nThere is an export table, but the section containing it could not be found\n"));
+	  return TRUE;
+	}
+      else if (!(section->flags & SEC_HAS_CONTENTS))
+        {
+	  fprintf (file,
+		   _("\nThere is an export table in %s, but that section has no contents\n"),
+		   section->name);
+	  return TRUE;
+        }
+
+      dataoff = addr - section->vma;
+      datasize = extra->DataDirectory[PE_EXPORT_TABLE].Size;
+      if (datasize > section->size - dataoff)
+	{
+	  fprintf (file,
+		   _("\nThere is an export table in %s, but it does not fit into that section\n"),
+		   section->name);
+	  return TRUE;
+	}
+    }
+
+  /* PR 17512: Handle corrupt PE binaries.  */
+  if (datasize < 36)
+    {
+      fprintf (file,
+	       _("\nThere is an export table in %s, but it is too small (%d)\n"),
+	       section->name, (int) datasize);
+      return TRUE;
+    }
+
+  fprintf (file, _("\nThere is an export table in %s at 0x%lx\n"),
+	   section->name, (unsigned long) addr);
+
+  data = (bfd_byte *) bfd_malloc (datasize);
+  if (data == NULL)
+    return FALSE;
+
+  if (! bfd_get_section_contents (abfd, section, data,
+				  (file_ptr) dataoff, datasize))
+    return FALSE;
+
+  /* Go get Export Directory Table.  */
+  edt.export_flags   = bfd_get_32 (abfd, data +  0);
+  edt.time_stamp     = bfd_get_32 (abfd, data +  4);
+  edt.major_ver      = bfd_get_16 (abfd, data +  8);
+  edt.minor_ver      = bfd_get_16 (abfd, data + 10);
+  edt.name           = bfd_get_32 (abfd, data + 12);
+  edt.base           = bfd_get_32 (abfd, data + 16);
+  edt.num_functions  = bfd_get_32 (abfd, data + 20);
+  edt.num_names      = bfd_get_32 (abfd, data + 24);
+  edt.eat_addr       = bfd_get_32 (abfd, data + 28);
+  edt.npt_addr       = bfd_get_32 (abfd, data + 32);
+  edt.ot_addr        = bfd_get_32 (abfd, data + 36);
+
+  adj = section->vma - extra->ImageBase + dataoff;
+
+  /* Dump the EDT first.  */
+  fprintf (file,
+	   _("\nThe Export Tables (interpreted %s section contents)\n\n"),
+	   section->name);
+
+  fprintf (file,
+	   _("Export Flags \t\t\t%lx\n"), (unsigned long) edt.export_flags);
+
+  fprintf (file,
+	   _("Time/Date stamp \t\t%lx\n"), (unsigned long) edt.time_stamp);
+
+  fprintf (file,
+	   _("Major/Minor \t\t\t%d/%d\n"), edt.major_ver, edt.minor_ver);
+
+  fprintf (file,
+	   _("Name \t\t\t\t"));
+  bfd_fprintf_vma (abfd, file, edt.name);
+
+  if ((edt.name >= adj) && (edt.name < adj + datasize))
+    fprintf (file, " %.*s\n",
+	     (int) (datasize - (edt.name - adj)),
+	     data + edt.name - adj);
+  else
+    fprintf (file, "(outside .edata section)\n");
+
+  fprintf (file,
+	   _("Ordinal Base \t\t\t%ld\n"), edt.base);
+
+  fprintf (file,
+	   _("Number in:\n"));
+
+  fprintf (file,
+	   _("\tExport Address Table \t\t%08lx\n"),
+	   edt.num_functions);
+
+  fprintf (file,
+	   _("\t[Name Pointer/Ordinal] Table\t%08lx\n"), edt.num_names);
+
+  fprintf (file,
+	   _("Table Addresses\n"));
+
+  fprintf (file,
+	   _("\tExport Address Table \t\t"));
+  bfd_fprintf_vma (abfd, file, edt.eat_addr);
+  fprintf (file, "\n");
+
+  fprintf (file,
+	   _("\tName Pointer Table \t\t"));
+  bfd_fprintf_vma (abfd, file, edt.npt_addr);
+  fprintf (file, "\n");
+
+  fprintf (file,
+	   _("\tOrdinal Table \t\t\t"));
+  bfd_fprintf_vma (abfd, file, edt.ot_addr);
+  fprintf (file, "\n");
+
+  /* The next table to find is the Export Address Table. It's basically
+     a list of pointers that either locate a function in this dll, or
+     forward the call to another dll. Something like:
+      typedef union
+      {
+        long export_rva;
+        long forwarder_rva;
+      } export_address_table_entry;  */
+
+  fprintf (file,
+	  _("\nExport Address Table -- Ordinal Base %ld\n"),
+	  edt.base);
+
+  /* PR 17512: Handle corrupt PE binaries.  */
+  if (edt.eat_addr + (edt.num_functions * 4) - adj >= datasize
+      /* PR 17512: file: 092b1829 */
+      || (edt.num_functions * 4) < edt.num_functions
+      /* PR 17512 file: 140-165018-0.004.  */
+      || data + edt.eat_addr - adj < data)
+    fprintf (file, _("\tInvalid Export Address Table rva (0x%lx) or entry count (0x%lx)\n"),
+	     (long) edt.eat_addr,
+	     (long) edt.num_functions);
+  else for (i = 0; i < edt.num_functions; ++i)
+    {
+      bfd_vma eat_member = bfd_get_32 (abfd,
+				       data + edt.eat_addr + (i * 4) - adj);
+      if (eat_member == 0)
+	continue;
+
+      if (eat_member - adj <= datasize)
+	{
+	  /* This rva is to a name (forwarding function) in our section.  */
+	  /* Should locate a function descriptor.  */
+	  fprintf (file,
+		   "\t[%4ld] +base[%4ld] %04lx %s -- %.*s\n",
+		   (long) i,
+		   (long) (i + edt.base),
+		   (unsigned long) eat_member,
+		   _("Forwarder RVA"),
+		   (int)(datasize - (eat_member - adj)),
+		   data + eat_member - adj);
+	}
+      else
+	{
+	  /* Should locate a function descriptor in the reldata section.  */
+	  fprintf (file,
+		   "\t[%4ld] +base[%4ld] %04lx %s\n",
+		   (long) i,
+		   (long) (i + edt.base),
+		   (unsigned long) eat_member,
+		   _("Export RVA"));
+	}
+    }
+
+  /* The Export Name Pointer Table is paired with the Export Ordinal Table.  */
+  /* Dump them in parallel for clarity.  */
+  fprintf (file,
+	   _("\n[Ordinal/Name Pointer] Table\n"));
+
+  /* PR 17512: Handle corrupt PE binaries.  */
+  if (edt.npt_addr + (edt.num_names * 4) - adj >= datasize
+      /* PR 17512: file: bb68816e.  */
+      || edt.num_names * 4 < edt.num_names
+      || (data + edt.npt_addr - adj) < data)
+    fprintf (file, _("\tInvalid Name Pointer Table rva (0x%lx) or entry count (0x%lx)\n"),
+	     (long) edt.npt_addr,
+	     (long) edt.num_names);
+  /* PR 17512: file: 140-147171-0.004.  */
+  else if (edt.ot_addr + (edt.num_names * 2) - adj >= datasize
+	   || data + edt.ot_addr - adj < data)
+    fprintf (file, _("\tInvalid Ordinal Table rva (0x%lx) or entry count (0x%lx)\n"),
+	     (long) edt.ot_addr,
+	     (long) edt.num_names);
+  else for (i = 0; i < edt.num_names; ++i)
+    {
+      bfd_vma  name_ptr;
+      bfd_vma  ord;
+
+      ord = bfd_get_16 (abfd, data + edt.ot_addr + (i * 2) - adj);
+      name_ptr = bfd_get_32 (abfd, data + edt.npt_addr + (i * 4) - adj);
+
+      if ((name_ptr - adj) >= datasize)
+	{
+	  fprintf (file, _("\t[%4ld] <corrupt offset: %lx>\n"),
+		   (long) ord, (long) name_ptr);
+	}
+      else
+	{
+	  char * name = (char *) data + name_ptr - adj;
+
+	  fprintf (file, "\t[%4ld] %.*s\n", (long) ord,
+		   (int)((char *)(data + datasize) - name), name);
+	}
+    }
+
+  free (data);
+
+  return TRUE;
+}
+
+/* This really is architecture dependent.  On IA-64, a .pdata entry
+   consists of three dwords containing relative virtual addresses that
+   specify the start and end address of the code range the entry
+   covers and the address of the corresponding unwind info data.
+
+   On ARM and SH-4, a compressed PDATA structure is used :
+   _IMAGE_CE_RUNTIME_FUNCTION_ENTRY, whereas MIPS is documented to use
+   _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY.
+   See http://msdn2.microsoft.com/en-us/library/ms253988(VS.80).aspx .
+
+   This is the version for uncompressed data.  */
+
+static bfd_boolean
+pe_print_pdata (bfd * abfd, void * vfile)
+{
+#if defined(COFF_WITH_pep) && !defined(COFF_WITH_pex64)
+# define PDATA_ROW_SIZE	(3 * 8)
+#else
+# define PDATA_ROW_SIZE	(5 * 4)
+#endif
+  FILE *file = (FILE *) vfile;
+  bfd_byte *data = 0;
+  asection *section = bfd_get_section_by_name (abfd, ".pdata");
+  bfd_size_type datasize = 0;
+  bfd_size_type i;
+  bfd_size_type start, stop;
+  int onaline = PDATA_ROW_SIZE;
+
+  if (section == NULL
+      || coff_section_data (abfd, section) == NULL
+      || pei_section_data (abfd, section) == NULL)
+    return TRUE;
+
+  stop = pei_section_data (abfd, section)->virt_size;
+  if ((stop % onaline) != 0)
+    fprintf (file,
+	     _("Warning, .pdata section size (%ld) is not a multiple of %d\n"),
+	     (long) stop, onaline);
+
+  fprintf (file,
+	   _("\nThe Function Table (interpreted .pdata section contents)\n"));
+#if defined(COFF_WITH_pep) && !defined(COFF_WITH_pex64)
+  fprintf (file,
+	   _(" vma:\t\t\tBegin Address    End Address      Unwind Info\n"));
+#else
+  fprintf (file, _("\
+ vma:\t\tBegin    End      EH       EH       PrologEnd  Exception\n\
+     \t\tAddress  Address  Handler  Data     Address    Mask\n"));
+#endif
+
+  datasize = section->size;
+  if (datasize == 0)
+    return TRUE;
+
+  /* PR 17512: file: 002-193900-0.004.  */
+  if (datasize < stop)
+    {
+      fprintf (file, _("Virtual size of .pdata section (%ld) larger than real size (%ld)\n"),
+	       (long) stop, (long) datasize);
+      return FALSE;
+    }
+
+  if (! bfd_malloc_and_get_section (abfd, section, &data))
+    {
+      if (data != NULL)
+	free (data);
+      return FALSE;
+    }
+
+  start = 0;
+
+  for (i = start; i < stop; i += onaline)
+    {
+      bfd_vma begin_addr;
+      bfd_vma end_addr;
+      bfd_vma eh_handler;
+      bfd_vma eh_data;
+      bfd_vma prolog_end_addr;
+#if !defined(COFF_WITH_pep) || defined(COFF_WITH_pex64)
+      int em_data;
+#endif
+
+      if (i + PDATA_ROW_SIZE > stop)
+	break;
+
+      begin_addr      = GET_PDATA_ENTRY (abfd, data + i     );
+      end_addr        = GET_PDATA_ENTRY (abfd, data + i +  4);
+      eh_handler      = GET_PDATA_ENTRY (abfd, data + i +  8);
+      eh_data         = GET_PDATA_ENTRY (abfd, data + i + 12);
+      prolog_end_addr = GET_PDATA_ENTRY (abfd, data + i + 16);
+
+      if (begin_addr == 0 && end_addr == 0 && eh_handler == 0
+	  && eh_data == 0 && prolog_end_addr == 0)
+	/* We are probably into the padding of the section now.  */
+	break;
+
+#if !defined(COFF_WITH_pep) || defined(COFF_WITH_pex64)
+      em_data = ((eh_handler & 0x1) << 2) | (prolog_end_addr & 0x3);
+#endif
+      eh_handler &= ~(bfd_vma) 0x3;
+      prolog_end_addr &= ~(bfd_vma) 0x3;
+
+      fputc (' ', file);
+      bfd_fprintf_vma (abfd, file, i + section->vma); fputc ('\t', file);
+      bfd_fprintf_vma (abfd, file, begin_addr); fputc (' ', file);
+      bfd_fprintf_vma (abfd, file, end_addr); fputc (' ', file);
+      bfd_fprintf_vma (abfd, file, eh_handler);
+#if !defined(COFF_WITH_pep) || defined(COFF_WITH_pex64)
+      fputc (' ', file);
+      bfd_fprintf_vma (abfd, file, eh_data); fputc (' ', file);
+      bfd_fprintf_vma (abfd, file, prolog_end_addr);
+      fprintf (file, "   %x", em_data);
+#endif
+
+#ifdef POWERPC_LE_PE
+      if (eh_handler == 0 && eh_data != 0)
+	{
+	  /* Special bits here, although the meaning may be a little
+	     mysterious. The only one I know for sure is 0x03
+	     Code Significance
+	     0x00 None
+	     0x01 Register Save Millicode
+	     0x02 Register Restore Millicode
+	     0x03 Glue Code Sequence.  */
+	  switch (eh_data)
+	    {
+	    case 0x01:
+	      fprintf (file, _(" Register save millicode"));
+	      break;
+	    case 0x02:
+	      fprintf (file, _(" Register restore millicode"));
+	      break;
+	    case 0x03:
+	      fprintf (file, _(" Glue code sequence"));
+	      break;
+	    default:
+	      break;
+	    }
+	}
+#endif
+      fprintf (file, "\n");
+    }
+
+  free (data);
+
+  return TRUE;
+#undef PDATA_ROW_SIZE
+}
+
+typedef struct sym_cache
+{
+  int        symcount;
+  asymbol ** syms;
+} sym_cache;
+
+static asymbol **
+slurp_symtab (bfd *abfd, sym_cache *psc)
+{
+  asymbol ** sy = NULL;
+  long storage;
+
+  if (!(bfd_get_file_flags (abfd) & HAS_SYMS))
+    {
+      psc->symcount = 0;
+      return NULL;
+    }
+
+  storage = bfd_get_symtab_upper_bound (abfd);
+  if (storage < 0)
+    return NULL;
+  if (storage)
+    {
+      sy = (asymbol **) bfd_malloc (storage);
+      if (sy == NULL)
+	return NULL;
+    }
+
+  psc->symcount = bfd_canonicalize_symtab (abfd, sy);
+  if (psc->symcount < 0)
+    return NULL;
+  return sy;
+}
+
+static const char *
+my_symbol_for_address (bfd *abfd, bfd_vma func, sym_cache *psc)
+{
+  int i;
+
+  if (psc->syms == 0)
+    psc->syms = slurp_symtab (abfd, psc);
+
+  for (i = 0; i < psc->symcount; i++)
+    {
+      if (psc->syms[i]->section->vma + psc->syms[i]->value == func)
+	return psc->syms[i]->name;
+    }
+
+  return NULL;
+}
+
+static void
+cleanup_syms (sym_cache *psc)
+{
+  psc->symcount = 0;
+  free (psc->syms);
+  psc->syms = NULL;
+}
+
+/* This is the version for "compressed" pdata.  */
+
+bfd_boolean
+_bfd_XX_print_ce_compressed_pdata (bfd * abfd, void * vfile)
+{
+# define PDATA_ROW_SIZE	(2 * 4)
+  FILE *file = (FILE *) vfile;
+  bfd_byte *data = NULL;
+  asection *section = bfd_get_section_by_name (abfd, ".pdata");
+  bfd_size_type datasize = 0;
+  bfd_size_type i;
+  bfd_size_type start, stop;
+  int onaline = PDATA_ROW_SIZE;
+  struct sym_cache cache = {0, 0} ;
+
+  if (section == NULL
+      || coff_section_data (abfd, section) == NULL
+      || pei_section_data (abfd, section) == NULL)
+    return TRUE;
+
+  stop = pei_section_data (abfd, section)->virt_size;
+  if ((stop % onaline) != 0)
+    fprintf (file,
+	     _("Warning, .pdata section size (%ld) is not a multiple of %d\n"),
+	     (long) stop, onaline);
+
+  fprintf (file,
+	   _("\nThe Function Table (interpreted .pdata section contents)\n"));
+
+  fprintf (file, _("\
+ vma:\t\tBegin    Prolog   Function Flags    Exception EH\n\
+     \t\tAddress  Length   Length   32b exc  Handler   Data\n"));
+
+  datasize = section->size;
+  if (datasize == 0)
+    return TRUE;
+
+  if (! bfd_malloc_and_get_section (abfd, section, &data))
+    {
+      if (data != NULL)
+	free (data);
+      return FALSE;
+    }
+
+  start = 0;
+
+  for (i = start; i < stop; i += onaline)
+    {
+      bfd_vma begin_addr;
+      bfd_vma other_data;
+      bfd_vma prolog_length, function_length;
+      int flag32bit, exception_flag;
+      asection *tsection;
+
+      if (i + PDATA_ROW_SIZE > stop)
+	break;
+
+      begin_addr = GET_PDATA_ENTRY (abfd, data + i     );
+      other_data = GET_PDATA_ENTRY (abfd, data + i +  4);
+
+      if (begin_addr == 0 && other_data == 0)
+	/* We are probably into the padding of the section now.  */
+	break;
+
+      prolog_length = (other_data & 0x000000FF);
+      function_length = (other_data & 0x3FFFFF00) >> 8;
+      flag32bit = (int)((other_data & 0x40000000) >> 30);
+      exception_flag = (int)((other_data & 0x80000000) >> 31);
+
+      fputc (' ', file);
+      bfd_fprintf_vma (abfd, file, i + section->vma); fputc ('\t', file);
+      bfd_fprintf_vma (abfd, file, begin_addr); fputc (' ', file);
+      bfd_fprintf_vma (abfd, file, prolog_length); fputc (' ', file);
+      bfd_fprintf_vma (abfd, file, function_length); fputc (' ', file);
+      fprintf (file, "%2d  %2d   ", flag32bit, exception_flag);
+
+      /* Get the exception handler's address and the data passed from the
+         .text section. This is really the data that belongs with the .pdata
+         but got "compressed" out for the ARM and SH4 architectures.  */
+      tsection = bfd_get_section_by_name (abfd, ".text");
+      if (tsection && coff_section_data (abfd, tsection)
+	  && pei_section_data (abfd, tsection))
+	{
+	  bfd_vma eh_off = (begin_addr - 8) - tsection->vma;
+	  bfd_byte *tdata;
+
+	  tdata = (bfd_byte *) bfd_malloc (8);
+	  if (tdata)
+	    {
+	      if (bfd_get_section_contents (abfd, tsection, tdata, eh_off, 8))
+		{
+		  bfd_vma eh, eh_data;
+
+		  eh = bfd_get_32 (abfd, tdata);
+		  eh_data = bfd_get_32 (abfd, tdata + 4);
+		  fprintf (file, "%08x  ", (unsigned int) eh);
+		  fprintf (file, "%08x", (unsigned int) eh_data);
+		  if (eh != 0)
+		    {
+		      const char *s = my_symbol_for_address (abfd, eh, &cache);
+
+		      if (s)
+			fprintf (file, " (%s) ", s);
+		    }
+		}
+	      free (tdata);
+	    }
+	}
+
+      fprintf (file, "\n");
+    }
+
+  free (data);
+
+  cleanup_syms (& cache);
+
+  return TRUE;
+#undef PDATA_ROW_SIZE
+}
+
+
+#define IMAGE_REL_BASED_HIGHADJ 4
+static const char * const tbl[] =
+{
+  "ABSOLUTE",
+  "HIGH",
+  "LOW",
+  "HIGHLOW",
+  "HIGHADJ",
+  "MIPS_JMPADDR",
+  "SECTION",
+  "REL32",
+  "RESERVED1",
+  "MIPS_JMPADDR16",
+  "DIR64",
+  "HIGH3ADJ",
+  "UNKNOWN",   /* MUST be last.  */
+};
+
+static bfd_boolean
+pe_print_reloc (bfd * abfd, void * vfile)
+{
+  FILE *file = (FILE *) vfile;
+  bfd_byte *data = 0;
+  asection *section = bfd_get_section_by_name (abfd, ".reloc");
+  bfd_byte *p, *end;
+
+  if (section == NULL || section->size == 0 || !(section->flags & SEC_HAS_CONTENTS))
+    return TRUE;
+
+  fprintf (file,
+	   _("\n\nPE File Base Relocations (interpreted .reloc section contents)\n"));
+
+  if (! bfd_malloc_and_get_section (abfd, section, &data))
+    {
+      if (data != NULL)
+	free (data);
+      return FALSE;
+    }
+
+  p = data;
+  end = data + section->size;
+  while (p + 8 <= end)
+    {
+      int j;
+      bfd_vma virtual_address;
+      unsigned long number, size;
+      bfd_byte *chunk_end;
+
+      /* The .reloc section is a sequence of blocks, with a header consisting
+	 of two 32 bit quantities, followed by a number of 16 bit entries.  */
+      virtual_address = bfd_get_32 (abfd, p);
+      size = bfd_get_32 (abfd, p + 4);
+      p += 8;
+      number = (size - 8) / 2;
+
+      if (size == 0)
+	break;
+
+      fprintf (file,
+	       _("\nVirtual Address: %08lx Chunk size %ld (0x%lx) Number of fixups %ld\n"),
+	       (unsigned long) virtual_address, size, size, number);
+
+      chunk_end = p + size;
+      if (chunk_end > end)
+	chunk_end = end;
+      j = 0;
+      while (p + 2 <= chunk_end)
+	{
+	  unsigned short e = bfd_get_16 (abfd, p);
+	  unsigned int t = (e & 0xF000) >> 12;
+	  int off = e & 0x0FFF;
+
+	  if (t >= sizeof (tbl) / sizeof (tbl[0]))
+	    t = (sizeof (tbl) / sizeof (tbl[0])) - 1;
+
+	  fprintf (file,
+		   _("\treloc %4d offset %4x [%4lx] %s"),
+		   j, off, (unsigned long) (off + virtual_address), tbl[t]);
+
+	  p += 2;
+	  j++;
+
+	  /* HIGHADJ takes an argument, - the next record *is* the
+	     low 16 bits of addend.  */
+	  if (t == IMAGE_REL_BASED_HIGHADJ && p + 2 <= chunk_end)
+	    {
+	      fprintf (file, " (%4x)", (unsigned int) bfd_get_16 (abfd, p));
+	      p += 2;
+	      j++;
+	    }
+
+	  fprintf (file, "\n");
+	}
+    }
+
+  free (data);
+
+  return TRUE;
+}
+
+/* A data structure describing the regions of a .rsrc section.
+   Some fields are filled in as the section is parsed.  */
+
+typedef struct rsrc_regions
+{
+  bfd_byte * section_start;
+  bfd_byte * section_end;
+  bfd_byte * strings_start;
+  bfd_byte * resource_start;
+} rsrc_regions;
+
+static bfd_byte *
+rsrc_print_resource_directory (FILE * , bfd *, unsigned int, bfd_byte *,
+			       rsrc_regions *, bfd_vma);
+
+/* Print the resource entry at DATA, with the text indented by INDENT.
+   Recusively calls rsrc_print_resource_directory to print the contents
+   of directory entries.
+   Returns the address of the end of the data associated with the entry
+   or section_end + 1 upon failure.  */
+
+static bfd_byte *
+rsrc_print_resource_entries (FILE *         file,
+			     bfd *          abfd,
+			     unsigned int   indent,
+			     bfd_boolean    is_name,
+			     bfd_byte *     data,
+			     rsrc_regions * regions,
+			     bfd_vma        rva_bias)
+{
+  unsigned long entry, addr, size;
+  bfd_byte * leaf;
+
+  if (data + 8 >= regions->section_end)
+    return regions->section_end + 1;
+
+  fprintf (file, _("%03x %*.s Entry: "), (int)(data - regions->section_start), indent, " ");
+
+  entry = (unsigned long) bfd_get_32 (abfd, data);
+  if (is_name)
+    {
+      bfd_byte * name;
+
+      /* Note - the documentation says that this field is an RVA value
+	 but windres appears to produce a section relative offset with
+	 the top bit set.  Support both styles for now.  */
+      if (HighBitSet (entry))
+	name = regions->section_start + WithoutHighBit (entry);
+      else
+	name = regions->section_start + entry - rva_bias;
+
+      if (name + 2 < regions->section_end && name > regions->section_start)
+	{
+	  unsigned int len;
+
+	  if (regions->strings_start == NULL)
+	    regions->strings_start = name;
+
+	  len = bfd_get_16 (abfd, name);
+
+	  fprintf (file, _("name: [val: %08lx len %d]: "), entry, len);
+
+	  if (name + 2 + len * 2 < regions->section_end)
+	    {
+	      /* This strange loop is to cope with multibyte characters.  */
+	      while (len --)
+		{
+		  char c;
+
+		  name += 2;
+		  c = * name;
+		  /* Avoid printing control characters.  */
+		  if (c > 0 && c < 32)
+		    fprintf (file, "^%c", c + 64);
+		  else
+		    fprintf (file, "%.1s", name);
+		}
+	    }
+	  else
+	    {
+	      fprintf (file, _("<corrupt string length: %#x>\n"), len);
+	      /* PR binutils/17512: Do not try to continue decoding a
+		 corrupted resource section.  It is likely to end up with
+		 reams of extraneous output.  FIXME: We could probably
+		 continue if we disable the printing of strings...  */
+	      return regions->section_end + 1;
+	    }
+	}
+      else
+	{
+	  fprintf (file, _("<corrupt string offset: %#lx>\n"), entry);
+	  return regions->section_end + 1;
+	}
+    }
+  else
+    fprintf (file, _("ID: %#08lx"), entry);
+
+  entry = (long) bfd_get_32 (abfd, data + 4);
+  fprintf (file, _(", Value: %#08lx\n"), entry);
+
+  if (HighBitSet  (entry))
+    {
+      data = regions->section_start + WithoutHighBit (entry);
+      if (data <= regions->section_start || data > regions->section_end)
+	return regions->section_end + 1;
+
+      /* FIXME: PR binutils/17512: A corrupt file could contain a loop
+	 in the resource table.  We need some way to detect this.  */
+      return rsrc_print_resource_directory (file, abfd, indent + 1, data,
+					    regions, rva_bias);
+    }
+
+  leaf = regions->section_start + entry;
+
+  if (leaf + 16 >= regions->section_end
+      /* PR 17512: file: 055dff7e.  */
+      || leaf < regions->section_start)
+    return regions->section_end + 1;
+
+  fprintf (file, _("%03x %*.s  Leaf: Addr: %#08lx, Size: %#08lx, Codepage: %d\n"),
+	   (int) (entry), indent, " ",
+	   addr = (long) bfd_get_32 (abfd, leaf),
+	   size = (long) bfd_get_32 (abfd, leaf + 4),
+	   (int) bfd_get_32 (abfd, leaf + 8));
+
+  /* Check that the reserved entry is 0.  */
+  if (bfd_get_32 (abfd, leaf + 12) != 0
+      /* And that the data address/size is valid too.  */
+      || (regions->section_start + (addr - rva_bias) + size > regions->section_end))
+    return regions->section_end + 1;
+
+  if (regions->resource_start == NULL)
+    regions->resource_start = regions->section_start + (addr - rva_bias);
+
+  return regions->section_start + (addr - rva_bias) + size;
+}
+
+#define max(a,b) ((a) > (b) ? (a) : (b))
+#define min(a,b) ((a) < (b) ? (a) : (b))
+
+static bfd_byte *
+rsrc_print_resource_directory (FILE *         file,
+			       bfd *          abfd,
+			       unsigned int   indent,
+			       bfd_byte *     data,
+			       rsrc_regions * regions,
+			       bfd_vma        rva_bias)
+{
+  unsigned int num_names, num_ids;
+  bfd_byte * highest_data = data;
+
+  if (data + 16 >= regions->section_end)
+    return regions->section_end + 1;
+
+  fprintf (file, "%03x %*.s ", (int)(data - regions->section_start), indent, " ");
+  switch (indent)
+    {
+    case 0: fprintf (file, "Type"); break;
+    case 2: fprintf (file, "Name"); break;
+    case 4: fprintf (file, "Language"); break;
+    default:
+      fprintf (file, _("<unknown directory type: %d>\n"), indent);
+      /* FIXME: For now we end the printing here.  If in the
+	 future more directory types are added to the RSRC spec
+	 then we will need to change this.  */
+      return regions->section_end + 1;
+    }
+
+  fprintf (file, _(" Table: Char: %d, Time: %08lx, Ver: %d/%d, Num Names: %d, IDs: %d\n"),
+	   (int) bfd_get_32 (abfd, data),
+	   (long) bfd_get_32 (abfd, data + 4),
+	   (int)  bfd_get_16 (abfd, data + 8),
+	   (int)  bfd_get_16 (abfd, data + 10),
+	   num_names = (int) bfd_get_16 (abfd, data + 12),
+	   num_ids =   (int) bfd_get_16 (abfd, data + 14));
+  data += 16;
+
+  while (num_names --)
+    {
+      bfd_byte * entry_end;
+
+      entry_end = rsrc_print_resource_entries (file, abfd, indent + 1, TRUE,
+					       data, regions, rva_bias);
+      data += 8;
+      highest_data = max (highest_data, entry_end);
+      if (entry_end >= regions->section_end)
+	return entry_end;
+    }
+
+  while (num_ids --)
+    {
+      bfd_byte * entry_end;
+
+      entry_end = rsrc_print_resource_entries (file, abfd, indent + 1, FALSE,
+					       data, regions, rva_bias);
+      data += 8;
+      highest_data = max (highest_data, entry_end);
+      if (entry_end >= regions->section_end)
+	return entry_end;
+    }
+
+  return max (highest_data, data);
+}
+
+/* Display the contents of a .rsrc section.  We do not try to
+   reproduce the resources, windres does that.  Instead we dump
+   the tables in a human readable format.  */
+
+static bfd_boolean
+rsrc_print_section (bfd * abfd, void * vfile)
+{
+  bfd_vma rva_bias;
+  pe_data_type * pe;
+  FILE * file = (FILE *) vfile;
+  bfd_size_type datasize;
+  asection * section;
+  bfd_byte * data;
+  rsrc_regions regions;
+
+  pe = pe_data (abfd);
+  if (pe == NULL)
+    return TRUE;
+
+  section = bfd_get_section_by_name (abfd, ".rsrc");
+  if (section == NULL)
+    return TRUE;
+  if (!(section->flags & SEC_HAS_CONTENTS))
+    return TRUE;
+
+  datasize = section->size;
+  if (datasize == 0)
+    return TRUE;
+
+  rva_bias = section->vma - pe->pe_opthdr.ImageBase;
+
+  if (! bfd_malloc_and_get_section (abfd, section, & data))
+    {
+      if (data != NULL)
+	free (data);
+      return FALSE;
+    }
+
+  regions.section_start = data;
+  regions.section_end = data + datasize;
+  regions.strings_start = NULL;
+  regions.resource_start = NULL;
+
+  fflush (file);
+  fprintf (file, "\nThe .rsrc Resource Directory section:\n");
+
+  while (data < regions.section_end)
+    {
+      bfd_byte * p = data;
+
+      data = rsrc_print_resource_directory (file, abfd, 0, data, & regions, rva_bias);
+
+      if (data == regions.section_end + 1)
+	fprintf (file, _("Corrupt .rsrc section detected!\n"));
+      else
+	{
+	  /* Align data before continuing.  */
+	  int align = (1 << section->alignment_power) - 1;
+
+	  data = (bfd_byte *) (((ptrdiff_t) (data + align)) & ~ align);
+	  rva_bias += data - p;
+
+	  /* For reasons that are unclear .rsrc sections are sometimes created
+	     aligned to a 1^3 boundary even when their alignment is set at
+	     1^2.  Catch that case here before we issue a spurious warning
+	     message.  */
+	  if (data == (regions.section_end - 4))
+	    data = regions.section_end;
+	  else if (data < regions.section_end)
+	    {
+	      /* If the extra data is all zeros then do not complain.
+		 This is just padding so that the section meets the
+		 page size requirements.  */
+	      while (++ data < regions.section_end)
+		if (*data != 0)
+		  break;
+	      if (data < regions.section_end)
+		fprintf (file, _("\nWARNING: Extra data in .rsrc section - it will be ignored by Windows:\n"));
+	    }
+	}
+    }
+
+  if (regions.strings_start != NULL)
+    fprintf (file, " String table starts at offset: %#03x\n",
+	     (int) (regions.strings_start - regions.section_start));
+  if (regions.resource_start != NULL)
+    fprintf (file, " Resources start at offset: %#03x\n",
+	     (int) (regions.resource_start - regions.section_start));
+
+  free (regions.section_start);
+  return TRUE;
+}
+
+#define IMAGE_NUMBEROF_DEBUG_TYPES 12
+
+static char * debug_type_names[IMAGE_NUMBEROF_DEBUG_TYPES] =
+{
+  "Unknown",
+  "COFF",
+  "CodeView",
+  "FPO",
+  "Misc",
+  "Exception",
+  "Fixup",
+  "OMAP-to-SRC",
+  "OMAP-from-SRC",
+  "Borland",
+  "Reserved",
+  "CLSID",
+};
+
+static bfd_boolean
+pe_print_debugdata (bfd * abfd, void * vfile)
+{
+  FILE *file = (FILE *) vfile;
+  pe_data_type *pe = pe_data (abfd);
+  struct internal_extra_pe_aouthdr *extra = &pe->pe_opthdr;
+  asection *section;
+  bfd_byte *data = 0;
+  bfd_size_type dataoff;
+  unsigned int i;
+
+  bfd_vma addr = extra->DataDirectory[PE_DEBUG_DATA].VirtualAddress;
+  bfd_size_type size = extra->DataDirectory[PE_DEBUG_DATA].Size;
+
+  if (size == 0)
+    return TRUE;
+
+  addr += extra->ImageBase;
+  for (section = abfd->sections; section != NULL; section = section->next)
+    {
+      if ((addr >= section->vma) && (addr < (section->vma + section->size)))
+        break;
+    }
+
+  if (section == NULL)
+    {
+      fprintf (file,
+               _("\nThere is a debug directory, but the section containing it could not be found\n"));
+      return TRUE;
+    }
+  else if (!(section->flags & SEC_HAS_CONTENTS))
+    {
+      fprintf (file,
+               _("\nThere is a debug directory in %s, but that section has no contents\n"),
+               section->name);
+      return TRUE;
+    }
+  else if (section->size < size)
+    {
+      fprintf (file,
+               _("\nError: section %s contains the debug data starting address but it is too small\n"),
+               section->name);
+      return FALSE;
+    }
+
+  fprintf (file, _("\nThere is a debug directory in %s at 0x%lx\n\n"),
+	   section->name, (unsigned long) addr);
+
+  dataoff = addr - section->vma;
+
+  if (size > (section->size - dataoff))
+    {
+      fprintf (file, _("The debug data size field in the data directory is too big for the section"));
+      return FALSE;
+    }
+
+  fprintf (file,
+	   _("Type                Size     Rva      Offset\n"));
+
+  /* Read the whole section.  */
+  if (!bfd_malloc_and_get_section (abfd, section, &data))
+    {
+      if (data != NULL)
+	free (data);
+      return FALSE;
+    }
+
+  for (i = 0; i < size / sizeof (struct external_IMAGE_DEBUG_DIRECTORY); i++)
+    {
+      const char *type_name;
+      struct external_IMAGE_DEBUG_DIRECTORY *ext
+	= &((struct external_IMAGE_DEBUG_DIRECTORY *)(data + dataoff))[i];
+      struct internal_IMAGE_DEBUG_DIRECTORY idd;
+
+      _bfd_XXi_swap_debugdir_in (abfd, ext, &idd);
+
+      if ((idd.Type) >= IMAGE_NUMBEROF_DEBUG_TYPES)
+        type_name = debug_type_names[0];
+      else
+        type_name = debug_type_names[idd.Type];
+
+      fprintf (file, " %2ld  %14s %08lx %08lx %08lx\n",
+	       idd.Type, type_name, idd.SizeOfData,
+	       idd.AddressOfRawData, idd.PointerToRawData);
+
+      if (idd.Type == PE_IMAGE_DEBUG_TYPE_CODEVIEW)
+        {
+          char signature[CV_INFO_SIGNATURE_LENGTH * 2 + 1];
+	  /* PR 17512: file: 065-29434-0.001:0.1
+	     We need to use a 32-bit aligned buffer
+	     to safely read in a codeview record.  */
+          char buffer[256 + 1] ATTRIBUTE_ALIGNED_ALIGNOF (CODEVIEW_INFO);
+
+          CODEVIEW_INFO *cvinfo = (CODEVIEW_INFO *) buffer;
+
+          /* The debug entry doesn't have to have to be in a section,
+	     in which case AddressOfRawData is 0, so always use PointerToRawData.  */
+          if (!_bfd_XXi_slurp_codeview_record (abfd, (file_ptr) idd.PointerToRawData,
+					       idd.SizeOfData, cvinfo))
+            continue;
+
+          for (i = 0; i < cvinfo->SignatureLength; i++)
+            sprintf (&signature[i*2], "%02x", cvinfo->Signature[i] & 0xff);
+
+          fprintf (file, "(format %c%c%c%c signature %s age %ld)\n",
+		   buffer[0], buffer[1], buffer[2], buffer[3],
+		   signature, cvinfo->Age);
+        }
+    }
+
+  if (size % sizeof (struct external_IMAGE_DEBUG_DIRECTORY) != 0)
+    fprintf (file,
+            _("The debug directory size is not a multiple of the debug directory entry size\n"));
+
+  return TRUE;
+}
+
+/* Print out the program headers.  */
+
+bfd_boolean
+_bfd_XX_print_private_bfd_data_common (bfd * abfd, void * vfile)
+{
+  FILE *file = (FILE *) vfile;
+  int j;
+  pe_data_type *pe = pe_data (abfd);
+  struct internal_extra_pe_aouthdr *i = &pe->pe_opthdr;
+  const char *subsystem_name = NULL;
+  const char *name;
+
+  /* The MS dumpbin program reportedly ands with 0xff0f before
+     printing the characteristics field.  Not sure why.  No reason to
+     emulate it here.  */
+  fprintf (file, _("\nCharacteristics 0x%x\n"), pe->real_flags);
+#undef PF
+#define PF(x, y) if (pe->real_flags & x) { fprintf (file, "\t%s\n", y); }
+  PF (IMAGE_FILE_RELOCS_STRIPPED, "relocations stripped");
+  PF (IMAGE_FILE_EXECUTABLE_IMAGE, "executable");
+  PF (IMAGE_FILE_LINE_NUMS_STRIPPED, "line numbers stripped");
+  PF (IMAGE_FILE_LOCAL_SYMS_STRIPPED, "symbols stripped");
+  PF (IMAGE_FILE_LARGE_ADDRESS_AWARE, "large address aware");
+  PF (IMAGE_FILE_BYTES_REVERSED_LO, "little endian");
+  PF (IMAGE_FILE_32BIT_MACHINE, "32 bit words");
+  PF (IMAGE_FILE_DEBUG_STRIPPED, "debugging information removed");
+  PF (IMAGE_FILE_SYSTEM, "system file");
+  PF (IMAGE_FILE_DLL, "DLL");
+  PF (IMAGE_FILE_BYTES_REVERSED_HI, "big endian");
+#undef PF
+
+  /* ctime implies '\n'.  */
+  {
+    time_t t = pe->coff.timestamp;
+    fprintf (file, "\nTime/Date\t\t%s", ctime (&t));
+  }
+
+#ifndef IMAGE_NT_OPTIONAL_HDR_MAGIC
+# define IMAGE_NT_OPTIONAL_HDR_MAGIC 0x10b
+#endif
+#ifndef IMAGE_NT_OPTIONAL_HDR64_MAGIC
+# define IMAGE_NT_OPTIONAL_HDR64_MAGIC 0x20b
+#endif
+#ifndef IMAGE_NT_OPTIONAL_HDRROM_MAGIC
+# define IMAGE_NT_OPTIONAL_HDRROM_MAGIC 0x107
+#endif
+
+  switch (i->Magic)
+    {
+    case IMAGE_NT_OPTIONAL_HDR_MAGIC:
+      name = "PE32";
+      break;
+    case IMAGE_NT_OPTIONAL_HDR64_MAGIC:
+      name = "PE32+";
+      break;
+    case IMAGE_NT_OPTIONAL_HDRROM_MAGIC:
+      name = "ROM";
+      break;
+    default:
+      name = NULL;
+      break;
+    }
+  fprintf (file, "Magic\t\t\t%04x", i->Magic);
+  if (name)
+    fprintf (file, "\t(%s)",name);
+  fprintf (file, "\nMajorLinkerVersion\t%d\n", i->MajorLinkerVersion);
+  fprintf (file, "MinorLinkerVersion\t%d\n", i->MinorLinkerVersion);
+  fprintf (file, "SizeOfCode\t\t%08lx\n", (unsigned long) i->SizeOfCode);
+  fprintf (file, "SizeOfInitializedData\t%08lx\n",
+	   (unsigned long) i->SizeOfInitializedData);
+  fprintf (file, "SizeOfUninitializedData\t%08lx\n",
+	   (unsigned long) i->SizeOfUninitializedData);
+  fprintf (file, "AddressOfEntryPoint\t");
+  bfd_fprintf_vma (abfd, file, i->AddressOfEntryPoint);
+  fprintf (file, "\nBaseOfCode\t\t");
+  bfd_fprintf_vma (abfd, file, i->BaseOfCode);
+#if !defined(COFF_WITH_pep) && !defined(COFF_WITH_pex64)
+  /* PE32+ does not have BaseOfData member!  */
+  fprintf (file, "\nBaseOfData\t\t");
+  bfd_fprintf_vma (abfd, file, i->BaseOfData);
+#endif
+
+  fprintf (file, "\nImageBase\t\t");
+  bfd_fprintf_vma (abfd, file, i->ImageBase);
+  fprintf (file, "\nSectionAlignment\t");
+  bfd_fprintf_vma (abfd, file, i->SectionAlignment);
+  fprintf (file, "\nFileAlignment\t\t");
+  bfd_fprintf_vma (abfd, file, i->FileAlignment);
+  fprintf (file, "\nMajorOSystemVersion\t%d\n", i->MajorOperatingSystemVersion);
+  fprintf (file, "MinorOSystemVersion\t%d\n", i->MinorOperatingSystemVersion);
+  fprintf (file, "MajorImageVersion\t%d\n", i->MajorImageVersion);
+  fprintf (file, "MinorImageVersion\t%d\n", i->MinorImageVersion);
+  fprintf (file, "MajorSubsystemVersion\t%d\n", i->MajorSubsystemVersion);
+  fprintf (file, "MinorSubsystemVersion\t%d\n", i->MinorSubsystemVersion);
+  fprintf (file, "Win32Version\t\t%08lx\n", (unsigned long) i->Reserved1);
+  fprintf (file, "SizeOfImage\t\t%08lx\n", (unsigned long) i->SizeOfImage);
+  fprintf (file, "SizeOfHeaders\t\t%08lx\n", (unsigned long) i->SizeOfHeaders);
+  fprintf (file, "CheckSum\t\t%08lx\n", (unsigned long) i->CheckSum);
+
+  switch (i->Subsystem)
+    {
+    case IMAGE_SUBSYSTEM_UNKNOWN:
+      subsystem_name = "unspecified";
+      break;
+    case IMAGE_SUBSYSTEM_NATIVE:
+      subsystem_name = "NT native";
+      break;
+    case IMAGE_SUBSYSTEM_WINDOWS_GUI:
+      subsystem_name = "Windows GUI";
+      break;
+    case IMAGE_SUBSYSTEM_WINDOWS_CUI:
+      subsystem_name = "Windows CUI";
+      break;
+    case IMAGE_SUBSYSTEM_POSIX_CUI:
+      subsystem_name = "POSIX CUI";
+      break;
+    case IMAGE_SUBSYSTEM_WINDOWS_CE_GUI:
+      subsystem_name = "Wince CUI";
+      break;
+    // These are from UEFI Platform Initialization Specification 1.1.
+    case IMAGE_SUBSYSTEM_EFI_APPLICATION:
+      subsystem_name = "EFI application";
+      break;
+    case IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER:
+      subsystem_name = "EFI boot service driver";
+      break;
+    case IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER:
+      subsystem_name = "EFI runtime driver";
+      break;
+    case IMAGE_SUBSYSTEM_SAL_RUNTIME_DRIVER:
+      subsystem_name = "SAL runtime driver";
+      break;
+    // This is from revision 8.0 of the MS PE/COFF spec
+    case IMAGE_SUBSYSTEM_XBOX:
+      subsystem_name = "XBOX";
+      break;
+    // Added default case for clarity - subsystem_name is NULL anyway.
+    default:
+      subsystem_name = NULL;
+    }
+
+  fprintf (file, "Subsystem\t\t%08x", i->Subsystem);
+  if (subsystem_name)
+    fprintf (file, "\t(%s)", subsystem_name);
+  fprintf (file, "\nDllCharacteristics\t%08x\n", i->DllCharacteristics);
+  fprintf (file, "SizeOfStackReserve\t");
+  bfd_fprintf_vma (abfd, file, i->SizeOfStackReserve);
+  fprintf (file, "\nSizeOfStackCommit\t");
+  bfd_fprintf_vma (abfd, file, i->SizeOfStackCommit);
+  fprintf (file, "\nSizeOfHeapReserve\t");
+  bfd_fprintf_vma (abfd, file, i->SizeOfHeapReserve);
+  fprintf (file, "\nSizeOfHeapCommit\t");
+  bfd_fprintf_vma (abfd, file, i->SizeOfHeapCommit);
+  fprintf (file, "\nLoaderFlags\t\t%08lx\n", (unsigned long) i->LoaderFlags);
+  fprintf (file, "NumberOfRvaAndSizes\t%08lx\n",
+	   (unsigned long) i->NumberOfRvaAndSizes);
+
+  fprintf (file, "\nThe Data Directory\n");
+  for (j = 0; j < IMAGE_NUMBEROF_DIRECTORY_ENTRIES; j++)
+    {
+      fprintf (file, "Entry %1x ", j);
+      bfd_fprintf_vma (abfd, file, i->DataDirectory[j].VirtualAddress);
+      fprintf (file, " %08lx ", (unsigned long) i->DataDirectory[j].Size);
+      fprintf (file, "%s\n", dir_names[j]);
+    }
+
+  pe_print_idata (abfd, vfile);
+  pe_print_edata (abfd, vfile);
+  if (bfd_coff_have_print_pdata (abfd))
+    bfd_coff_print_pdata (abfd, vfile);
+  else
+    pe_print_pdata (abfd, vfile);
+  pe_print_reloc (abfd, vfile);
+  pe_print_debugdata (abfd, file);
+
+  rsrc_print_section (abfd, vfile);
+
+  return TRUE;
+}
+
+static bfd_boolean
+is_vma_in_section (bfd *abfd ATTRIBUTE_UNUSED, asection *sect, void *obj)
+{
+  bfd_vma addr = * (bfd_vma *) obj;
+  return (addr >= sect->vma) && (addr < (sect->vma + sect->size));
+}
+
+static asection *
+find_section_by_vma (bfd *abfd, bfd_vma addr)
+{
+  return bfd_sections_find_if (abfd, is_vma_in_section, (void *) & addr);
+}
+
+/* Copy any private info we understand from the input bfd
+   to the output bfd.  */
+
+bfd_boolean
+_bfd_XX_bfd_copy_private_bfd_data_common (bfd * ibfd, bfd * obfd)
+{
+  pe_data_type *ipe, *ope;
+
+  /* One day we may try to grok other private data.  */
+  if (ibfd->xvec->flavour != bfd_target_coff_flavour
+      || obfd->xvec->flavour != bfd_target_coff_flavour)
+    return TRUE;
+
+  ipe = pe_data (ibfd);
+  ope = pe_data (obfd);
+
+  /* pe_opthdr is copied in copy_object.  */
+  ope->dll = ipe->dll;
+
+  /* Don't copy input subsystem if output is different from input.  */
+  if (obfd->xvec != ibfd->xvec)
+    ope->pe_opthdr.Subsystem = IMAGE_SUBSYSTEM_UNKNOWN;
+
+  /* For strip: if we removed .reloc, we'll make a real mess of things
+     if we don't remove this entry as well.  */
+  if (! pe_data (obfd)->has_reloc_section)
+    {
+      pe_data (obfd)->pe_opthdr.DataDirectory[PE_BASE_RELOCATION_TABLE].VirtualAddress = 0;
+      pe_data (obfd)->pe_opthdr.DataDirectory[PE_BASE_RELOCATION_TABLE].Size = 0;
+    }
+
+  /* For PIE, if there is .reloc, we won't add IMAGE_FILE_RELOCS_STRIPPED.
+     But there is no .reloc, we make sure that IMAGE_FILE_RELOCS_STRIPPED
+     won't be added.  */
+  if (! pe_data (ibfd)->has_reloc_section
+      && ! (pe_data (ibfd)->real_flags & IMAGE_FILE_RELOCS_STRIPPED))
+    pe_data (obfd)->dont_strip_reloc = 1;
+
+  /* The file offsets contained in the debug directory need rewriting.  */
+  if (ope->pe_opthdr.DataDirectory[PE_DEBUG_DATA].Size != 0)
+    {
+      bfd_vma addr = ope->pe_opthdr.DataDirectory[PE_DEBUG_DATA].VirtualAddress
+	+ ope->pe_opthdr.ImageBase;
+      asection *section = find_section_by_vma (obfd, addr);
+      bfd_byte *data;
+
+      if (section && bfd_malloc_and_get_section (obfd, section, &data))
+        {
+          unsigned int i;
+          struct external_IMAGE_DEBUG_DIRECTORY *dd =
+	    (struct external_IMAGE_DEBUG_DIRECTORY *)(data + (addr - section->vma));
+
+	  /* PR 17512: file: 0f15796a.  */
+	  if (ope->pe_opthdr.DataDirectory[PE_DEBUG_DATA].Size + (addr - section->vma)
+	      > bfd_get_section_size (section))
+	    {
+	      _bfd_error_handler (_("%B: Data Directory size (%lx) exceeds space left in section (%lx)"),
+				  obfd, ope->pe_opthdr.DataDirectory[PE_DEBUG_DATA].Size,
+				  bfd_get_section_size (section) - (addr - section->vma));
+	      return FALSE;
+	    }
+
+          for (i = 0; i < ope->pe_opthdr.DataDirectory[PE_DEBUG_DATA].Size
+		 / sizeof (struct external_IMAGE_DEBUG_DIRECTORY); i++)
+            {
+              asection *ddsection;
+              struct external_IMAGE_DEBUG_DIRECTORY *edd = &(dd[i]);
+              struct internal_IMAGE_DEBUG_DIRECTORY idd;
+
+              _bfd_XXi_swap_debugdir_in (obfd, edd, &idd);
+
+              if (idd.AddressOfRawData == 0)
+                continue; /* RVA 0 means only offset is valid, not handled yet.  */
+
+              ddsection = find_section_by_vma (obfd, idd.AddressOfRawData + ope->pe_opthdr.ImageBase);
+              if (!ddsection)
+                continue; /* Not in a section! */
+
+              idd.PointerToRawData = ddsection->filepos + (idd.AddressOfRawData
+							   + ope->pe_opthdr.ImageBase) - ddsection->vma;
+
+              _bfd_XXi_swap_debugdir_out (obfd, &idd, edd);
+            }
+
+          if (!bfd_set_section_contents (obfd, section, data, 0, section->size))
+	    {
+	      _bfd_error_handler (_("Failed to update file offsets in debug directory"));
+	      return FALSE;
+	    }
+        }
+      else if (section)
+	{
+	  _bfd_error_handler (_("%B: Failed to read debug data section"), obfd);
+	  return FALSE;
+	}
+    }
+
+  return TRUE;
+}
+
+/* Copy private section data.  */
+
+bfd_boolean
+_bfd_XX_bfd_copy_private_section_data (bfd *ibfd,
+				       asection *isec,
+				       bfd *obfd,
+				       asection *osec)
+{
+  if (bfd_get_flavour (ibfd) != bfd_target_coff_flavour
+      || bfd_get_flavour (obfd) != bfd_target_coff_flavour)
+    return TRUE;
+
+  if (coff_section_data (ibfd, isec) != NULL
+      && pei_section_data (ibfd, isec) != NULL)
+    {
+      if (coff_section_data (obfd, osec) == NULL)
+	{
+	  bfd_size_type amt = sizeof (struct coff_section_tdata);
+	  osec->used_by_bfd = bfd_zalloc (obfd, amt);
+	  if (osec->used_by_bfd == NULL)
+	    return FALSE;
+	}
+
+      if (pei_section_data (obfd, osec) == NULL)
+	{
+	  bfd_size_type amt = sizeof (struct pei_section_tdata);
+	  coff_section_data (obfd, osec)->tdata = bfd_zalloc (obfd, amt);
+	  if (coff_section_data (obfd, osec)->tdata == NULL)
+	    return FALSE;
+	}
+
+      pei_section_data (obfd, osec)->virt_size =
+	pei_section_data (ibfd, isec)->virt_size;
+      pei_section_data (obfd, osec)->pe_flags =
+	pei_section_data (ibfd, isec)->pe_flags;
+    }
+
+  return TRUE;
+}
+
+void
+_bfd_XX_get_symbol_info (bfd * abfd, asymbol *symbol, symbol_info *ret)
+{
+  coff_get_symbol_info (abfd, symbol, ret);
+}
+
+#if !defined(COFF_WITH_pep) && defined(COFF_WITH_pex64)
+static int
+sort_x64_pdata (const void *l, const void *r)
+{
+  const char *lp = (const char *) l;
+  const char *rp = (const char *) r;
+  bfd_vma vl, vr;
+  vl = bfd_getl32 (lp); vr = bfd_getl32 (rp);
+  if (vl != vr)
+    return (vl < vr ? -1 : 1);
+  /* We compare just begin address.  */
+  return 0;
+}
+#endif
+
+/* Functions to process a .rsrc section.  */
+
+static unsigned int sizeof_leaves;
+static unsigned int sizeof_strings;
+static unsigned int sizeof_tables_and_entries;
+
+static bfd_byte *
+rsrc_count_directory (bfd *, bfd_byte *, bfd_byte *, bfd_byte *, bfd_vma);
+
+static bfd_byte *
+rsrc_count_entries (bfd *          abfd,
+		    bfd_boolean    is_name,
+		    bfd_byte *     datastart,
+		    bfd_byte *     data,
+		    bfd_byte *     dataend,
+		    bfd_vma        rva_bias)
+{
+  unsigned long entry, addr, size;
+
+  if (data + 8 >= dataend)
+    return dataend + 1;
+
+  if (is_name)
+    {
+      bfd_byte * name;
+
+      entry = (long) bfd_get_32 (abfd, data);
+
+      if (HighBitSet (entry))
+	name = datastart + WithoutHighBit (entry);
+      else
+	name = datastart + entry - rva_bias;
+
+      if (name + 2 >= dataend || name < datastart)
+	return dataend + 1;
+
+      unsigned int len = bfd_get_16 (abfd, name);
+      if (len == 0 || len > 256)
+	return dataend + 1;
+    }
+
+  entry = (long) bfd_get_32 (abfd, data + 4);
+
+  if (HighBitSet (entry))
+    {
+      data = datastart + WithoutHighBit (entry);
+
+      if (data <= datastart || data >= dataend)
+	return dataend + 1;
+
+      return rsrc_count_directory (abfd, datastart, data, dataend, rva_bias);
+    }
+
+  if (datastart + entry + 16 >= dataend)
+    return dataend + 1;
+
+  addr = (long) bfd_get_32 (abfd, datastart + entry);
+  size = (long) bfd_get_32 (abfd, datastart + entry + 4);
+
+  return datastart + addr - rva_bias + size;
+}
+
+static bfd_byte *
+rsrc_count_directory (bfd *          abfd,
+		      bfd_byte *     datastart,
+		      bfd_byte *     data,
+		      bfd_byte *     dataend,
+		      bfd_vma        rva_bias)
+{
+  unsigned int  num_entries, num_ids;
+  bfd_byte *    highest_data = data;
+
+  if (data + 16 >= dataend)
+    return dataend + 1;
+
+  num_entries  = (int) bfd_get_16 (abfd, data + 12);
+  num_ids      = (int) bfd_get_16 (abfd, data + 14);
+
+  num_entries += num_ids;
+
+  data += 16;
+
+  while (num_entries --)
+    {
+      bfd_byte * entry_end;
+
+      entry_end = rsrc_count_entries (abfd, num_entries >= num_ids,
+				      datastart, data, dataend, rva_bias);
+      data += 8;
+      highest_data = max (highest_data, entry_end);
+      if (entry_end >= dataend)
+	break;
+    }
+
+  return max (highest_data, data);
+}
+
+typedef struct rsrc_dir_chain
+{
+  unsigned int         num_entries;
+  struct rsrc_entry *  first_entry;
+  struct rsrc_entry *  last_entry;
+} rsrc_dir_chain;
+
+typedef struct rsrc_directory
+{
+  unsigned int characteristics;
+  unsigned int time;
+  unsigned int major;
+  unsigned int minor;
+
+  rsrc_dir_chain names;
+  rsrc_dir_chain ids;
+
+  struct rsrc_entry * entry;
+} rsrc_directory;
+
+typedef struct rsrc_string
+{
+  unsigned int  len;
+  bfd_byte *    string;
+} rsrc_string;
+
+typedef struct rsrc_leaf
+{
+  unsigned int  size;
+  unsigned int  codepage;
+  bfd_byte *    data;
+} rsrc_leaf;
+
+typedef struct rsrc_entry
+{
+  bfd_boolean is_name;
+  union
+  {
+    unsigned int          id;
+    struct rsrc_string    name;
+  } name_id;
+
+  bfd_boolean is_dir;
+  union
+  {
+    struct rsrc_directory * directory;
+    struct rsrc_leaf *      leaf;
+  } value;
+
+  struct rsrc_entry *     next_entry;
+  struct rsrc_directory * parent;
+} rsrc_entry;
+
+static bfd_byte *
+rsrc_parse_directory (bfd *, rsrc_directory *, bfd_byte *,
+		      bfd_byte *, bfd_byte *, bfd_vma, rsrc_entry *);
+
+static bfd_byte *
+rsrc_parse_entry (bfd *            abfd,
+		  bfd_boolean      is_name,
+		  rsrc_entry *     entry,
+		  bfd_byte *       datastart,
+		  bfd_byte *       data,
+		  bfd_byte *       dataend,
+		  bfd_vma          rva_bias,
+		  rsrc_directory * parent)
+{
+  unsigned long val, addr, size;
+
+  val = bfd_get_32 (abfd, data);
+
+  entry->parent = parent;
+  entry->is_name = is_name;
+
+  if (is_name)
+    {
+      bfd_byte * address;
+
+      if (HighBitSet (val))
+	{
+	  val = WithoutHighBit (val);
+
+	  address = datastart + val;
+	}
+      else
+	{
+	  address = datastart + val - rva_bias;
+	}
+
+      if (address + 3 > dataend)
+	return dataend;
+
+      entry->name_id.name.len    = bfd_get_16 (abfd, address);
+      entry->name_id.name.string = address + 2;
+    }
+  else
+    entry->name_id.id = val;
+
+  val = bfd_get_32 (abfd, data + 4);
+
+  if (HighBitSet (val))
+    {
+      entry->is_dir = TRUE;
+      entry->value.directory = bfd_malloc (sizeof * entry->value.directory);
+      if (entry->value.directory == NULL)
+	return dataend;
+
+      return rsrc_parse_directory (abfd, entry->value.directory,
+				   datastart,
+				   datastart + WithoutHighBit (val),
+				   dataend, rva_bias, entry);
+    }
+
+  entry->is_dir = FALSE;
+  entry->value.leaf = bfd_malloc (sizeof * entry->value.leaf);
+  if (entry->value.leaf == NULL)
+    return dataend;
+
+  data = datastart + val;
+  if (data < datastart || data >= dataend)
+    return dataend;
+
+  addr = bfd_get_32 (abfd, data);
+  size = entry->value.leaf->size = bfd_get_32 (abfd, data + 4);
+  entry->value.leaf->codepage = bfd_get_32 (abfd, data + 8);
+  /* FIXME: We assume that the reserved field (data + 12) is OK.  */
+
+  entry->value.leaf->data = bfd_malloc (size);
+  if (entry->value.leaf->data == NULL)
+    return dataend;
+
+  memcpy (entry->value.leaf->data, datastart + addr - rva_bias, size);
+  return datastart + (addr - rva_bias) + size;
+}
+
+static bfd_byte *
+rsrc_parse_entries (bfd *            abfd,
+		    rsrc_dir_chain * chain,
+		    bfd_boolean      is_name,
+		    bfd_byte *       highest_data,
+		    bfd_byte *       datastart,
+		    bfd_byte *       data,
+		    bfd_byte *       dataend,
+		    bfd_vma          rva_bias,
+		    rsrc_directory * parent)
+{
+  unsigned int i;
+  rsrc_entry * entry;
+
+  if (chain->num_entries == 0)
+    {
+      chain->first_entry = chain->last_entry = NULL;
+      return highest_data;
+    }
+
+  entry = bfd_malloc (sizeof * entry);
+  if (entry == NULL)
+    return dataend;
+
+  chain->first_entry = entry;
+
+  for (i = chain->num_entries; i--;)
+    {
+      bfd_byte * entry_end;
+
+      entry_end = rsrc_parse_entry (abfd, is_name, entry, datastart,
+				    data, dataend, rva_bias, parent);
+      data += 8;
+      highest_data = max (entry_end, highest_data);
+      if (entry_end > dataend)
+	return dataend;
+
+      if (i)
+	{
+	  entry->next_entry = bfd_malloc (sizeof * entry);
+	  entry = entry->next_entry;
+	  if (entry == NULL)
+	    return dataend;
+	}
+      else
+	entry->next_entry = NULL;
+    }
+
+  chain->last_entry = entry;
+
+  return highest_data;
+}
+
+static bfd_byte *
+rsrc_parse_directory (bfd *            abfd,
+		      rsrc_directory * table,
+		      bfd_byte *       datastart,
+		      bfd_byte *       data,
+		      bfd_byte *       dataend,
+		      bfd_vma          rva_bias,
+		      rsrc_entry *     entry)
+{
+  bfd_byte * highest_data = data;
+
+  if (table == NULL)
+    return dataend;
+
+  table->characteristics = bfd_get_32 (abfd, data);
+  table->time = bfd_get_32 (abfd, data + 4);
+  table->major = bfd_get_16 (abfd, data + 8);
+  table->minor = bfd_get_16 (abfd, data + 10);
+  table->names.num_entries = bfd_get_16 (abfd, data + 12);
+  table->ids.num_entries = bfd_get_16 (abfd, data + 14);
+  table->entry = entry;
+
+  data += 16;
+
+  highest_data = rsrc_parse_entries (abfd, & table->names, TRUE, data,
+				     datastart, data, dataend, rva_bias, table);
+  data += table->names.num_entries * 8;
+
+  highest_data = rsrc_parse_entries (abfd, & table->ids, FALSE, highest_data,
+				     datastart, data, dataend, rva_bias, table);
+  data += table->ids.num_entries * 8;
+
+  return max (highest_data, data);
+}
+
+typedef struct rsrc_write_data
+{
+  bfd *      abfd;
+  bfd_byte * datastart;
+  bfd_byte * next_table;
+  bfd_byte * next_leaf;
+  bfd_byte * next_string;
+  bfd_byte * next_data;
+  bfd_vma    rva_bias;
+} rsrc_write_data;
+
+static void
+rsrc_write_string (rsrc_write_data * data,
+		   rsrc_string *     string)
+{
+  bfd_put_16 (data->abfd, string->len, data->next_string);
+  memcpy (data->next_string + 2, string->string, string->len * 2);
+  data->next_string += (string->len + 1) * 2;
+}
+
+static inline unsigned int
+rsrc_compute_rva (rsrc_write_data * data,
+		  bfd_byte *        addr)
+{
+  return (addr - data->datastart) + data->rva_bias;
+}
+
+static void
+rsrc_write_leaf (rsrc_write_data * data,
+		 rsrc_leaf *       leaf)
+{
+  bfd_put_32 (data->abfd, rsrc_compute_rva (data, data->next_data),
+	      data->next_leaf);
+  bfd_put_32 (data->abfd, leaf->size,     data->next_leaf + 4);
+  bfd_put_32 (data->abfd, leaf->codepage, data->next_leaf + 8);
+  bfd_put_32 (data->abfd, 0 /*reserved*/, data->next_leaf + 12);
+  data->next_leaf += 16;
+
+  memcpy (data->next_data, leaf->data, leaf->size);
+  /* An undocumented feature of Windows resources is that each unit
+     of raw data is 8-byte aligned...  */
+  data->next_data += ((leaf->size + 7) & ~7);
+}
+
+static void rsrc_write_directory (rsrc_write_data *, rsrc_directory *);
+
+static void
+rsrc_write_entry (rsrc_write_data *  data,
+		  bfd_byte *         where,
+		  rsrc_entry *       entry)
+{
+  if (entry->is_name)
+    {
+      bfd_put_32 (data->abfd,
+		  SetHighBit (data->next_string - data->datastart),
+		  where);
+      rsrc_write_string (data, & entry->name_id.name);
+    }
+  else
+    bfd_put_32 (data->abfd, entry->name_id.id, where);
+
+  if (entry->is_dir)
+    {
+      bfd_put_32 (data->abfd,
+		  SetHighBit (data->next_table - data->datastart),
+		  where + 4);
+      rsrc_write_directory (data, entry->value.directory);
+    }
+  else
+    {
+      bfd_put_32 (data->abfd, data->next_leaf - data->datastart, where + 4);
+      rsrc_write_leaf (data, entry->value.leaf);
+    }
+}
+
+static void
+rsrc_compute_region_sizes (rsrc_directory * dir)
+{
+  struct rsrc_entry * entry;
+
+  if (dir == NULL)
+    return;
+
+  sizeof_tables_and_entries += 16;
+
+  for (entry = dir->names.first_entry; entry != NULL; entry = entry->next_entry)
+    {
+      sizeof_tables_and_entries += 8;
+
+      sizeof_strings += (entry->name_id.name.len + 1) * 2;
+
+      if (entry->is_dir)
+	rsrc_compute_region_sizes (entry->value.directory);
+      else
+	sizeof_leaves += 16;
+    }
+
+  for (entry = dir->ids.first_entry; entry != NULL; entry = entry->next_entry)
+    {
+      sizeof_tables_and_entries += 8;
+
+      if (entry->is_dir)
+	rsrc_compute_region_sizes (entry->value.directory);
+      else
+	sizeof_leaves += 16;
+    }
+}
+
+static void
+rsrc_write_directory (rsrc_write_data * data,
+		      rsrc_directory *  dir)
+{
+  rsrc_entry * entry;
+  unsigned int i;
+  bfd_byte * next_entry;
+  bfd_byte * nt;
+
+  bfd_put_32 (data->abfd, dir->characteristics, data->next_table);
+  bfd_put_32 (data->abfd, 0 /*dir->time*/, data->next_table + 4);
+  bfd_put_16 (data->abfd, dir->major, data->next_table + 8);
+  bfd_put_16 (data->abfd, dir->minor, data->next_table + 10);
+  bfd_put_16 (data->abfd, dir->names.num_entries, data->next_table + 12);
+  bfd_put_16 (data->abfd, dir->ids.num_entries, data->next_table + 14);
+
+  /* Compute where the entries and the next table will be placed.  */
+  next_entry = data->next_table + 16;
+  data->next_table = next_entry + (dir->names.num_entries * 8)
+    + (dir->ids.num_entries * 8);
+  nt = data->next_table;
+
+  /* Write the entries.  */
+  for (i = dir->names.num_entries, entry = dir->names.first_entry;
+       i > 0 && entry != NULL;
+       i--, entry = entry->next_entry)
+    {
+      BFD_ASSERT (entry->is_name);
+      rsrc_write_entry (data, next_entry, entry);
+      next_entry += 8;
+    }
+  BFD_ASSERT (i == 0);
+  BFD_ASSERT (entry == NULL);
+
+  for (i = dir->ids.num_entries, entry = dir->ids.first_entry;
+       i > 0 && entry != NULL;
+       i--, entry = entry->next_entry)
+    {
+      BFD_ASSERT (! entry->is_name);
+      rsrc_write_entry (data, next_entry, entry);
+      next_entry += 8;
+    }
+  BFD_ASSERT (i == 0);
+  BFD_ASSERT (entry == NULL);
+  BFD_ASSERT (nt == next_entry);
+}
+
+#if defined HAVE_WCHAR_H && ! defined __CYGWIN__ && ! defined __MINGW32__
+/* Return the length (number of units) of the first character in S,
+   putting its 'ucs4_t' representation in *PUC.  */
+
+static unsigned int
+#if defined HAVE_WCTYPE_H
+u16_mbtouc (wint_t * puc, const unsigned short * s, unsigned int n)
+#else
+u16_mbtouc (wchar_t * puc, const unsigned short * s, unsigned int n)
+#endif
+{
+  unsigned short c = * s;
+
+  if (c < 0xd800 || c >= 0xe000)
+    {
+      *puc = c;
+      return 1;
+    }
+
+  if (c < 0xdc00)
+    {
+      if (n >= 2)
+        {
+          if (s[1] >= 0xdc00 && s[1] < 0xe000)
+            {
+              *puc = 0x10000 + ((c - 0xd800) << 10) + (s[1] - 0xdc00);
+              return 2;
+            }
+        }
+      else
+        {
+          /* Incomplete multibyte character.  */
+          *puc = 0xfffd;
+          return n;
+        }
+    }
+
+  /* Invalid multibyte character.  */
+  *puc = 0xfffd;
+  return 1;
+}
+#endif /* HAVE_WCHAR_H and not Cygwin/Mingw */
+
+/* Perform a comparison of two entries.  */
+static signed int
+rsrc_cmp (bfd_boolean is_name, rsrc_entry * a, rsrc_entry * b)
+{
+  signed int    res;
+  bfd_byte *    astring;
+  unsigned int  alen;
+  bfd_byte *    bstring;
+  unsigned int  blen;
+
+  if (! is_name)
+    return a->name_id.id - b->name_id.id;
+
+  /* We have to perform a case insenstive, unicode string comparison...  */
+  astring = a->name_id.name.string;
+  alen    = a->name_id.name.len;
+  bstring = b->name_id.name.string;
+  blen    = b->name_id.name.len;
+
+#if defined  __CYGWIN__ || defined __MINGW32__
+  /* Under Windows hosts (both Cygwin and Mingw types),
+     unicode == UTF-16 == wchar_t.  The case insensitive string comparison
+     function however goes by different names in the two environments...  */
+
+#undef rscpcmp
+#ifdef __CYGWIN__
+#define rscpcmp wcsncasecmp
+#endif
+#ifdef __MINGW32__
+#define rscpcmp wcsnicmp
+#endif
+
+  res = rscpcmp ((const wchar_t *) astring, (const wchar_t *) bstring,
+		 min (alen, blen));
+
+#elif defined HAVE_WCHAR_H
+  {
+    unsigned int  i;
+
+    res = 0;
+    for (i = min (alen, blen); i--; astring += 2, bstring += 2)
+      {
+#if defined HAVE_WCTYPE_H
+	wint_t awc;
+	wint_t bwc;
+#else
+	wchar_t awc;
+	wchar_t bwc;
+#endif
+
+	/* Convert UTF-16 unicode characters into wchar_t characters
+	   so that we can then perform a case insensitive comparison.  */
+	unsigned int Alen = u16_mbtouc (& awc, (const unsigned short *) astring, 2);
+	unsigned int Blen = u16_mbtouc (& bwc, (const unsigned short *) bstring, 2);
+
+	if (Alen != Blen)
+	  return Alen - Blen;
+
+#ifdef HAVE_WCTYPE_H
+	awc = towlower (awc);
+	bwc = towlower (bwc);
+
+	res = awc - bwc;
+#else
+	res = wcsncasecmp (& awc, & bwc, 1);
+#endif
+	if (res)
+	  break;
+      }
+  }
+#else
+  /* Do the best we can - a case sensitive, untranslated comparison.  */
+  res = memcmp (astring, bstring, min (alen, blen) * 2);
+#endif
+
+  if (res == 0)
+    res = alen - blen;
+
+  return res;
+}
+
+static void
+rsrc_print_name (char * buffer, rsrc_string string)
+{
+  unsigned int  i;
+  bfd_byte *    name = string.string;
+
+  for (i = string.len; i--; name += 2)
+    sprintf (buffer + strlen (buffer), "%.1s", name);
+}
+
+static const char *
+rsrc_resource_name (rsrc_entry * entry, rsrc_directory * dir)
+{
+  static char buffer [256];
+  bfd_boolean is_string = FALSE;
+
+  buffer[0] = 0;
+
+  if (dir != NULL && dir->entry != NULL && dir->entry->parent != NULL
+      && dir->entry->parent->entry != NULL)
+    {
+      strcpy (buffer, "type: ");
+      if (dir->entry->parent->entry->is_name)
+	rsrc_print_name (buffer + strlen (buffer),
+			 dir->entry->parent->entry->name_id.name);
+      else
+	{
+	  unsigned int id = dir->entry->parent->entry->name_id.id;
+
+	  sprintf (buffer + strlen (buffer), "%x", id);
+	  switch (id)
+	    {
+	    case 1: strcat (buffer, " (CURSOR)"); break;
+	    case 2: strcat (buffer, " (BITMAP)"); break;
+	    case 3: strcat (buffer, " (ICON)"); break;
+            case 4: strcat (buffer, " (MENU)"); break;
+	    case 5: strcat (buffer, " (DIALOG)"); break;
+	    case 6: strcat (buffer, " (STRING)"); is_string = TRUE; break;
+	    case 7: strcat (buffer, " (FONTDIR)"); break;
+	    case 8: strcat (buffer, " (FONT)"); break;
+	    case 9: strcat (buffer, " (ACCELERATOR)"); break;
+	    case 10: strcat (buffer, " (RCDATA)"); break;
+	    case 11: strcat (buffer, " (MESSAGETABLE)"); break;
+	    case 12: strcat (buffer, " (GROUP_CURSOR)"); break;
+	    case 14: strcat (buffer, " (GROUP_ICON)"); break;
+	    case 16: strcat (buffer, " (VERSION)"); break;
+	    case 17: strcat (buffer, " (DLGINCLUDE)"); break;
+	    case 19: strcat (buffer, " (PLUGPLAY)"); break;
+	    case 20: strcat (buffer, " (VXD)"); break;
+	    case 21: strcat (buffer, " (ANICURSOR)"); break;
+	    case 22: strcat (buffer, " (ANIICON)"); break;
+	    case 23: strcat (buffer, " (HTML)"); break;
+	    case 24: strcat (buffer, " (MANIFEST)"); break;
+	    case 240: strcat (buffer, " (DLGINIT)"); break;
+	    case 241: strcat (buffer, " (TOOLBAR)"); break;
+	    }
+	}
+    }
+
+  if (dir != NULL && dir->entry != NULL)
+    {
+      strcat (buffer, " name: ");
+      if (dir->entry->is_name)
+	rsrc_print_name (buffer + strlen (buffer), dir->entry->name_id.name);
+      else
+	{
+	  unsigned int id = dir->entry->name_id.id;
+
+	  sprintf (buffer + strlen (buffer), "%x", id);
+
+	  if (is_string)
+	    sprintf (buffer + strlen (buffer), " (resource id range: %d - %d)",
+		     (id - 1) << 4, (id << 4) - 1);
+	}
+    }
+
+  if (entry != NULL)
+    {
+      strcat (buffer, " lang: ");
+
+      if (entry->is_name)
+	rsrc_print_name (buffer + strlen (buffer), entry->name_id.name);
+      else
+	sprintf (buffer + strlen (buffer), "%x", entry->name_id.id);
+    }
+
+  return buffer;
+}
+
+/* *sigh* Windows resource strings are special.  Only the top 28-bits of
+   their ID is stored in the NAME entry.  The bottom four bits are used as
+   an index into unicode string table that makes up the data of the leaf.
+   So identical type-name-lang string resources may not actually be
+   identical at all.
+
+   This function is called when we have detected two string resources with
+   match top-28-bit IDs.  We have to scan the string tables inside the leaves
+   and discover if there are any real collisions.  If there are then we report
+   them and return FALSE.  Otherwise we copy any strings from B into A and
+   then return TRUE.  */
+
+static bfd_boolean
+rsrc_merge_string_entries (rsrc_entry * a ATTRIBUTE_UNUSED,
+			   rsrc_entry * b ATTRIBUTE_UNUSED)
+{
+  unsigned int copy_needed = 0;
+  unsigned int i;
+  bfd_byte * astring;
+  bfd_byte * bstring;
+  bfd_byte * new_data;
+  bfd_byte * nstring;
+
+  /* Step one: Find out what we have to do.  */
+  BFD_ASSERT (! a->is_dir);
+  astring = a->value.leaf->data;
+
+  BFD_ASSERT (! b->is_dir);
+  bstring = b->value.leaf->data;
+
+  for (i = 0; i < 16; i++)
+    {
+      unsigned int alen = astring[0] + (astring[1] << 8);
+      unsigned int blen = bstring[0] + (bstring[1] << 8);
+
+      if (alen == 0)
+	{
+	  copy_needed += blen * 2;
+	}
+      else if (blen == 0)
+	;
+      else if (alen != blen)
+	/* FIXME: Should we continue the loop in order to report other duplicates ?  */
+	break;
+      /* alen == blen != 0.  We might have two identical strings.  If so we
+	 can ignore the second one.  There is no need for wchar_t vs UTF-16
+	 theatrics here - we are only interested in (case sensitive) equality.  */
+      else if (memcmp (astring + 2, bstring + 2, alen * 2) != 0)
+	break;
+
+      astring += (alen + 1) * 2;
+      bstring += (blen + 1) * 2;
+    }
+
+  if (i != 16)
+    {
+      if (a->parent != NULL
+	  && a->parent->entry != NULL
+	  && a->parent->entry->is_name == FALSE)
+	_bfd_error_handler (_(".rsrc merge failure: duplicate string resource: %d"),
+			    ((a->parent->entry->name_id.id - 1) << 4) + i);
+      return FALSE;
+    }
+
+  if (copy_needed == 0)
+    return TRUE;
+
+  /* If we reach here then A and B must both have non-colliding strings.
+     (We never get string resources with fully empty string tables).
+     We need to allocate an extra COPY_NEEDED bytes in A and then bring
+     in B's strings.  */
+  new_data = bfd_malloc (a->value.leaf->size + copy_needed);
+  if (new_data == NULL)
+    return FALSE;
+
+  nstring = new_data;
+  astring = a->value.leaf->data;
+  bstring = b->value.leaf->data;
+
+  for (i = 0; i < 16; i++)
+    {
+      unsigned int alen = astring[0] + (astring[1] << 8);
+      unsigned int blen = bstring[0] + (bstring[1] << 8);
+
+      if (alen != 0)
+	{
+	  memcpy (nstring, astring, (alen + 1) * 2);
+	  nstring += (alen + 1) * 2;
+	}
+      else if (blen != 0)
+	{
+	  memcpy (nstring, bstring, (blen + 1) * 2);
+	  nstring += (blen + 1) * 2;
+	}
+      else
+	{
+	  * nstring++ = 0;
+	  * nstring++ = 0;
+	}
+
+      astring += (alen + 1) * 2;
+      bstring += (blen + 1) * 2;
+    }
+
+  BFD_ASSERT (nstring - new_data == (signed) (a->value.leaf->size + copy_needed));
+
+  free (a->value.leaf->data);
+  a->value.leaf->data = new_data;
+  a->value.leaf->size += copy_needed;
+
+  return TRUE;
+}
+
+static void rsrc_merge (rsrc_entry *, rsrc_entry *);
+
+/* Sort the entries in given part of the directory.
+   We use an old fashioned bubble sort because we are dealing
+   with lists and we want to handle matches specially.  */
+
+static void
+rsrc_sort_entries (rsrc_dir_chain *  chain,
+		   bfd_boolean       is_name,
+		   rsrc_directory *  dir)
+{
+  rsrc_entry * entry;
+  rsrc_entry * next;
+  rsrc_entry ** points_to_entry;
+  bfd_boolean swapped;
+
+  if (chain->num_entries < 2)
+    return;
+
+  do
+    {
+      swapped = FALSE;
+      points_to_entry = & chain->first_entry;
+      entry = * points_to_entry;
+      next  = entry->next_entry;
+
+      do
+	{
+	  signed int cmp = rsrc_cmp (is_name, entry, next);
+
+	  if (cmp > 0)
+	    {
+	      entry->next_entry = next->next_entry;
+	      next->next_entry = entry;
+	      * points_to_entry = next;
+	      points_to_entry = & next->next_entry;
+	      next = entry->next_entry;
+	      swapped = TRUE;
+	    }
+	  else if (cmp == 0)
+	    {
+	      if (entry->is_dir && next->is_dir)
+		{
+		  /* When we encounter identical directory entries we have to
+		     merge them together.  The exception to this rule is for
+		     resource manifests - there can only be one of these,
+		     even if they differ in language.  Zero-language manifests
+		     are assumed to be default manifests (provided by the
+		     Cygwin/MinGW build system) and these can be silently dropped,
+		     unless that would reduce the number of manifests to zero.
+		     There should only ever be one non-zero lang manifest -
+		     if there are more it is an error.  A non-zero lang
+		     manifest takes precedence over a default manifest.  */
+		  if (entry->is_name == FALSE
+		      && entry->name_id.id == 1
+		      && dir != NULL
+		      && dir->entry != NULL
+		      && dir->entry->is_name == FALSE
+		      && dir->entry->name_id.id == 0x18)
+		    {
+		      if (next->value.directory->names.num_entries == 0
+			  && next->value.directory->ids.num_entries == 1
+			  && next->value.directory->ids.first_entry->is_name == FALSE
+			  && next->value.directory->ids.first_entry->name_id.id == 0)
+			/* Fall through so that NEXT is dropped.  */
+			;
+		      else if (entry->value.directory->names.num_entries == 0
+			       && entry->value.directory->ids.num_entries == 1
+			       && entry->value.directory->ids.first_entry->is_name == FALSE
+			       && entry->value.directory->ids.first_entry->name_id.id == 0)
+			{
+			  /* Swap ENTRY and NEXT.  Then fall through so that the old ENTRY is dropped.  */
+			  entry->next_entry = next->next_entry;
+			  next->next_entry = entry;
+			  * points_to_entry = next;
+			  points_to_entry = & next->next_entry;
+			  next = entry->next_entry;
+			  swapped = TRUE;
+			}
+		      else
+			{
+			  _bfd_error_handler (_(".rsrc merge failure: multiple non-default manifests"));
+			  bfd_set_error (bfd_error_file_truncated);
+			  return;
+			}
+
+		      /* Unhook NEXT from the chain.  */
+		      /* FIXME: memory loss here.  */
+		      entry->next_entry = next->next_entry;
+		      chain->num_entries --;
+		      if (chain->num_entries < 2)
+			return;
+		      next = next->next_entry;
+		    }
+		  else
+		    rsrc_merge (entry, next);
+		}
+	      else if (entry->is_dir != next->is_dir)
+		{
+		  _bfd_error_handler (_(".rsrc merge failure: a directory matches a leaf"));
+		  bfd_set_error (bfd_error_file_truncated);
+		  return;
+		}
+	      else
+		{
+		  /* Otherwise with identical leaves we issue an error
+		     message - because there should never be duplicates.
+		     The exception is Type 18/Name 1/Lang 0 which is the
+		     defaul manifest - this can just be dropped.  */
+		  if (entry->is_name == FALSE
+		      && entry->name_id.id == 0
+		      && dir != NULL
+		      && dir->entry != NULL
+		      && dir->entry->is_name == FALSE
+		      && dir->entry->name_id.id == 1
+		      && dir->entry->parent != NULL
+		      && dir->entry->parent->entry != NULL
+		      && dir->entry->parent->entry->is_name == FALSE
+		      && dir->entry->parent->entry->name_id.id == 0x18 /* RT_MANIFEST */)
+		    ;
+		  else if (dir != NULL
+			   && dir->entry != NULL
+			   && dir->entry->parent != NULL
+			   && dir->entry->parent->entry != NULL
+			   && dir->entry->parent->entry->is_name == FALSE
+			   && dir->entry->parent->entry->name_id.id == 0x6 /* RT_STRING */)
+		    {
+		      /* Strings need special handling.  */
+		      if (! rsrc_merge_string_entries (entry, next))
+			{
+			  /* _bfd_error_handler should have been called inside merge_strings.  */
+			  bfd_set_error (bfd_error_file_truncated);
+			  return;
+			}
+		    }
+		  else
+		    {
+		      if (dir == NULL
+			  || dir->entry == NULL
+			  || dir->entry->parent == NULL
+			  || dir->entry->parent->entry == NULL)
+			_bfd_error_handler (_(".rsrc merge failure: duplicate leaf"));
+		      else
+			_bfd_error_handler (_(".rsrc merge failure: duplicate leaf: %s"),
+					    rsrc_resource_name (entry, dir));
+		      bfd_set_error (bfd_error_file_truncated);
+		      return;
+		    }
+		}
+
+	      /* Unhook NEXT from the chain.  */
+	      entry->next_entry = next->next_entry;
+	      chain->num_entries --;
+	      if (chain->num_entries < 2)
+		return;
+	      next = next->next_entry;
+	    }
+	  else
+	    {
+	      points_to_entry = & entry->next_entry;
+	      entry = next;
+	      next = next->next_entry;
+	    }
+	}
+      while (next);
+
+      chain->last_entry = entry;
+    }
+  while (swapped);
+}
+
+/* Attach B's chain onto A.  */
+static void
+rsrc_attach_chain (rsrc_dir_chain * achain, rsrc_dir_chain * bchain)
+{
+  if (bchain->num_entries == 0)
+    return;
+
+  achain->num_entries += bchain->num_entries;
+
+  if (achain->first_entry == NULL)
+    {
+      achain->first_entry = bchain->first_entry;
+      achain->last_entry  = bchain->last_entry;
+    }
+  else
+    {
+      achain->last_entry->next_entry = bchain->first_entry;
+      achain->last_entry = bchain->last_entry;
+    }
+
+  bchain->num_entries = 0;
+  bchain->first_entry = bchain->last_entry = NULL;
+}
+
+static void
+rsrc_merge (struct rsrc_entry * a, struct rsrc_entry * b)
+{
+  rsrc_directory * adir;
+  rsrc_directory * bdir;
+
+  BFD_ASSERT (a->is_dir);
+  BFD_ASSERT (b->is_dir);
+
+  adir = a->value.directory;
+  bdir = b->value.directory;
+
+  if (adir->characteristics != bdir->characteristics)
+    {
+      _bfd_error_handler (_(".rsrc merge failure: dirs with differing characteristics\n"));
+      bfd_set_error (bfd_error_file_truncated);
+      return;
+    }
+
+  if (adir->major != bdir->major || adir->minor != bdir->minor)
+    {
+      _bfd_error_handler (_(".rsrc merge failure: differing directory versions\n"));
+      bfd_set_error (bfd_error_file_truncated);
+      return;
+    }
+
+  /* Attach B's name chain to A.  */
+  rsrc_attach_chain (& adir->names, & bdir->names);
+
+  /* Attach B's ID chain to A.  */
+  rsrc_attach_chain (& adir->ids, & bdir->ids);
+
+  /* Now sort A's entries.  */
+  rsrc_sort_entries (& adir->names, TRUE, adir);
+  rsrc_sort_entries (& adir->ids, FALSE, adir);
+}
+
+/* Check the .rsrc section.  If it contains multiple concatenated
+   resources then we must merge them properly.  Otherwise Windows
+   will ignore all but the first set.  */
+
+static void
+rsrc_process_section (bfd * abfd,
+		      struct coff_final_link_info * pfinfo)
+{
+  rsrc_directory    new_table;
+  bfd_size_type     size;
+  asection *        sec;
+  pe_data_type *    pe;
+  bfd_vma           rva_bias;
+  bfd_byte *        data;
+  bfd_byte *        datastart;
+  bfd_byte *        dataend;
+  bfd_byte *        new_data;
+  unsigned int      num_resource_sets;
+  rsrc_directory *  type_tables;
+  rsrc_write_data   write_data;
+  unsigned int      indx;
+  bfd *             input;
+  unsigned int      num_input_rsrc = 0;
+  unsigned int      max_num_input_rsrc = 4;
+  ptrdiff_t *       rsrc_sizes = NULL;
+
+  new_table.names.num_entries = 0;
+  new_table.ids.num_entries = 0;
+
+  sec = bfd_get_section_by_name (abfd, ".rsrc");
+  if (sec == NULL || (size = sec->rawsize) == 0)
+    return;
+
+  pe = pe_data (abfd);
+  if (pe == NULL)
+    return;
+
+  rva_bias = sec->vma - pe->pe_opthdr.ImageBase;
+
+  data = bfd_malloc (size);
+  if (data == NULL)
+    return;
+
+  datastart = data;
+
+  if (! bfd_get_section_contents (abfd, sec, data, 0, size))
+    goto end;
+
+  /* Step zero: Scan the input bfds looking for .rsrc sections and record
+     their lengths.  Note - we rely upon the fact that the linker script
+     does *not* sort the input .rsrc sections, so that the order in the
+     linkinfo list matches the order in the output .rsrc section.
+
+     We need to know the lengths because each input .rsrc section has padding
+     at the end of a variable amount.  (It does not appear to be based upon
+     the section alignment or the file alignment).  We need to skip any
+     padding bytes when parsing the input .rsrc sections.  */
+  rsrc_sizes = bfd_malloc (max_num_input_rsrc * sizeof * rsrc_sizes);
+  if (rsrc_sizes == NULL)
+    goto end;
+
+  for (input = pfinfo->info->input_bfds;
+       input != NULL;
+       input = input->link.next)
+    {
+      asection * rsrc_sec = bfd_get_section_by_name (input, ".rsrc");
+
+      /* PR 18372 - skip discarded .rsrc sections.  */
+      if (rsrc_sec != NULL && !discarded_section (rsrc_sec))
+	{
+	  if (num_input_rsrc == max_num_input_rsrc)
+	    {
+	      max_num_input_rsrc += 10;
+	      rsrc_sizes = bfd_realloc (rsrc_sizes, max_num_input_rsrc
+					* sizeof * rsrc_sizes);
+	      if (rsrc_sizes == NULL)
+		goto end;
+	    }
+
+	  BFD_ASSERT (rsrc_sec->size > 0);
+	  rsrc_sizes [num_input_rsrc ++] = rsrc_sec->size;
+	}
+    }
+
+  if (num_input_rsrc < 2)
+    goto end;
+
+  /* Step one: Walk the section, computing the size of the tables,
+     leaves and data and decide if we need to do anything.  */
+  dataend = data + size;
+  num_resource_sets = 0;
+
+  while (data < dataend)
+    {
+      bfd_byte * p = data;
+
+      data = rsrc_count_directory (abfd, data, data, dataend, rva_bias);
+
+      if (data > dataend)
+	{
+	  /* Corrupted .rsrc section - cannot merge.  */
+	  _bfd_error_handler (_("%s: .rsrc merge failure: corrupt .rsrc section"),
+			      bfd_get_filename (abfd));
+	  bfd_set_error (bfd_error_file_truncated);
+	  goto end;
+	}
+
+      if ((data - p) > rsrc_sizes [num_resource_sets])
+	{
+	  _bfd_error_handler (_("%s: .rsrc merge failure: unexpected .rsrc size"),
+			      bfd_get_filename (abfd));
+	  bfd_set_error (bfd_error_file_truncated);
+	  goto end;
+	}
+      /* FIXME: Should we add a check for "data - p" being much smaller
+	 than rsrc_sizes[num_resource_sets] ?  */
+
+      data = p + rsrc_sizes[num_resource_sets];
+      rva_bias += data - p;
+      ++ num_resource_sets;
+    }
+  BFD_ASSERT (num_resource_sets == num_input_rsrc);
+
+  /* Step two: Walk the data again, building trees of the resources.  */
+  data = datastart;
+  rva_bias = sec->vma - pe->pe_opthdr.ImageBase;
+
+  type_tables = bfd_malloc (num_resource_sets * sizeof * type_tables);
+  if (type_tables == NULL)
+    goto end;
+
+  indx = 0;
+  while (data < dataend)
+    {
+      bfd_byte * p = data;
+
+      (void) rsrc_parse_directory (abfd, type_tables + indx, data, data,
+				   dataend, rva_bias, NULL);
+      data = p + rsrc_sizes[indx];
+      rva_bias += data - p;
+      ++ indx;
+    }
+  BFD_ASSERT (indx == num_resource_sets);
+
+  /* Step three: Merge the top level tables (there can be only one).
+
+     We must ensure that the merged entries are in ascending order.
+
+     We also thread the top level table entries from the old tree onto
+     the new table, so that they can be pulled off later.  */
+
+  /* FIXME: Should we verify that all type tables are the same ?  */
+  new_table.characteristics = type_tables[0].characteristics;
+  new_table.time            = type_tables[0].time;
+  new_table.major           = type_tables[0].major;
+  new_table.minor           = type_tables[0].minor;
+
+  /* Chain the NAME entries onto the table.  */
+  new_table.names.first_entry = NULL;
+  new_table.names.last_entry = NULL;
+
+  for (indx = 0; indx < num_resource_sets; indx++)
+    rsrc_attach_chain (& new_table.names, & type_tables[indx].names);
+
+  rsrc_sort_entries (& new_table.names, TRUE, & new_table);
+
+  /* Chain the ID entries onto the table.  */
+  new_table.ids.first_entry = NULL;
+  new_table.ids.last_entry = NULL;
+
+  for (indx = 0; indx < num_resource_sets; indx++)
+    rsrc_attach_chain (& new_table.ids, & type_tables[indx].ids);
+
+  rsrc_sort_entries (& new_table.ids, FALSE, & new_table);
+
+  /* Step four: Create new contents for the .rsrc section.  */
+  /* Step four point one: Compute the size of each region of the .rsrc section.
+     We do this now, rather than earlier, as the merging above may have dropped
+     some entries.  */
+  sizeof_leaves = sizeof_strings = sizeof_tables_and_entries = 0;
+  rsrc_compute_region_sizes (& new_table);
+  /* We increment sizeof_strings to make sure that resource data
+     starts on an 8-byte boundary.  FIXME: Is this correct ?  */
+  sizeof_strings = (sizeof_strings + 7) & ~ 7;
+
+  new_data = bfd_zalloc (abfd, size);
+  if (new_data == NULL)
+    goto end;
+
+  write_data.abfd        = abfd;
+  write_data.datastart   = new_data;
+  write_data.next_table  = new_data;
+  write_data.next_leaf   = new_data + sizeof_tables_and_entries;
+  write_data.next_string = write_data.next_leaf + sizeof_leaves;
+  write_data.next_data   = write_data.next_string + sizeof_strings;
+  write_data.rva_bias    = sec->vma - pe->pe_opthdr.ImageBase;
+
+  rsrc_write_directory (& write_data, & new_table);
+
+  /* Step five: Replace the old contents with the new.
+     We recompute the size as we may have lost entries due to mergeing.  */
+  size = ((write_data.next_data - new_data) + 3) & ~ 3;
+
+  {
+    int page_size;
+
+    if (coff_data (abfd)->link_info)
+      {
+	page_size = pe_data (abfd)->pe_opthdr.FileAlignment;
+
+	/* If no file alignment has been set, default to one.
+	   This repairs 'ld -r' for arm-wince-pe target.  */
+	if (page_size == 0)
+	  page_size = 1;
+      }
+    else
+      page_size = PE_DEF_FILE_ALIGNMENT;
+    size = (size + page_size - 1) & - page_size;
+  }
+
+  bfd_set_section_contents (pfinfo->output_bfd, sec, new_data, 0, size);
+  sec->size = sec->rawsize = size;
+
+ end:
+  /* Step six: Free all the memory that we have used.  */
+  /* FIXME: Free the resource tree, if we have one.  */
+  free (datastart);
+  free (rsrc_sizes);
+}
+
+/* Handle the .idata section and other things that need symbol table
+   access.  */
+
+bfd_boolean
+_bfd_XXi_final_link_postscript (bfd * abfd, struct coff_final_link_info *pfinfo)
+{
+  struct coff_link_hash_entry *h1;
+  struct bfd_link_info *info = pfinfo->info;
+  bfd_boolean result = TRUE;
+
+  /* There are a few fields that need to be filled in now while we
+     have symbol table access.
+
+     The .idata subsections aren't directly available as sections, but
+     they are in the symbol table, so get them from there.  */
+
+  /* The import directory.  This is the address of .idata$2, with size
+     of .idata$2 + .idata$3.  */
+  h1 = coff_link_hash_lookup (coff_hash_table (info),
+			      ".idata$2", FALSE, FALSE, TRUE);
+  if (h1 != NULL)
+    {
+      /* PR ld/2729: We cannot rely upon all the output sections having been
+	 created properly, so check before referencing them.  Issue a warning
+	 message for any sections tht could not be found.  */
+      if ((h1->root.type == bfd_link_hash_defined
+	   || h1->root.type == bfd_link_hash_defweak)
+	  && h1->root.u.def.section != NULL
+	  && h1->root.u.def.section->output_section != NULL)
+	pe_data (abfd)->pe_opthdr.DataDirectory[PE_IMPORT_TABLE].VirtualAddress =
+	  (h1->root.u.def.value
+	   + h1->root.u.def.section->output_section->vma
+	   + h1->root.u.def.section->output_offset);
+      else
+	{
+	  _bfd_error_handler
+	    (_("%B: unable to fill in DataDictionary[1] because .idata$2 is missing"),
+	     abfd);
+	  result = FALSE;
+	}
+
+      h1 = coff_link_hash_lookup (coff_hash_table (info),
+				  ".idata$4", FALSE, FALSE, TRUE);
+      if (h1 != NULL
+	  && (h1->root.type == bfd_link_hash_defined
+	   || h1->root.type == bfd_link_hash_defweak)
+	  && h1->root.u.def.section != NULL
+	  && h1->root.u.def.section->output_section != NULL)
+	pe_data (abfd)->pe_opthdr.DataDirectory[PE_IMPORT_TABLE].Size =
+	  ((h1->root.u.def.value
+	    + h1->root.u.def.section->output_section->vma
+	    + h1->root.u.def.section->output_offset)
+	   - pe_data (abfd)->pe_opthdr.DataDirectory[PE_IMPORT_TABLE].VirtualAddress);
+      else
+	{
+	  _bfd_error_handler
+	    (_("%B: unable to fill in DataDictionary[1] because .idata$4 is missing"),
+	     abfd);
+	  result = FALSE;
+	}
+
+      /* The import address table.  This is the size/address of
+         .idata$5.  */
+      h1 = coff_link_hash_lookup (coff_hash_table (info),
+				  ".idata$5", FALSE, FALSE, TRUE);
+      if (h1 != NULL
+	  && (h1->root.type == bfd_link_hash_defined
+	   || h1->root.type == bfd_link_hash_defweak)
+	  && h1->root.u.def.section != NULL
+	  && h1->root.u.def.section->output_section != NULL)
+	pe_data (abfd)->pe_opthdr.DataDirectory[PE_IMPORT_ADDRESS_TABLE].VirtualAddress =
+	  (h1->root.u.def.value
+	   + h1->root.u.def.section->output_section->vma
+	   + h1->root.u.def.section->output_offset);
+      else
+	{
+	  _bfd_error_handler
+	    (_("%B: unable to fill in DataDictionary[12] because .idata$5 is missing"),
+	     abfd);
+	  result = FALSE;
+	}
+
+      h1 = coff_link_hash_lookup (coff_hash_table (info),
+				  ".idata$6", FALSE, FALSE, TRUE);
+      if (h1 != NULL
+	  && (h1->root.type == bfd_link_hash_defined
+	   || h1->root.type == bfd_link_hash_defweak)
+	  && h1->root.u.def.section != NULL
+	  && h1->root.u.def.section->output_section != NULL)
+	pe_data (abfd)->pe_opthdr.DataDirectory[PE_IMPORT_ADDRESS_TABLE].Size =
+	  ((h1->root.u.def.value
+	    + h1->root.u.def.section->output_section->vma
+	    + h1->root.u.def.section->output_offset)
+	   - pe_data (abfd)->pe_opthdr.DataDirectory[PE_IMPORT_ADDRESS_TABLE].VirtualAddress);
+      else
+	{
+	  _bfd_error_handler
+	    (_("%B: unable to fill in DataDictionary[PE_IMPORT_ADDRESS_TABLE (12)] because .idata$6 is missing"),
+	     abfd);
+	  result = FALSE;
+	}
+    }
+  else
+    {
+      h1 = coff_link_hash_lookup (coff_hash_table (info),
+				  "__IAT_start__", FALSE, FALSE, TRUE);
+      if (h1 != NULL
+	  && (h1->root.type == bfd_link_hash_defined
+	   || h1->root.type == bfd_link_hash_defweak)
+	  && h1->root.u.def.section != NULL
+	  && h1->root.u.def.section->output_section != NULL)
+	{
+	  bfd_vma iat_va;
+
+	  iat_va =
+	    (h1->root.u.def.value
+	     + h1->root.u.def.section->output_section->vma
+	     + h1->root.u.def.section->output_offset);
+
+	  h1 = coff_link_hash_lookup (coff_hash_table (info),
+				      "__IAT_end__", FALSE, FALSE, TRUE);
+	  if (h1 != NULL
+	      && (h1->root.type == bfd_link_hash_defined
+	       || h1->root.type == bfd_link_hash_defweak)
+	      && h1->root.u.def.section != NULL
+	      && h1->root.u.def.section->output_section != NULL)
+	    {
+	      pe_data (abfd)->pe_opthdr.DataDirectory[PE_IMPORT_ADDRESS_TABLE].Size =
+		((h1->root.u.def.value
+		  + h1->root.u.def.section->output_section->vma
+		  + h1->root.u.def.section->output_offset)
+		 - iat_va);
+	      if (pe_data (abfd)->pe_opthdr.DataDirectory[PE_IMPORT_ADDRESS_TABLE].Size != 0)
+		pe_data (abfd)->pe_opthdr.DataDirectory[PE_IMPORT_ADDRESS_TABLE].VirtualAddress =
+		  iat_va - pe_data (abfd)->pe_opthdr.ImageBase;
+	    }
+	  else
+	    {
+	      _bfd_error_handler
+		(_("%B: unable to fill in DataDictionary[PE_IMPORT_ADDRESS_TABLE(12)]"
+		   " because .idata$6 is missing"), abfd);
+	      result = FALSE;
+	    }
+        }
+    }
+
+  h1 = coff_link_hash_lookup (coff_hash_table (info),
+			      (bfd_get_symbol_leading_char (abfd) != 0
+			       ? "__tls_used" : "_tls_used"),
+			      FALSE, FALSE, TRUE);
+  if (h1 != NULL)
+    {
+      if ((h1->root.type == bfd_link_hash_defined
+	   || h1->root.type == bfd_link_hash_defweak)
+	  && h1->root.u.def.section != NULL
+	  && h1->root.u.def.section->output_section != NULL)
+	pe_data (abfd)->pe_opthdr.DataDirectory[PE_TLS_TABLE].VirtualAddress =
+	  (h1->root.u.def.value
+	   + h1->root.u.def.section->output_section->vma
+	   + h1->root.u.def.section->output_offset
+	   - pe_data (abfd)->pe_opthdr.ImageBase);
+      else
+	{
+	  _bfd_error_handler
+	    (_("%B: unable to fill in DataDictionary[9] because __tls_used is missing"),
+	     abfd);
+	  result = FALSE;
+	}
+     /* According to PECOFF sepcifications by Microsoft version 8.2
+	the TLS data directory consists of 4 pointers, followed
+	by two 4-byte integer. This implies that the total size
+	is different for 32-bit and 64-bit executables.  */
+#if !defined(COFF_WITH_pep) && !defined(COFF_WITH_pex64)
+      pe_data (abfd)->pe_opthdr.DataDirectory[PE_TLS_TABLE].Size = 0x18;
+#else
+      pe_data (abfd)->pe_opthdr.DataDirectory[PE_TLS_TABLE].Size = 0x28;
+#endif
+    }
+
+/* If there is a .pdata section and we have linked pdata finally, we
+     need to sort the entries ascending.  */
+#if !defined(COFF_WITH_pep) && defined(COFF_WITH_pex64)
+  {
+    asection *sec = bfd_get_section_by_name (abfd, ".pdata");
+
+    if (sec)
+      {
+	bfd_size_type x = sec->rawsize;
+	bfd_byte *tmp_data = NULL;
+
+	if (x)
+	  tmp_data = bfd_malloc (x);
+
+	if (tmp_data != NULL)
+	  {
+	    if (bfd_get_section_contents (abfd, sec, tmp_data, 0, x))
+	      {
+		qsort (tmp_data,
+		       (size_t) (x / 12),
+		       12, sort_x64_pdata);
+		bfd_set_section_contents (pfinfo->output_bfd, sec,
+					  tmp_data, 0, x);
+	      }
+	    free (tmp_data);
+	  }
+	else
+	  result = FALSE;
+      }
+  }
+#endif
+
+  rsrc_process_section (abfd, pfinfo);
+
+  /* If we couldn't find idata$2, we either have an excessively
+     trivial program or are in DEEP trouble; we have to assume trivial
+     program....  */
+  return result;
+}
diff -Naur binutils-2.26/bfd/pei-arm-winnt.c binutils-2.26.0007/bfd/pei-arm-winnt.c
--- binutils-2.26/bfd/pei-arm-winnt.c	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.26.0007/bfd/pei-arm-winnt.c	2016-03-10 17:02:24.204052839 +0100
@@ -0,0 +1,31 @@
+/* BFD back-end for ARM WINNT PE IMAGE COFF files.
+   Copyright (C) 2006-2014 Free Software Foundation, Inc.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#define TARGET_UNDERSCORE    0
+#define USER_LABEL_PREFIX    ""
+
+#define TARGET_LITTLE_SYM    arm_pei_winnt_le_vec
+#define TARGET_LITTLE_NAME   "pei-arm-winnt-little"
+#define TARGET_BIG_SYM       arm_pei_winnt_be_vec
+#define TARGET_BIG_NAME      "pei-arm-winnt-big"
+
+#define LOCAL_LABEL_PREFIX "."
+
+#include "pei-arm.c"
diff -Naur binutils-2.26/bfd/peicode.h binutils-2.26.0007/bfd/peicode.h
--- binutils-2.26/bfd/peicode.h	2015-11-13 09:27:40.000000000 +0100
+++ binutils-2.26.0007/bfd/peicode.h	2016-03-10 17:02:24.217385878 +0100
@@ -733,6 +733,13 @@
     16, 12
   },
 #endif
+#ifdef ARMNTPEMAGIC
+  { ARMNTPEMAGIC,
+    { 0x40, 0xf2, 0x00, 0x0c, 0xc0, 0xf2,
+      0x00, 0x0c, 0xdc, 0xf8, 0x00, 0xf0 },
+    12, 0
+  },
+#endif
   { 0, { 0 }, 0, 0 }
 };
 
@@ -1204,6 +1211,17 @@
       }
 #endif
       break;
+
+    case IMAGE_FILE_MACHINE_ARMNT:
+#ifdef ARMNTPEMAGIC
+      {
+  extern const bfd_target TARGET_LITTLE_SYM;
+
+  if (abfd->xvec == & TARGET_LITTLE_SYM)
+    magic = ARMNTPEMAGIC;
+      }
+#endif
+      break;
 
     case IMAGE_FILE_MACHINE_POWERPC:
       /* We no longer support PowerPC.  */
diff -Naur binutils-2.26/bfd/peicode.h.orig binutils-2.26.0007/bfd/peicode.h.orig
--- binutils-2.26/bfd/peicode.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.26.0007/bfd/peicode.h.orig	2016-03-10 17:01:59.024607456 +0100
@@ -0,0 +1,1492 @@
+/* Support for the generic parts of PE/PEI, for BFD.
+   Copyright (C) 1995-2015 Free Software Foundation, Inc.
+   Written by Cygnus Solutions.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+
+/* Most of this hacked by  Steve Chamberlain,
+			sac@cygnus.com
+
+   PE/PEI rearrangement (and code added): Donn Terry
+                                       Softway Systems, Inc.  */
+
+/* Hey look, some documentation [and in a place you expect to find it]!
+
+   The main reference for the pei format is "Microsoft Portable Executable
+   and Common Object File Format Specification 4.1".  Get it if you need to
+   do some serious hacking on this code.
+
+   Another reference:
+   "Peering Inside the PE: A Tour of the Win32 Portable Executable
+   File Format", MSJ 1994, Volume 9.
+
+   The *sole* difference between the pe format and the pei format is that the
+   latter has an MSDOS 2.0 .exe header on the front that prints the message
+   "This app must be run under Windows." (or some such).
+   (FIXME: Whether that statement is *really* true or not is unknown.
+   Are there more subtle differences between pe and pei formats?
+   For now assume there aren't.  If you find one, then for God sakes
+   document it here!)
+
+   The Microsoft docs use the word "image" instead of "executable" because
+   the former can also refer to a DLL (shared library).  Confusion can arise
+   because the `i' in `pei' also refers to "image".  The `pe' format can
+   also create images (i.e. executables), it's just that to run on a win32
+   system you need to use the pei format.
+
+   FIXME: Please add more docs here so the next poor fool that has to hack
+   on this code has a chance of getting something accomplished without
+   wasting too much time.  */
+
+#include "libpei.h"
+
+static bfd_boolean (*pe_saved_coff_bfd_print_private_bfd_data) (bfd *, void *) =
+#ifndef coff_bfd_print_private_bfd_data
+     NULL;
+#else
+     coff_bfd_print_private_bfd_data;
+#undef coff_bfd_print_private_bfd_data
+#endif
+
+static bfd_boolean                      pe_print_private_bfd_data (bfd *, void *);
+#define coff_bfd_print_private_bfd_data pe_print_private_bfd_data
+
+static bfd_boolean (*pe_saved_coff_bfd_copy_private_bfd_data) (bfd *, bfd *) =
+#ifndef coff_bfd_copy_private_bfd_data
+     NULL;
+#else
+     coff_bfd_copy_private_bfd_data;
+#undef coff_bfd_copy_private_bfd_data
+#endif
+
+static bfd_boolean                     pe_bfd_copy_private_bfd_data (bfd *, bfd *);
+#define coff_bfd_copy_private_bfd_data pe_bfd_copy_private_bfd_data
+
+#define coff_mkobject      pe_mkobject
+#define coff_mkobject_hook pe_mkobject_hook
+
+#ifdef COFF_IMAGE_WITH_PE
+/* This structure contains static variables used by the ILF code.  */
+typedef asection * asection_ptr;
+
+typedef struct
+{
+  bfd *			abfd;
+  bfd_byte *		data;
+  struct bfd_in_memory * bim;
+  unsigned short        magic;
+
+  arelent *		reltab;
+  unsigned int 		relcount;
+
+  coff_symbol_type * 	sym_cache;
+  coff_symbol_type * 	sym_ptr;
+  unsigned int       	sym_index;
+
+  unsigned int * 	sym_table;
+  unsigned int * 	table_ptr;
+
+  combined_entry_type * native_syms;
+  combined_entry_type * native_ptr;
+
+  coff_symbol_type **	sym_ptr_table;
+  coff_symbol_type **	sym_ptr_ptr;
+
+  unsigned int		sec_index;
+
+  char *                string_table;
+  char *                string_ptr;
+  char *		end_string_ptr;
+
+  SYMENT *              esym_table;
+  SYMENT *              esym_ptr;
+
+  struct internal_reloc * int_reltab;
+}
+pe_ILF_vars;
+#endif /* COFF_IMAGE_WITH_PE */
+
+const bfd_target *coff_real_object_p
+  (bfd *, unsigned, struct internal_filehdr *, struct internal_aouthdr *);
+
+#ifndef NO_COFF_RELOCS
+static void
+coff_swap_reloc_in (bfd * abfd, void * src, void * dst)
+{
+  RELOC *reloc_src = (RELOC *) src;
+  struct internal_reloc *reloc_dst = (struct internal_reloc *) dst;
+
+  reloc_dst->r_vaddr  = H_GET_32 (abfd, reloc_src->r_vaddr);
+  reloc_dst->r_symndx = H_GET_S32 (abfd, reloc_src->r_symndx);
+  reloc_dst->r_type   = H_GET_16 (abfd, reloc_src->r_type);
+#ifdef SWAP_IN_RELOC_OFFSET
+  reloc_dst->r_offset = SWAP_IN_RELOC_OFFSET (abfd, reloc_src->r_offset);
+#endif
+}
+
+static unsigned int
+coff_swap_reloc_out (bfd * abfd, void * src, void * dst)
+{
+  struct internal_reloc *reloc_src = (struct internal_reloc *) src;
+  struct external_reloc *reloc_dst = (struct external_reloc *) dst;
+
+  H_PUT_32 (abfd, reloc_src->r_vaddr, reloc_dst->r_vaddr);
+  H_PUT_32 (abfd, reloc_src->r_symndx, reloc_dst->r_symndx);
+  H_PUT_16 (abfd, reloc_src->r_type, reloc_dst->r_type);
+
+#ifdef SWAP_OUT_RELOC_OFFSET
+  SWAP_OUT_RELOC_OFFSET (abfd, reloc_src->r_offset, reloc_dst->r_offset);
+#endif
+#ifdef SWAP_OUT_RELOC_EXTRA
+  SWAP_OUT_RELOC_EXTRA (abfd, reloc_src, reloc_dst);
+#endif
+  return RELSZ;
+}
+#endif /* not NO_COFF_RELOCS */
+
+#ifdef COFF_IMAGE_WITH_PE
+#undef FILHDR
+#define FILHDR struct external_PEI_IMAGE_hdr
+#endif
+
+static void
+coff_swap_filehdr_in (bfd * abfd, void * src, void * dst)
+{
+  FILHDR *filehdr_src = (FILHDR *) src;
+  struct internal_filehdr *filehdr_dst = (struct internal_filehdr *) dst;
+
+  filehdr_dst->f_magic  = H_GET_16 (abfd, filehdr_src->f_magic);
+  filehdr_dst->f_nscns  = H_GET_16 (abfd, filehdr_src->f_nscns);
+  filehdr_dst->f_timdat = H_GET_32 (abfd, filehdr_src->f_timdat);
+  filehdr_dst->f_nsyms  = H_GET_32 (abfd, filehdr_src->f_nsyms);
+  filehdr_dst->f_flags  = H_GET_16 (abfd, filehdr_src->f_flags);
+  filehdr_dst->f_symptr = H_GET_32 (abfd, filehdr_src->f_symptr);
+
+  /* Other people's tools sometimes generate headers with an nsyms but
+     a zero symptr.  */
+  if (filehdr_dst->f_nsyms != 0 && filehdr_dst->f_symptr == 0)
+    {
+      filehdr_dst->f_nsyms = 0;
+      filehdr_dst->f_flags |= F_LSYMS;
+    }
+
+  filehdr_dst->f_opthdr = H_GET_16 (abfd, filehdr_src-> f_opthdr);
+}
+
+#ifdef COFF_IMAGE_WITH_PE
+# define coff_swap_filehdr_out _bfd_XXi_only_swap_filehdr_out
+#elif defined COFF_WITH_pex64
+# define coff_swap_filehdr_out _bfd_pex64_only_swap_filehdr_out
+#elif defined COFF_WITH_pep
+# define coff_swap_filehdr_out _bfd_pep_only_swap_filehdr_out
+#else
+# define coff_swap_filehdr_out _bfd_pe_only_swap_filehdr_out
+#endif
+
+static void
+coff_swap_scnhdr_in (bfd * abfd, void * ext, void * in)
+{
+  SCNHDR *scnhdr_ext = (SCNHDR *) ext;
+  struct internal_scnhdr *scnhdr_int = (struct internal_scnhdr *) in;
+
+  memcpy (scnhdr_int->s_name, scnhdr_ext->s_name, sizeof (scnhdr_int->s_name));
+
+  scnhdr_int->s_vaddr   = GET_SCNHDR_VADDR (abfd, scnhdr_ext->s_vaddr);
+  scnhdr_int->s_paddr   = GET_SCNHDR_PADDR (abfd, scnhdr_ext->s_paddr);
+  scnhdr_int->s_size    = GET_SCNHDR_SIZE (abfd, scnhdr_ext->s_size);
+  scnhdr_int->s_scnptr  = GET_SCNHDR_SCNPTR (abfd, scnhdr_ext->s_scnptr);
+  scnhdr_int->s_relptr  = GET_SCNHDR_RELPTR (abfd, scnhdr_ext->s_relptr);
+  scnhdr_int->s_lnnoptr = GET_SCNHDR_LNNOPTR (abfd, scnhdr_ext->s_lnnoptr);
+  scnhdr_int->s_flags   = H_GET_32 (abfd, scnhdr_ext->s_flags);
+
+  /* MS handles overflow of line numbers by carrying into the reloc
+     field (it appears).  Since it's supposed to be zero for PE
+     *IMAGE* format, that's safe.  This is still a bit iffy.  */
+#ifdef COFF_IMAGE_WITH_PE
+  scnhdr_int->s_nlnno = (H_GET_16 (abfd, scnhdr_ext->s_nlnno)
+			 + (H_GET_16 (abfd, scnhdr_ext->s_nreloc) << 16));
+  scnhdr_int->s_nreloc = 0;
+#else
+  scnhdr_int->s_nreloc = H_GET_16 (abfd, scnhdr_ext->s_nreloc);
+  scnhdr_int->s_nlnno = H_GET_16 (abfd, scnhdr_ext->s_nlnno);
+#endif
+
+  if (scnhdr_int->s_vaddr != 0)
+    {
+      scnhdr_int->s_vaddr += pe_data (abfd)->pe_opthdr.ImageBase;
+      /* Do not cut upper 32-bits for 64-bit vma.  */
+#ifndef COFF_WITH_pex64
+      scnhdr_int->s_vaddr &= 0xffffffff;
+#endif
+    }
+
+#ifndef COFF_NO_HACK_SCNHDR_SIZE
+  /* If this section holds uninitialized data and is from an object file
+     or from an executable image that has not initialized the field,
+     or if the image is an executable file and the physical size is padded,
+     use the virtual size (stored in s_paddr) instead.  */
+  if (scnhdr_int->s_paddr > 0
+      && (((scnhdr_int->s_flags & IMAGE_SCN_CNT_UNINITIALIZED_DATA) != 0
+	   && (! bfd_pei_p (abfd) || scnhdr_int->s_size == 0))
+          || (bfd_pei_p (abfd) && (scnhdr_int->s_size > scnhdr_int->s_paddr))))
+  /* This code used to set scnhdr_int->s_paddr to 0.  However,
+     coff_set_alignment_hook stores s_paddr in virt_size, which
+     only works if it correctly holds the virtual size of the
+     section.  */
+    scnhdr_int->s_size = scnhdr_int->s_paddr;
+#endif
+}
+
+static bfd_boolean
+pe_mkobject (bfd * abfd)
+{
+  pe_data_type *pe;
+  bfd_size_type amt = sizeof (pe_data_type);
+
+  abfd->tdata.pe_obj_data = (struct pe_tdata *) bfd_zalloc (abfd, amt);
+
+  if (abfd->tdata.pe_obj_data == 0)
+    return FALSE;
+
+  pe = pe_data (abfd);
+
+  pe->coff.pe = 1;
+
+  /* in_reloc_p is architecture dependent.  */
+  pe->in_reloc_p = in_reloc_p;
+
+  memset (& pe->pe_opthdr, 0, sizeof pe->pe_opthdr);
+  return TRUE;
+}
+
+/* Create the COFF backend specific information.  */
+
+static void *
+pe_mkobject_hook (bfd * abfd,
+		  void * filehdr,
+		  void * aouthdr ATTRIBUTE_UNUSED)
+{
+  struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;
+  pe_data_type *pe;
+
+  if (! pe_mkobject (abfd))
+    return NULL;
+
+  pe = pe_data (abfd);
+  pe->coff.sym_filepos = internal_f->f_symptr;
+  /* These members communicate important constants about the symbol
+     table to GDB's symbol-reading code.  These `constants'
+     unfortunately vary among coff implementations...  */
+  pe->coff.local_n_btmask = N_BTMASK;
+  pe->coff.local_n_btshft = N_BTSHFT;
+  pe->coff.local_n_tmask = N_TMASK;
+  pe->coff.local_n_tshift = N_TSHIFT;
+  pe->coff.local_symesz = SYMESZ;
+  pe->coff.local_auxesz = AUXESZ;
+  pe->coff.local_linesz = LINESZ;
+
+  pe->coff.timestamp = internal_f->f_timdat;
+
+  obj_raw_syment_count (abfd) =
+    obj_conv_table_size (abfd) =
+      internal_f->f_nsyms;
+
+  pe->real_flags = internal_f->f_flags;
+
+  if ((internal_f->f_flags & F_DLL) != 0)
+    pe->dll = 1;
+
+  if ((internal_f->f_flags & IMAGE_FILE_DEBUG_STRIPPED) == 0)
+    abfd->flags |= HAS_DEBUG;
+
+#ifdef COFF_IMAGE_WITH_PE
+  if (aouthdr)
+    pe->pe_opthdr = ((struct internal_aouthdr *) aouthdr)->pe;
+#endif
+
+#ifdef ARM
+  if (! _bfd_coff_arm_set_private_flags (abfd, internal_f->f_flags))
+    coff_data (abfd) ->flags = 0;
+#endif
+
+  return (void *) pe;
+}
+
+static bfd_boolean
+pe_print_private_bfd_data (bfd *abfd, void * vfile)
+{
+  FILE *file = (FILE *) vfile;
+
+  if (!_bfd_XX_print_private_bfd_data_common (abfd, vfile))
+    return FALSE;
+
+  if (pe_saved_coff_bfd_print_private_bfd_data == NULL)
+    return TRUE;
+
+  fputc ('\n', file);
+
+  return pe_saved_coff_bfd_print_private_bfd_data (abfd, vfile);
+}
+
+/* Copy any private info we understand from the input bfd
+   to the output bfd.  */
+
+static bfd_boolean
+pe_bfd_copy_private_bfd_data (bfd *ibfd, bfd *obfd)
+{
+  /* PR binutils/716: Copy the large address aware flag.
+     XXX: Should we be copying other flags or other fields in the pe_data()
+     structure ?  */
+  if (pe_data (obfd) != NULL
+      && pe_data (ibfd) != NULL
+      && pe_data (ibfd)->real_flags & IMAGE_FILE_LARGE_ADDRESS_AWARE)
+    pe_data (obfd)->real_flags |= IMAGE_FILE_LARGE_ADDRESS_AWARE;
+
+  if (!_bfd_XX_bfd_copy_private_bfd_data_common (ibfd, obfd))
+    return FALSE;
+
+  if (pe_saved_coff_bfd_copy_private_bfd_data)
+    return pe_saved_coff_bfd_copy_private_bfd_data (ibfd, obfd);
+
+  return TRUE;
+}
+
+#define coff_bfd_copy_private_section_data \
+  _bfd_XX_bfd_copy_private_section_data
+
+#define coff_get_symbol_info _bfd_XX_get_symbol_info
+
+#ifdef COFF_IMAGE_WITH_PE
+
+/* Code to handle Microsoft's Image Library Format.
+   Also known as LINK6 format.
+   Documentation about this format can be found at:
+
+   http://msdn.microsoft.com/library/specs/pecoff_section8.htm  */
+
+/* The following constants specify the sizes of the various data
+   structures that we have to create in order to build a bfd describing
+   an ILF object file.  The final "+ 1" in the definitions of SIZEOF_IDATA6
+   and SIZEOF_IDATA7 below is to allow for the possibility that we might
+   need a padding byte in order to ensure 16 bit alignment for the section's
+   contents.
+
+   The value for SIZEOF_ILF_STRINGS is computed as follows:
+
+      There will be NUM_ILF_SECTIONS section symbols.  Allow 9 characters
+      per symbol for their names (longest section name is .idata$x).
+
+      There will be two symbols for the imported value, one the symbol name
+      and one with _imp__ prefixed.  Allowing for the terminating nul's this
+      is strlen (symbol_name) * 2 + 8 + 21 + strlen (source_dll).
+
+      The strings in the string table must start STRING__SIZE_SIZE bytes into
+      the table in order to for the string lookup code in coffgen/coffcode to
+      work.  */
+#define NUM_ILF_RELOCS		8
+#define NUM_ILF_SECTIONS        6
+#define NUM_ILF_SYMS 		(2 + NUM_ILF_SECTIONS)
+
+#define SIZEOF_ILF_SYMS		 (NUM_ILF_SYMS * sizeof (* vars.sym_cache))
+#define SIZEOF_ILF_SYM_TABLE	 (NUM_ILF_SYMS * sizeof (* vars.sym_table))
+#define SIZEOF_ILF_NATIVE_SYMS	 (NUM_ILF_SYMS * sizeof (* vars.native_syms))
+#define SIZEOF_ILF_SYM_PTR_TABLE (NUM_ILF_SYMS * sizeof (* vars.sym_ptr_table))
+#define SIZEOF_ILF_EXT_SYMS	 (NUM_ILF_SYMS * sizeof (* vars.esym_table))
+#define SIZEOF_ILF_RELOCS	 (NUM_ILF_RELOCS * sizeof (* vars.reltab))
+#define SIZEOF_ILF_INT_RELOCS	 (NUM_ILF_RELOCS * sizeof (* vars.int_reltab))
+#define SIZEOF_ILF_STRINGS	 (strlen (symbol_name) * 2 + 8 \
+					+ 21 + strlen (source_dll) \
+					+ NUM_ILF_SECTIONS * 9 \
+					+ STRING_SIZE_SIZE)
+#define SIZEOF_IDATA2		(5 * 4)
+
+/* For PEx64 idata4 & 5 have thumb size of 8 bytes.  */
+#ifdef COFF_WITH_pex64
+#define SIZEOF_IDATA4		(2 * 4)
+#define SIZEOF_IDATA5		(2 * 4)
+#else
+#define SIZEOF_IDATA4		(1 * 4)
+#define SIZEOF_IDATA5		(1 * 4)
+#endif
+
+#define SIZEOF_IDATA6		(2 + strlen (symbol_name) + 1 + 1)
+#define SIZEOF_IDATA7		(strlen (source_dll) + 1 + 1)
+#define SIZEOF_ILF_SECTIONS     (NUM_ILF_SECTIONS * sizeof (struct coff_section_tdata))
+
+#define ILF_DATA_SIZE				\
+    + SIZEOF_ILF_SYMS				\
+    + SIZEOF_ILF_SYM_TABLE			\
+    + SIZEOF_ILF_NATIVE_SYMS			\
+    + SIZEOF_ILF_SYM_PTR_TABLE			\
+    + SIZEOF_ILF_EXT_SYMS			\
+    + SIZEOF_ILF_RELOCS				\
+    + SIZEOF_ILF_INT_RELOCS			\
+    + SIZEOF_ILF_STRINGS			\
+    + SIZEOF_IDATA2				\
+    + SIZEOF_IDATA4				\
+    + SIZEOF_IDATA5				\
+    + SIZEOF_IDATA6				\
+    + SIZEOF_IDATA7				\
+    + SIZEOF_ILF_SECTIONS			\
+    + MAX_TEXT_SECTION_SIZE
+
+/* Create an empty relocation against the given symbol.  */
+
+static void
+pe_ILF_make_a_symbol_reloc (pe_ILF_vars *               vars,
+			    bfd_vma                     address,
+			    bfd_reloc_code_real_type    reloc,
+			    struct bfd_symbol **  	sym,
+			    unsigned int                sym_index)
+{
+  arelent * entry;
+  struct internal_reloc * internal;
+
+  entry = vars->reltab + vars->relcount;
+  internal = vars->int_reltab + vars->relcount;
+
+  entry->address     = address;
+  entry->addend      = 0;
+  entry->howto       = bfd_reloc_type_lookup (vars->abfd, reloc);
+  entry->sym_ptr_ptr = sym;
+
+  internal->r_vaddr  = address;
+  internal->r_symndx = sym_index;
+  internal->r_type   = entry->howto->type;
+
+  vars->relcount ++;
+
+  BFD_ASSERT (vars->relcount <= NUM_ILF_RELOCS);
+}
+
+/* Create an empty relocation against the given section.  */
+
+static void
+pe_ILF_make_a_reloc (pe_ILF_vars *             vars,
+		     bfd_vma                   address,
+		     bfd_reloc_code_real_type  reloc,
+		     asection_ptr              sec)
+{
+  pe_ILF_make_a_symbol_reloc (vars, address, reloc, sec->symbol_ptr_ptr,
+			      coff_section_data (vars->abfd, sec)->i);
+}
+
+/* Move the queued relocs into the given section.  */
+
+static void
+pe_ILF_save_relocs (pe_ILF_vars * vars,
+		    asection_ptr  sec)
+{
+  /* Make sure that there is somewhere to store the internal relocs.  */
+  if (coff_section_data (vars->abfd, sec) == NULL)
+    /* We should probably return an error indication here.  */
+    abort ();
+
+  coff_section_data (vars->abfd, sec)->relocs = vars->int_reltab;
+  coff_section_data (vars->abfd, sec)->keep_relocs = TRUE;
+
+  sec->relocation  = vars->reltab;
+  sec->reloc_count = vars->relcount;
+  sec->flags      |= SEC_RELOC;
+
+  vars->reltab     += vars->relcount;
+  vars->int_reltab += vars->relcount;
+  vars->relcount   = 0;
+
+  BFD_ASSERT ((bfd_byte *) vars->int_reltab < (bfd_byte *) vars->string_table);
+}
+
+/* Create a global symbol and add it to the relevant tables.  */
+
+static void
+pe_ILF_make_a_symbol (pe_ILF_vars *  vars,
+		      const char *   prefix,
+		      const char *   symbol_name,
+		      asection_ptr   section,
+		      flagword       extra_flags)
+{
+  coff_symbol_type * sym;
+  combined_entry_type * ent;
+  SYMENT * esym;
+  unsigned short sclass;
+
+  if (extra_flags & BSF_LOCAL)
+    sclass = C_STAT;
+  else
+    sclass = C_EXT;
+
+#ifdef THUMBPEMAGIC
+  if (vars->magic == THUMBPEMAGIC)
+    {
+      if (extra_flags & BSF_FUNCTION)
+	sclass = C_THUMBEXTFUNC;
+      else if (extra_flags & BSF_LOCAL)
+	sclass = C_THUMBSTAT;
+      else
+	sclass = C_THUMBEXT;
+    }
+#endif
+
+  BFD_ASSERT (vars->sym_index < NUM_ILF_SYMS);
+
+  sym = vars->sym_ptr;
+  ent = vars->native_ptr;
+  esym = vars->esym_ptr;
+
+  /* Copy the symbol's name into the string table.  */
+  sprintf (vars->string_ptr, "%s%s", prefix, symbol_name);
+
+  if (section == NULL)
+    section = bfd_und_section_ptr;
+
+  /* Initialise the external symbol.  */
+  H_PUT_32 (vars->abfd, vars->string_ptr - vars->string_table,
+	    esym->e.e.e_offset);
+  H_PUT_16 (vars->abfd, section->target_index, esym->e_scnum);
+  esym->e_sclass[0] = sclass;
+
+  /* The following initialisations are unnecessary - the memory is
+     zero initialised.  They are just kept here as reminders.  */
+
+  /* Initialise the internal symbol structure.  */
+  ent->u.syment.n_sclass          = sclass;
+  ent->u.syment.n_scnum           = section->target_index;
+  ent->u.syment._n._n_n._n_offset = (bfd_hostptr_t) sym;
+  ent->is_sym = TRUE;
+
+  sym->symbol.the_bfd = vars->abfd;
+  sym->symbol.name    = vars->string_ptr;
+  sym->symbol.flags   = BSF_EXPORT | BSF_GLOBAL | extra_flags;
+  sym->symbol.section = section;
+  sym->native         = ent;
+
+  * vars->table_ptr = vars->sym_index;
+  * vars->sym_ptr_ptr = sym;
+
+  /* Adjust pointers for the next symbol.  */
+  vars->sym_index ++;
+  vars->sym_ptr ++;
+  vars->sym_ptr_ptr ++;
+  vars->table_ptr ++;
+  vars->native_ptr ++;
+  vars->esym_ptr ++;
+  vars->string_ptr += strlen (symbol_name) + strlen (prefix) + 1;
+
+  BFD_ASSERT (vars->string_ptr < vars->end_string_ptr);
+}
+
+/* Create a section.  */
+
+static asection_ptr
+pe_ILF_make_a_section (pe_ILF_vars * vars,
+		       const char *  name,
+		       unsigned int  size,
+		       flagword      extra_flags)
+{
+  asection_ptr sec;
+  flagword     flags;
+
+  sec = bfd_make_section_old_way (vars->abfd, name);
+  if (sec == NULL)
+    return NULL;
+
+  flags = SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_KEEP | SEC_IN_MEMORY;
+
+  bfd_set_section_flags (vars->abfd, sec, flags | extra_flags);
+
+  (void) bfd_set_section_alignment (vars->abfd, sec, 2);
+
+  /* Check that we will not run out of space.  */
+  BFD_ASSERT (vars->data + size < vars->bim->buffer + vars->bim->size);
+
+  /* Set the section size and contents.  The actual
+     contents are filled in by our parent.  */
+  bfd_set_section_size (vars->abfd, sec, (bfd_size_type) size);
+  sec->contents = vars->data;
+  sec->target_index = vars->sec_index ++;
+
+  /* Advance data pointer in the vars structure.  */
+  vars->data += size;
+
+  /* Skip the padding byte if it was not needed.
+     The logic here is that if the string length is odd,
+     then the entire string length, including the null byte,
+     is even and so the extra, padding byte, is not needed.  */
+  if (size & 1)
+    vars->data --;
+
+# if (GCC_VERSION >= 3000)
+  /* PR 18758: See note in pe_ILF_buid_a_bfd.  We must make sure that we
+     preserve host alignment requirements.  We test 'size' rather than
+     vars.data as we cannot perform binary arithmetic on pointers.  We assume
+     that vars.data was sufficiently aligned upon entry to this function.
+     The BFD_ASSERTs in this functions will warn us if we run out of room,
+     but we should already have enough padding built in to ILF_DATA_SIZE.  */
+  {
+    unsigned int alignment = __alignof__ (struct coff_section_tdata);
+
+    if (size & (alignment - 1))
+      vars->data += alignment - (size & (alignment - 1));
+  }
+#endif
+  /* Create a coff_section_tdata structure for our use.  */
+  sec->used_by_bfd = (struct coff_section_tdata *) vars->data;
+  vars->data += sizeof (struct coff_section_tdata);
+
+  BFD_ASSERT (vars->data <= vars->bim->buffer + vars->bim->size);
+
+  /* Create a symbol to refer to this section.  */
+  pe_ILF_make_a_symbol (vars, "", name, sec, BSF_LOCAL);
+
+  /* Cache the index to the symbol in the coff_section_data structure.  */
+  coff_section_data (vars->abfd, sec)->i = vars->sym_index - 1;
+
+  return sec;
+}
+
+/* This structure contains the code that goes into the .text section
+   in order to perform a jump into the DLL lookup table.  The entries
+   in the table are index by the magic number used to represent the
+   machine type in the PE file.  The contents of the data[] arrays in
+   these entries are stolen from the jtab[] arrays in ld/pe-dll.c.
+   The SIZE field says how many bytes in the DATA array are actually
+   used.  The OFFSET field says where in the data array the address
+   of the .idata$5 section should be placed.  */
+#define MAX_TEXT_SECTION_SIZE 32
+
+typedef struct
+{
+  unsigned short magic;
+  unsigned char  data[MAX_TEXT_SECTION_SIZE];
+  unsigned int   size;
+  unsigned int   offset;
+}
+jump_table;
+
+static jump_table jtab[] =
+{
+#ifdef I386MAGIC
+  { I386MAGIC,
+    { 0xff, 0x25, 0x00, 0x00, 0x00, 0x00, 0x90, 0x90 },
+    8, 2
+  },
+#endif
+
+#ifdef AMD64MAGIC
+  { AMD64MAGIC,
+    { 0xff, 0x25, 0x00, 0x00, 0x00, 0x00, 0x90, 0x90 },
+    8, 2
+  },
+#endif
+
+#ifdef  MC68MAGIC
+  { MC68MAGIC,
+    { /* XXX fill me in */ },
+    0, 0
+  },
+#endif
+
+#ifdef  MIPS_ARCH_MAGIC_WINCE
+  { MIPS_ARCH_MAGIC_WINCE,
+    { 0x00, 0x00, 0x08, 0x3c, 0x00, 0x00, 0x08, 0x8d,
+      0x08, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00 },
+    16, 0
+  },
+#endif
+
+#ifdef  SH_ARCH_MAGIC_WINCE
+  { SH_ARCH_MAGIC_WINCE,
+    { 0x01, 0xd0, 0x02, 0x60, 0x2b, 0x40,
+      0x09, 0x00, 0x00, 0x00, 0x00, 0x00 },
+    12, 8
+  },
+#endif
+
+#ifdef  ARMPEMAGIC
+  { ARMPEMAGIC,
+    { 0x00, 0xc0, 0x9f, 0xe5, 0x00, 0xf0,
+      0x9c, 0xe5, 0x00, 0x00, 0x00, 0x00},
+    12, 8
+  },
+#endif
+
+#ifdef  THUMBPEMAGIC
+  { THUMBPEMAGIC,
+    { 0x40, 0xb4, 0x02, 0x4e, 0x36, 0x68, 0xb4, 0x46,
+      0x40, 0xbc, 0x60, 0x47, 0x00, 0x00, 0x00, 0x00 },
+    16, 12
+  },
+#endif
+  { 0, { 0 }, 0, 0 }
+};
+
+#ifndef NUM_ENTRIES
+#define NUM_ENTRIES(a) (sizeof (a) / sizeof (a)[0])
+#endif
+
+/* Build a full BFD from the information supplied in a ILF object.  */
+
+static bfd_boolean
+pe_ILF_build_a_bfd (bfd *           abfd,
+		    unsigned int    magic,
+		    char *          symbol_name,
+		    char *          source_dll,
+		    unsigned int    ordinal,
+		    unsigned int    types)
+{
+  bfd_byte *               ptr;
+  pe_ILF_vars              vars;
+  struct internal_filehdr  internal_f;
+  unsigned int             import_type;
+  unsigned int             import_name_type;
+  asection_ptr             id4, id5, id6 = NULL, text = NULL;
+  coff_symbol_type **      imp_sym;
+  unsigned int             imp_index;
+
+  /* Decode and verify the types field of the ILF structure.  */
+  import_type = types & 0x3;
+  import_name_type = (types & 0x1c) >> 2;
+
+  switch (import_type)
+    {
+    case IMPORT_CODE:
+    case IMPORT_DATA:
+      break;
+
+    case IMPORT_CONST:
+      /* XXX code yet to be written.  */
+      _bfd_error_handler (_("%B: Unhandled import type; %x"),
+			  abfd, import_type);
+      return FALSE;
+
+    default:
+      _bfd_error_handler (_("%B: Unrecognised import type; %x"),
+			  abfd, import_type);
+      return FALSE;
+    }
+
+  switch (import_name_type)
+    {
+    case IMPORT_ORDINAL:
+    case IMPORT_NAME:
+    case IMPORT_NAME_NOPREFIX:
+    case IMPORT_NAME_UNDECORATE:
+      break;
+
+    default:
+      _bfd_error_handler (_("%B: Unrecognised import name type; %x"),
+			  abfd, import_name_type);
+      return FALSE;
+    }
+
+  /* Initialise local variables.
+
+     Note these are kept in a structure rather than being
+     declared as statics since bfd frowns on global variables.
+
+     We are going to construct the contents of the BFD in memory,
+     so allocate all the space that we will need right now.  */
+  vars.bim
+    = (struct bfd_in_memory *) bfd_malloc ((bfd_size_type) sizeof (*vars.bim));
+  if (vars.bim == NULL)
+    return FALSE;
+
+  ptr = (bfd_byte *) bfd_zmalloc ((bfd_size_type) ILF_DATA_SIZE);
+  vars.bim->buffer = ptr;
+  vars.bim->size   = ILF_DATA_SIZE;
+  if (ptr == NULL)
+    goto error_return;
+
+  /* Initialise the pointers to regions of the memory and the
+     other contents of the pe_ILF_vars structure as well.  */
+  vars.sym_cache = (coff_symbol_type *) ptr;
+  vars.sym_ptr   = (coff_symbol_type *) ptr;
+  vars.sym_index = 0;
+  ptr += SIZEOF_ILF_SYMS;
+
+  vars.sym_table = (unsigned int *) ptr;
+  vars.table_ptr = (unsigned int *) ptr;
+  ptr += SIZEOF_ILF_SYM_TABLE;
+
+  vars.native_syms = (combined_entry_type *) ptr;
+  vars.native_ptr  = (combined_entry_type *) ptr;
+  ptr += SIZEOF_ILF_NATIVE_SYMS;
+
+  vars.sym_ptr_table = (coff_symbol_type **) ptr;
+  vars.sym_ptr_ptr   = (coff_symbol_type **) ptr;
+  ptr += SIZEOF_ILF_SYM_PTR_TABLE;
+
+  vars.esym_table = (SYMENT *) ptr;
+  vars.esym_ptr   = (SYMENT *) ptr;
+  ptr += SIZEOF_ILF_EXT_SYMS;
+
+  vars.reltab   = (arelent *) ptr;
+  vars.relcount = 0;
+  ptr += SIZEOF_ILF_RELOCS;
+
+  vars.int_reltab  = (struct internal_reloc *) ptr;
+  ptr += SIZEOF_ILF_INT_RELOCS;
+
+  vars.string_table = (char *) ptr;
+  vars.string_ptr   = (char *) ptr + STRING_SIZE_SIZE;
+  ptr += SIZEOF_ILF_STRINGS;
+  vars.end_string_ptr = (char *) ptr;
+
+  /* The remaining space in bim->buffer is used
+     by the pe_ILF_make_a_section() function.  */
+# if (GCC_VERSION >= 3000)
+  /* PR 18758: Make sure that the data area is sufficiently aligned for
+     pointers on the host.  __alignof__ is a gcc extension, hence the test
+     above.  For other compilers we will have to assume that the alignment is
+     unimportant, or else extra code can be added here and in
+     pe_ILF_make_a_section.
+
+     Note - we cannot test 'ptr' directly as it is illegal to perform binary
+     arithmetic on pointers, but we know that the strings section is the only
+     one that might end on an unaligned boundary.  */
+  {
+    unsigned int alignment = __alignof__ (char *);
+
+    if (SIZEOF_ILF_STRINGS & (alignment - 1))
+      ptr += alignment - (SIZEOF_ILF_STRINGS & (alignment - 1));
+  }
+#endif
+
+  vars.data = ptr;
+  vars.abfd = abfd;
+  vars.sec_index = 0;
+  vars.magic = magic;
+
+  /* Create the initial .idata$<n> sections:
+     [.idata$2:  Import Directory Table -- not needed]
+     .idata$4:  Import Lookup Table
+     .idata$5:  Import Address Table
+
+     Note we do not create a .idata$3 section as this is
+     created for us by the linker script.  */
+  id4 = pe_ILF_make_a_section (& vars, ".idata$4", SIZEOF_IDATA4, 0);
+  id5 = pe_ILF_make_a_section (& vars, ".idata$5", SIZEOF_IDATA5, 0);
+  if (id4 == NULL || id5 == NULL)
+    goto error_return;
+
+  /* Fill in the contents of these sections.  */
+  if (import_name_type == IMPORT_ORDINAL)
+    {
+      if (ordinal == 0)
+	/* XXX - treat as IMPORT_NAME ??? */
+	abort ();
+
+#ifdef COFF_WITH_pex64
+      ((unsigned int *) id4->contents)[0] = ordinal;
+      ((unsigned int *) id4->contents)[1] = 0x80000000;
+      ((unsigned int *) id5->contents)[0] = ordinal;
+      ((unsigned int *) id5->contents)[1] = 0x80000000;
+#else
+      * (unsigned int *) id4->contents = ordinal | 0x80000000;
+      * (unsigned int *) id5->contents = ordinal | 0x80000000;
+#endif
+    }
+  else
+    {
+      char * symbol;
+      unsigned int len;
+
+      /* Create .idata$6 - the Hint Name Table.  */
+      id6 = pe_ILF_make_a_section (& vars, ".idata$6", SIZEOF_IDATA6, 0);
+      if (id6 == NULL)
+	goto error_return;
+
+      /* If necessary, trim the import symbol name.  */
+      symbol = symbol_name;
+
+      /* As used by MS compiler, '_', '@', and '?' are alternative
+	 forms of USER_LABEL_PREFIX, with '?' for c++ mangled names,
+	 '@' used for fastcall (in C),  '_' everywhere else.  Only one
+	 of these is used for a symbol.  We strip this leading char for
+	 IMPORT_NAME_NOPREFIX and IMPORT_NAME_UNDECORATE as per the
+	 PE COFF 6.0 spec (section 8.3, Import Name Type).  */
+
+      if (import_name_type != IMPORT_NAME)
+	{
+	  char c = symbol[0];
+
+	  /* Check that we don't remove for targets with empty
+	     USER_LABEL_PREFIX the leading underscore.  */
+	  if ((c == '_' && abfd->xvec->symbol_leading_char != 0)
+	      || c == '@' || c == '?')
+	    symbol++;
+	}
+
+      len = strlen (symbol);
+      if (import_name_type == IMPORT_NAME_UNDECORATE)
+	{
+	  /* Truncate at the first '@'.  */
+	  char *at = strchr (symbol, '@');
+
+	  if (at != NULL)
+	    len = at - symbol;
+	}
+
+      id6->contents[0] = ordinal & 0xff;
+      id6->contents[1] = ordinal >> 8;
+
+      memcpy ((char *) id6->contents + 2, symbol, len);
+      id6->contents[len + 2] = '\0';
+    }
+
+  if (import_name_type != IMPORT_ORDINAL)
+    {
+      pe_ILF_make_a_reloc (&vars, (bfd_vma) 0, BFD_RELOC_RVA, id6);
+      pe_ILF_save_relocs (&vars, id4);
+
+      pe_ILF_make_a_reloc (&vars, (bfd_vma) 0, BFD_RELOC_RVA, id6);
+      pe_ILF_save_relocs (&vars, id5);
+    }
+
+  /* Create extra sections depending upon the type of import we are dealing with.  */
+  switch (import_type)
+    {
+      int i;
+
+    case IMPORT_CODE:
+      /* Create a .text section.
+	 First we need to look up its contents in the jump table.  */
+      for (i = NUM_ENTRIES (jtab); i--;)
+	{
+	  if (jtab[i].size == 0)
+	    continue;
+	  if (jtab[i].magic == magic)
+	    break;
+	}
+      /* If we did not find a matching entry something is wrong.  */
+      if (i < 0)
+	abort ();
+
+      /* Create the .text section.  */
+      text = pe_ILF_make_a_section (& vars, ".text", jtab[i].size, SEC_CODE);
+      if (text == NULL)
+	goto error_return;
+
+      /* Copy in the jump code.  */
+      memcpy (text->contents, jtab[i].data, jtab[i].size);
+
+      /* Create an import symbol.  */
+      pe_ILF_make_a_symbol (& vars, "__imp_", symbol_name, id5, 0);
+      imp_sym   = vars.sym_ptr_ptr - 1;
+      imp_index = vars.sym_index - 1;
+
+      /* Create a reloc for the data in the text section.  */
+#ifdef MIPS_ARCH_MAGIC_WINCE
+      if (magic == MIPS_ARCH_MAGIC_WINCE)
+	{
+	  pe_ILF_make_a_symbol_reloc (&vars, (bfd_vma) 0, BFD_RELOC_HI16_S,
+				      (struct bfd_symbol **) imp_sym,
+				      imp_index);
+	  pe_ILF_make_a_reloc (&vars, (bfd_vma) 0, BFD_RELOC_LO16, text);
+	  pe_ILF_make_a_symbol_reloc (&vars, (bfd_vma) 4, BFD_RELOC_LO16,
+				      (struct bfd_symbol **) imp_sym,
+				      imp_index);
+	}
+      else
+#endif
+#ifdef AMD64MAGIC
+      if (magic == AMD64MAGIC)
+	{
+	  pe_ILF_make_a_symbol_reloc (&vars, (bfd_vma) jtab[i].offset,
+				      BFD_RELOC_32_PCREL, (asymbol **) imp_sym,
+				      imp_index);
+	}
+      else
+#endif
+	pe_ILF_make_a_symbol_reloc (&vars, (bfd_vma) jtab[i].offset,
+				    BFD_RELOC_32, (asymbol **) imp_sym,
+				    imp_index);
+
+      pe_ILF_save_relocs (& vars, text);
+      break;
+
+    case IMPORT_DATA:
+      break;
+
+    default:
+      /* XXX code not yet written.  */
+      abort ();
+    }
+
+  /* Initialise the bfd.  */
+  memset (& internal_f, 0, sizeof (internal_f));
+
+  internal_f.f_magic  = magic;
+  internal_f.f_symptr = 0;
+  internal_f.f_nsyms  = 0;
+  internal_f.f_flags  = F_AR32WR | F_LNNO; /* XXX is this correct ?  */
+
+  if (   ! bfd_set_start_address (abfd, (bfd_vma) 0)
+      || ! bfd_coff_set_arch_mach_hook (abfd, & internal_f))
+    goto error_return;
+
+  if (bfd_coff_mkobject_hook (abfd, (void *) & internal_f, NULL) == NULL)
+    goto error_return;
+
+  coff_data (abfd)->pe = 1;
+#ifdef THUMBPEMAGIC
+  if (vars.magic == THUMBPEMAGIC)
+    /* Stop some linker warnings about thumb code not supporting interworking.  */
+    coff_data (abfd)->flags |= F_INTERWORK | F_INTERWORK_SET;
+#endif
+
+  /* Switch from file contents to memory contents.  */
+  bfd_cache_close (abfd);
+
+  abfd->iostream = (void *) vars.bim;
+  abfd->flags |= BFD_IN_MEMORY /* | HAS_LOCALS */;
+  abfd->iovec = &_bfd_memory_iovec;
+  abfd->where = 0;
+  abfd->origin = 0;
+  obj_sym_filepos (abfd) = 0;
+
+  /* Now create a symbol describing the imported value.  */
+  switch (import_type)
+    {
+    case IMPORT_CODE:
+      pe_ILF_make_a_symbol (& vars, "", symbol_name, text,
+			    BSF_NOT_AT_END | BSF_FUNCTION);
+
+      /* Create an import symbol for the DLL, without the
+       .dll suffix.  */
+      ptr = (bfd_byte *) strrchr (source_dll, '.');
+      if (ptr)
+	* ptr = 0;
+      pe_ILF_make_a_symbol (& vars, "__IMPORT_DESCRIPTOR_", source_dll, NULL, 0);
+      if (ptr)
+	* ptr = '.';
+      break;
+
+    case IMPORT_DATA:
+      /* Nothing to do here.  */
+      break;
+
+    default:
+      /* XXX code not yet written.  */
+      abort ();
+    }
+
+  /* Point the bfd at the symbol table.  */
+  obj_symbols (abfd) = vars.sym_cache;
+  bfd_get_symcount (abfd) = vars.sym_index;
+
+  obj_raw_syments (abfd) = vars.native_syms;
+  obj_raw_syment_count (abfd) = vars.sym_index;
+
+  obj_coff_external_syms (abfd) = (void *) vars.esym_table;
+  obj_coff_keep_syms (abfd) = TRUE;
+
+  obj_convert (abfd) = vars.sym_table;
+  obj_conv_table_size (abfd) = vars.sym_index;
+
+  obj_coff_strings (abfd) = vars.string_table;
+  obj_coff_keep_strings (abfd) = TRUE;
+
+  abfd->flags |= HAS_SYMS;
+
+  return TRUE;
+
+ error_return:
+  if (vars.bim->buffer != NULL)
+    free (vars.bim->buffer);
+  free (vars.bim);
+  return FALSE;
+}
+
+/* We have detected a Image Library Format archive element.
+   Decode the element and return the appropriate target.  */
+
+static const bfd_target *
+pe_ILF_object_p (bfd * abfd)
+{
+  bfd_byte        buffer[14];
+  bfd_byte *      ptr;
+  char *          symbol_name;
+  char *          source_dll;
+  unsigned int    machine;
+  bfd_size_type   size;
+  unsigned int    ordinal;
+  unsigned int    types;
+  unsigned int    magic;
+
+  /* Upon entry the first six bytes of the ILF header have
+      already been read.  Now read the rest of the header.  */
+  if (bfd_bread (buffer, (bfd_size_type) 14, abfd) != 14)
+    return NULL;
+
+  ptr = buffer;
+
+  machine = H_GET_16 (abfd, ptr);
+  ptr += 2;
+
+  /* Check that the machine type is recognised.  */
+  magic = 0;
+
+  switch (machine)
+    {
+    case IMAGE_FILE_MACHINE_UNKNOWN:
+    case IMAGE_FILE_MACHINE_ALPHA:
+    case IMAGE_FILE_MACHINE_ALPHA64:
+    case IMAGE_FILE_MACHINE_IA64:
+      break;
+
+    case IMAGE_FILE_MACHINE_I386:
+#ifdef I386MAGIC
+      magic = I386MAGIC;
+#endif
+      break;
+
+    case IMAGE_FILE_MACHINE_AMD64:
+#ifdef AMD64MAGIC
+      magic = AMD64MAGIC;
+#endif
+      break;
+
+    case IMAGE_FILE_MACHINE_M68K:
+#ifdef MC68AGIC
+      magic = MC68MAGIC;
+#endif
+      break;
+
+    case IMAGE_FILE_MACHINE_R3000:
+    case IMAGE_FILE_MACHINE_R4000:
+    case IMAGE_FILE_MACHINE_R10000:
+
+    case IMAGE_FILE_MACHINE_MIPS16:
+    case IMAGE_FILE_MACHINE_MIPSFPU:
+    case IMAGE_FILE_MACHINE_MIPSFPU16:
+#ifdef MIPS_ARCH_MAGIC_WINCE
+      magic = MIPS_ARCH_MAGIC_WINCE;
+#endif
+      break;
+
+    case IMAGE_FILE_MACHINE_SH3:
+    case IMAGE_FILE_MACHINE_SH4:
+#ifdef SH_ARCH_MAGIC_WINCE
+      magic = SH_ARCH_MAGIC_WINCE;
+#endif
+      break;
+
+    case IMAGE_FILE_MACHINE_ARM:
+#ifdef ARMPEMAGIC
+      magic = ARMPEMAGIC;
+#endif
+      break;
+
+    case IMAGE_FILE_MACHINE_THUMB:
+#ifdef THUMBPEMAGIC
+      {
+	extern const bfd_target TARGET_LITTLE_SYM;
+
+	if (abfd->xvec == & TARGET_LITTLE_SYM)
+	  magic = THUMBPEMAGIC;
+      }
+#endif
+      break;
+
+    case IMAGE_FILE_MACHINE_POWERPC:
+      /* We no longer support PowerPC.  */
+    default:
+      _bfd_error_handler
+	(_("%B: Unrecognised machine type (0x%x)"
+	   " in Import Library Format archive"),
+	 abfd, machine);
+      bfd_set_error (bfd_error_malformed_archive);
+
+      return NULL;
+      break;
+    }
+
+  if (magic == 0)
+    {
+      _bfd_error_handler
+	(_("%B: Recognised but unhandled machine type (0x%x)"
+	   " in Import Library Format archive"),
+	 abfd, machine);
+      bfd_set_error (bfd_error_wrong_format);
+
+      return NULL;
+    }
+
+  /* We do not bother to check the date.
+     date = H_GET_32 (abfd, ptr);  */
+  ptr += 4;
+
+  size = H_GET_32 (abfd, ptr);
+  ptr += 4;
+
+  if (size == 0)
+    {
+      _bfd_error_handler
+	(_("%B: size field is zero in Import Library Format header"), abfd);
+      bfd_set_error (bfd_error_malformed_archive);
+
+      return NULL;
+    }
+
+  ordinal = H_GET_16 (abfd, ptr);
+  ptr += 2;
+
+  types = H_GET_16 (abfd, ptr);
+  /* ptr += 2; */
+
+  /* Now read in the two strings that follow.  */
+  ptr = (bfd_byte *) bfd_alloc (abfd, size);
+  if (ptr == NULL)
+    return NULL;
+
+  if (bfd_bread (ptr, size, abfd) != size)
+    {
+      bfd_release (abfd, ptr);
+      return NULL;
+    }
+
+  symbol_name = (char *) ptr;
+  source_dll  = symbol_name + strlen (symbol_name) + 1;
+
+  /* Verify that the strings are null terminated.  */
+  if (ptr[size - 1] != 0
+      || (bfd_size_type) ((bfd_byte *) source_dll - ptr) >= size)
+    {
+      _bfd_error_handler
+	(_("%B: string not null terminated in ILF object file."), abfd);
+      bfd_set_error (bfd_error_malformed_archive);
+      bfd_release (abfd, ptr);
+      return NULL;
+    }
+
+  /* Now construct the bfd.  */
+  if (! pe_ILF_build_a_bfd (abfd, magic, symbol_name,
+			    source_dll, ordinal, types))
+    {
+      bfd_release (abfd, ptr);
+      return NULL;
+    }
+
+  return abfd->xvec;
+}
+
+static void
+pe_bfd_read_buildid(bfd *abfd)
+{
+  pe_data_type *pe = pe_data (abfd);
+  struct internal_extra_pe_aouthdr *extra = &pe->pe_opthdr;
+  asection *section;
+  bfd_byte *data = 0;
+  bfd_size_type dataoff;
+  unsigned int i;
+
+  bfd_vma addr = extra->DataDirectory[PE_DEBUG_DATA].VirtualAddress;
+  bfd_size_type size = extra->DataDirectory[PE_DEBUG_DATA].Size;
+
+  if (size == 0)
+    return;
+
+  addr += extra->ImageBase;
+
+  /* Search for the section containing the DebugDirectory */
+  for (section = abfd->sections; section != NULL; section = section->next)
+    {
+      if ((addr >= section->vma) && (addr < (section->vma + section->size)))
+        break;
+    }
+
+  if (section == NULL)
+    {
+      return;
+    }
+  else if (!(section->flags & SEC_HAS_CONTENTS))
+    {
+      return;
+    }
+
+  dataoff = addr - section->vma;
+
+  /* Read the whole section. */
+  if (!bfd_malloc_and_get_section (abfd, section, &data))
+    {
+      if (data != NULL)
+	free (data);
+      return;
+    }
+
+  /* Search for a CodeView entry in the DebugDirectory */
+  for (i = 0; i < size / sizeof (struct external_IMAGE_DEBUG_DIRECTORY); i++)
+    {
+      struct external_IMAGE_DEBUG_DIRECTORY *ext
+	= &((struct external_IMAGE_DEBUG_DIRECTORY *)(data + dataoff))[i];
+      struct internal_IMAGE_DEBUG_DIRECTORY idd;
+
+      _bfd_XXi_swap_debugdir_in (abfd, ext, &idd);
+
+      if (idd.Type == PE_IMAGE_DEBUG_TYPE_CODEVIEW)
+        {
+          char buffer[256 + 1];
+          CODEVIEW_INFO *cvinfo = (CODEVIEW_INFO *) buffer;
+
+          /*
+            The debug entry doesn't have to have to be in a section, in which
+            case AddressOfRawData is 0, so always use PointerToRawData.
+          */
+          if (_bfd_XXi_slurp_codeview_record (abfd,
+                                              (file_ptr) idd.PointerToRawData,
+                                              idd.SizeOfData, cvinfo))
+            {
+              struct bfd_build_id* build_id = bfd_alloc(abfd,
+                         sizeof(struct bfd_build_id) + cvinfo->SignatureLength);
+              if (build_id)
+                {
+                  build_id->size = cvinfo->SignatureLength;
+                  memcpy(build_id->data,  cvinfo->Signature,
+                         cvinfo->SignatureLength);
+                  abfd->build_id = build_id;
+                }
+            }
+          break;
+        }
+    }
+}
+
+static const bfd_target *
+pe_bfd_object_p (bfd * abfd)
+{
+  bfd_byte buffer[6];
+  struct external_PEI_DOS_hdr dos_hdr;
+  struct external_PEI_IMAGE_hdr image_hdr;
+  struct internal_filehdr internal_f;
+  struct internal_aouthdr internal_a;
+  file_ptr opt_hdr_size;
+  file_ptr offset;
+  const bfd_target *result;
+
+  /* Detect if this a Microsoft Import Library Format element.  */
+  /* First read the beginning of the header.  */
+  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0
+      || bfd_bread (buffer, (bfd_size_type) 6, abfd) != 6)
+    {
+      if (bfd_get_error () != bfd_error_system_call)
+	bfd_set_error (bfd_error_wrong_format);
+      return NULL;
+    }
+
+  /* Then check the magic and the version (only 0 is supported).  */
+  if (H_GET_32 (abfd, buffer) == 0xffff0000
+      && H_GET_16 (abfd, buffer + 4) == 0)
+    return pe_ILF_object_p (abfd);
+
+  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0
+      || bfd_bread (&dos_hdr, (bfd_size_type) sizeof (dos_hdr), abfd)
+	 != sizeof (dos_hdr))
+    {
+      if (bfd_get_error () != bfd_error_system_call)
+	bfd_set_error (bfd_error_wrong_format);
+      return NULL;
+    }
+
+  /* There are really two magic numbers involved; the magic number
+     that says this is a NT executable (PEI) and the magic number that
+     determines the architecture.  The former is DOSMAGIC, stored in
+     the e_magic field.  The latter is stored in the f_magic field.
+     If the NT magic number isn't valid, the architecture magic number
+     could be mimicked by some other field (specifically, the number
+     of relocs in section 3).  Since this routine can only be called
+     correctly for a PEI file, check the e_magic number here, and, if
+     it doesn't match, clobber the f_magic number so that we don't get
+     a false match.  */
+  if (H_GET_16 (abfd, dos_hdr.e_magic) != DOSMAGIC)
+    {
+      bfd_set_error (bfd_error_wrong_format);
+      return NULL;
+    }
+
+  offset = H_GET_32 (abfd, dos_hdr.e_lfanew);
+  if (bfd_seek (abfd, offset, SEEK_SET) != 0
+      || (bfd_bread (&image_hdr, (bfd_size_type) sizeof (image_hdr), abfd)
+	  != sizeof (image_hdr)))
+    {
+      if (bfd_get_error () != bfd_error_system_call)
+	bfd_set_error (bfd_error_wrong_format);
+      return NULL;
+    }
+
+  if (H_GET_32 (abfd, image_hdr.nt_signature) != 0x4550)
+    {
+      bfd_set_error (bfd_error_wrong_format);
+      return NULL;
+    }
+
+  /* Swap file header, so that we get the location for calling
+     real_object_p.  */
+  bfd_coff_swap_filehdr_in (abfd, &image_hdr, &internal_f);
+
+  if (! bfd_coff_bad_format_hook (abfd, &internal_f)
+      || internal_f.f_opthdr > bfd_coff_aoutsz (abfd))
+    {
+      bfd_set_error (bfd_error_wrong_format);
+      return NULL;
+    }
+
+  /* Read the optional header, which has variable size.  */
+  opt_hdr_size = internal_f.f_opthdr;
+
+  if (opt_hdr_size != 0)
+    {
+      bfd_size_type amt = opt_hdr_size;
+      void * opthdr;
+
+      /* PR 17521 file: 230-131433-0.004.  */
+      if (amt < sizeof (PEAOUTHDR))
+	amt = sizeof (PEAOUTHDR);
+
+      opthdr = bfd_zalloc (abfd, amt);
+      if (opthdr == NULL)
+	return NULL;
+      if (bfd_bread (opthdr, opt_hdr_size, abfd)
+	  != (bfd_size_type) opt_hdr_size)
+	return NULL;
+
+      bfd_set_error (bfd_error_no_error);
+      bfd_coff_swap_aouthdr_in (abfd, opthdr, & internal_a);
+      if (bfd_get_error () != bfd_error_no_error)
+	return NULL;
+    }
+
+
+  result = coff_real_object_p (abfd, internal_f.f_nscns, &internal_f,
+                               (opt_hdr_size != 0
+                                ? &internal_a
+                                : (struct internal_aouthdr *) NULL));
+
+
+  if (result)
+    {
+      /* Now the whole header has been processed, see if there is a build-id */
+      pe_bfd_read_buildid(abfd);
+    }
+
+  return result;
+}
+
+#define coff_object_p pe_bfd_object_p
+#endif /* COFF_IMAGE_WITH_PE */
diff -Naur binutils-2.26/bfd/targets.c binutils-2.26.0007/bfd/targets.c
--- binutils-2.26/bfd/targets.c	2015-11-13 09:27:40.000000000 +0100
+++ binutils-2.26.0007/bfd/targets.c	2016-03-10 17:02:24.234052177 +0100
@@ -604,12 +604,16 @@
 extern const bfd_target arm_pe_epoc_le_vec;
 extern const bfd_target arm_pe_wince_be_vec;
 extern const bfd_target arm_pe_wince_le_vec;
+extern const bfd_target arm_pe_winnt_be_vec;
+extern const bfd_target arm_pe_winnt_le_vec;
 extern const bfd_target arm_pei_be_vec;
 extern const bfd_target arm_pei_le_vec;
 extern const bfd_target arm_pei_epoc_be_vec;
 extern const bfd_target arm_pei_epoc_le_vec;
 extern const bfd_target arm_pei_wince_be_vec;
 extern const bfd_target arm_pei_wince_le_vec;
+extern const bfd_target arm_pei_winnt_be_vec;
+extern const bfd_target arm_pei_winnt_le_vec;
 extern const bfd_target avr_elf32_vec;
 extern const bfd_target bfin_elf32_vec;
 extern const bfd_target bfin_elf32_fdpic_vec;
@@ -1004,12 +1008,16 @@
 	&arm_pe_epoc_le_vec,
 	&arm_pe_wince_be_vec,
 	&arm_pe_wince_le_vec,
+	&arm_pe_winnt_be_vec,
+	&arm_pe_winnt_le_vec,
 	&arm_pei_be_vec,
 	&arm_pei_le_vec,
 	&arm_pei_epoc_be_vec,
 	&arm_pei_epoc_le_vec,
 	&arm_pei_wince_be_vec,
 	&arm_pei_wince_le_vec,
+	&arm_pei_winnt_be_vec,
+	&arm_pei_winnt_le_vec,
 
 	&avr_elf32_vec,
 
diff -Naur binutils-2.26/bfd/targets.c.orig binutils-2.26.0007/bfd/targets.c.orig
--- binutils-2.26/bfd/targets.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.26.0007/bfd/targets.c.orig	2016-03-10 17:01:59.501263644 +0100
@@ -0,0 +1,1883 @@
+/* Generic target-file-type support for the BFD library.
+   Copyright (C) 1990-2015 Free Software Foundation, Inc.
+   Written by Cygnus Support.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+#include "fnmatch.h"
+
+/*
+   It's okay to see some:
+#if 0
+   directives in this source file, as targets.c uses them to exclude
+   certain BFD vectors.  This comment is specially formatted to catch
+   users who grep for ^#if 0, so please keep it this way!
+*/
+
+/*
+SECTION
+	Targets
+
+DESCRIPTION
+	Each port of BFD to a different machine requires the creation
+	of a target back end. All the back end provides to the root
+	part of BFD is a structure containing pointers to functions
+	which perform certain low level operations on files. BFD
+	translates the applications's requests through a pointer into
+	calls to the back end routines.
+
+	When a file is opened with <<bfd_openr>>, its format and
+	target are unknown. BFD uses various mechanisms to determine
+	how to interpret the file. The operations performed are:
+
+	o Create a BFD by calling the internal routine
+	<<_bfd_new_bfd>>, then call <<bfd_find_target>> with the
+	target string supplied to <<bfd_openr>> and the new BFD pointer.
+
+	o If a null target string was provided to <<bfd_find_target>>,
+	look up the environment variable <<GNUTARGET>> and use
+	that as the target string.
+
+	o If the target string is still <<NULL>>, or the target string is
+	<<default>>, then use the first item in the target vector
+	as the target type, and set <<target_defaulted>> in the BFD to
+	cause <<bfd_check_format>> to loop through all the targets.
+	@xref{bfd_target}.  @xref{Formats}.
+
+	o Otherwise, inspect the elements in the target vector
+	one by one, until a match on target name is found. When found,
+	use it.
+
+	o Otherwise return the error <<bfd_error_invalid_target>> to
+	<<bfd_openr>>.
+
+	o <<bfd_openr>> attempts to open the file using
+	<<bfd_open_file>>, and returns the BFD.
+
+	Once the BFD has been opened and the target selected, the file
+	format may be determined. This is done by calling
+	<<bfd_check_format>> on the BFD with a suggested format.
+	If <<target_defaulted>> has been set, each possible target
+	type is tried to see if it recognizes the specified format.
+	<<bfd_check_format>> returns <<TRUE>> when the caller guesses right.
+@menu
+@* bfd_target::
+@end menu
+*/
+
+/*
+
+INODE
+	bfd_target,  , Targets, Targets
+DOCDD
+SUBSECTION
+	bfd_target
+
+DESCRIPTION
+	This structure contains everything that BFD knows about a
+	target. It includes things like its byte order, name, and which
+	routines to call to do various operations.
+
+	Every BFD points to a target structure with its <<xvec>>
+	member.
+
+	The macros below are used to dispatch to functions through the
+	<<bfd_target>> vector. They are used in a number of macros further
+	down in @file{bfd.h}, and are also used when calling various
+	routines by hand inside the BFD implementation.  The @var{arglist}
+	argument must be parenthesized; it contains all the arguments
+	to the called function.
+
+	They make the documentation (more) unpleasant to read, so if
+	someone wants to fix this and not break the above, please do.
+
+.#define BFD_SEND(bfd, message, arglist) \
+.  ((*((bfd)->xvec->message)) arglist)
+.
+.#ifdef DEBUG_BFD_SEND
+.#undef BFD_SEND
+.#define BFD_SEND(bfd, message, arglist) \
+.  (((bfd) && (bfd)->xvec && (bfd)->xvec->message) ? \
+.    ((*((bfd)->xvec->message)) arglist) : \
+.    (bfd_assert (__FILE__,__LINE__), NULL))
+.#endif
+
+	For operations which index on the BFD format:
+
+.#define BFD_SEND_FMT(bfd, message, arglist) \
+.  (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist)
+.
+.#ifdef DEBUG_BFD_SEND
+.#undef BFD_SEND_FMT
+.#define BFD_SEND_FMT(bfd, message, arglist) \
+.  (((bfd) && (bfd)->xvec && (bfd)->xvec->message) ? \
+.   (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist) : \
+.   (bfd_assert (__FILE__,__LINE__), NULL))
+.#endif
+.
+	This is the structure which defines the type of BFD this is.  The
+	<<xvec>> member of the struct <<bfd>> itself points here.  Each
+	module that implements access to a different target under BFD,
+	defines one of these.
+
+	FIXME, these names should be rationalised with the names of
+	the entry points which call them. Too bad we can't have one
+	macro to define them both!
+
+.enum bfd_flavour
+.{
+.  {* N.B. Update bfd_flavour_name if you change this.  *}
+.  bfd_target_unknown_flavour,
+.  bfd_target_aout_flavour,
+.  bfd_target_coff_flavour,
+.  bfd_target_ecoff_flavour,
+.  bfd_target_xcoff_flavour,
+.  bfd_target_elf_flavour,
+.  bfd_target_ieee_flavour,
+.  bfd_target_nlm_flavour,
+.  bfd_target_oasys_flavour,
+.  bfd_target_tekhex_flavour,
+.  bfd_target_srec_flavour,
+.  bfd_target_verilog_flavour,
+.  bfd_target_ihex_flavour,
+.  bfd_target_som_flavour,
+.  bfd_target_os9k_flavour,
+.  bfd_target_versados_flavour,
+.  bfd_target_msdos_flavour,
+.  bfd_target_ovax_flavour,
+.  bfd_target_evax_flavour,
+.  bfd_target_mmo_flavour,
+.  bfd_target_mach_o_flavour,
+.  bfd_target_pef_flavour,
+.  bfd_target_pef_xlib_flavour,
+.  bfd_target_sym_flavour
+.};
+.
+.enum bfd_endian { BFD_ENDIAN_BIG, BFD_ENDIAN_LITTLE, BFD_ENDIAN_UNKNOWN };
+.
+.{* Forward declaration.  *}
+.typedef struct bfd_link_info _bfd_link_info;
+.
+.{* Forward declaration.  *}
+.typedef struct flag_info flag_info;
+.
+.typedef struct bfd_target
+.{
+.  {* Identifies the kind of target, e.g., SunOS4, Ultrix, etc.  *}
+.  char *name;
+.
+. {* The "flavour" of a back end is a general indication about
+.    the contents of a file.  *}
+.  enum bfd_flavour flavour;
+.
+.  {* The order of bytes within the data area of a file.  *}
+.  enum bfd_endian byteorder;
+.
+. {* The order of bytes within the header parts of a file.  *}
+.  enum bfd_endian header_byteorder;
+.
+.  {* A mask of all the flags which an executable may have set -
+.     from the set <<BFD_NO_FLAGS>>, <<HAS_RELOC>>, ...<<D_PAGED>>.  *}
+.  flagword object_flags;
+.
+. {* A mask of all the flags which a section may have set - from
+.    the set <<SEC_NO_FLAGS>>, <<SEC_ALLOC>>, ...<<SET_NEVER_LOAD>>.  *}
+.  flagword section_flags;
+.
+. {* The character normally found at the front of a symbol.
+.    (if any), perhaps `_'.  *}
+.  char symbol_leading_char;
+.
+. {* The pad character for file names within an archive header.  *}
+.  char ar_pad_char;
+.
+.  {* The maximum number of characters in an archive header.  *}
+.  unsigned char ar_max_namelen;
+.
+.  {* How well this target matches, used to select between various
+.     possible targets when more than one target matches.  *}
+.  unsigned char match_priority;
+.
+.  {* Entries for byte swapping for data. These are different from the
+.     other entry points, since they don't take a BFD as the first argument.
+.     Certain other handlers could do the same.  *}
+.  bfd_uint64_t   (*bfd_getx64) (const void *);
+.  bfd_int64_t    (*bfd_getx_signed_64) (const void *);
+.  void           (*bfd_putx64) (bfd_uint64_t, void *);
+.  bfd_vma        (*bfd_getx32) (const void *);
+.  bfd_signed_vma (*bfd_getx_signed_32) (const void *);
+.  void           (*bfd_putx32) (bfd_vma, void *);
+.  bfd_vma        (*bfd_getx16) (const void *);
+.  bfd_signed_vma (*bfd_getx_signed_16) (const void *);
+.  void           (*bfd_putx16) (bfd_vma, void *);
+.
+.  {* Byte swapping for the headers.  *}
+.  bfd_uint64_t   (*bfd_h_getx64) (const void *);
+.  bfd_int64_t    (*bfd_h_getx_signed_64) (const void *);
+.  void           (*bfd_h_putx64) (bfd_uint64_t, void *);
+.  bfd_vma        (*bfd_h_getx32) (const void *);
+.  bfd_signed_vma (*bfd_h_getx_signed_32) (const void *);
+.  void           (*bfd_h_putx32) (bfd_vma, void *);
+.  bfd_vma        (*bfd_h_getx16) (const void *);
+.  bfd_signed_vma (*bfd_h_getx_signed_16) (const void *);
+.  void           (*bfd_h_putx16) (bfd_vma, void *);
+.
+.  {* Format dependent routines: these are vectors of entry points
+.     within the target vector structure, one for each format to check.  *}
+.
+.  {* Check the format of a file being read.  Return a <<bfd_target *>> or zero.  *}
+.  const struct bfd_target *(*_bfd_check_format[bfd_type_end]) (bfd *);
+.
+.  {* Set the format of a file being written.  *}
+.  bfd_boolean (*_bfd_set_format[bfd_type_end]) (bfd *);
+.
+.  {* Write cached information into a file being written, at <<bfd_close>>.  *}
+.  bfd_boolean (*_bfd_write_contents[bfd_type_end]) (bfd *);
+.
+The general target vector.  These vectors are initialized using the
+BFD_JUMP_TABLE macros.
+.
+.  {* Generic entry points.  *}
+.#define BFD_JUMP_TABLE_GENERIC(NAME) \
+.  NAME##_close_and_cleanup, \
+.  NAME##_bfd_free_cached_info, \
+.  NAME##_new_section_hook, \
+.  NAME##_get_section_contents, \
+.  NAME##_get_section_contents_in_window
+.
+.  {* Called when the BFD is being closed to do any necessary cleanup.  *}
+.  bfd_boolean (*_close_and_cleanup) (bfd *);
+.  {* Ask the BFD to free all cached information.  *}
+.  bfd_boolean (*_bfd_free_cached_info) (bfd *);
+.  {* Called when a new section is created.  *}
+.  bfd_boolean (*_new_section_hook) (bfd *, sec_ptr);
+.  {* Read the contents of a section.  *}
+.  bfd_boolean (*_bfd_get_section_contents)
+.    (bfd *, sec_ptr, void *, file_ptr, bfd_size_type);
+.  bfd_boolean (*_bfd_get_section_contents_in_window)
+.    (bfd *, sec_ptr, bfd_window *, file_ptr, bfd_size_type);
+.
+.  {* Entry points to copy private data.  *}
+.#define BFD_JUMP_TABLE_COPY(NAME) \
+.  NAME##_bfd_copy_private_bfd_data, \
+.  NAME##_bfd_merge_private_bfd_data, \
+.  _bfd_generic_init_private_section_data, \
+.  NAME##_bfd_copy_private_section_data, \
+.  NAME##_bfd_copy_private_symbol_data, \
+.  NAME##_bfd_copy_private_header_data, \
+.  NAME##_bfd_set_private_flags, \
+.  NAME##_bfd_print_private_bfd_data
+.
+.  {* Called to copy BFD general private data from one object file
+.     to another.  *}
+.  bfd_boolean (*_bfd_copy_private_bfd_data) (bfd *, bfd *);
+.  {* Called to merge BFD general private data from one object file
+.     to a common output file when linking.  *}
+.  bfd_boolean (*_bfd_merge_private_bfd_data) (bfd *, bfd *);
+.  {* Called to initialize BFD private section data from one object file
+.     to another.  *}
+.#define bfd_init_private_section_data(ibfd, isec, obfd, osec, link_info) \
+.  BFD_SEND (obfd, _bfd_init_private_section_data, (ibfd, isec, obfd, osec, link_info))
+.  bfd_boolean (*_bfd_init_private_section_data)
+.    (bfd *, sec_ptr, bfd *, sec_ptr, struct bfd_link_info *);
+.  {* Called to copy BFD private section data from one object file
+.     to another.  *}
+.  bfd_boolean (*_bfd_copy_private_section_data)
+.    (bfd *, sec_ptr, bfd *, sec_ptr);
+.  {* Called to copy BFD private symbol data from one symbol
+.     to another.  *}
+.  bfd_boolean (*_bfd_copy_private_symbol_data)
+.    (bfd *, asymbol *, bfd *, asymbol *);
+.  {* Called to copy BFD private header data from one object file
+.     to another.  *}
+.  bfd_boolean (*_bfd_copy_private_header_data)
+.    (bfd *, bfd *);
+.  {* Called to set private backend flags.  *}
+.  bfd_boolean (*_bfd_set_private_flags) (bfd *, flagword);
+.
+.  {* Called to print private BFD data.  *}
+.  bfd_boolean (*_bfd_print_private_bfd_data) (bfd *, void *);
+.
+.  {* Core file entry points.  *}
+.#define BFD_JUMP_TABLE_CORE(NAME) \
+.  NAME##_core_file_failing_command, \
+.  NAME##_core_file_failing_signal, \
+.  NAME##_core_file_matches_executable_p, \
+.  NAME##_core_file_pid
+.
+.  char *      (*_core_file_failing_command) (bfd *);
+.  int         (*_core_file_failing_signal) (bfd *);
+.  bfd_boolean (*_core_file_matches_executable_p) (bfd *, bfd *);
+.  int         (*_core_file_pid) (bfd *);
+.
+.  {* Archive entry points.  *}
+.#define BFD_JUMP_TABLE_ARCHIVE(NAME) \
+.  NAME##_slurp_armap, \
+.  NAME##_slurp_extended_name_table, \
+.  NAME##_construct_extended_name_table, \
+.  NAME##_truncate_arname, \
+.  NAME##_write_armap, \
+.  NAME##_read_ar_hdr, \
+.  NAME##_write_ar_hdr, \
+.  NAME##_openr_next_archived_file, \
+.  NAME##_get_elt_at_index, \
+.  NAME##_generic_stat_arch_elt, \
+.  NAME##_update_armap_timestamp
+.
+.  bfd_boolean (*_bfd_slurp_armap) (bfd *);
+.  bfd_boolean (*_bfd_slurp_extended_name_table) (bfd *);
+.  bfd_boolean (*_bfd_construct_extended_name_table)
+.    (bfd *, char **, bfd_size_type *, const char **);
+.  void        (*_bfd_truncate_arname) (bfd *, const char *, char *);
+.  bfd_boolean (*write_armap)
+.    (bfd *, unsigned int, struct orl *, unsigned int, int);
+.  void *      (*_bfd_read_ar_hdr_fn) (bfd *);
+.  bfd_boolean (*_bfd_write_ar_hdr_fn) (bfd *, bfd *);
+.  bfd *       (*openr_next_archived_file) (bfd *, bfd *);
+.#define bfd_get_elt_at_index(b,i) BFD_SEND (b, _bfd_get_elt_at_index, (b,i))
+.  bfd *       (*_bfd_get_elt_at_index) (bfd *, symindex);
+.  int         (*_bfd_stat_arch_elt) (bfd *, struct stat *);
+.  bfd_boolean (*_bfd_update_armap_timestamp) (bfd *);
+.
+.  {* Entry points used for symbols.  *}
+.#define BFD_JUMP_TABLE_SYMBOLS(NAME) \
+.  NAME##_get_symtab_upper_bound, \
+.  NAME##_canonicalize_symtab, \
+.  NAME##_make_empty_symbol, \
+.  NAME##_print_symbol, \
+.  NAME##_get_symbol_info, \
+.  NAME##_get_symbol_version_string, \
+.  NAME##_bfd_is_local_label_name, \
+.  NAME##_bfd_is_target_special_symbol, \
+.  NAME##_get_lineno, \
+.  NAME##_find_nearest_line, \
+.  NAME##_find_line, \
+.  NAME##_find_inliner_info, \
+.  NAME##_bfd_make_debug_symbol, \
+.  NAME##_read_minisymbols, \
+.  NAME##_minisymbol_to_symbol
+.
+.  long        (*_bfd_get_symtab_upper_bound) (bfd *);
+.  long        (*_bfd_canonicalize_symtab)
+.    (bfd *, struct bfd_symbol **);
+.  struct bfd_symbol *
+.              (*_bfd_make_empty_symbol) (bfd *);
+.  void        (*_bfd_print_symbol)
+.    (bfd *, void *, struct bfd_symbol *, bfd_print_symbol_type);
+.#define bfd_print_symbol(b,p,s,e) BFD_SEND (b, _bfd_print_symbol, (b,p,s,e))
+.  void        (*_bfd_get_symbol_info)
+.    (bfd *, struct bfd_symbol *, symbol_info *);
+.#define bfd_get_symbol_info(b,p,e) BFD_SEND (b, _bfd_get_symbol_info, (b,p,e))
+.  const char *(*_bfd_get_symbol_version_string)
+.    (bfd *, struct bfd_symbol *, bfd_boolean *);
+.#define bfd_get_symbol_version_string(b,s,h) BFD_SEND (b, _bfd_get_symbol_version_string, (b,s,h))
+.  bfd_boolean (*_bfd_is_local_label_name) (bfd *, const char *);
+.  bfd_boolean (*_bfd_is_target_special_symbol) (bfd *, asymbol *);
+.  alent *     (*_get_lineno) (bfd *, struct bfd_symbol *);
+.  bfd_boolean (*_bfd_find_nearest_line)
+.    (bfd *, struct bfd_symbol **, struct bfd_section *, bfd_vma,
+.     const char **, const char **, unsigned int *, unsigned int *);
+.  bfd_boolean (*_bfd_find_line)
+.    (bfd *, struct bfd_symbol **, struct bfd_symbol *,
+.     const char **, unsigned int *);
+.  bfd_boolean (*_bfd_find_inliner_info)
+.    (bfd *, const char **, const char **, unsigned int *);
+. {* Back-door to allow format-aware applications to create debug symbols
+.    while using BFD for everything else.  Currently used by the assembler
+.    when creating COFF files.  *}
+.  asymbol *   (*_bfd_make_debug_symbol)
+.    (bfd *, void *, unsigned long size);
+.#define bfd_read_minisymbols(b, d, m, s) \
+.  BFD_SEND (b, _read_minisymbols, (b, d, m, s))
+.  long        (*_read_minisymbols)
+.    (bfd *, bfd_boolean, void **, unsigned int *);
+.#define bfd_minisymbol_to_symbol(b, d, m, f) \
+.  BFD_SEND (b, _minisymbol_to_symbol, (b, d, m, f))
+.  asymbol *   (*_minisymbol_to_symbol)
+.    (bfd *, bfd_boolean, const void *, asymbol *);
+.
+.  {* Routines for relocs.  *}
+.#define BFD_JUMP_TABLE_RELOCS(NAME) \
+.  NAME##_get_reloc_upper_bound, \
+.  NAME##_canonicalize_reloc, \
+.  NAME##_bfd_reloc_type_lookup, \
+.  NAME##_bfd_reloc_name_lookup
+.
+.  long        (*_get_reloc_upper_bound) (bfd *, sec_ptr);
+.  long        (*_bfd_canonicalize_reloc)
+.    (bfd *, sec_ptr, arelent **, struct bfd_symbol **);
+.  {* See documentation on reloc types.  *}
+.  reloc_howto_type *
+.              (*reloc_type_lookup) (bfd *, bfd_reloc_code_real_type);
+.  reloc_howto_type *
+.              (*reloc_name_lookup) (bfd *, const char *);
+.
+.
+.  {* Routines used when writing an object file.  *}
+.#define BFD_JUMP_TABLE_WRITE(NAME) \
+.  NAME##_set_arch_mach, \
+.  NAME##_set_section_contents
+.
+.  bfd_boolean (*_bfd_set_arch_mach)
+.    (bfd *, enum bfd_architecture, unsigned long);
+.  bfd_boolean (*_bfd_set_section_contents)
+.    (bfd *, sec_ptr, const void *, file_ptr, bfd_size_type);
+.
+.  {* Routines used by the linker.  *}
+.#define BFD_JUMP_TABLE_LINK(NAME) \
+.  NAME##_sizeof_headers, \
+.  NAME##_bfd_get_relocated_section_contents, \
+.  NAME##_bfd_relax_section, \
+.  NAME##_bfd_link_hash_table_create, \
+.  NAME##_bfd_link_add_symbols, \
+.  NAME##_bfd_link_just_syms, \
+.  NAME##_bfd_copy_link_hash_symbol_type, \
+.  NAME##_bfd_final_link, \
+.  NAME##_bfd_link_split_section, \
+.  NAME##_bfd_gc_sections, \
+.  NAME##_bfd_lookup_section_flags, \
+.  NAME##_bfd_merge_sections, \
+.  NAME##_bfd_is_group_section, \
+.  NAME##_bfd_discard_group, \
+.  NAME##_section_already_linked, \
+.  NAME##_bfd_define_common_symbol
+.
+.  int         (*_bfd_sizeof_headers) (bfd *, struct bfd_link_info *);
+.  bfd_byte *  (*_bfd_get_relocated_section_contents)
+.    (bfd *, struct bfd_link_info *, struct bfd_link_order *,
+.     bfd_byte *, bfd_boolean, struct bfd_symbol **);
+.
+.  bfd_boolean (*_bfd_relax_section)
+.    (bfd *, struct bfd_section *, struct bfd_link_info *, bfd_boolean *);
+.
+.  {* Create a hash table for the linker.  Different backends store
+.     different information in this table.  *}
+.  struct bfd_link_hash_table *
+.              (*_bfd_link_hash_table_create) (bfd *);
+.
+.  {* Add symbols from this object file into the hash table.  *}
+.  bfd_boolean (*_bfd_link_add_symbols) (bfd *, struct bfd_link_info *);
+.
+.  {* Indicate that we are only retrieving symbol values from this section.  *}
+.  void        (*_bfd_link_just_syms) (asection *, struct bfd_link_info *);
+.
+.  {* Copy the symbol type and other attributes for a linker script
+.     assignment of one symbol to another.  *}
+.#define bfd_copy_link_hash_symbol_type(b, t, f) \
+.  BFD_SEND (b, _bfd_copy_link_hash_symbol_type, (b, t, f))
+.  void (*_bfd_copy_link_hash_symbol_type)
+.    (bfd *, struct bfd_link_hash_entry *, struct bfd_link_hash_entry *);
+.
+.  {* Do a link based on the link_order structures attached to each
+.     section of the BFD.  *}
+.  bfd_boolean (*_bfd_final_link) (bfd *, struct bfd_link_info *);
+.
+.  {* Should this section be split up into smaller pieces during linking.  *}
+.  bfd_boolean (*_bfd_link_split_section) (bfd *, struct bfd_section *);
+.
+.  {* Remove sections that are not referenced from the output.  *}
+.  bfd_boolean (*_bfd_gc_sections) (bfd *, struct bfd_link_info *);
+.
+.  {* Sets the bitmask of allowed and disallowed section flags.  *}
+.  bfd_boolean (*_bfd_lookup_section_flags) (struct bfd_link_info *,
+.					     struct flag_info *,
+.					     asection *);
+.
+.  {* Attempt to merge SEC_MERGE sections.  *}
+.  bfd_boolean (*_bfd_merge_sections) (bfd *, struct bfd_link_info *);
+.
+.  {* Is this section a member of a group?  *}
+.  bfd_boolean (*_bfd_is_group_section) (bfd *, const struct bfd_section *);
+.
+.  {* Discard members of a group.  *}
+.  bfd_boolean (*_bfd_discard_group) (bfd *, struct bfd_section *);
+.
+.  {* Check if SEC has been already linked during a reloceatable or
+.     final link.  *}
+.  bfd_boolean (*_section_already_linked) (bfd *, asection *,
+.					   struct bfd_link_info *);
+.
+.  {* Define a common symbol.  *}
+.  bfd_boolean (*_bfd_define_common_symbol) (bfd *, struct bfd_link_info *,
+.					     struct bfd_link_hash_entry *);
+.
+.  {* Routines to handle dynamic symbols and relocs.  *}
+.#define BFD_JUMP_TABLE_DYNAMIC(NAME) \
+.  NAME##_get_dynamic_symtab_upper_bound, \
+.  NAME##_canonicalize_dynamic_symtab, \
+.  NAME##_get_synthetic_symtab, \
+.  NAME##_get_dynamic_reloc_upper_bound, \
+.  NAME##_canonicalize_dynamic_reloc
+.
+.  {* Get the amount of memory required to hold the dynamic symbols.  *}
+.  long        (*_bfd_get_dynamic_symtab_upper_bound) (bfd *);
+.  {* Read in the dynamic symbols.  *}
+.  long        (*_bfd_canonicalize_dynamic_symtab)
+.    (bfd *, struct bfd_symbol **);
+.  {* Create synthetized symbols.  *}
+.  long        (*_bfd_get_synthetic_symtab)
+.    (bfd *, long, struct bfd_symbol **, long, struct bfd_symbol **,
+.     struct bfd_symbol **);
+.  {* Get the amount of memory required to hold the dynamic relocs.  *}
+.  long        (*_bfd_get_dynamic_reloc_upper_bound) (bfd *);
+.  {* Read in the dynamic relocs.  *}
+.  long        (*_bfd_canonicalize_dynamic_reloc)
+.    (bfd *, arelent **, struct bfd_symbol **);
+.
+
+A pointer to an alternative bfd_target in case the current one is not
+satisfactory.  This can happen when the target cpu supports both big
+and little endian code, and target chosen by the linker has the wrong
+endianness.  The function open_output() in ld/ldlang.c uses this field
+to find an alternative output format that is suitable.
+
+.  {* Opposite endian version of this target.  *}
+.  const struct bfd_target * alternative_target;
+.
+
+.  {* Data for use by back-end routines, which isn't
+.     generic enough to belong in this structure.  *}
+.  const void *backend_data;
+.
+.} bfd_target;
+.
+*/
+
+/* All known xvecs (even those that don't compile on all systems).
+   Alphabetized for easy reference.
+   They are listed a second time below, since
+   we can't intermix extern's and initializers.  */
+extern const bfd_target aarch64_elf32_be_vec;
+extern const bfd_target aarch64_elf32_le_vec;
+extern const bfd_target aarch64_elf64_be_vec;
+extern const bfd_target aarch64_elf64_be_cloudabi_vec;
+extern const bfd_target aarch64_elf64_le_vec;
+extern const bfd_target aarch64_elf64_le_cloudabi_vec;
+extern const bfd_target alpha_ecoff_le_vec;
+extern const bfd_target alpha_elf64_vec;
+extern const bfd_target alpha_elf64_fbsd_vec;
+extern const bfd_target alpha_nlm32_vec;
+extern const bfd_target alpha_vms_vec;
+extern const bfd_target alpha_vms_lib_txt_vec;
+extern const bfd_target am33_elf32_linux_vec;
+extern const bfd_target aout0_be_vec;
+extern const bfd_target aout64_vec;
+extern const bfd_target aout_vec;
+extern const bfd_target aout_adobe_vec;
+extern const bfd_target arc_elf32_be_vec;
+extern const bfd_target arc_elf32_le_vec;
+extern const bfd_target arm_aout_be_vec;
+extern const bfd_target arm_aout_le_vec;
+extern const bfd_target arm_aout_nbsd_vec;
+extern const bfd_target arm_aout_riscix_vec;
+extern const bfd_target arm_coff_be_vec;
+extern const bfd_target arm_coff_le_vec;
+extern const bfd_target arm_elf32_be_vec;
+extern const bfd_target arm_elf32_le_vec;
+extern const bfd_target arm_elf32_nacl_be_vec;
+extern const bfd_target arm_elf32_nacl_le_vec;
+extern const bfd_target arm_elf32_symbian_be_vec;
+extern const bfd_target arm_elf32_symbian_le_vec;
+extern const bfd_target arm_elf32_vxworks_be_vec;
+extern const bfd_target arm_elf32_vxworks_le_vec;
+extern const bfd_target arm_pe_be_vec;
+extern const bfd_target arm_pe_le_vec;
+extern const bfd_target arm_pe_epoc_be_vec;
+extern const bfd_target arm_pe_epoc_le_vec;
+extern const bfd_target arm_pe_wince_be_vec;
+extern const bfd_target arm_pe_wince_le_vec;
+extern const bfd_target arm_pei_be_vec;
+extern const bfd_target arm_pei_le_vec;
+extern const bfd_target arm_pei_epoc_be_vec;
+extern const bfd_target arm_pei_epoc_le_vec;
+extern const bfd_target arm_pei_wince_be_vec;
+extern const bfd_target arm_pei_wince_le_vec;
+extern const bfd_target avr_elf32_vec;
+extern const bfd_target bfin_elf32_vec;
+extern const bfd_target bfin_elf32_fdpic_vec;
+extern const bfd_target bout_be_vec;
+extern const bfd_target bout_le_vec;
+extern const bfd_target cr16_elf32_vec;
+extern const bfd_target cr16c_elf32_vec;
+extern const bfd_target cris_aout_vec;
+extern const bfd_target cris_elf32_vec;
+extern const bfd_target cris_elf32_us_vec;
+extern const bfd_target crx_elf32_vec;
+extern const bfd_target d10v_elf32_vec;
+extern const bfd_target d30v_elf32_vec;
+extern const bfd_target dlx_elf32_be_vec;
+extern const bfd_target elf32_be_vec;
+extern const bfd_target elf32_le_vec;
+extern const bfd_target elf64_be_vec;
+extern const bfd_target elf64_le_vec;
+extern const bfd_target epiphany_elf32_vec;
+extern const bfd_target fr30_elf32_vec;
+extern const bfd_target frv_elf32_vec;
+extern const bfd_target frv_elf32_fdpic_vec;
+extern const bfd_target h8300_coff_vec;
+extern const bfd_target h8300_elf32_vec;
+extern const bfd_target h8300_elf32_linux_vec;
+extern const bfd_target h8500_coff_vec;
+extern const bfd_target hppa_elf32_vec;
+extern const bfd_target hppa_elf32_linux_vec;
+extern const bfd_target hppa_elf32_nbsd_vec;
+extern const bfd_target hppa_elf64_vec;
+extern const bfd_target hppa_elf64_linux_vec;
+extern const bfd_target hppa_som_vec;
+extern const bfd_target i370_elf32_vec;
+extern const bfd_target i386_aout_vec;
+extern const bfd_target i386_aout_bsd_vec;
+extern const bfd_target i386_aout_dynix_vec;
+extern const bfd_target i386_aout_fbsd_vec;
+extern const bfd_target i386_aout_linux_vec;
+extern const bfd_target i386_aout_lynx_vec;
+extern const bfd_target i386_aout_mach3_vec;
+extern const bfd_target i386_aout_nbsd_vec;
+extern const bfd_target i386_aout_os9k_vec;
+extern const bfd_target i386_coff_vec;
+extern const bfd_target i386_coff_go32_vec;
+extern const bfd_target i386_coff_go32stubbed_vec;
+extern const bfd_target i386_coff_lynx_vec;
+extern const bfd_target i386_elf32_vec;
+extern const bfd_target i386_elf32_fbsd_vec;
+extern const bfd_target i386_elf32_nacl_vec;
+extern const bfd_target i386_elf32_sol2_vec;
+extern const bfd_target i386_elf32_vxworks_vec;
+extern const bfd_target i386_mach_o_vec;
+extern const bfd_target i386_msdos_vec;
+extern const bfd_target i386_nlm32_vec;
+extern const bfd_target i386_pe_vec;
+extern const bfd_target i386_pei_vec;
+extern const bfd_target iamcu_elf32_vec;
+extern const bfd_target i860_coff_vec;
+extern const bfd_target i860_elf32_vec;
+extern const bfd_target i860_elf32_le_vec;
+extern const bfd_target i960_elf32_vec;
+extern const bfd_target ia64_elf32_be_vec;
+extern const bfd_target ia64_elf32_hpux_be_vec;
+extern const bfd_target ia64_elf64_be_vec;
+extern const bfd_target ia64_elf64_le_vec;
+extern const bfd_target ia64_elf64_hpux_be_vec;
+extern const bfd_target ia64_elf64_vms_vec;
+extern const bfd_target ia64_pei_vec;
+extern const bfd_target icoff_be_vec;
+extern const bfd_target icoff_le_vec;
+extern const bfd_target ieee_vec;
+extern const bfd_target ip2k_elf32_vec;
+extern const bfd_target iq2000_elf32_vec;
+extern const bfd_target k1om_elf64_vec;
+extern const bfd_target k1om_elf64_fbsd_vec;
+extern const bfd_target l1om_elf64_vec;
+extern const bfd_target l1om_elf64_fbsd_vec;
+extern const bfd_target lm32_elf32_vec;
+extern const bfd_target lm32_elf32_fdpic_vec;
+extern const bfd_target m32c_elf32_vec;
+extern const bfd_target m32r_elf32_vec;
+extern const bfd_target m32r_elf32_le_vec;
+extern const bfd_target m32r_elf32_linux_vec;
+extern const bfd_target m32r_elf32_linux_le_vec;
+extern const bfd_target m68hc11_elf32_vec;
+extern const bfd_target m68hc12_elf32_vec;
+extern const bfd_target m68k_aout_4knbsd_vec;
+extern const bfd_target m68k_aout_hp300bsd_vec;
+extern const bfd_target m68k_aout_hp300hpux_vec;
+extern const bfd_target m68k_aout_linux_vec;
+extern const bfd_target m68k_aout_nbsd_vec;
+extern const bfd_target m68k_aout_newsos3_vec;
+extern const bfd_target m68k_coff_vec;
+extern const bfd_target m68k_coff_apollo_vec;
+extern const bfd_target m68k_coff_aux_vec;
+extern const bfd_target m68k_coff_sysv_vec;
+extern const bfd_target m68k_coff_un_vec;
+extern const bfd_target m68k_elf32_vec;
+extern const bfd_target m68k_versados_vec;
+extern const bfd_target m88k_aout_mach3_vec;
+extern const bfd_target m88k_aout_obsd_vec;
+extern const bfd_target m88k_coff_bcs_vec;
+extern const bfd_target m88k_elf32_vec;
+extern const bfd_target mach_o_be_vec;
+extern const bfd_target mach_o_le_vec;
+extern const bfd_target mach_o_fat_vec;
+extern const bfd_target mcore_elf32_be_vec;
+extern const bfd_target mcore_elf32_le_vec;
+extern const bfd_target mcore_pe_be_vec;
+extern const bfd_target mcore_pe_le_vec;
+extern const bfd_target mcore_pei_be_vec;
+extern const bfd_target mcore_pei_le_vec;
+extern const bfd_target mep_elf32_vec;
+extern const bfd_target mep_elf32_le_vec;
+extern const bfd_target metag_elf32_vec;
+extern const bfd_target microblaze_elf32_vec;
+extern const bfd_target microblaze_elf32_le_vec;
+extern const bfd_target mips_aout_be_vec;
+extern const bfd_target mips_aout_le_vec;
+extern const bfd_target mips_ecoff_be_vec;
+extern const bfd_target mips_ecoff_le_vec;
+extern const bfd_target mips_ecoff_bele_vec;
+extern const bfd_target mips_elf32_be_vec;
+extern const bfd_target mips_elf32_le_vec;
+extern const bfd_target mips_elf32_n_be_vec;
+extern const bfd_target mips_elf32_n_le_vec;
+extern const bfd_target mips_elf32_ntrad_be_vec;
+extern const bfd_target mips_elf32_ntrad_le_vec;
+extern const bfd_target mips_elf32_ntradfbsd_be_vec;
+extern const bfd_target mips_elf32_ntradfbsd_le_vec;
+extern const bfd_target mips_elf32_trad_be_vec;
+extern const bfd_target mips_elf32_trad_le_vec;
+extern const bfd_target mips_elf32_tradfbsd_be_vec;
+extern const bfd_target mips_elf32_tradfbsd_le_vec;
+extern const bfd_target mips_elf32_vxworks_be_vec;
+extern const bfd_target mips_elf32_vxworks_le_vec;
+extern const bfd_target mips_elf64_be_vec;
+extern const bfd_target mips_elf64_le_vec;
+extern const bfd_target mips_elf64_trad_be_vec;
+extern const bfd_target mips_elf64_trad_le_vec;
+extern const bfd_target mips_elf64_tradfbsd_be_vec;
+extern const bfd_target mips_elf64_tradfbsd_le_vec;
+extern const bfd_target mips_pe_le_vec;
+extern const bfd_target mips_pei_le_vec;
+extern const bfd_target mmix_elf64_vec;
+extern const bfd_target mmix_mmo_vec;
+extern const bfd_target mn10200_elf32_vec;
+extern const bfd_target mn10300_elf32_vec;
+extern const bfd_target moxie_elf32_be_vec;
+extern const bfd_target moxie_elf32_le_vec;
+extern const bfd_target msp430_elf32_vec;
+extern const bfd_target msp430_elf32_ti_vec;
+extern const bfd_target mt_elf32_vec;
+extern const bfd_target nds32_elf32_be_vec;
+extern const bfd_target nds32_elf32_le_vec;
+extern const bfd_target nds32_elf32_linux_be_vec;
+extern const bfd_target nds32_elf32_linux_le_vec;
+extern const bfd_target nios2_elf32_be_vec;
+extern const bfd_target nios2_elf32_le_vec;
+extern const bfd_target ns32k_aout_pc532mach_vec;
+extern const bfd_target ns32k_aout_pc532nbsd_vec;
+extern const bfd_target oasys_vec;
+extern const bfd_target or1k_elf32_vec;
+extern const bfd_target pdp11_aout_vec;
+extern const bfd_target pef_vec;
+extern const bfd_target pef_xlib_vec;
+extern const bfd_target pj_elf32_vec;
+extern const bfd_target pj_elf32_le_vec;
+extern const bfd_target plugin_vec;
+extern const bfd_target powerpc_boot_vec;
+extern const bfd_target powerpc_elf32_vec;
+extern const bfd_target powerpc_elf32_le_vec;
+extern const bfd_target powerpc_elf32_fbsd_vec;
+extern const bfd_target powerpc_elf32_vxworks_vec;
+extern const bfd_target powerpc_elf64_vec;
+extern const bfd_target powerpc_elf64_le_vec;
+extern const bfd_target powerpc_elf64_fbsd_vec;
+extern const bfd_target powerpc_nlm32_vec;
+extern const bfd_target powerpc_pe_vec;
+extern const bfd_target powerpc_pe_le_vec;
+extern const bfd_target powerpc_pei_vec;
+extern const bfd_target powerpc_pei_le_vec;
+extern const bfd_target powerpc_xcoff_vec;
+extern const bfd_target rl78_elf32_vec;
+extern const bfd_target rs6000_xcoff64_vec;
+extern const bfd_target rs6000_xcoff64_aix_vec;
+extern const bfd_target rs6000_xcoff_vec;
+extern const bfd_target rx_elf32_be_vec;
+extern const bfd_target rx_elf32_be_ns_vec;
+extern const bfd_target rx_elf32_le_vec;
+extern const bfd_target s390_elf32_vec;
+extern const bfd_target s390_elf64_vec;
+extern const bfd_target score_elf32_be_vec;
+extern const bfd_target score_elf32_le_vec;
+extern const bfd_target sh64_elf32_vec;
+extern const bfd_target sh64_elf32_le_vec;
+extern const bfd_target sh64_elf32_linux_vec;
+extern const bfd_target sh64_elf32_linux_be_vec;
+extern const bfd_target sh64_elf32_nbsd_vec;
+extern const bfd_target sh64_elf32_nbsd_le_vec;
+extern const bfd_target sh64_elf64_vec;
+extern const bfd_target sh64_elf64_le_vec;
+extern const bfd_target sh64_elf64_linux_vec;
+extern const bfd_target sh64_elf64_linux_be_vec;
+extern const bfd_target sh64_elf64_nbsd_vec;
+extern const bfd_target sh64_elf64_nbsd_le_vec;
+extern const bfd_target sh_coff_vec;
+extern const bfd_target sh_coff_le_vec;
+extern const bfd_target sh_coff_small_vec;
+extern const bfd_target sh_coff_small_le_vec;
+extern const bfd_target sh_elf32_vec;
+extern const bfd_target sh_elf32_le_vec;
+extern const bfd_target sh_elf32_fdpic_be_vec;
+extern const bfd_target sh_elf32_fdpic_le_vec;
+extern const bfd_target sh_elf32_linux_vec;
+extern const bfd_target sh_elf32_linux_be_vec;
+extern const bfd_target sh_elf32_nbsd_vec;
+extern const bfd_target sh_elf32_nbsd_le_vec;
+extern const bfd_target sh_elf32_symbian_le_vec;
+extern const bfd_target sh_elf32_vxworks_vec;
+extern const bfd_target sh_elf32_vxworks_le_vec;
+extern const bfd_target sh_pe_le_vec;
+extern const bfd_target sh_pei_le_vec;
+extern const bfd_target sparc_aout_le_vec;
+extern const bfd_target sparc_aout_linux_vec;
+extern const bfd_target sparc_aout_lynx_vec;
+extern const bfd_target sparc_aout_nbsd_vec;
+extern const bfd_target sparc_aout_sunos_be_vec;
+extern const bfd_target sparc_coff_vec;
+extern const bfd_target sparc_coff_lynx_vec;
+extern const bfd_target sparc_elf32_vec;
+extern const bfd_target sparc_elf32_sol2_vec;
+extern const bfd_target sparc_elf32_vxworks_vec;
+extern const bfd_target sparc_elf64_vec;
+extern const bfd_target sparc_elf64_fbsd_vec;
+extern const bfd_target sparc_elf64_sol2_vec;
+extern const bfd_target sparc_nlm32_vec;
+extern const bfd_target spu_elf32_vec;
+extern const bfd_target sym_vec;
+extern const bfd_target tic30_aout_vec;
+extern const bfd_target tic30_coff_vec;
+extern const bfd_target tic4x_coff0_vec;
+extern const bfd_target tic4x_coff0_beh_vec;
+extern const bfd_target tic4x_coff1_vec;
+extern const bfd_target tic4x_coff1_beh_vec;
+extern const bfd_target tic4x_coff2_vec;
+extern const bfd_target tic4x_coff2_beh_vec;
+extern const bfd_target tic54x_coff0_vec;
+extern const bfd_target tic54x_coff0_beh_vec;
+extern const bfd_target tic54x_coff1_vec;
+extern const bfd_target tic54x_coff1_beh_vec;
+extern const bfd_target tic54x_coff2_vec;
+extern const bfd_target tic54x_coff2_beh_vec;
+extern const bfd_target tic6x_elf32_be_vec;
+extern const bfd_target tic6x_elf32_le_vec;
+extern const bfd_target tic6x_elf32_c6000_be_vec;
+extern const bfd_target tic6x_elf32_c6000_le_vec;
+extern const bfd_target tic6x_elf32_linux_be_vec;
+extern const bfd_target tic6x_elf32_linux_le_vec;
+extern const bfd_target tic80_coff_vec;
+extern const bfd_target tilegx_elf32_be_vec;
+extern const bfd_target tilegx_elf32_le_vec;
+extern const bfd_target tilegx_elf64_be_vec;
+extern const bfd_target tilegx_elf64_le_vec;
+extern const bfd_target tilepro_elf32_vec;
+extern const bfd_target v800_elf32_vec;
+extern const bfd_target v850_elf32_vec;
+extern const bfd_target ft32_elf32_vec;
+extern const bfd_target vax_aout_1knbsd_vec;
+extern const bfd_target vax_aout_bsd_vec;
+extern const bfd_target vax_aout_nbsd_vec;
+extern const bfd_target vax_elf32_vec;
+extern const bfd_target visium_elf32_vec;
+extern const bfd_target w65_coff_vec;
+extern const bfd_target we32k_coff_vec;
+extern const bfd_target x86_64_coff_vec;
+extern const bfd_target x86_64_elf32_vec;
+extern const bfd_target x86_64_elf32_nacl_vec;
+extern const bfd_target x86_64_elf64_vec;
+extern const bfd_target x86_64_elf64_cloudabi_vec;
+extern const bfd_target x86_64_elf64_fbsd_vec;
+extern const bfd_target x86_64_elf64_nacl_vec;
+extern const bfd_target x86_64_elf64_sol2_vec;
+extern const bfd_target x86_64_mach_o_vec;
+extern const bfd_target x86_64_pe_vec;
+extern const bfd_target x86_64_pe_be_vec;
+extern const bfd_target x86_64_pei_vec;
+extern const bfd_target xc16x_elf32_vec;
+extern const bfd_target xgate_elf32_vec;
+extern const bfd_target xstormy16_elf32_vec;
+extern const bfd_target xtensa_elf32_be_vec;
+extern const bfd_target xtensa_elf32_le_vec;
+extern const bfd_target z80_coff_vec;
+extern const bfd_target z8k_coff_vec;
+
+/* These are always included.  */
+extern const bfd_target srec_vec;
+extern const bfd_target symbolsrec_vec;
+extern const bfd_target verilog_vec;
+extern const bfd_target tekhex_vec;
+extern const bfd_target binary_vec;
+extern const bfd_target ihex_vec;
+
+/* All of the xvecs for core files.  */
+extern const bfd_target core_aix386_vec;
+extern const bfd_target core_cisco_be_vec;
+extern const bfd_target core_cisco_le_vec;
+extern const bfd_target core_hppabsd_vec;
+extern const bfd_target core_hpux_vec;
+extern const bfd_target core_irix_vec;
+extern const bfd_target core_netbsd_vec;
+extern const bfd_target core_osf_vec;
+extern const bfd_target core_ptrace_vec;
+extern const bfd_target core_sco5_vec;
+extern const bfd_target core_trad_vec;
+
+static const bfd_target * const _bfd_target_vector[] =
+{
+#ifdef SELECT_VECS
+
+	SELECT_VECS,
+
+#else /* not SELECT_VECS */
+
+#ifdef DEFAULT_VECTOR
+	&DEFAULT_VECTOR,
+#endif
+	/* This list is alphabetized to make it easy to compare
+	   with other vector lists -- the decls above and
+	   the case statement in configure.ac.
+	   Try to keep it in order when adding new targets, and
+	   use a name of the form <cpu>_<format>_<other>_<endian>_vec.
+	   Note that sorting is done as if _<endian>_vec wasn't present.
+	   Vectors that don't compile on all systems, or aren't finished,
+	   should have an entry here with #if 0 around it, to show that
+	   it wasn't omitted by mistake.  */
+#ifdef BFD64
+	&aarch64_elf32_be_vec,
+	&aarch64_elf32_le_vec,
+	&aarch64_elf64_be_vec,
+	&aarch64_elf64_be_cloudabi_vec,
+	&aarch64_elf64_le_vec,
+	&aarch64_elf64_le_cloudabi_vec,
+#endif
+
+#ifdef BFD64
+	&alpha_ecoff_le_vec,
+	&alpha_elf64_vec,
+	&alpha_elf64_fbsd_vec,
+	&alpha_nlm32_vec,
+	&alpha_vms_vec,
+#endif
+	&alpha_vms_lib_txt_vec,
+
+	&am33_elf32_linux_vec,
+
+	&aout0_be_vec,
+#ifdef BFD64
+	&aout64_vec,	/* Only compiled if host has long-long support.  */
+#endif
+#if 0
+	/* Since a.out files lack decent magic numbers, no way to recognize
+	   which kind of a.out file it is.  */
+	&aout_vec,
+#endif
+	&aout_adobe_vec,
+
+	&arc_elf32_be_vec,
+	&arc_elf32_le_vec,
+
+#if 0
+	/* We have no way of distinguishing these from other a.out variants.  */
+	&arm_aout_be_vec,
+	&arm_aout_le_vec,
+#endif
+	&arm_aout_nbsd_vec,
+#if 0
+	/* We have no way of distinguishing these from other a.out variants.  */
+	&arm_aout_riscix_vec,
+#endif
+	&arm_coff_be_vec,
+	&arm_coff_le_vec,
+	&arm_elf32_be_vec,
+	&arm_elf32_le_vec,
+	&arm_elf32_symbian_be_vec,
+	&arm_elf32_symbian_le_vec,
+	&arm_elf32_vxworks_be_vec,
+	&arm_elf32_vxworks_le_vec,
+	&arm_pe_be_vec,
+	&arm_pe_le_vec,
+	&arm_pe_epoc_be_vec,
+	&arm_pe_epoc_le_vec,
+	&arm_pe_wince_be_vec,
+	&arm_pe_wince_le_vec,
+	&arm_pei_be_vec,
+	&arm_pei_le_vec,
+	&arm_pei_epoc_be_vec,
+	&arm_pei_epoc_le_vec,
+	&arm_pei_wince_be_vec,
+	&arm_pei_wince_le_vec,
+
+	&avr_elf32_vec,
+
+	&bfin_elf32_vec,
+	&bfin_elf32_fdpic_vec,
+
+	&bout_be_vec,
+	&bout_le_vec,
+
+	&cr16_elf32_vec,
+	&cr16c_elf32_vec,
+
+	&cris_aout_vec,
+	&cris_elf32_vec,
+	&cris_elf32_us_vec,
+
+	&crx_elf32_vec,
+
+	&d10v_elf32_vec,
+	&d30v_elf32_vec,
+
+	&dlx_elf32_be_vec,
+
+	/* This, and other vectors, may not be used in any *.mt configuration.
+	   But that does not mean they are unnecessary.  If configured with
+	   --enable-targets=all, objdump or gdb should be able to examine
+	   the file even if we don't recognize the machine type.  */
+	&elf32_be_vec,
+	&elf32_le_vec,
+#ifdef BFD64
+	&elf64_be_vec,
+	&elf64_le_vec,
+#endif
+
+	&epiphany_elf32_vec,
+
+	&fr30_elf32_vec,
+
+	&frv_elf32_vec,
+	&frv_elf32_fdpic_vec,
+
+	&h8300_coff_vec,
+	&h8300_elf32_vec,
+	&h8300_elf32_linux_vec,
+	&h8500_coff_vec,
+
+	&hppa_elf32_vec,
+	&hppa_elf32_linux_vec,
+	&hppa_elf32_nbsd_vec,
+#ifdef BFD64
+	&hppa_elf64_vec,
+	&hppa_elf64_linux_vec,
+#endif
+	&hppa_som_vec,
+
+	&i370_elf32_vec,
+
+	&i386_aout_vec,
+	&i386_aout_bsd_vec,
+#if 0
+	&i386_aout_dynix_vec,
+#endif
+	&i386_aout_fbsd_vec,
+#if 0
+	/* Since a.out files lack decent magic numbers, no way to recognize
+	   which kind of a.out file it is.  */
+	&i386_aout_linux_vec,
+#endif
+	&i386_aout_lynx_vec,
+#if 0
+	/* No distinguishing features for Mach 3 executables.  */
+	&i386_aout_mach3_vec,
+#endif
+	&i386_aout_nbsd_vec,
+	&i386_aout_os9k_vec,
+	&i386_coff_vec,
+	&i386_coff_go32_vec,
+	&i386_coff_go32stubbed_vec,
+	&i386_coff_lynx_vec,
+	&i386_elf32_vec,
+	&i386_elf32_fbsd_vec,
+	&i386_elf32_nacl_vec,
+	&i386_elf32_sol2_vec,
+	&i386_elf32_vxworks_vec,
+	&i386_mach_o_vec,
+	&i386_msdos_vec,
+	&i386_nlm32_vec,
+	&i386_pe_vec,
+	&i386_pei_vec,
+
+	&iamcu_elf32_vec,
+
+	&i860_coff_vec,
+	&i860_elf32_vec,
+	&i860_elf32_le_vec,
+
+	&i960_elf32_vec,
+
+#ifdef BFD64
+#if 0
+	&ia64_elf32_be_vec,
+#endif
+	&ia64_elf32_hpux_be_vec,
+	&ia64_elf64_be_vec,
+	&ia64_elf64_le_vec,
+	&ia64_elf64_hpux_be_vec,
+	&ia64_elf64_vms_vec,
+	&ia64_pei_vec,
+#endif
+
+	&icoff_be_vec,
+	&icoff_le_vec,
+
+	&ieee_vec,
+
+	&ip2k_elf32_vec,
+	&iq2000_elf32_vec,
+
+#ifdef BFD64
+	&k1om_elf64_vec,
+	&k1om_elf64_fbsd_vec,
+	&l1om_elf64_vec,
+	&l1om_elf64_fbsd_vec,
+#endif
+
+	&lm32_elf32_vec,
+
+	&m32c_elf32_vec,
+
+	&m32r_elf32_vec,
+	&m32r_elf32_le_vec,
+	&m32r_elf32_linux_vec,
+	&m32r_elf32_linux_le_vec,
+
+	&m68hc11_elf32_vec,
+	&m68hc12_elf32_vec,
+
+#if 0
+	&m68k_aout_4knbsd_vec,
+	/* Clashes with sparc_aout_sunos_be_vec magic no.  */
+	&m68k_aout_hp300bsd_vec,
+#endif
+	&m68k_aout_hp300hpux_vec,
+#if 0
+	/* Since a.out files lack decent magic numbers, no way to recognize
+	   which kind of a.out file it is.  */
+	&m68k_aout_linux_vec,
+#endif
+	&m68k_aout_nbsd_vec,
+	&m68k_aout_newsos3_vec,
+	&m68k_coff_vec,
+#if 0
+	&m68k_coff_apollo_vec,
+	&m68k_coff_aux_vec,
+#endif
+	&m68k_coff_sysv_vec,
+	&m68k_coff_un_vec,
+	&m68k_elf32_vec,
+	&m68k_versados_vec,
+
+	&m88k_aout_mach3_vec,
+	&m88k_aout_obsd_vec,
+	&m88k_coff_bcs_vec,
+	&m88k_elf32_vec,
+
+	&mach_o_be_vec,
+	&mach_o_le_vec,
+	&mach_o_fat_vec,
+
+	&mcore_elf32_be_vec,
+	&mcore_elf32_le_vec,
+	&mcore_pe_be_vec,
+	&mcore_pe_le_vec,
+	&mcore_pei_be_vec,
+	&mcore_pei_le_vec,
+
+	&mep_elf32_vec,
+
+	&metag_elf32_vec,
+
+	&microblaze_elf32_vec,
+
+#if 0
+	/* No one seems to use this.  */
+	&mips_aout_be_vec,
+#endif
+	&mips_aout_le_vec,
+	&mips_ecoff_be_vec,
+	&mips_ecoff_le_vec,
+	&mips_ecoff_bele_vec,
+#ifdef BFD64
+	&mips_elf32_be_vec,
+	&mips_elf32_le_vec,
+	&mips_elf32_n_be_vec,
+	&mips_elf32_n_le_vec,
+	&mips_elf32_ntrad_be_vec,
+	&mips_elf32_ntrad_le_vec,
+	&mips_elf32_ntradfbsd_be_vec,
+	&mips_elf32_ntradfbsd_le_vec,
+	&mips_elf32_trad_be_vec,
+	&mips_elf32_trad_le_vec,
+	&mips_elf32_tradfbsd_be_vec,
+	&mips_elf32_tradfbsd_le_vec,
+	&mips_elf32_vxworks_be_vec,
+	&mips_elf32_vxworks_le_vec,
+	&mips_elf64_be_vec,
+	&mips_elf64_le_vec,
+	&mips_elf64_trad_be_vec,
+	&mips_elf64_trad_le_vec,
+	&mips_elf64_tradfbsd_be_vec,
+	&mips_elf64_tradfbsd_le_vec,
+#endif
+	&mips_pe_le_vec,
+	&mips_pei_le_vec,
+
+#ifdef BFD64
+	&mmix_elf64_vec,
+	&mmix_mmo_vec,
+#endif
+
+	&mn10200_elf32_vec,
+	&mn10300_elf32_vec,
+
+	&moxie_elf32_be_vec,
+	&moxie_elf32_le_vec,
+
+	&msp430_elf32_vec,
+	&msp430_elf32_ti_vec,
+
+	&mt_elf32_vec,
+
+	&nds32_elf32_be_vec,
+	&nds32_elf32_le_vec,
+	&nds32_elf32_linux_be_vec,
+	&nds32_elf32_linux_le_vec,
+
+	&nios2_elf32_be_vec,
+	&nios2_elf32_le_vec,
+
+	&ns32k_aout_pc532mach_vec,
+	&ns32k_aout_pc532nbsd_vec,
+
+#if 0
+	/* We have no oasys tools anymore, so we can't test any of this
+	   anymore. If you want to test the stuff yourself, go ahead...
+	   steve@cygnus.com
+	   Worse, since there is no magic number for archives, there
+	   can be annoying target mis-matches.  */
+	&oasys_vec,
+#endif
+
+	&or1k_elf32_vec,
+
+	&pdp11_aout_vec,
+
+	&pef_vec,
+	&pef_xlib_vec,
+
+	&pj_elf32_vec,
+	&pj_elf32_le_vec,
+
+#if BFD_SUPPORTS_PLUGINS
+	&plugin_vec,
+#endif
+
+	&powerpc_boot_vec,
+	&powerpc_elf32_vec,
+	&powerpc_elf32_le_vec,
+	&powerpc_elf32_fbsd_vec,
+	&powerpc_elf32_vxworks_vec,
+#ifdef BFD64
+	&powerpc_elf64_vec,
+	&powerpc_elf64_le_vec,
+	&powerpc_elf64_fbsd_vec,
+#endif
+	&powerpc_nlm32_vec,
+	&powerpc_pe_vec,
+	&powerpc_pe_le_vec,
+	&powerpc_pei_vec,
+	&powerpc_pei_le_vec,
+#if 0
+	/* This has the same magic number as RS/6000.  */
+	&powerpc_xcoff_vec,
+#endif
+
+	&rl78_elf32_vec,
+
+#ifdef BFD64
+	&rs6000_xcoff64_vec,
+	&rs6000_xcoff64_aix_vec,
+#endif
+	&rs6000_xcoff_vec,
+
+	&rx_elf32_be_vec,
+	&rx_elf32_be_ns_vec,
+	&rx_elf32_le_vec,
+
+	&s390_elf32_vec,
+#ifdef BFD64
+	&s390_elf64_vec,
+#endif
+
+#ifdef BFD64
+	&score_elf32_be_vec,
+	&score_elf32_le_vec,
+#endif
+
+#ifdef BFD64
+	&sh64_elf32_vec,
+	&sh64_elf32_le_vec,
+	&sh64_elf32_linux_vec,
+	&sh64_elf32_linux_be_vec,
+	&sh64_elf32_nbsd_vec,
+	&sh64_elf32_nbsd_le_vec,
+	&sh64_elf64_vec,
+	&sh64_elf64_le_vec,
+	&sh64_elf64_linux_vec,
+	&sh64_elf64_linux_be_vec,
+	&sh64_elf64_nbsd_vec,
+	&sh64_elf64_nbsd_le_vec,
+#endif
+	&sh_coff_vec,
+	&sh_coff_le_vec,
+	&sh_coff_small_vec,
+	&sh_coff_small_le_vec,
+	&sh_elf32_vec,
+	&sh_elf32_le_vec,
+	&sh_elf32_fdpic_be_vec,
+	&sh_elf32_fdpic_le_vec,
+	&sh_elf32_linux_vec,
+	&sh_elf32_linux_be_vec,
+	&sh_elf32_nbsd_vec,
+	&sh_elf32_nbsd_le_vec,
+	&sh_elf32_symbian_le_vec,
+	&sh_elf32_vxworks_vec,
+	&sh_elf32_vxworks_le_vec,
+	&sh_pe_le_vec,
+	&sh_pei_le_vec,
+
+	&sparc_aout_le_vec,
+	&sparc_aout_linux_vec,
+	&sparc_aout_lynx_vec,
+	&sparc_aout_nbsd_vec,
+	&sparc_aout_sunos_be_vec,
+	&sparc_coff_vec,
+	&sparc_coff_lynx_vec,
+	&sparc_elf32_vec,
+	&sparc_elf32_sol2_vec,
+	&sparc_elf32_vxworks_vec,
+#ifdef BFD64
+	&sparc_elf64_vec,
+	&sparc_elf64_fbsd_vec,
+	&sparc_elf64_sol2_vec,
+#endif
+	&sparc_nlm32_vec,
+
+	&spu_elf32_vec,
+
+	&sym_vec,
+
+	&tic30_aout_vec,
+	&tic30_coff_vec,
+	&tic54x_coff0_beh_vec,
+	&tic54x_coff0_vec,
+	&tic54x_coff1_beh_vec,
+	&tic54x_coff1_vec,
+	&tic54x_coff2_beh_vec,
+	&tic54x_coff2_vec,
+	&tic6x_elf32_be_vec,
+	&tic6x_elf32_le_vec,
+	&tic80_coff_vec,
+
+	&tilegx_elf32_be_vec,
+	&tilegx_elf32_le_vec,
+#ifdef BFD64
+	&tilegx_elf64_be_vec,
+	&tilegx_elf64_le_vec,
+#endif
+	&tilepro_elf32_vec,
+
+	&ft32_elf32_vec,
+
+	&v800_elf32_vec,
+	&v850_elf32_vec,
+
+	&vax_aout_1knbsd_vec,
+	&vax_aout_bsd_vec,
+	&vax_aout_nbsd_vec,
+	&vax_elf32_vec,
+
+	&visium_elf32_vec,
+
+	&w65_coff_vec,
+
+	&we32k_coff_vec,
+
+#ifdef BFD64
+	&x86_64_coff_vec,
+	&x86_64_elf32_vec,
+	&x86_64_elf32_nacl_vec,
+	&x86_64_elf64_vec,
+	&x86_64_elf64_cloudabi_vec,
+	&x86_64_elf64_fbsd_vec,
+	&x86_64_elf64_nacl_vec,
+	&x86_64_elf64_sol2_vec,
+	&x86_64_mach_o_vec,
+	&x86_64_pe_vec,
+	&x86_64_pe_be_vec,
+	&x86_64_pei_vec,
+#endif
+
+	&xc16x_elf32_vec,
+
+	&xgate_elf32_vec,
+
+	&xstormy16_elf32_vec,
+
+	&xtensa_elf32_be_vec,
+	&xtensa_elf32_le_vec,
+
+	&z80_coff_vec,
+
+	&z8k_coff_vec,
+#endif /* not SELECT_VECS */
+
+/* Always support S-records, for convenience.  */
+	&srec_vec,
+	&symbolsrec_vec,
+/* And verilog.  */
+	&verilog_vec,
+/* And tekhex */
+	&tekhex_vec,
+/* Likewise for binary output.  */
+	&binary_vec,
+/* Likewise for ihex.  */
+	&ihex_vec,
+
+/* Add any required traditional-core-file-handler.  */
+
+#ifdef AIX386_CORE
+	&core_aix386_vec,
+#endif
+#if 0
+	/* We don't include cisco_core_*_vec.  Although it has a magic number,
+	   the magic number isn't at the beginning of the file, and thus
+	   might spuriously match other kinds of files.  */
+	&core_cisco_be_vec,
+	&core_cisco_le_vec,
+#endif
+#ifdef HPPABSD_CORE
+	&core_hppabsd_vec,
+#endif
+#ifdef HPUX_CORE
+	&core_hpux_vec,
+#endif
+#ifdef IRIX_CORE
+	&core_irix_vec,
+#endif
+#ifdef NETBSD_CORE
+	&core_netbsd_vec,
+#endif
+#ifdef OSF_CORE
+	&core_osf_vec,
+#endif
+#ifdef PTRACE_CORE
+	&core_ptrace_vec,
+#endif
+#ifdef SCO5_CORE
+	&core_sco5_vec,
+#endif
+#ifdef TRAD_CORE
+	&core_trad_vec,
+#endif
+
+	NULL /* end of list marker */
+};
+const bfd_target * const *bfd_target_vector = _bfd_target_vector;
+
+/* bfd_default_vector[0] contains either the address of the default vector,
+   if there is one, or zero if there isn't.  */
+
+const bfd_target *bfd_default_vector[] = {
+#ifdef DEFAULT_VECTOR
+	&DEFAULT_VECTOR,
+#endif
+	NULL
+};
+
+/* bfd_associated_vector[] contains the associated target vectors used
+   to reduce the ambiguity in bfd_check_format_matches.  */
+
+static const bfd_target *_bfd_associated_vector[] = {
+#ifdef ASSOCIATED_VECS
+	ASSOCIATED_VECS,
+#endif
+	NULL
+};
+const bfd_target * const *bfd_associated_vector = _bfd_associated_vector;
+
+/* When there is an ambiguous match, bfd_check_format_matches puts the
+   names of the matching targets in an array.  This variable is the maximum
+   number of entries that the array could possibly need.  */
+const size_t _bfd_target_vector_entries = sizeof (_bfd_target_vector)/sizeof (*_bfd_target_vector);
+
+/* This array maps configuration triplets onto BFD vectors.  */
+
+struct targmatch
+{
+  /* The configuration triplet.  */
+  const char *triplet;
+  /* The BFD vector.  If this is NULL, then the vector is found by
+     searching forward for the next structure with a non NULL vector
+     field.  */
+  const bfd_target *vector;
+};
+
+/* targmatch.h is built by Makefile out of config.bfd.  */
+static const struct targmatch bfd_target_match[] = {
+#include "targmatch.h"
+  { NULL, NULL }
+};
+
+/* Find a target vector, given a name or configuration triplet.  */
+
+static const bfd_target *
+find_target (const char *name)
+{
+  const bfd_target * const *target;
+  const struct targmatch *match;
+
+  for (target = &bfd_target_vector[0]; *target != NULL; target++)
+    if (strcmp (name, (*target)->name) == 0)
+      return *target;
+
+  /* If we couldn't match on the exact name, try matching on the
+     configuration triplet.  FIXME: We should run the triplet through
+     config.sub first, but that is hard.  */
+  for (match = &bfd_target_match[0]; match->triplet != NULL; match++)
+    {
+      if (fnmatch (match->triplet, name, 0) == 0)
+	{
+	  while (match->vector == NULL)
+	    ++match;
+	  return match->vector;
+	}
+    }
+
+  bfd_set_error (bfd_error_invalid_target);
+  return NULL;
+}
+
+/*
+FUNCTION
+	bfd_set_default_target
+
+SYNOPSIS
+	bfd_boolean bfd_set_default_target (const char *name);
+
+DESCRIPTION
+	Set the default target vector to use when recognizing a BFD.
+	This takes the name of the target, which may be a BFD target
+	name or a configuration triplet.
+*/
+
+bfd_boolean
+bfd_set_default_target (const char *name)
+{
+  const bfd_target *target;
+
+  if (bfd_default_vector[0] != NULL
+      && strcmp (name, bfd_default_vector[0]->name) == 0)
+    return TRUE;
+
+  target = find_target (name);
+  if (target == NULL)
+    return FALSE;
+
+  bfd_default_vector[0] = target;
+  return TRUE;
+}
+
+/*
+FUNCTION
+	bfd_find_target
+
+SYNOPSIS
+	const bfd_target *bfd_find_target (const char *target_name, bfd *abfd);
+
+DESCRIPTION
+	Return a pointer to the transfer vector for the object target
+	named @var{target_name}.  If @var{target_name} is <<NULL>>,
+	choose the one in the environment variable <<GNUTARGET>>; if
+	that is null or not defined, then choose the first entry in the
+	target list.  Passing in the string "default" or setting the
+	environment variable to "default" will cause the first entry in
+	the target list to be returned, and "target_defaulted" will be
+	set in the BFD if @var{abfd} isn't <<NULL>>.  This causes
+	<<bfd_check_format>> to loop over all the targets to find the
+	one that matches the file being read.
+*/
+
+const bfd_target *
+bfd_find_target (const char *target_name, bfd *abfd)
+{
+  const char *targname;
+  const bfd_target *target;
+
+  if (target_name != NULL)
+    targname = target_name;
+  else
+    targname = getenv ("GNUTARGET");
+
+  /* This is safe; the vector cannot be null.  */
+  if (targname == NULL || strcmp (targname, "default") == 0)
+    {
+      if (bfd_default_vector[0] != NULL)
+	target = bfd_default_vector[0];
+      else
+	target = bfd_target_vector[0];
+      if (abfd)
+	{
+	  abfd->xvec = target;
+	  abfd->target_defaulted = TRUE;
+	}
+      return target;
+    }
+
+  if (abfd)
+    abfd->target_defaulted = FALSE;
+
+  target = find_target (targname);
+  if (target == NULL)
+    return NULL;
+
+  if (abfd)
+    abfd->xvec = target;
+  return target;
+}
+
+/* Helper function for bfd_get_target_info to determine the target's
+   architecture.  This method handles bfd internal target names as
+   tuples and triplets.  */
+static bfd_boolean
+_bfd_find_arch_match (const char *tname, const char **arch,
+		      const char **def_target_arch)
+{
+  if (!arch)
+    return FALSE;
+
+  while (*arch != NULL)
+    {
+      const char *in_a = strstr (*arch, tname);
+      char end_ch = (in_a ? in_a[strlen (tname)] : 0);
+
+      if (in_a && (in_a == *arch || in_a[-1] == ':')
+          && end_ch == 0)
+        {
+          *def_target_arch = *arch;
+          return TRUE;
+        }
+      arch++;
+    }
+  return FALSE;
+}
+
+/*
+FUNCTION
+	bfd_get_target_info
+SYNOPSIS
+	const bfd_target *bfd_get_target_info (const char *target_name,
+					       bfd *abfd,
+					       bfd_boolean *is_bigendian,
+					       int *underscoring,
+					       const char **def_target_arch);
+DESCRIPTION
+        Return a pointer to the transfer vector for the object target
+        named @var{target_name}.  If @var{target_name} is <<NULL>>,
+        choose the one in the environment variable <<GNUTARGET>>; if
+        that is null or not defined, then choose the first entry in the
+        target list.  Passing in the string "default" or setting the
+        environment variable to "default" will cause the first entry in
+        the target list to be returned, and "target_defaulted" will be
+        set in the BFD if @var{abfd} isn't <<NULL>>.  This causes
+        <<bfd_check_format>> to loop over all the targets to find the
+        one that matches the file being read.
+	If @var{is_bigendian} is not <<NULL>>, then set this value to target's
+	endian mode. True for big-endian, FALSE for little-endian or for
+	invalid target.
+	If @var{underscoring} is not <<NULL>>, then set this value to target's
+	underscoring mode. Zero for none-underscoring, -1 for invalid target,
+	else the value of target vector's symbol underscoring.
+	If @var{def_target_arch} is not <<NULL>>, then set it to the architecture
+	string specified by the target_name.
+*/
+const bfd_target *
+bfd_get_target_info (const char *target_name, bfd *abfd,
+		     bfd_boolean *is_bigendian,
+		     int *underscoring, const char **def_target_arch)
+{
+  const bfd_target *target_vec;
+
+  if (is_bigendian)
+    *is_bigendian = FALSE;
+  if (underscoring)
+    *underscoring = -1;
+  if (def_target_arch)
+    *def_target_arch = NULL;
+  target_vec = bfd_find_target (target_name, abfd);
+  if (! target_vec)
+    return NULL;
+  if (is_bigendian)
+    *is_bigendian = ((target_vec->byteorder == BFD_ENDIAN_BIG) ? TRUE
+							       : FALSE);
+  if (underscoring)
+    *underscoring = ((int) target_vec->symbol_leading_char) & 0xff;
+
+  if (def_target_arch)
+    {
+      const char *tname = target_vec->name;
+      const char **arches = bfd_arch_list ();
+
+      if (arches && tname)
+        {
+          char *hyp = strchr (tname, '-');
+
+          if (hyp != NULL)
+            {
+              tname = ++hyp;
+
+	      /* Make sure we detect architecture names
+		 for triplets like "pe-arm-wince-little".  */
+	      if (!_bfd_find_arch_match (tname, arches, def_target_arch))
+		{
+		  char new_tname[50];
+
+		  strcpy (new_tname, hyp);
+		  while ((hyp = strrchr (new_tname, '-')) != NULL)
+		    {
+		      *hyp = 0;
+		      if (_bfd_find_arch_match (new_tname, arches,
+						def_target_arch))
+			break;
+		    }
+		}
+	    }
+	  else
+	    _bfd_find_arch_match (tname, arches, def_target_arch);
+	}
+
+      if (arches)
+        free (arches);
+    }
+  return target_vec;
+}
+
+/*
+FUNCTION
+	bfd_target_list
+
+SYNOPSIS
+	const char ** bfd_target_list (void);
+
+DESCRIPTION
+	Return a freshly malloced NULL-terminated
+	vector of the names of all the valid BFD targets. Do not
+	modify the names.
+
+*/
+
+const char **
+bfd_target_list (void)
+{
+  int vec_length = 0;
+  bfd_size_type amt;
+  const bfd_target * const *target;
+  const  char **name_list, **name_ptr;
+
+  for (target = &bfd_target_vector[0]; *target != NULL; target++)
+    vec_length++;
+
+  amt = (vec_length + 1) * sizeof (char **);
+  name_ptr = name_list = (const  char **) bfd_malloc (amt);
+
+  if (name_list == NULL)
+    return NULL;
+
+  for (target = &bfd_target_vector[0]; *target != NULL; target++)
+    if (target == &bfd_target_vector[0]
+	|| *target != bfd_target_vector[0])
+      *name_ptr++ = (*target)->name;
+
+  *name_ptr = NULL;
+  return name_list;
+}
+
+/*
+FUNCTION
+	bfd_seach_for_target
+
+SYNOPSIS
+	const bfd_target *bfd_search_for_target
+	  (int (*search_func) (const bfd_target *, void *),
+	   void *);
+
+DESCRIPTION
+	Return a pointer to the first transfer vector in the list of
+	transfer vectors maintained by BFD that produces a non-zero
+	result when passed to the function @var{search_func}.  The
+	parameter @var{data} is passed, unexamined, to the search
+	function.
+*/
+
+const bfd_target *
+bfd_search_for_target (int (*search_func) (const bfd_target *, void *),
+		       void *data)
+{
+  const bfd_target * const *target;
+
+  for (target = bfd_target_vector; *target != NULL; target ++)
+    if (search_func (*target, data))
+      return *target;
+
+  return NULL;
+}
+
+/*
+FUNCTION
+	bfd_flavour_name
+
+SYNOPSIS
+	const char *bfd_flavour_name (enum bfd_flavour flavour);
+
+DESCRIPTION
+	Return the string form of @var{flavour}.
+*/
+
+const char *
+bfd_flavour_name (enum bfd_flavour flavour)
+{
+  switch (flavour)
+    {
+    case bfd_target_unknown_flavour: return "unknown file format";
+    case bfd_target_aout_flavour: return "a.out";
+    case bfd_target_coff_flavour: return "COFF";
+    case bfd_target_ecoff_flavour: return "ECOFF";
+    case bfd_target_xcoff_flavour: return "XCOFF";
+    case bfd_target_elf_flavour: return "ELF";
+    case bfd_target_ieee_flavour: return "IEEE";
+    case bfd_target_nlm_flavour: return "NLM";
+    case bfd_target_oasys_flavour: return "Oasys";
+    case bfd_target_tekhex_flavour: return "Tekhex";
+    case bfd_target_srec_flavour: return "Srec";
+    case bfd_target_verilog_flavour: return "Verilog";
+    case bfd_target_ihex_flavour: return "Ihex";
+    case bfd_target_som_flavour: return "SOM";
+    case bfd_target_os9k_flavour: return "OS9K";
+    case bfd_target_versados_flavour: return "Versados";
+    case bfd_target_msdos_flavour: return "MSDOS";
+    case bfd_target_ovax_flavour: return "Ovax";
+    case bfd_target_evax_flavour: return "Evax";
+    case bfd_target_mmo_flavour: return "mmo";
+    case bfd_target_mach_o_flavour: return "MACH_O";
+    case bfd_target_pef_flavour: return "PEF";
+    case bfd_target_pef_xlib_flavour: return "PEF_XLIB";
+    case bfd_target_sym_flavour: return "SYM";
+    /* There is no "default" case here so that -Wswitch (part of -Wall)
+       catches missing entries.  */
+    }
+
+  abort ();
+}
diff -Naur binutils-2.26/binutils/configure binutils-2.26.0007/binutils/configure
--- binutils-2.26/binutils/configure	2016-01-25 09:54:09.000000000 +0100
+++ binutils-2.26.0007/binutils/configure	2016-03-10 17:02:24.244051956 +0100
@@ -14405,6 +14405,16 @@
 	  BUILD_WINDRES='$(WINDRES_PROG)$(EXEEXT)'
 	  BUILD_WINDMC='$(WINDMC_PROG)$(EXEEXT)'
 	  ;;
+  arm*-*-mingw* | arm*-*-cygwin*)
+      BUILD_DLLTOOL='$(DLLTOOL_PROG)$(EXEEXT)'
+    if test -z "$DLLTOOL_DEFAULT"; then
+      DLLTOOL_DEFAULT="-DDLLTOOL_DEFAULT_ARM_WINNT"
+    fi
+    DLLTOOL_DEFS="$DLLTOOL_DEFS -DDLLTOOL_ARM_WINNT -DDLLTOOL_ARM"
+    BUILD_WINDRES='$(WINDRES_PROG)$(EXEEXT)'
+    BUILD_WINDMC='$(WINDMC_PROG)$(EXEEXT)'
+    BUILD_DLLWRAP='$(DLLWRAP_PROG)$(EXEEXT)'
+    ;;
 	arm-*-pe*)
   	  BUILD_DLLTOOL='$(DLLTOOL_PROG)$(EXEEXT)'
 	  if test -z "$DLLTOOL_DEFAULT"; then
diff -Naur binutils-2.26/binutils/configure.ac binutils-2.26.0007/binutils/configure.ac
--- binutils-2.26/binutils/configure.ac	2016-01-25 09:51:06.000000000 +0100
+++ binutils-2.26.0007/binutils/configure.ac	2016-03-10 17:02:24.247385216 +0100
@@ -306,6 +306,16 @@
 	  BUILD_WINDRES='$(WINDRES_PROG)$(EXEEXT)'
 	  BUILD_WINDMC='$(WINDMC_PROG)$(EXEEXT)'
 	  ;;
+	arm*-*-mingw* | arm*-*-cygwin*)
+  	  BUILD_DLLTOOL='$(DLLTOOL_PROG)$(EXEEXT)'
+	  if test -z "$DLLTOOL_DEFAULT"; then
+	    DLLTOOL_DEFAULT="-DDLLTOOL_DEFAULT_ARM_WINCE"
+	  fi
+	  DLLTOOL_DEFS="$DLLTOOL_DEFS -DDLLTOOL_ARM_WINCE -DDLLTOOL_ARM"
+	  BUILD_WINDRES='$(WINDRES_PROG)$(EXEEXT)'
+	  BUILD_WINDMC='$(WINDMC_PROG)$(EXEEXT)'
+	  BUILD_DLLWRAP='$(DLLWRAP_PROG)$(EXEEXT)'
+	  ;;
 	arm-*-pe*)
   	  BUILD_DLLTOOL='$(DLLTOOL_PROG)$(EXEEXT)'
 	  if test -z "$DLLTOOL_DEFAULT"; then
diff -Naur binutils-2.26/binutils/configure.ac.orig binutils-2.26.0007/binutils/configure.ac.orig
--- binutils-2.26/binutils/configure.ac.orig	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.26.0007/binutils/configure.ac.orig	2016-03-10 17:01:41.571657241 +0100
@@ -0,0 +1,517 @@
+dnl Process this file with autoconf to produce a configure script.
+dnl
+dnl   Copyright (C) 2012-2015 Free Software Foundation, Inc.
+dnl
+dnl This file is free software; you can redistribute it and/or modify
+dnl it under the terms of the GNU General Public License as published by
+dnl the Free Software Foundation; either version 3 of the License, or
+dnl (at your option) any later version.
+dnl
+dnl This program is distributed in the hope that it will be useful,
+dnl but WITHOUT ANY WARRANTY; without even the implied warranty of
+dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+dnl GNU General Public License for more details.
+dnl
+dnl You should have received a copy of the GNU General Public License
+dnl along with this program; see the file COPYING3.  If not see
+dnl <http://www.gnu.org/licenses/>.
+dnl
+
+AC_PREREQ(2.59)
+m4_include([../bfd/version.m4])
+AC_INIT([binutils], BFD_VERSION)
+AC_CONFIG_SRCDIR(ar.c)
+
+AC_CANONICAL_TARGET
+AC_ISC_POSIX
+
+AM_INIT_AUTOMAKE
+
+AC_PROG_CC
+AC_GNU_SOURCE
+AC_USE_SYSTEM_EXTENSIONS
+
+LT_INIT
+ACX_LARGEFILE
+
+AC_ARG_ENABLE(targets,
+[  --enable-targets        alternative target configurations],
+[case "${enableval}" in
+  yes | "") AC_MSG_ERROR(enable-targets option must specify target names or 'all')
+            ;;
+  no)       enable_targets= ;;
+  *)        enable_targets=$enableval ;;
+esac])dnl
+
+AC_ARG_ENABLE(deterministic-archives,
+[AS_HELP_STRING([--enable-deterministic-archives],
+		[ar and ranlib default to -D behavior])], [
+if test "${enableval}" = no; then
+  default_ar_deterministic=0
+else
+  default_ar_deterministic=1
+fi], [default_ar_deterministic=0])
+
+AC_DEFINE_UNQUOTED(DEFAULT_AR_DETERMINISTIC, $default_ar_deterministic,
+		   [Should ar and ranlib use -D behavior by default?])
+
+AC_ARG_ENABLE(default-strings-all,
+[AS_HELP_STRING([--disable-default-strings-all],
+		[strings defaults to --data behavior])], [
+if test "${enableval}" = no; then
+  default_strings_all=0
+else
+  default_strings_all=1
+fi], [default_strings_all=1])
+
+AC_DEFINE_UNQUOTED(DEFAULT_STRINGS_ALL, $default_strings_all,
+		   [Should strings use -a behavior by default?])
+
+AM_BINUTILS_WARNINGS
+
+AC_CONFIG_HEADERS(config.h:config.in)
+
+AH_VERBATIM([00_CONFIG_H_CHECK],
+[/* Check that config.h is #included before system headers
+   (this works only for glibc, but that should be enough).  */
+#if defined(__GLIBC__) && !defined(__FreeBSD_kernel__) && !defined(__CONFIG_H__)
+#  error config.h must be #included before system headers
+#endif
+#define __CONFIG_H__ 1])
+
+if test -z "$target" ; then
+    AC_MSG_ERROR(Unrecognized target system type; please check config.sub.)
+fi
+if test -z "$host" ; then
+    AC_MSG_ERROR(Unrecognized host system type; please check config.sub.)
+fi
+
+AC_PROG_YACC
+AM_PROG_LEX
+
+ALL_LINGUAS="bg ca da es fi fr id it ja ro ru rw sk sv tr uk vi zh_CN zh_TW hr"
+ZW_GNU_GETTEXT_SISTER_DIR
+AM_PO_SUBDIRS
+
+AM_MAINTAINER_MODE
+AM_CONDITIONAL(GENINSRC_NEVER, false)
+AC_EXEEXT
+if test -n "$EXEEXT"; then
+  AC_DEFINE(HAVE_EXECUTABLE_SUFFIX, 1,
+	    [Does the platform use an executable suffix?])
+fi
+AC_DEFINE_UNQUOTED(EXECUTABLE_SUFFIX, "${EXEEXT}",
+		   [Suffix used for executables, if any.])
+
+# host-specific stuff:
+
+HDEFINES=
+
+. ${srcdir}/../bfd/configure.host
+
+AC_SUBST(HDEFINES)
+AR=${AR-ar}
+AC_SUBST(AR)
+AC_PROG_RANLIB
+AC_PROG_INSTALL
+
+BFD_CC_FOR_BUILD
+
+DEMANGLER_NAME=c++filt
+case "${host}" in
+  *-*-go32* | *-*-msdos*)
+    DEMANGLER_NAME=cxxfilt
+esac
+AC_SUBST(DEMANGLER_NAME)
+
+AC_CHECK_SIZEOF([long])
+AC_CHECK_TYPES([long long], [AC_CHECK_SIZEOF(long long)])
+
+AC_CHECK_HEADERS(string.h strings.h stdlib.h unistd.h fcntl.h sys/file.h limits.h locale.h sys/param.h wchar.h)
+AC_HEADER_SYS_WAIT
+ACX_HEADER_STRING
+AC_FUNC_ALLOCA
+AC_CHECK_FUNCS(sbrk utimes setmode getc_unlocked strcoll setlocale)
+AC_CHECK_FUNC([mkstemp],
+	      AC_DEFINE([HAVE_MKSTEMP], 1,
+	      [Define to 1 if you have the `mkstemp' function.]))
+AC_CHECK_FUNC([mkdtemp],
+              AC_DEFINE([HAVE_MKDTEMP], 1,
+              [Define to 1 if you have the `mkdtemp' function.]))
+  AC_MSG_CHECKING([for mbstate_t])
+  AC_TRY_COMPILE([#include <wchar.h>],
+  [mbstate_t teststate;],
+  have_mbstate_t=yes, have_mbstate_t=no)
+  AC_MSG_RESULT($have_mbstate_t)
+  if test x"$have_mbstate_t" = xyes; then
+    AC_DEFINE(HAVE_MBSTATE_T,1,[Define if mbstate_t exists in wchar.h.])
+  fi
+
+# Some systems have frexp only in -lm, not in -lc.
+AC_SEARCH_LIBS(frexp, m)
+
+AM_LC_MESSAGES
+
+AC_MSG_CHECKING(for time_t in time.h)
+AC_CACHE_VAL(bu_cv_decl_time_t_time_h,
+[AC_COMPILE_IFELSE([AC_LANG_PROGRAM([#include <time.h>], [time_t i;])],
+bu_cv_decl_time_t_time_h=yes, bu_cv_decl_time_t_time_h=no)])
+AC_MSG_RESULT($bu_cv_decl_time_t_time_h)
+if test $bu_cv_decl_time_t_time_h = yes; then
+  AC_DEFINE([HAVE_TIME_T_IN_TIME_H], 1,
+	    [Is the type time_t defined in <time.h>?])
+fi
+
+AC_MSG_CHECKING(for time_t in sys/types.h)
+AC_CACHE_VAL(bu_cv_decl_time_t_types_h,
+[AC_COMPILE_IFELSE([AC_LANG_PROGRAM([#include <sys/types.h>], [time_t i;])],
+bu_cv_decl_time_t_types_h=yes, bu_cv_decl_time_t_types_h=no)])
+AC_MSG_RESULT($bu_cv_decl_time_t_types_h)
+if test $bu_cv_decl_time_t_types_h = yes; then
+  AC_DEFINE([HAVE_TIME_T_IN_TYPES_H], 1,
+	    [Is the type time_t defined in <sys/types.h>?])
+fi
+
+AC_MSG_CHECKING(for a known getopt prototype in unistd.h)
+AC_CACHE_VAL(bu_cv_decl_getopt_unistd_h,
+[AC_COMPILE_IFELSE([AC_LANG_PROGRAM([#include <unistd.h>], [extern int getopt (int, char *const*, const char *);])],
+bu_cv_decl_getopt_unistd_h=yes, bu_cv_decl_getopt_unistd_h=no)])
+AC_MSG_RESULT($bu_cv_decl_getopt_unistd_h)
+if test $bu_cv_decl_getopt_unistd_h = yes; then
+  AC_DEFINE([HAVE_DECL_GETOPT], 1,
+	    [Is the prototype for getopt in <unistd.h> in the expected format?])
+fi
+
+# Under Next 3.2 <utime.h> apparently does not define struct utimbuf
+# by default.
+AC_MSG_CHECKING([for utime.h])
+AC_CACHE_VAL(bu_cv_header_utime_h,
+[AC_COMPILE_IFELSE([AC_LANG_PROGRAM([#include <sys/types.h>
+#ifdef HAVE_TIME_H
+#include <time.h>
+#endif
+#include <utime.h>],
+[struct utimbuf s;])],
+bu_cv_header_utime_h=yes, bu_cv_header_utime_h=no)])
+AC_MSG_RESULT($bu_cv_header_utime_h)
+if test $bu_cv_header_utime_h = yes; then
+  AC_DEFINE(HAVE_GOOD_UTIME_H, 1, [Does <utime.h> define struct utimbuf?])
+fi
+
+AC_CHECK_DECLS([environ, fprintf, getc_unlocked, getenv,
+		sbrk, snprintf, stpcpy, strnlen, strstr, vsnprintf])
+
+# Link in zlib if we can.  This allows us to read compressed debug
+# sections.  This is used only by readelf.c (objdump uses bfd for
+# reading compressed sections).
+AM_ZLIB
+
+BFD_BINARY_FOPEN
+
+# target-specific stuff:
+
+# Canonicalize the secondary target names.
+if test -n "$enable_targets"; then
+    for targ in `echo $enable_targets | sed 's/,/ /g'`
+    do
+	result=`$ac_config_sub $targ 2>/dev/null`
+	if test -n "$result"; then
+	    canon_targets="$canon_targets $result"
+	else
+	    # Allow targets that config.sub doesn't recognize, like "all".
+	    canon_targets="$canon_targets $targ"
+	fi
+    done
+fi
+
+AC_CHECK_HEADER(iconv.h)
+AM_ICONV
+
+all_targets=false
+BUILD_NLMCONV=
+NLMCONV_DEFS=
+BUILD_SRCONV=
+BUILD_DLLTOOL=
+DLLTOOL_DEFS=
+DLLTOOL_DEFAULT=
+BUILD_WINDRES=
+BUILD_WINDMC=
+BUILD_DLLWRAP=
+BUILD_MISC=
+BUILD_INSTALL_MISC=
+OBJDUMP_DEFS=
+OBJDUMP_PRIVATE_VECTORS=
+OBJDUMP_PRIVATE_OFILES=
+od_vectors=
+
+for targ in $target $canon_targets
+do
+    if test "x$targ" = "xall"; then
+        all_targets=true
+	BUILD_NLMCONV='$(NLMCONV_PROG)$(EXEEXT)'
+	BUILD_SRCONV='$(SRCONV_PROG)'
+	NLMCONV_DEFS="-DNLMCONV_I386 -DNLMCONV_ALPHA -DNLMCONV_POWERPC -DNLMCONV_SPARC"
+	BUILD_MISC="${BUILD_MISC} "'bin2c$(EXEEXT_FOR_BUILD)'
+	BUILD_WINDRES='$(WINDRES_PROG)$(EXEEXT)'
+	BUILD_WINDMC='$(WINDMC_PROG)$(EXEEXT)'
+	BUILD_DLLTOOL='$(DLLTOOL_PROG)$(EXEEXT)'
+	if test -z "$DLLTOOL_DEFAULT"; then
+	  DLLTOOL_DEFAULT="-DDLLTOOL_DEFAULT_I386"
+	fi
+	DLLTOOL_DEFS="$DLLTOOL_DEFS -DDLLTOOL_I386"
+	BUILD_DLLWRAP='$(DLLWRAP_PROG)$(EXEEXT)'
+	od_vectors="$od_vectors objdump_private_desc_xcoff"
+    else
+	case $targ in
+changequote(,)dnl
+	i[3-7]86*-*-netware*)
+changequote([,])dnl
+	  BUILD_NLMCONV='$(NLMCONV_PROG)$(EXEEXT)'
+	  NLMCONV_DEFS="$NLMCONV_DEFS -DNLMCONV_I386"
+	  ;;
+	alpha*-*-netware*)
+	  BUILD_NLMCONV='$(NLMCONV_PROG)$(EXEEXT)'
+	  NLMCONV_DEFS="$NLMCONV_DEFS -DNLMCONV_ALPHA"
+	  ;;
+	powerpc*-*-netware*)
+	  BUILD_NLMCONV='$(NLMCONV_PROG)$(EXEEXT)'
+	  NLMCONV_DEFS="$NLMCONV_DEFS -DNLMCONV_POWERPC"
+	  ;;
+	sparc*-*-netware*)
+	  BUILD_NLMCONV='$(NLMCONV_PROG)$(EXEEXT)'
+	  NLMCONV_DEFS="$NLMCONV_DEFS -DNLMCONV_SPARC"
+	  ;;
+	esac
+
+	case $targ in
+	*-*-hms*) BUILD_SRCONV='$(SRCONV_PROG)' ;;
+	esac
+
+	case $targ in
+	arm-epoc-pe*)
+  	  BUILD_DLLTOOL='$(DLLTOOL_PROG)$(EXEEXT)'
+	  if test -z "$DLLTOOL_DEFAULT"; then
+	    DLLTOOL_DEFAULT="-DDLLTOOL_DEFAULT_ARM_EPOC"
+	  fi
+	  DLLTOOL_DEFS="$DLLTOOL_DEFS -DDLLTOOL_ARM_EPOC -DDLLTOOL_ARM"
+	  BUILD_WINDRES='$(WINDRES_PROG)$(EXEEXT)'
+	  BUILD_WINDMC='$(WINDMC_PROG)$(EXEEXT)'
+	  ;;
+	arm-wince-pe* | arm-*-wince | arm*-*-cegcc* | arm*-*-mingw32ce*)
+  	  BUILD_DLLTOOL='$(DLLTOOL_PROG)$(EXEEXT)'
+	  if test -z "$DLLTOOL_DEFAULT"; then
+	    DLLTOOL_DEFAULT="-DDLLTOOL_DEFAULT_ARM_WINCE"
+	  fi
+	  DLLTOOL_DEFS="$DLLTOOL_DEFS -DDLLTOOL_ARM_WINCE -DDLLTOOL_ARM"
+	  BUILD_WINDRES='$(WINDRES_PROG)$(EXEEXT)'
+	  BUILD_WINDMC='$(WINDMC_PROG)$(EXEEXT)'
+	  ;;
+	arm-*-pe*)
+  	  BUILD_DLLTOOL='$(DLLTOOL_PROG)$(EXEEXT)'
+	  if test -z "$DLLTOOL_DEFAULT"; then
+	    DLLTOOL_DEFAULT="-DDLLTOOL_DEFAULT_ARM"
+	  fi
+	  DLLTOOL_DEFS="$DLLTOOL_DEFS -DDLLTOOL_ARM"
+	  BUILD_WINDRES='$(WINDRES_PROG)$(EXEEXT)'
+	  BUILD_WINDMC='$(WINDMC_PROG)$(EXEEXT)'
+	  ;;
+	x86_64-*-mingw* | x86_64-*-cygwin*)
+  	  BUILD_DLLTOOL='$(DLLTOOL_PROG)$(EXEEXT)'
+	  if test -z "$DLLTOOL_DEFAULT"; then
+	    DLLTOOL_DEFAULT="-DDLLTOOL_DEFAULT_MX86_64"
+	  fi
+	  DLLTOOL_DEFS="$DLLTOOL_DEFS -DDLLTOOL_MX86_64"
+	  BUILD_WINDRES='$(WINDRES_PROG)$(EXEEXT)'
+	  BUILD_WINDMC='$(WINDMC_PROG)$(EXEEXT)'
+	  BUILD_DLLWRAP='$(DLLWRAP_PROG)$(EXEEXT)'
+	  ;;
+changequote(,)dnl
+	i[3-7]86-*-pe* | i[3-7]86-*-cygwin* | i[3-7]86-*-mingw32** | i[3-7]86-*-netbsdpe*)
+changequote([,])dnl
+  	  BUILD_DLLTOOL='$(DLLTOOL_PROG)$(EXEEXT)'
+	  if test -z "$DLLTOOL_DEFAULT"; then
+	    DLLTOOL_DEFAULT="-DDLLTOOL_DEFAULT_I386"
+	  fi
+	  DLLTOOL_DEFS="$DLLTOOL_DEFS -DDLLTOOL_I386"
+	  BUILD_WINDRES='$(WINDRES_PROG)$(EXEEXT)'
+	  BUILD_WINDMC='$(WINDMC_PROG)$(EXEEXT)'
+	  BUILD_DLLWRAP='$(DLLWRAP_PROG)$(EXEEXT)'
+	  ;;
+changequote(,)dnl
+	i[3-7]86-*-interix)
+changequote([,])dnl
+	  BUILD_DLLTOOL='$(DLLTOOL_PROG)'
+	  if test -z "$DLLTOOL_DEFAULT"; then
+	    DLLTOOL_DEFAULT="-DDLLTOOL_DEFAULT_I386"
+	  fi
+	  DLLTOOL_DEFS="$DLLTOOL_DEFS -DDLLTOOL_I386"
+	  ;;
+changequote(,)dnl
+	powerpc*-aix5.[01])
+changequote([,])dnl
+	  ;;
+changequote(,)dnl
+	powerpc*-aix[5-9].*)
+changequote([,])dnl
+	  OBJDUMP_DEFS="-DAIX_WEAK_SUPPORT"
+	  ;;
+	powerpc*-*-pe* | powerpc*-*-cygwin*)
+  	  BUILD_DLLTOOL='$(DLLTOOL_PROG)$(EXEEXT)'
+	  if test -z "$DLLTOOL_DEFAULT"; then
+	    DLLTOOL_DEFAULT="-DDLLTOOL_DEFAULT_PPC"
+	  fi
+	  DLLTOOL_DEFS="$DLLTOOL_DEFS -DDLLTOOL_PPC"
+	  BUILD_WINDRES='$(WINDRES_PROG)$(EXEEXT)'
+	  BUILD_WINDMC='$(WINDMC_PROG)$(EXEEXT)'
+	  ;;
+	powerpc*-*-linux* | powerpc*-*-elf* | powerpc*-*-eabi*)
+	  case "$BUILD_INSTALL_MISC" in
+	    *embedspu*) ;;
+	    *) BUILD_INSTALL_MISC="${BUILD_INSTALL_MISC} embedspu"
+	  esac
+	  ;;
+	sh*-*-pe)
+  	  BUILD_DLLTOOL='$(DLLTOOL_PROG)$(EXEEXT)'
+	  if test -z "$DLLTOOL_DEFAULT"; then
+	    DLLTOOL_DEFAULT="-DDLLTOOL_DEFAULT_SH"
+	  fi
+	  DLLTOOL_DEFS="$DLLTOOL_DEFS -DDLLTOOL_SH"
+	  BUILD_WINDRES='$(WINDRES_PROG)$(EXEEXT)'
+	  BUILD_WINDMC='$(WINDMC_PROG)$(EXEEXT)'
+	  ;;
+	spu-*-*)
+	  BUILD_MISC="${BUILD_MISC} "'bin2c$(EXEEXT_FOR_BUILD)'
+	  ;;
+	mips*-*-pe)
+  	  BUILD_DLLTOOL='$(DLLTOOL_PROG)$(EXEEXT)'
+	  if test -z "$DLLTOOL_DEFAULT"; then
+	    DLLTOOL_DEFAULT="-DDLLTOOL_DEFAULT_MIPS"
+	  fi
+	  DLLTOOL_DEFS="$DLLTOOL_DEFS -DDLLTOOL_MIPS"
+	  BUILD_WINDRES='$(WINDRES_PROG)$(EXEEXT)'
+	  BUILD_WINDMC='$(WINDMC_PROG)$(EXEEXT)'
+	  ;;
+	mcore-*-pe)
+  	  BUILD_DLLTOOL='$(DLLTOOL_PROG)$(EXEEXT)'
+	  if test -z "$DLLTOOL_DEFAULT"; then
+	    DLLTOOL_DEFAULT="-DDLLTOOL_DEFAULT_MCORE"
+	  fi
+	  DLLTOOL_DEFS="$DLLTOOL_DEFS -DDLLTOOL_MCORE"
+	  BUILD_WINDRES='$(WINDRES_PROG)$(EXEEXT)'
+	  BUILD_WINDMC='$(WINDMC_PROG)$(EXEEXT)'
+	  ;;
+	mcore-*-elf)
+  	  BUILD_DLLTOOL='$(DLLTOOL_PROG)$(EXEEXT)'
+	  if test -z "$DLLTOOL_DEFAULT"; then
+	    DLLTOOL_DEFAULT="-DDLLTOOL_DEFAULT_MCORE_ELF"
+	  fi
+	  DLLTOOL_DEFS="$DLLTOOL_DEFS -DDLLTOOL_MCORE_ELF"
+	  ;;
+  	mep-*)
+	  OBJDUMP_DEFS="-DSKIP_ZEROES=256 -DSKIP_ZEROES_AT_END=0"
+	  ;;
+	esac
+
+	# Add objdump private vectors.
+	case $targ in
+	avr-*-*)
+	  od_vectors="$od_vectors objdump_private_desc_elf32_avr"
+	  ;;
+	powerpc-*-aix*)
+	  od_vectors="$od_vectors objdump_private_desc_xcoff"
+	  ;;
+        *-*-darwin*)
+	  od_vectors="$od_vectors objdump_private_desc_mach_o"
+	  ;;
+	esac
+    fi
+done
+
+# Uniq objdump private vector, build objdump target ofiles.
+od_files=
+f=""
+for i in $od_vectors ; do
+    case " $f " in
+    *" $i "*) ;;
+    *)
+	f="$f $i"
+	OBJDUMP_PRIVATE_VECTORS="$OBJDUMP_PRIVATE_VECTORS &$i,"
+	case $i in
+	objdump_private_desc_elf32_avr)
+	    od_files="$od_files od-elf32_avr" ;;
+	objdump_private_desc_xcoff)
+	    od_files="$od_files od-xcoff" ;;
+	objdump_private_desc_mach_o)
+	    od_files="$od_files od-macho" ;;
+	*) AC_MSG_ERROR(*** unknown private vector $i) ;;
+	esac
+	;;
+    esac
+done
+
+# Uniq objdump target ofiles
+f=""
+for i in $od_files ; do
+    case " $f " in
+    *" $i "*) ;;
+    *)
+	f="$f $i"
+	OBJDUMP_PRIVATE_OFILES="$OBJDUMP_PRIVATE_OFILES $i.$objext"
+	;;
+    esac
+done
+
+DLLTOOL_DEFS="$DLLTOOL_DEFS $DLLTOOL_DEFAULT"
+
+if test "${with_windres+set}" = set; then
+	  BUILD_WINDRES='$(WINDRES_PROG)$(EXEEXT)'
+fi
+
+if test "${with_windmc+set}" = set; then
+	  BUILD_WINDMC='$(WINDMC_PROG)$(EXEEXT)'
+fi
+
+OBJDUMP_DEFS="${OBJDUMP_DEFS} -DOBJDUMP_PRIVATE_VECTORS=\"${OBJDUMP_PRIVATE_VECTORS}\""
+
+AC_SUBST(NLMCONV_DEFS)
+AC_SUBST(BUILD_NLMCONV)
+AC_SUBST(BUILD_SRCONV)
+AC_SUBST(BUILD_DLLTOOL)
+AC_SUBST(DLLTOOL_DEFS)
+AC_SUBST(BUILD_WINDRES)
+AC_SUBST(BUILD_WINDMC)
+AC_SUBST(BUILD_DLLWRAP)
+AC_SUBST(BUILD_MISC)
+AC_SUBST(BUILD_INSTALL_MISC)
+AC_SUBST(OBJDUMP_DEFS)
+AC_SUBST(OBJDUMP_PRIVATE_OFILES)
+
+AC_DEFINE_UNQUOTED(TARGET, "${target}", [Configured target name.])
+
+targ=$target
+. $srcdir/../bfd/config.bfd
+if test "x$targ_underscore" = "xyes"; then
+    UNDERSCORE=1
+else
+    UNDERSCORE=0
+fi
+AC_DEFINE_UNQUOTED(TARGET_PREPENDS_UNDERSCORE, $UNDERSCORE,
+ [Define to 1 if user symbol names have a leading underscore, 0 if not.])
+
+# Emulation
+targ=$target
+. ${srcdir}/configure.tgt
+EMULATION=$targ_emul
+EMULATION_VECTOR=$targ_emul_vector
+
+AC_SUBST(EMULATION)
+AC_SUBST(EMULATION_VECTOR)
+
+# Required for html and install-html
+AC_SUBST(datarootdir)
+AC_SUBST(docdir)
+AC_SUBST(htmldir)
+AC_SUBST(pdfdir)
+
+AC_CONFIG_FILES(Makefile doc/Makefile po/Makefile.in:po/Make-in)
+AC_OUTPUT
diff -Naur binutils-2.26/binutils/configure.orig binutils-2.26.0007/binutils/configure.orig
--- binutils-2.26/binutils/configure.orig	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.26.0007/binutils/configure.orig	2016-03-10 17:01:41.551657679 +0100
@@ -0,0 +1,17060 @@
+#! /bin/sh
+# Guess values for system-dependent variables and create Makefiles.
+# Generated by GNU Autoconf 2.64 for binutils 2.26.
+#
+# Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
+# 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software
+# Foundation, Inc.
+#
+# This configure script is free software; the Free Software Foundation
+# gives unlimited permission to copy, distribute and modify it.
+## -------------------- ##
+## M4sh Initialization. ##
+## -------------------- ##
+
+# Be more Bourne compatible
+DUALCASE=1; export DUALCASE # for MKS sh
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
+esac
+fi
+
+
+as_nl='
+'
+export as_nl
+# Printing a long string crashes Solaris 7 /usr/bin/printf.
+as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
+# Prefer a ksh shell builtin over an external printf program on Solaris,
+# but without wasting forks for bash or zsh.
+if test -z "$BASH_VERSION$ZSH_VERSION" \
+    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='print -r --'
+  as_echo_n='print -rn --'
+elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='printf %s\n'
+  as_echo_n='printf %s'
+else
+  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
+    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
+    as_echo_n='/usr/ucb/echo -n'
+  else
+    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
+    as_echo_n_body='eval
+      arg=$1;
+      case $arg in #(
+      *"$as_nl"*)
+	expr "X$arg" : "X\\(.*\\)$as_nl";
+	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
+      esac;
+      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
+    '
+    export as_echo_n_body
+    as_echo_n='sh -c $as_echo_n_body as_echo'
+  fi
+  export as_echo_body
+  as_echo='sh -c $as_echo_body as_echo'
+fi
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  PATH_SEPARATOR=:
+  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
+    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
+      PATH_SEPARATOR=';'
+  }
+fi
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.  Quoting is
+# there to prevent editors from complaining about space-tab.
+# (If _AS_PATH_WALK were called with IFS unset, it would disable word
+# splitting by setting IFS to empty value.)
+IFS=" ""	$as_nl"
+
+# Find who we are.  Look in the path if we contain no directory separator.
+case $0 in #((
+  *[\\/]* ) as_myself=$0 ;;
+  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+  done
+IFS=$as_save_IFS
+
+     ;;
+esac
+# We did not find ourselves, most probably we were run as `sh COMMAND'
+# in which case we are not to be found in the path.
+if test "x$as_myself" = x; then
+  as_myself=$0
+fi
+if test ! -f "$as_myself"; then
+  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  exit 1
+fi
+
+# Unset variables that we do not need and which cause bugs (e.g. in
+# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
+# suppresses any "Segmentation fault" message there.  '((' could
+# trigger a bug in pdksh 5.2.14.
+for as_var in BASH_ENV ENV MAIL MAILPATH
+do eval test x\${$as_var+set} = xset \
+  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
+done
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+LC_ALL=C
+export LC_ALL
+LANGUAGE=C
+export LANGUAGE
+
+# CDPATH.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+if test "x$CONFIG_SHELL" = x; then
+  as_bourne_compatible="if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on \${1+\"\$@\"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '\${1+\"\$@\"}'='\"\$@\"'
+  setopt NO_GLOB_SUBST
+else
+  case \`(set -o) 2>/dev/null\` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
+esac
+fi
+"
+  as_required="as_fn_return () { (exit \$1); }
+as_fn_success () { as_fn_return 0; }
+as_fn_failure () { as_fn_return 1; }
+as_fn_ret_success () { return 0; }
+as_fn_ret_failure () { return 1; }
+
+exitcode=0
+as_fn_success || { exitcode=1; echo as_fn_success failed.; }
+as_fn_failure && { exitcode=1; echo as_fn_failure succeeded.; }
+as_fn_ret_success || { exitcode=1; echo as_fn_ret_success failed.; }
+as_fn_ret_failure && { exitcode=1; echo as_fn_ret_failure succeeded.; }
+if ( set x; as_fn_ret_success y && test x = \"\$1\" ); then :
+
+else
+  exitcode=1; echo positional parameters were not saved.
+fi
+test x\$exitcode = x0 || exit 1"
+  as_suggested="  as_lineno_1=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_1a=\$LINENO
+  as_lineno_2=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_2a=\$LINENO
+  eval 'test \"x\$as_lineno_1'\$as_run'\" != \"x\$as_lineno_2'\$as_run'\" &&
+  test \"x\`expr \$as_lineno_1'\$as_run' + 1\`\" = \"x\$as_lineno_2'\$as_run'\"' || exit 1
+test \$(( 1 + 1 )) = 2 || exit 1
+
+  test -n \"\${ZSH_VERSION+set}\${BASH_VERSION+set}\" || (
+    ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+    ECHO=\$ECHO\$ECHO\$ECHO\$ECHO\$ECHO
+    ECHO=\$ECHO\$ECHO\$ECHO\$ECHO\$ECHO\$ECHO
+    PATH=/empty FPATH=/empty; export PATH FPATH
+    test \"X\`printf %s \$ECHO\`\" = \"X\$ECHO\" \\
+      || test \"X\`print -r -- \$ECHO\`\" = \"X\$ECHO\" ) || exit 1"
+  if (eval "$as_required") 2>/dev/null; then :
+  as_have_required=yes
+else
+  as_have_required=no
+fi
+  if test x$as_have_required = xyes && (eval "$as_suggested") 2>/dev/null; then :
+
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+as_found=false
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  as_found=:
+  case $as_dir in #(
+	 /*)
+	   for as_base in sh bash ksh sh5; do
+	     # Try only shells that exist, to save several forks.
+	     as_shell=$as_dir/$as_base
+	     if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
+		    { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$as_shell"; } 2>/dev/null; then :
+  CONFIG_SHELL=$as_shell as_have_required=yes
+		   if { $as_echo "$as_bourne_compatible""$as_suggested" | as_run=a "$as_shell"; } 2>/dev/null; then :
+  break 2
+fi
+fi
+	   done;;
+       esac
+  as_found=false
+done
+$as_found || { if { test -f "$SHELL" || test -f "$SHELL.exe"; } &&
+	      { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$SHELL"; } 2>/dev/null; then :
+  CONFIG_SHELL=$SHELL as_have_required=yes
+fi; }
+IFS=$as_save_IFS
+
+
+      if test "x$CONFIG_SHELL" != x; then :
+  # We cannot yet assume a decent shell, so we have to provide a
+	# neutralization value for shells without unset; and this also
+	# works around shells that cannot unset nonexistent variables.
+	BASH_ENV=/dev/null
+	ENV=/dev/null
+	(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
+	export CONFIG_SHELL
+	exec "$CONFIG_SHELL" "$as_myself" ${1+"$@"}
+fi
+
+    if test x$as_have_required = xno; then :
+  $as_echo "$0: This script requires a shell more modern than all"
+  $as_echo "$0: the shells that I found on your system."
+  if test x${ZSH_VERSION+set} = xset ; then
+    $as_echo "$0: In particular, zsh $ZSH_VERSION has bugs and should"
+    $as_echo "$0: be upgraded to zsh 4.3.4 or later."
+  else
+    $as_echo "$0: Please tell bug-autoconf@gnu.org about your system,
+$0: including any error possibly output before this
+$0: message. Then install a modern shell, or manually run
+$0: the script under such a shell if you do have one."
+  fi
+  exit 1
+fi
+fi
+fi
+SHELL=${CONFIG_SHELL-/bin/sh}
+export SHELL
+# Unset more variables known to interfere with behavior of common tools.
+CLICOLOR_FORCE= GREP_OPTIONS=
+unset CLICOLOR_FORCE GREP_OPTIONS
+
+## --------------------- ##
+## M4sh Shell Functions. ##
+## --------------------- ##
+# as_fn_unset VAR
+# ---------------
+# Portably unset VAR.
+as_fn_unset ()
+{
+  { eval $1=; unset $1;}
+}
+as_unset=as_fn_unset
+
+# as_fn_set_status STATUS
+# -----------------------
+# Set $? to STATUS, without forking.
+as_fn_set_status ()
+{
+  return $1
+} # as_fn_set_status
+
+# as_fn_exit STATUS
+# -----------------
+# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
+as_fn_exit ()
+{
+  set +e
+  as_fn_set_status $1
+  exit $1
+} # as_fn_exit
+
+# as_fn_mkdir_p
+# -------------
+# Create "$as_dir" as a directory, including parents if necessary.
+as_fn_mkdir_p ()
+{
+
+  case $as_dir in #(
+  -*) as_dir=./$as_dir;;
+  esac
+  test -d "$as_dir" || eval $as_mkdir_p || {
+    as_dirs=
+    while :; do
+      case $as_dir in #(
+      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
+      *) as_qdir=$as_dir;;
+      esac
+      as_dirs="'$as_qdir' $as_dirs"
+      as_dir=`$as_dirname -- "$as_dir" ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      test -d "$as_dir" && break
+    done
+    test -z "$as_dirs" || eval "mkdir $as_dirs"
+  } || test -d "$as_dir" || as_fn_error "cannot create directory $as_dir"
+
+
+} # as_fn_mkdir_p
+# as_fn_append VAR VALUE
+# ----------------------
+# Append the text in VALUE to the end of the definition contained in VAR. Take
+# advantage of any shell optimizations that allow amortized linear growth over
+# repeated appends, instead of the typical quadratic growth present in naive
+# implementations.
+if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
+  eval 'as_fn_append ()
+  {
+    eval $1+=\$2
+  }'
+else
+  as_fn_append ()
+  {
+    eval $1=\$$1\$2
+  }
+fi # as_fn_append
+
+# as_fn_arith ARG...
+# ------------------
+# Perform arithmetic evaluation on the ARGs, and store the result in the
+# global $as_val. Take advantage of shells that can avoid forks. The arguments
+# must be portable across $(()) and expr.
+if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
+  eval 'as_fn_arith ()
+  {
+    as_val=$(( $* ))
+  }'
+else
+  as_fn_arith ()
+  {
+    as_val=`expr "$@" || test $? -eq 1`
+  }
+fi # as_fn_arith
+
+
+# as_fn_error ERROR [LINENO LOG_FD]
+# ---------------------------------
+# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
+# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
+# script with status $?, using 1 if that was 0.
+as_fn_error ()
+{
+  as_status=$?; test $as_status -eq 0 && as_status=1
+  if test "$3"; then
+    as_lineno=${as_lineno-"$2"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    $as_echo "$as_me:${as_lineno-$LINENO}: error: $1" >&$3
+  fi
+  $as_echo "$as_me: error: $1" >&2
+  as_fn_exit $as_status
+} # as_fn_error
+
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
+  as_dirname=dirname
+else
+  as_dirname=false
+fi
+
+as_me=`$as_basename -- "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+
+  as_lineno_1=$LINENO as_lineno_1a=$LINENO
+  as_lineno_2=$LINENO as_lineno_2a=$LINENO
+  eval 'test "x$as_lineno_1'$as_run'" != "x$as_lineno_2'$as_run'" &&
+  test "x`expr $as_lineno_1'$as_run' + 1`" = "x$as_lineno_2'$as_run'"' || {
+  # Blame Lee E. McMahon (1931-1989) for sed's syntax.  :-)
+  sed -n '
+    p
+    /[$]LINENO/=
+  ' <$as_myself |
+    sed '
+      s/[$]LINENO.*/&-/
+      t lineno
+      b
+      :lineno
+      N
+      :loop
+      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
+      t loop
+      s/-\n.*//
+    ' >$as_me.lineno &&
+  chmod +x "$as_me.lineno" ||
+    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensitive to this).
+  . "./$as_me.lineno"
+  # Exit status is that of the last command.
+  exit
+}
+
+ECHO_C= ECHO_N= ECHO_T=
+case `echo -n x` in #(((((
+-n*)
+  case `echo 'xy\c'` in
+  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
+  xy)  ECHO_C='\c';;
+  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
+       ECHO_T='	';;
+  esac;;
+*)
+  ECHO_N='-n';;
+esac
+
+rm -f conf$$ conf$$.exe conf$$.file
+if test -d conf$$.dir; then
+  rm -f conf$$.dir/conf$$.file
+else
+  rm -f conf$$.dir
+  mkdir conf$$.dir 2>/dev/null
+fi
+if (echo >conf$$.file) 2>/dev/null; then
+  if ln -s conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s='ln -s'
+    # ... but there are two gotchas:
+    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
+    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
+    # In both cases, we have to default to `cp -p'.
+    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
+      as_ln_s='cp -p'
+  elif ln conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s=ln
+  else
+    as_ln_s='cp -p'
+  fi
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
+rmdir conf$$.dir 2>/dev/null
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p='mkdir -p "$as_dir"'
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+if test -x / >/dev/null 2>&1; then
+  as_test_x='test -x'
+else
+  if ls -dL / >/dev/null 2>&1; then
+    as_ls_L_option=L
+  else
+    as_ls_L_option=
+  fi
+  as_test_x='
+    eval sh -c '\''
+      if test -d "$1"; then
+	test -d "$1/.";
+      else
+	case $1 in #(
+	-*)set "./$1";;
+	esac;
+	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
+	???[sx]*):;;*)false;;esac;fi
+    '\'' sh
+  '
+fi
+as_executable_p=$as_test_x
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+SHELL=${CONFIG_SHELL-/bin/sh}
+
+
+exec 7<&0 </dev/null 6>&1
+
+# Name of the host.
+# hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
+# so uname gets run too.
+ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
+
+#
+# Initializations.
+#
+ac_default_prefix=/usr/local
+ac_clean_files=
+ac_config_libobj_dir=.
+LIBOBJS=
+cross_compiling=no
+subdirs=
+MFLAGS=
+MAKEFLAGS=
+
+# Identity of this package.
+PACKAGE_NAME='binutils'
+PACKAGE_TARNAME='binutils'
+PACKAGE_VERSION='2.26'
+PACKAGE_STRING='binutils 2.26'
+PACKAGE_BUGREPORT=''
+PACKAGE_URL=''
+
+ac_unique_file="ar.c"
+# Factoring default headers for most tests.
+ac_includes_default="\
+#include <stdio.h>
+#ifdef HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
+#ifdef STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#else
+# ifdef HAVE_STDLIB_H
+#  include <stdlib.h>
+# endif
+#endif
+#ifdef HAVE_STRING_H
+# if !defined STDC_HEADERS && defined HAVE_MEMORY_H
+#  include <memory.h>
+# endif
+# include <string.h>
+#endif
+#ifdef HAVE_STRINGS_H
+# include <strings.h>
+#endif
+#ifdef HAVE_INTTYPES_H
+# include <inttypes.h>
+#endif
+#ifdef HAVE_STDINT_H
+# include <stdint.h>
+#endif
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif"
+
+ac_subst_vars='am__EXEEXT_FALSE
+am__EXEEXT_TRUE
+LTLIBOBJS
+LIBOBJS
+EMULATION_VECTOR
+EMULATION
+OBJDUMP_PRIVATE_OFILES
+OBJDUMP_DEFS
+BUILD_INSTALL_MISC
+BUILD_MISC
+BUILD_DLLWRAP
+BUILD_WINDMC
+BUILD_WINDRES
+DLLTOOL_DEFS
+BUILD_DLLTOOL
+BUILD_SRCONV
+BUILD_NLMCONV
+NLMCONV_DEFS
+LTLIBICONV
+LIBICONV
+zlibinc
+zlibdir
+ALLOCA
+DEMANGLER_NAME
+EXEEXT_FOR_BUILD
+CC_FOR_BUILD
+HDEFINES
+GENINSRC_NEVER_FALSE
+GENINSRC_NEVER_TRUE
+MAINT
+MAINTAINER_MODE_FALSE
+MAINTAINER_MODE_TRUE
+MSGMERGE
+MSGFMT
+MKINSTALLDIRS
+CATOBJEXT
+GENCAT
+INSTOBJEXT
+DATADIRNAME
+CATALOGS
+POSUB
+GMSGFMT
+XGETTEXT
+INCINTL
+LIBINTL_DEP
+LIBINTL
+USE_NLS
+LEXLIB
+LEX_OUTPUT_ROOT
+LEX
+YFLAGS
+YACC
+NO_WERROR
+WARN_CFLAGS
+OTOOL64
+OTOOL
+LIPO
+NMEDIT
+DSYMUTIL
+RANLIB
+AR
+OBJDUMP
+LN_S
+NM
+ac_ct_DUMPBIN
+DUMPBIN
+LD
+FGREP
+SED
+LIBTOOL
+EGREP
+GREP
+CPP
+am__fastdepCC_FALSE
+am__fastdepCC_TRUE
+CCDEPMODE
+AMDEPBACKSLASH
+AMDEP_FALSE
+AMDEP_TRUE
+am__quote
+am__include
+DEPDIR
+am__untar
+am__tar
+AMTAR
+am__leading_dot
+SET_MAKE
+AWK
+mkdir_p
+MKDIR_P
+INSTALL_STRIP_PROGRAM
+STRIP
+install_sh
+MAKEINFO
+AUTOHEADER
+AUTOMAKE
+AUTOCONF
+ACLOCAL
+VERSION
+PACKAGE
+CYGPATH_W
+am__isrc
+INSTALL_DATA
+INSTALL_SCRIPT
+INSTALL_PROGRAM
+OBJEXT
+EXEEXT
+ac_ct_CC
+CPPFLAGS
+LDFLAGS
+CFLAGS
+CC
+target_os
+target_vendor
+target_cpu
+target
+host_os
+host_vendor
+host_cpu
+host
+build_os
+build_vendor
+build_cpu
+build
+target_alias
+host_alias
+build_alias
+LIBS
+ECHO_T
+ECHO_N
+ECHO_C
+DEFS
+mandir
+localedir
+libdir
+psdir
+pdfdir
+dvidir
+htmldir
+infodir
+docdir
+oldincludedir
+includedir
+localstatedir
+sharedstatedir
+sysconfdir
+datadir
+datarootdir
+libexecdir
+sbindir
+bindir
+program_transform_name
+prefix
+exec_prefix
+PACKAGE_URL
+PACKAGE_BUGREPORT
+PACKAGE_STRING
+PACKAGE_VERSION
+PACKAGE_TARNAME
+PACKAGE_NAME
+PATH_SEPARATOR
+SHELL'
+ac_subst_files=''
+ac_user_opts='
+enable_option_checking
+enable_dependency_tracking
+enable_shared
+enable_static
+with_pic
+enable_fast_install
+with_gnu_ld
+enable_libtool_lock
+enable_plugins
+enable_largefile
+enable_targets
+enable_deterministic_archives
+enable_default_strings_all
+enable_werror
+enable_build_warnings
+enable_nls
+enable_maintainer_mode
+with_system_zlib
+enable_rpath
+with_libiconv_prefix
+'
+      ac_precious_vars='build_alias
+host_alias
+target_alias
+CC
+CFLAGS
+LDFLAGS
+LIBS
+CPPFLAGS
+CPP
+YACC
+YFLAGS'
+
+
+# Initialize some variables set by options.
+ac_init_help=
+ac_init_version=false
+ac_unrecognized_opts=
+ac_unrecognized_sep=
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+cache_file=/dev/null
+exec_prefix=NONE
+no_create=
+no_recursion=
+prefix=NONE
+program_prefix=NONE
+program_suffix=NONE
+program_transform_name=s,x,x,
+silent=
+site=
+srcdir=
+verbose=
+x_includes=NONE
+x_libraries=NONE
+
+# Installation directory options.
+# These are left unexpanded so users can "make install exec_prefix=/foo"
+# and all the variables that are supposed to be based on exec_prefix
+# by default will actually change.
+# Use braces instead of parens because sh, perl, etc. also accept them.
+# (The list follows the same order as the GNU Coding Standards.)
+bindir='${exec_prefix}/bin'
+sbindir='${exec_prefix}/sbin'
+libexecdir='${exec_prefix}/libexec'
+datarootdir='${prefix}/share'
+datadir='${datarootdir}'
+sysconfdir='${prefix}/etc'
+sharedstatedir='${prefix}/com'
+localstatedir='${prefix}/var'
+includedir='${prefix}/include'
+oldincludedir='/usr/include'
+docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
+infodir='${datarootdir}/info'
+htmldir='${docdir}'
+dvidir='${docdir}'
+pdfdir='${docdir}'
+psdir='${docdir}'
+libdir='${exec_prefix}/lib'
+localedir='${datarootdir}/locale'
+mandir='${datarootdir}/man'
+
+ac_prev=
+ac_dashdash=
+for ac_option
+do
+  # If the previous option needs an argument, assign it.
+  if test -n "$ac_prev"; then
+    eval $ac_prev=\$ac_option
+    ac_prev=
+    continue
+  fi
+
+  case $ac_option in
+  *=*)	ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
+  *)	ac_optarg=yes ;;
+  esac
+
+  # Accept the important Cygnus configure options, so we can diagnose typos.
+
+  case $ac_dashdash$ac_option in
+  --)
+    ac_dashdash=yes ;;
+
+  -bindir | --bindir | --bindi | --bind | --bin | --bi)
+    ac_prev=bindir ;;
+  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
+    bindir=$ac_optarg ;;
+
+  -build | --build | --buil | --bui | --bu)
+    ac_prev=build_alias ;;
+  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
+    build_alias=$ac_optarg ;;
+
+  -cache-file | --cache-file | --cache-fil | --cache-fi \
+  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
+    ac_prev=cache_file ;;
+  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
+  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
+    cache_file=$ac_optarg ;;
+
+  --config-cache | -C)
+    cache_file=config.cache ;;
+
+  -datadir | --datadir | --datadi | --datad)
+    ac_prev=datadir ;;
+  -datadir=* | --datadir=* | --datadi=* | --datad=*)
+    datadir=$ac_optarg ;;
+
+  -datarootdir | --datarootdir | --datarootdi | --datarootd | --dataroot \
+  | --dataroo | --dataro | --datar)
+    ac_prev=datarootdir ;;
+  -datarootdir=* | --datarootdir=* | --datarootdi=* | --datarootd=* \
+  | --dataroot=* | --dataroo=* | --dataro=* | --datar=*)
+    datarootdir=$ac_optarg ;;
+
+  -disable-* | --disable-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error "invalid feature name: $ac_useropt"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"enable_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--disable-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval enable_$ac_useropt=no ;;
+
+  -docdir | --docdir | --docdi | --doc | --do)
+    ac_prev=docdir ;;
+  -docdir=* | --docdir=* | --docdi=* | --doc=* | --do=*)
+    docdir=$ac_optarg ;;
+
+  -dvidir | --dvidir | --dvidi | --dvid | --dvi | --dv)
+    ac_prev=dvidir ;;
+  -dvidir=* | --dvidir=* | --dvidi=* | --dvid=* | --dvi=* | --dv=*)
+    dvidir=$ac_optarg ;;
+
+  -enable-* | --enable-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error "invalid feature name: $ac_useropt"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"enable_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--enable-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval enable_$ac_useropt=\$ac_optarg ;;
+
+  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
+  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
+  | --exec | --exe | --ex)
+    ac_prev=exec_prefix ;;
+  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
+  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
+  | --exec=* | --exe=* | --ex=*)
+    exec_prefix=$ac_optarg ;;
+
+  -gas | --gas | --ga | --g)
+    # Obsolete; use --with-gas.
+    with_gas=yes ;;
+
+  -help | --help | --hel | --he | -h)
+    ac_init_help=long ;;
+  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
+    ac_init_help=recursive ;;
+  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
+    ac_init_help=short ;;
+
+  -host | --host | --hos | --ho)
+    ac_prev=host_alias ;;
+  -host=* | --host=* | --hos=* | --ho=*)
+    host_alias=$ac_optarg ;;
+
+  -htmldir | --htmldir | --htmldi | --htmld | --html | --htm | --ht)
+    ac_prev=htmldir ;;
+  -htmldir=* | --htmldir=* | --htmldi=* | --htmld=* | --html=* | --htm=* \
+  | --ht=*)
+    htmldir=$ac_optarg ;;
+
+  -includedir | --includedir | --includedi | --included | --include \
+  | --includ | --inclu | --incl | --inc)
+    ac_prev=includedir ;;
+  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
+  | --includ=* | --inclu=* | --incl=* | --inc=*)
+    includedir=$ac_optarg ;;
+
+  -infodir | --infodir | --infodi | --infod | --info | --inf)
+    ac_prev=infodir ;;
+  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
+    infodir=$ac_optarg ;;
+
+  -libdir | --libdir | --libdi | --libd)
+    ac_prev=libdir ;;
+  -libdir=* | --libdir=* | --libdi=* | --libd=*)
+    libdir=$ac_optarg ;;
+
+  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
+  | --libexe | --libex | --libe)
+    ac_prev=libexecdir ;;
+  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
+  | --libexe=* | --libex=* | --libe=*)
+    libexecdir=$ac_optarg ;;
+
+  -localedir | --localedir | --localedi | --localed | --locale)
+    ac_prev=localedir ;;
+  -localedir=* | --localedir=* | --localedi=* | --localed=* | --locale=*)
+    localedir=$ac_optarg ;;
+
+  -localstatedir | --localstatedir | --localstatedi | --localstated \
+  | --localstate | --localstat | --localsta | --localst | --locals)
+    ac_prev=localstatedir ;;
+  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
+  | --localstate=* | --localstat=* | --localsta=* | --localst=* | --locals=*)
+    localstatedir=$ac_optarg ;;
+
+  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
+    ac_prev=mandir ;;
+  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
+    mandir=$ac_optarg ;;
+
+  -nfp | --nfp | --nf)
+    # Obsolete; use --without-fp.
+    with_fp=no ;;
+
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c | -n)
+    no_create=yes ;;
+
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
+    no_recursion=yes ;;
+
+  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
+  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
+  | --oldin | --oldi | --old | --ol | --o)
+    ac_prev=oldincludedir ;;
+  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
+  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
+  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
+    oldincludedir=$ac_optarg ;;
+
+  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
+    ac_prev=prefix ;;
+  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
+    prefix=$ac_optarg ;;
+
+  -program-prefix | --program-prefix | --program-prefi | --program-pref \
+  | --program-pre | --program-pr | --program-p)
+    ac_prev=program_prefix ;;
+  -program-prefix=* | --program-prefix=* | --program-prefi=* \
+  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
+    program_prefix=$ac_optarg ;;
+
+  -program-suffix | --program-suffix | --program-suffi | --program-suff \
+  | --program-suf | --program-su | --program-s)
+    ac_prev=program_suffix ;;
+  -program-suffix=* | --program-suffix=* | --program-suffi=* \
+  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
+    program_suffix=$ac_optarg ;;
+
+  -program-transform-name | --program-transform-name \
+  | --program-transform-nam | --program-transform-na \
+  | --program-transform-n | --program-transform- \
+  | --program-transform | --program-transfor \
+  | --program-transfo | --program-transf \
+  | --program-trans | --program-tran \
+  | --progr-tra | --program-tr | --program-t)
+    ac_prev=program_transform_name ;;
+  -program-transform-name=* | --program-transform-name=* \
+  | --program-transform-nam=* | --program-transform-na=* \
+  | --program-transform-n=* | --program-transform-=* \
+  | --program-transform=* | --program-transfor=* \
+  | --program-transfo=* | --program-transf=* \
+  | --program-trans=* | --program-tran=* \
+  | --progr-tra=* | --program-tr=* | --program-t=*)
+    program_transform_name=$ac_optarg ;;
+
+  -pdfdir | --pdfdir | --pdfdi | --pdfd | --pdf | --pd)
+    ac_prev=pdfdir ;;
+  -pdfdir=* | --pdfdir=* | --pdfdi=* | --pdfd=* | --pdf=* | --pd=*)
+    pdfdir=$ac_optarg ;;
+
+  -psdir | --psdir | --psdi | --psd | --ps)
+    ac_prev=psdir ;;
+  -psdir=* | --psdir=* | --psdi=* | --psd=* | --ps=*)
+    psdir=$ac_optarg ;;
+
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil)
+    silent=yes ;;
+
+  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
+    ac_prev=sbindir ;;
+  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
+  | --sbi=* | --sb=*)
+    sbindir=$ac_optarg ;;
+
+  -sharedstatedir | --sharedstatedir | --sharedstatedi \
+  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
+  | --sharedst | --shareds | --shared | --share | --shar \
+  | --sha | --sh)
+    ac_prev=sharedstatedir ;;
+  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
+  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
+  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
+  | --sha=* | --sh=*)
+    sharedstatedir=$ac_optarg ;;
+
+  -site | --site | --sit)
+    ac_prev=site ;;
+  -site=* | --site=* | --sit=*)
+    site=$ac_optarg ;;
+
+  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
+    ac_prev=srcdir ;;
+  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
+    srcdir=$ac_optarg ;;
+
+  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
+  | --syscon | --sysco | --sysc | --sys | --sy)
+    ac_prev=sysconfdir ;;
+  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
+  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
+    sysconfdir=$ac_optarg ;;
+
+  -target | --target | --targe | --targ | --tar | --ta | --t)
+    ac_prev=target_alias ;;
+  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
+    target_alias=$ac_optarg ;;
+
+  -v | -verbose | --verbose | --verbos | --verbo | --verb)
+    verbose=yes ;;
+
+  -version | --version | --versio | --versi | --vers | -V)
+    ac_init_version=: ;;
+
+  -with-* | --with-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error "invalid package name: $ac_useropt"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"with_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--with-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval with_$ac_useropt=\$ac_optarg ;;
+
+  -without-* | --without-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*without-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error "invalid package name: $ac_useropt"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"with_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--without-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval with_$ac_useropt=no ;;
+
+  --x)
+    # Obsolete; use --with-x.
+    with_x=yes ;;
+
+  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
+  | --x-incl | --x-inc | --x-in | --x-i)
+    ac_prev=x_includes ;;
+  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
+  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
+    x_includes=$ac_optarg ;;
+
+  -x-libraries | --x-libraries | --x-librarie | --x-librari \
+  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
+    ac_prev=x_libraries ;;
+  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
+  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
+    x_libraries=$ac_optarg ;;
+
+  -*) as_fn_error "unrecognized option: \`$ac_option'
+Try \`$0 --help' for more information."
+    ;;
+
+  *=*)
+    ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
+    # Reject names that are not valid shell variable names.
+    case $ac_envvar in #(
+      '' | [0-9]* | *[!_$as_cr_alnum]* )
+      as_fn_error "invalid variable name: \`$ac_envvar'" ;;
+    esac
+    eval $ac_envvar=\$ac_optarg
+    export $ac_envvar ;;
+
+  *)
+    # FIXME: should be removed in autoconf 3.0.
+    $as_echo "$as_me: WARNING: you should use --build, --host, --target" >&2
+    expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+      $as_echo "$as_me: WARNING: invalid host type: $ac_option" >&2
+    : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
+    ;;
+
+  esac
+done
+
+if test -n "$ac_prev"; then
+  ac_option=--`echo $ac_prev | sed 's/_/-/g'`
+  as_fn_error "missing argument to $ac_option"
+fi
+
+if test -n "$ac_unrecognized_opts"; then
+  case $enable_option_checking in
+    no) ;;
+    fatal) as_fn_error "unrecognized options: $ac_unrecognized_opts" ;;
+    *)     $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2 ;;
+  esac
+fi
+
+# Check all directory arguments for consistency.
+for ac_var in	exec_prefix prefix bindir sbindir libexecdir datarootdir \
+		datadir sysconfdir sharedstatedir localstatedir includedir \
+		oldincludedir docdir infodir htmldir dvidir pdfdir psdir \
+		libdir localedir mandir
+do
+  eval ac_val=\$$ac_var
+  # Remove trailing slashes.
+  case $ac_val in
+    */ )
+      ac_val=`expr "X$ac_val" : 'X\(.*[^/]\)' \| "X$ac_val" : 'X\(.*\)'`
+      eval $ac_var=\$ac_val;;
+  esac
+  # Be sure to have absolute directory names.
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* )  continue;;
+    NONE | '' ) case $ac_var in *prefix ) continue;; esac;;
+  esac
+  as_fn_error "expected an absolute directory name for --$ac_var: $ac_val"
+done
+
+# There might be people who depend on the old broken behavior: `$host'
+# used to hold the argument of --host etc.
+# FIXME: To remove some day.
+build=$build_alias
+host=$host_alias
+target=$target_alias
+
+# FIXME: To remove some day.
+if test "x$host_alias" != x; then
+  if test "x$build_alias" = x; then
+    cross_compiling=maybe
+    $as_echo "$as_me: WARNING: If you wanted to set the --build type, don't use --host.
+    If a cross compiler is detected then cross compile mode will be used." >&2
+  elif test "x$build_alias" != "x$host_alias"; then
+    cross_compiling=yes
+  fi
+fi
+
+ac_tool_prefix=
+test -n "$host_alias" && ac_tool_prefix=$host_alias-
+
+test "$silent" = yes && exec 6>/dev/null
+
+
+ac_pwd=`pwd` && test -n "$ac_pwd" &&
+ac_ls_di=`ls -di .` &&
+ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
+  as_fn_error "working directory cannot be determined"
+test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
+  as_fn_error "pwd does not report name of working directory"
+
+
+# Find the source files, if location was not specified.
+if test -z "$srcdir"; then
+  ac_srcdir_defaulted=yes
+  # Try the directory containing this script, then the parent directory.
+  ac_confdir=`$as_dirname -- "$as_myself" ||
+$as_expr X"$as_myself" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_myself" : 'X\(//\)[^/]' \| \
+	 X"$as_myself" : 'X\(//\)$' \| \
+	 X"$as_myself" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_myself" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+  srcdir=$ac_confdir
+  if test ! -r "$srcdir/$ac_unique_file"; then
+    srcdir=..
+  fi
+else
+  ac_srcdir_defaulted=no
+fi
+if test ! -r "$srcdir/$ac_unique_file"; then
+  test "$ac_srcdir_defaulted" = yes && srcdir="$ac_confdir or .."
+  as_fn_error "cannot find sources ($ac_unique_file) in $srcdir"
+fi
+ac_msg="sources are in $srcdir, but \`cd $srcdir' does not work"
+ac_abs_confdir=`(
+	cd "$srcdir" && test -r "./$ac_unique_file" || as_fn_error "$ac_msg"
+	pwd)`
+# When building in place, set srcdir=.
+if test "$ac_abs_confdir" = "$ac_pwd"; then
+  srcdir=.
+fi
+# Remove unnecessary trailing slashes from srcdir.
+# Double slashes in file names in object file debugging info
+# mess up M-x gdb in Emacs.
+case $srcdir in
+*/) srcdir=`expr "X$srcdir" : 'X\(.*[^/]\)' \| "X$srcdir" : 'X\(.*\)'`;;
+esac
+for ac_var in $ac_precious_vars; do
+  eval ac_env_${ac_var}_set=\${${ac_var}+set}
+  eval ac_env_${ac_var}_value=\$${ac_var}
+  eval ac_cv_env_${ac_var}_set=\${${ac_var}+set}
+  eval ac_cv_env_${ac_var}_value=\$${ac_var}
+done
+
+#
+# Report the --help message.
+#
+if test "$ac_init_help" = "long"; then
+  # Omit some internal or obsolete options to make the list less imposing.
+  # This message is too long to be a string in the A/UX 3.1 sh.
+  cat <<_ACEOF
+\`configure' configures binutils 2.26 to adapt to many kinds of systems.
+
+Usage: $0 [OPTION]... [VAR=VALUE]...
+
+To assign environment variables (e.g., CC, CFLAGS...), specify them as
+VAR=VALUE.  See below for descriptions of some of the useful variables.
+
+Defaults for the options are specified in brackets.
+
+Configuration:
+  -h, --help              display this help and exit
+      --help=short        display options specific to this package
+      --help=recursive    display the short help of all the included packages
+  -V, --version           display version information and exit
+  -q, --quiet, --silent   do not print \`checking...' messages
+      --cache-file=FILE   cache test results in FILE [disabled]
+  -C, --config-cache      alias for \`--cache-file=config.cache'
+  -n, --no-create         do not create output files
+      --srcdir=DIR        find the sources in DIR [configure dir or \`..']
+
+Installation directories:
+  --prefix=PREFIX         install architecture-independent files in PREFIX
+                          [$ac_default_prefix]
+  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
+                          [PREFIX]
+
+By default, \`make install' will install all the files in
+\`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
+an installation prefix other than \`$ac_default_prefix' using \`--prefix',
+for instance \`--prefix=\$HOME'.
+
+For better control, use the options below.
+
+Fine tuning of the installation directories:
+  --bindir=DIR            user executables [EPREFIX/bin]
+  --sbindir=DIR           system admin executables [EPREFIX/sbin]
+  --libexecdir=DIR        program executables [EPREFIX/libexec]
+  --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]
+  --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]
+  --localstatedir=DIR     modifiable single-machine data [PREFIX/var]
+  --libdir=DIR            object code libraries [EPREFIX/lib]
+  --includedir=DIR        C header files [PREFIX/include]
+  --oldincludedir=DIR     C header files for non-gcc [/usr/include]
+  --datarootdir=DIR       read-only arch.-independent data root [PREFIX/share]
+  --datadir=DIR           read-only architecture-independent data [DATAROOTDIR]
+  --infodir=DIR           info documentation [DATAROOTDIR/info]
+  --localedir=DIR         locale-dependent data [DATAROOTDIR/locale]
+  --mandir=DIR            man documentation [DATAROOTDIR/man]
+  --docdir=DIR            documentation root [DATAROOTDIR/doc/binutils]
+  --htmldir=DIR           html documentation [DOCDIR]
+  --dvidir=DIR            dvi documentation [DOCDIR]
+  --pdfdir=DIR            pdf documentation [DOCDIR]
+  --psdir=DIR             ps documentation [DOCDIR]
+_ACEOF
+
+  cat <<\_ACEOF
+
+Program names:
+  --program-prefix=PREFIX            prepend PREFIX to installed program names
+  --program-suffix=SUFFIX            append SUFFIX to installed program names
+  --program-transform-name=PROGRAM   run sed PROGRAM on installed program names
+
+System types:
+  --build=BUILD     configure for building on BUILD [guessed]
+  --host=HOST       cross-compile to build programs to run on HOST [BUILD]
+  --target=TARGET   configure for building compilers for TARGET [HOST]
+_ACEOF
+fi
+
+if test -n "$ac_init_help"; then
+  case $ac_init_help in
+     short | recursive ) echo "Configuration of binutils 2.26:";;
+   esac
+  cat <<\_ACEOF
+
+Optional Features:
+  --disable-option-checking  ignore unrecognized --enable/--with options
+  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
+  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+  --disable-dependency-tracking  speeds up one-time build
+  --enable-dependency-tracking   do not reject slow dependency extractors
+  --enable-shared[=PKGS]  build shared libraries [default=yes]
+  --enable-static[=PKGS]  build static libraries [default=yes]
+  --enable-fast-install[=PKGS]
+                          optimize for fast installation [default=yes]
+  --disable-libtool-lock  avoid locking (might break parallel builds)
+  --enable-plugins        Enable support for plugins
+  --disable-largefile     omit support for large files
+  --enable-targets        alternative target configurations
+  --enable-deterministic-archives
+                          ar and ranlib default to -D behavior
+  --disable-default-strings-all
+                          strings defaults to --data behavior
+  --enable-werror         treat compile warnings as errors
+  --enable-build-warnings enable build-time compiler warnings
+  --disable-nls           do not use Native Language Support
+  --enable-maintainer-mode  enable make rules and dependencies not useful
+			  (and sometimes confusing) to the casual installer
+  --disable-rpath         do not hardcode runtime library paths
+
+Optional Packages:
+  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
+  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
+  --with-pic              try to use only PIC/non-PIC objects [default=use
+                          both]
+  --with-gnu-ld           assume the C compiler uses GNU ld [default=no]
+  --with-system-zlib      use installed libz
+  --with-gnu-ld           assume the C compiler uses GNU ld default=no
+  --with-libiconv-prefix[=DIR]  search for libiconv in DIR/include and DIR/lib
+  --without-libiconv-prefix     don't search for libiconv in includedir and libdir
+
+Some influential environment variables:
+  CC          C compiler command
+  CFLAGS      C compiler flags
+  LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
+              nonstandard directory <lib dir>
+  LIBS        libraries to pass to the linker, e.g. -l<library>
+  CPPFLAGS    C/C++/Objective C preprocessor flags, e.g. -I<include dir> if
+              you have headers in a nonstandard directory <include dir>
+  CPP         C preprocessor
+  YACC        The `Yet Another C Compiler' implementation to use. Defaults to
+              the first program found out of: `bison -y', `byacc', `yacc'.
+  YFLAGS      The list of arguments that will be passed by default to $YACC.
+              This script will default YFLAGS to the empty string to avoid a
+              default value of `-d' given by some make applications.
+
+Use these variables to override the choices made by `configure' or to help
+it to find libraries and programs with nonstandard names/locations.
+
+Report bugs to the package provider.
+_ACEOF
+ac_status=$?
+fi
+
+if test "$ac_init_help" = "recursive"; then
+  # If there are subdirs, report their specific --help.
+  for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
+    test -d "$ac_dir" ||
+      { cd "$srcdir" && ac_pwd=`pwd` && srcdir=. && test -d "$ac_dir"; } ||
+      continue
+    ac_builddir=.
+
+case "$ac_dir" in
+.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
+*)
+  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
+  # A ".." for each directory in $ac_dir_suffix.
+  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
+  case $ac_top_builddir_sub in
+  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
+  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
+  esac ;;
+esac
+ac_abs_top_builddir=$ac_pwd
+ac_abs_builddir=$ac_pwd$ac_dir_suffix
+# for backward compatibility:
+ac_top_builddir=$ac_top_build_prefix
+
+case $srcdir in
+  .)  # We are building in place.
+    ac_srcdir=.
+    ac_top_srcdir=$ac_top_builddir_sub
+    ac_abs_top_srcdir=$ac_pwd ;;
+  [\\/]* | ?:[\\/]* )  # Absolute name.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir
+    ac_abs_top_srcdir=$srcdir ;;
+  *) # Relative name.
+    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_build_prefix$srcdir
+    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
+esac
+ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
+
+    cd "$ac_dir" || { ac_status=$?; continue; }
+    # Check for guested configure.
+    if test -f "$ac_srcdir/configure.gnu"; then
+      echo &&
+      $SHELL "$ac_srcdir/configure.gnu" --help=recursive
+    elif test -f "$ac_srcdir/configure"; then
+      echo &&
+      $SHELL "$ac_srcdir/configure" --help=recursive
+    else
+      $as_echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
+    fi || ac_status=$?
+    cd "$ac_pwd" || { ac_status=$?; break; }
+  done
+fi
+
+test -n "$ac_init_help" && exit $ac_status
+if $ac_init_version; then
+  cat <<\_ACEOF
+binutils configure 2.26
+generated by GNU Autoconf 2.64
+
+Copyright (C) 2009 Free Software Foundation, Inc.
+This configure script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it.
+_ACEOF
+  exit
+fi
+
+## ------------------------ ##
+## Autoconf initialization. ##
+## ------------------------ ##
+
+# ac_fn_c_try_compile LINENO
+# --------------------------
+# Try to compile conftest.$ac_ext, and return whether this succeeded.
+ac_fn_c_try_compile ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  rm -f conftest.$ac_objext
+  if { { ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compile") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_retval=1
+fi
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  return $ac_retval
+
+} # ac_fn_c_try_compile
+
+# ac_fn_c_try_link LINENO
+# -----------------------
+# Try to link conftest.$ac_ext, and return whether this succeeded.
+ac_fn_c_try_link ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  rm -f conftest.$ac_objext conftest$ac_exeext
+  if { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_retval=1
+fi
+  # Delete the IPA/IPO (Inter Procedural Analysis/Optimization) information
+  # created by the PGI compiler (conftest_ipa8_conftest.oo), as it would
+  # interfere with the next link command; also delete a directory that is
+  # left behind by Apple's compiler.  We do this before executing the actions.
+  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  return $ac_retval
+
+} # ac_fn_c_try_link
+
+# ac_fn_c_try_cpp LINENO
+# ----------------------
+# Try to preprocess conftest.$ac_ext, and return whether this succeeded.
+ac_fn_c_try_cpp ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  if { { ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+    ac_retval=1
+fi
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  return $ac_retval
+
+} # ac_fn_c_try_cpp
+
+# ac_fn_c_check_header_mongrel LINENO HEADER VAR INCLUDES
+# -------------------------------------------------------
+# Tests whether HEADER exists, giving a warning if it cannot be compiled using
+# the include files in INCLUDES and setting the cache variable VAR
+# accordingly.
+ac_fn_c_check_header_mongrel ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+  $as_echo_n "(cached) " >&6
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+else
+  # Is the header compilable?
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking $2 usability" >&5
+$as_echo_n "checking $2 usability... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+#include <$2>
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_header_compiler=yes
+else
+  ac_header_compiler=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_compiler" >&5
+$as_echo "$ac_header_compiler" >&6; }
+
+# Is the header present?
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking $2 presence" >&5
+$as_echo_n "checking $2 presence... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <$2>
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+  ac_header_preproc=yes
+else
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_preproc" >&5
+$as_echo "$ac_header_preproc" >&6; }
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in #((
+  yes:no: )
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: accepted by the compiler, rejected by the preprocessor!" >&5
+$as_echo "$as_me: WARNING: $2: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result" >&5
+$as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
+    ;;
+  no:yes:* )
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: present but cannot be compiled" >&5
+$as_echo "$as_me: WARNING: $2: present but cannot be compiled" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2:     check for missing prerequisite headers?" >&5
+$as_echo "$as_me: WARNING: $2:     check for missing prerequisite headers?" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: see the Autoconf documentation" >&5
+$as_echo "$as_me: WARNING: $2: see the Autoconf documentation" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2:     section \"Present But Cannot Be Compiled\"" >&5
+$as_echo "$as_me: WARNING: $2:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result" >&5
+$as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
+    ;;
+esac
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+  $as_echo_n "(cached) " >&6
+else
+  eval "$3=\$ac_header_compiler"
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+fi
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+
+} # ac_fn_c_check_header_mongrel
+
+# ac_fn_c_try_run LINENO
+# ----------------------
+# Try to link conftest.$ac_ext, and return whether this succeeded. Assumes
+# that executables *can* be run.
+ac_fn_c_try_run ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  if { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && { ac_try='./conftest$ac_exeext'
+  { { case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: program exited with status $ac_status" >&5
+       $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+       ac_retval=$ac_status
+fi
+  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  return $ac_retval
+
+} # ac_fn_c_try_run
+
+# ac_fn_c_check_header_compile LINENO HEADER VAR INCLUDES
+# -------------------------------------------------------
+# Tests whether HEADER exists and can be compiled using the include files in
+# INCLUDES, setting the cache variable VAR accordingly.
+ac_fn_c_check_header_compile ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+#include <$2>
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  eval "$3=yes"
+else
+  eval "$3=no"
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+
+} # ac_fn_c_check_header_compile
+
+# ac_fn_c_check_func LINENO FUNC VAR
+# ----------------------------------
+# Tests whether FUNC exists, setting the cache variable VAR accordingly
+ac_fn_c_check_func ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+/* Define $2 to an innocuous variant, in case <limits.h> declares $2.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $2 innocuous_$2
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $2 (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $2
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char $2 ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined __stub_$2 || defined __stub___$2
+choke me
+#endif
+
+int
+main ()
+{
+return $2 ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  eval "$3=yes"
+else
+  eval "$3=no"
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+
+} # ac_fn_c_check_func
+
+# ac_fn_c_compute_int LINENO EXPR VAR INCLUDES
+# --------------------------------------------
+# Tries to find the compile-time value of EXPR in a program that includes
+# INCLUDES, setting VAR accordingly. Returns whether the value could be
+# computed
+ac_fn_c_compute_int ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  if test "$cross_compiling" = yes; then
+    # Depending upon the size, compute the lo and hi bounds.
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+int
+main ()
+{
+static int test_array [1 - 2 * !(($2) >= 0)];
+test_array [0] = 0
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_lo=0 ac_mid=0
+  while :; do
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+int
+main ()
+{
+static int test_array [1 - 2 * !(($2) <= $ac_mid)];
+test_array [0] = 0
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_hi=$ac_mid; break
+else
+  as_fn_arith $ac_mid + 1 && ac_lo=$as_val
+			if test $ac_lo -le $ac_mid; then
+			  ac_lo= ac_hi=
+			  break
+			fi
+			as_fn_arith 2 '*' $ac_mid + 1 && ac_mid=$as_val
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  done
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+int
+main ()
+{
+static int test_array [1 - 2 * !(($2) < 0)];
+test_array [0] = 0
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_hi=-1 ac_mid=-1
+  while :; do
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+int
+main ()
+{
+static int test_array [1 - 2 * !(($2) >= $ac_mid)];
+test_array [0] = 0
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_lo=$ac_mid; break
+else
+  as_fn_arith '(' $ac_mid ')' - 1 && ac_hi=$as_val
+			if test $ac_mid -le $ac_hi; then
+			  ac_lo= ac_hi=
+			  break
+			fi
+			as_fn_arith 2 '*' $ac_mid && ac_mid=$as_val
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  done
+else
+  ac_lo= ac_hi=
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+# Binary search between lo and hi bounds.
+while test "x$ac_lo" != "x$ac_hi"; do
+  as_fn_arith '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo && ac_mid=$as_val
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+int
+main ()
+{
+static int test_array [1 - 2 * !(($2) <= $ac_mid)];
+test_array [0] = 0
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_hi=$ac_mid
+else
+  as_fn_arith '(' $ac_mid ')' + 1 && ac_lo=$as_val
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+done
+case $ac_lo in #((
+?*) eval "$3=\$ac_lo"; ac_retval=0 ;;
+'') ac_retval=1 ;;
+esac
+  else
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+static long int longval () { return $2; }
+static unsigned long int ulongval () { return $2; }
+#include <stdio.h>
+#include <stdlib.h>
+int
+main ()
+{
+
+  FILE *f = fopen ("conftest.val", "w");
+  if (! f)
+    return 1;
+  if (($2) < 0)
+    {
+      long int i = longval ();
+      if (i != ($2))
+	return 1;
+      fprintf (f, "%ld", i);
+    }
+  else
+    {
+      unsigned long int i = ulongval ();
+      if (i != ($2))
+	return 1;
+      fprintf (f, "%lu", i);
+    }
+  /* Do not output a trailing newline, as this causes \r\n confusion
+     on some platforms.  */
+  return ferror (f) || fclose (f) != 0;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+  echo >>conftest.val; read $3 <conftest.val; ac_retval=0
+else
+  ac_retval=1
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+rm -f conftest.val
+
+  fi
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  return $ac_retval
+
+} # ac_fn_c_compute_int
+
+# ac_fn_c_check_type LINENO TYPE VAR INCLUDES
+# -------------------------------------------
+# Tests whether TYPE exists after having included INCLUDES, setting cache
+# variable VAR accordingly.
+ac_fn_c_check_type ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+  $as_echo_n "(cached) " >&6
+else
+  eval "$3=no"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+int
+main ()
+{
+if (sizeof ($2))
+	 return 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+int
+main ()
+{
+if (sizeof (($2)))
+	    return 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+
+else
+  eval "$3=yes"
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+
+} # ac_fn_c_check_type
+
+# ac_fn_c_check_decl LINENO SYMBOL VAR
+# ------------------------------------
+# Tests whether SYMBOL is declared, setting cache variable VAR accordingly.
+ac_fn_c_check_decl ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  as_decl_name=`echo $2|sed 's/ *(.*//'`
+  as_decl_use=`echo $2|sed -e 's/(/((/' -e 's/)/) 0&/' -e 's/,/) 0& (/g'`
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $as_decl_name is declared" >&5
+$as_echo_n "checking whether $as_decl_name is declared... " >&6; }
+if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+int
+main ()
+{
+#ifndef $as_decl_name
+#ifdef __cplusplus
+  (void) $as_decl_use;
+#else
+  (void) $as_decl_name;
+#endif
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  eval "$3=yes"
+else
+  eval "$3=no"
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+
+} # ac_fn_c_check_decl
+cat >config.log <<_ACEOF
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by binutils $as_me 2.26, which was
+generated by GNU Autoconf 2.64.  Invocation command line was
+
+  $ $0 $@
+
+_ACEOF
+exec 5>>config.log
+{
+cat <<_ASUNAME
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
+
+/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
+/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`
+/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
+/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
+
+_ASUNAME
+
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    $as_echo "PATH: $as_dir"
+  done
+IFS=$as_save_IFS
+
+} >&5
+
+cat >&5 <<_ACEOF
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+_ACEOF
+
+
+# Keep a trace of the command line.
+# Strip out --no-create and --no-recursion so they do not pile up.
+# Strip out --silent because we don't want to record it for future runs.
+# Also quote any args containing shell meta-characters.
+# Make two passes to allow for proper duplicate-argument suppression.
+ac_configure_args=
+ac_configure_args0=
+ac_configure_args1=
+ac_must_keep_next=false
+for ac_pass in 1 2
+do
+  for ac_arg
+  do
+    case $ac_arg in
+    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
+    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+    | -silent | --silent | --silen | --sile | --sil)
+      continue ;;
+    *\'*)
+      ac_arg=`$as_echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    case $ac_pass in
+    1) as_fn_append ac_configure_args0 " '$ac_arg'" ;;
+    2)
+      as_fn_append ac_configure_args1 " '$ac_arg'"
+      if test $ac_must_keep_next = true; then
+	ac_must_keep_next=false # Got value, back to normal.
+      else
+	case $ac_arg in
+	  *=* | --config-cache | -C | -disable-* | --disable-* \
+	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
+	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
+	  | -with-* | --with-* | -without-* | --without-* | --x)
+	    case "$ac_configure_args0 " in
+	      "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
+	    esac
+	    ;;
+	  -* ) ac_must_keep_next=true ;;
+	esac
+      fi
+      as_fn_append ac_configure_args " '$ac_arg'"
+      ;;
+    esac
+  done
+done
+{ ac_configure_args0=; unset ac_configure_args0;}
+{ ac_configure_args1=; unset ac_configure_args1;}
+
+# When interrupted or exit'd, cleanup temporary files, and complete
+# config.log.  We remove comments because anyway the quotes in there
+# would cause problems or look ugly.
+# WARNING: Use '\'' to represent an apostrophe within the trap.
+# WARNING: Do not start the trap code with a newline, due to a FreeBSD 4.0 bug.
+trap 'exit_status=$?
+  # Save into config.log some information that might help in debugging.
+  {
+    echo
+
+    cat <<\_ASBOX
+## ---------------- ##
+## Cache variables. ##
+## ---------------- ##
+_ASBOX
+    echo
+    # The following way of writing the cache mishandles newlines in values,
+(
+  for ac_var in `(set) 2>&1 | sed -n '\''s/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'\''`; do
+    eval ac_val=\$$ac_var
+    case $ac_val in #(
+    *${as_nl}*)
+      case $ac_var in #(
+      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
+$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
+      esac
+      case $ac_var in #(
+      _ | IFS | as_nl) ;; #(
+      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
+      *) { eval $ac_var=; unset $ac_var;} ;;
+      esac ;;
+    esac
+  done
+  (set) 2>&1 |
+    case $as_nl`(ac_space='\'' '\''; set) 2>&1` in #(
+    *${as_nl}ac_space=\ *)
+      sed -n \
+	"s/'\''/'\''\\\\'\'''\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\''\\2'\''/p"
+      ;; #(
+    *)
+      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
+      ;;
+    esac |
+    sort
+)
+    echo
+
+    cat <<\_ASBOX
+## ----------------- ##
+## Output variables. ##
+## ----------------- ##
+_ASBOX
+    echo
+    for ac_var in $ac_subst_vars
+    do
+      eval ac_val=\$$ac_var
+      case $ac_val in
+      *\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+      esac
+      $as_echo "$ac_var='\''$ac_val'\''"
+    done | sort
+    echo
+
+    if test -n "$ac_subst_files"; then
+      cat <<\_ASBOX
+## ------------------- ##
+## File substitutions. ##
+## ------------------- ##
+_ASBOX
+      echo
+      for ac_var in $ac_subst_files
+      do
+	eval ac_val=\$$ac_var
+	case $ac_val in
+	*\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+	esac
+	$as_echo "$ac_var='\''$ac_val'\''"
+      done | sort
+      echo
+    fi
+
+    if test -s confdefs.h; then
+      cat <<\_ASBOX
+## ----------- ##
+## confdefs.h. ##
+## ----------- ##
+_ASBOX
+      echo
+      cat confdefs.h
+      echo
+    fi
+    test "$ac_signal" != 0 &&
+      $as_echo "$as_me: caught signal $ac_signal"
+    $as_echo "$as_me: exit $exit_status"
+  } >&5
+  rm -f core *.core core.conftest.* &&
+    rm -f -r conftest* confdefs* conf$$* $ac_clean_files &&
+    exit $exit_status
+' 0
+for ac_signal in 1 2 13 15; do
+  trap 'ac_signal='$ac_signal'; as_fn_exit 1' $ac_signal
+done
+ac_signal=0
+
+# confdefs.h avoids OS command line length limits that DEFS can exceed.
+rm -f -r conftest* confdefs.h
+
+$as_echo "/* confdefs.h */" > confdefs.h
+
+# Predefined preprocessor variables.
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_NAME "$PACKAGE_NAME"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_VERSION "$PACKAGE_VERSION"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_STRING "$PACKAGE_STRING"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_URL "$PACKAGE_URL"
+_ACEOF
+
+
+# Let the site file select an alternate cache file if it wants to.
+# Prefer an explicitly selected file to automatically selected ones.
+ac_site_file1=NONE
+ac_site_file2=NONE
+if test -n "$CONFIG_SITE"; then
+  ac_site_file1=$CONFIG_SITE
+elif test "x$prefix" != xNONE; then
+  ac_site_file1=$prefix/share/config.site
+  ac_site_file2=$prefix/etc/config.site
+else
+  ac_site_file1=$ac_default_prefix/share/config.site
+  ac_site_file2=$ac_default_prefix/etc/config.site
+fi
+for ac_site_file in "$ac_site_file1" "$ac_site_file2"
+do
+  test "x$ac_site_file" = xNONE && continue
+  if test -r "$ac_site_file"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: loading site script $ac_site_file" >&5
+$as_echo "$as_me: loading site script $ac_site_file" >&6;}
+    sed 's/^/| /' "$ac_site_file" >&5
+    . "$ac_site_file"
+  fi
+done
+
+if test -r "$cache_file"; then
+  # Some versions of bash will fail to source /dev/null (special
+  # files actually), so we avoid doing that.
+  if test -f "$cache_file"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: loading cache $cache_file" >&5
+$as_echo "$as_me: loading cache $cache_file" >&6;}
+    case $cache_file in
+      [\\/]* | ?:[\\/]* ) . "$cache_file";;
+      *)                      . "./$cache_file";;
+    esac
+  fi
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: creating cache $cache_file" >&5
+$as_echo "$as_me: creating cache $cache_file" >&6;}
+  >$cache_file
+fi
+
+# Check that the precious variables saved in the cache have kept the same
+# value.
+ac_cache_corrupted=false
+for ac_var in $ac_precious_vars; do
+  eval ac_old_set=\$ac_cv_env_${ac_var}_set
+  eval ac_new_set=\$ac_env_${ac_var}_set
+  eval ac_old_val=\$ac_cv_env_${ac_var}_value
+  eval ac_new_val=\$ac_env_${ac_var}_value
+  case $ac_old_set,$ac_new_set in
+    set,)
+      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
+$as_echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,set)
+      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was not set in the previous run" >&5
+$as_echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,);;
+    *)
+      if test "x$ac_old_val" != "x$ac_new_val"; then
+	# differences in whitespace do not lead to failure.
+	ac_old_val_w=`echo x $ac_old_val`
+	ac_new_val_w=`echo x $ac_new_val`
+	if test "$ac_old_val_w" != "$ac_new_val_w"; then
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' has changed since the previous run:" >&5
+$as_echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
+	  ac_cache_corrupted=:
+	else
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&5
+$as_echo "$as_me: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&2;}
+	  eval $ac_var=\$ac_old_val
+	fi
+	{ $as_echo "$as_me:${as_lineno-$LINENO}:   former value:  \`$ac_old_val'" >&5
+$as_echo "$as_me:   former value:  \`$ac_old_val'" >&2;}
+	{ $as_echo "$as_me:${as_lineno-$LINENO}:   current value: \`$ac_new_val'" >&5
+$as_echo "$as_me:   current value: \`$ac_new_val'" >&2;}
+      fi;;
+  esac
+  # Pass precious variables to config.status.
+  if test "$ac_new_set" = set; then
+    case $ac_new_val in
+    *\'*) ac_arg=$ac_var=`$as_echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
+    *) ac_arg=$ac_var=$ac_new_val ;;
+    esac
+    case " $ac_configure_args " in
+      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
+      *) as_fn_append ac_configure_args " '$ac_arg'" ;;
+    esac
+  fi
+done
+if $ac_cache_corrupted; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+  { $as_echo "$as_me:${as_lineno-$LINENO}: error: changes in the environment can compromise the build" >&5
+$as_echo "$as_me: error: changes in the environment can compromise the build" >&2;}
+  as_fn_error "run \`make distclean' and/or \`rm $cache_file' and start over" "$LINENO" 5
+fi
+## -------------------- ##
+## Main body of script. ##
+## -------------------- ##
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+
+
+
+
+
+ac_aux_dir=
+for ac_dir in "$srcdir" "$srcdir/.." "$srcdir/../.."; do
+  for ac_t in install-sh install.sh shtool; do
+    if test -f "$ac_dir/$ac_t"; then
+      ac_aux_dir=$ac_dir
+      ac_install_sh="$ac_aux_dir/$ac_t -c"
+      break 2
+    fi
+  done
+done
+if test -z "$ac_aux_dir"; then
+  as_fn_error "cannot find install-sh, install.sh, or shtool in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" "$LINENO" 5
+fi
+
+# These three variables are undocumented and unsupported,
+# and are intended to be withdrawn in a future Autoconf release.
+# They can cause serious problems if a builder's source tree is in a directory
+# whose full name contains unusual characters.
+ac_config_guess="$SHELL $ac_aux_dir/config.guess"  # Please don't use this var.
+ac_config_sub="$SHELL $ac_aux_dir/config.sub"  # Please don't use this var.
+ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.
+
+
+# Make sure we can run config.sub.
+$SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
+  as_fn_error "cannot run $SHELL $ac_aux_dir/config.sub" "$LINENO" 5
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking build system type" >&5
+$as_echo_n "checking build system type... " >&6; }
+if test "${ac_cv_build+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_build_alias=$build_alias
+test "x$ac_build_alias" = x &&
+  ac_build_alias=`$SHELL "$ac_aux_dir/config.guess"`
+test "x$ac_build_alias" = x &&
+  as_fn_error "cannot guess build type; you must specify one" "$LINENO" 5
+ac_cv_build=`$SHELL "$ac_aux_dir/config.sub" $ac_build_alias` ||
+  as_fn_error "$SHELL $ac_aux_dir/config.sub $ac_build_alias failed" "$LINENO" 5
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_build" >&5
+$as_echo "$ac_cv_build" >&6; }
+case $ac_cv_build in
+*-*-*) ;;
+*) as_fn_error "invalid value of canonical build" "$LINENO" 5;;
+esac
+build=$ac_cv_build
+ac_save_IFS=$IFS; IFS='-'
+set x $ac_cv_build
+shift
+build_cpu=$1
+build_vendor=$2
+shift; shift
+# Remember, the first character of IFS is used to create $*,
+# except with old shells:
+build_os=$*
+IFS=$ac_save_IFS
+case $build_os in *\ *) build_os=`echo "$build_os" | sed 's/ /-/g'`;; esac
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking host system type" >&5
+$as_echo_n "checking host system type... " >&6; }
+if test "${ac_cv_host+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test "x$host_alias" = x; then
+  ac_cv_host=$ac_cv_build
+else
+  ac_cv_host=`$SHELL "$ac_aux_dir/config.sub" $host_alias` ||
+    as_fn_error "$SHELL $ac_aux_dir/config.sub $host_alias failed" "$LINENO" 5
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_host" >&5
+$as_echo "$ac_cv_host" >&6; }
+case $ac_cv_host in
+*-*-*) ;;
+*) as_fn_error "invalid value of canonical host" "$LINENO" 5;;
+esac
+host=$ac_cv_host
+ac_save_IFS=$IFS; IFS='-'
+set x $ac_cv_host
+shift
+host_cpu=$1
+host_vendor=$2
+shift; shift
+# Remember, the first character of IFS is used to create $*,
+# except with old shells:
+host_os=$*
+IFS=$ac_save_IFS
+case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking target system type" >&5
+$as_echo_n "checking target system type... " >&6; }
+if test "${ac_cv_target+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test "x$target_alias" = x; then
+  ac_cv_target=$ac_cv_host
+else
+  ac_cv_target=`$SHELL "$ac_aux_dir/config.sub" $target_alias` ||
+    as_fn_error "$SHELL $ac_aux_dir/config.sub $target_alias failed" "$LINENO" 5
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_target" >&5
+$as_echo "$ac_cv_target" >&6; }
+case $ac_cv_target in
+*-*-*) ;;
+*) as_fn_error "invalid value of canonical target" "$LINENO" 5;;
+esac
+target=$ac_cv_target
+ac_save_IFS=$IFS; IFS='-'
+set x $ac_cv_target
+shift
+target_cpu=$1
+target_vendor=$2
+shift; shift
+# Remember, the first character of IFS is used to create $*,
+# except with old shells:
+target_os=$*
+IFS=$ac_save_IFS
+case $target_os in *\ *) target_os=`echo "$target_os" | sed 's/ /-/g'`;; esac
+
+
+# The aliases save the names the user supplied, while $host etc.
+# will get canonicalized.
+test -n "$target_alias" &&
+  test "$program_prefix$program_suffix$program_transform_name" = \
+    NONENONEs,x,x, &&
+  program_prefix=${target_alias}-
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}gcc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CC="${ac_tool_prefix}gcc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "gcc", so it can be a program name with args.
+set dummy gcc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_CC="gcc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
+$as_echo "$ac_ct_CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+else
+  CC="$ac_cv_prog_CC"
+fi
+
+if test -z "$CC"; then
+          if test -n "$ac_tool_prefix"; then
+    # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}cc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CC="${ac_tool_prefix}cc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  fi
+fi
+if test -z "$CC"; then
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  ac_prog_rejected=no
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
+       ac_prog_rejected=yes
+       continue
+     fi
+    ac_cv_prog_CC="cc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# != 0; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
+  fi
+fi
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  for ac_prog in cl.exe
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+    test -n "$CC" && break
+  done
+fi
+if test -z "$CC"; then
+  ac_ct_CC=$CC
+  for ac_prog in cl.exe
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_CC="$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
+$as_echo "$ac_ct_CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$ac_ct_CC" && break
+done
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+fi
+
+fi
+
+
+test -z "$CC" && { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error "no acceptable C compiler found in \$PATH
+See \`config.log' for more details." "$LINENO" 5; }
+
+# Provide some information about the compiler.
+$as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler version" >&5
+set X $ac_compile
+ac_compiler=$2
+for ac_option in --version -v -V -qversion; do
+  { { ac_try="$ac_compiler $ac_option >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compiler $ac_option >&5") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    sed '10a\
+... rest of stderr output deleted ...
+         10q' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    rm -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+done
+
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files a.out a.out.dSYM a.exe b.out conftest.out"
+# Try to create an executable without -o first, disregard a.out.
+# It will help us diagnose broken compilers, and finding out an intuition
+# of exeext.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler default output file name" >&5
+$as_echo_n "checking for C compiler default output file name... " >&6; }
+ac_link_default=`$as_echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
+
+# The possible output files:
+ac_files="a.out conftest.exe conftest a.exe a_out.exe b.out conftest.*"
+
+ac_rmfiles=
+for ac_file in $ac_files
+do
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
+    * ) ac_rmfiles="$ac_rmfiles $ac_file";;
+  esac
+done
+rm -f $ac_rmfiles
+
+if { { ac_try="$ac_link_default"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link_default") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then :
+  # Autoconf-2.13 could set the ac_cv_exeext variable to `no'.
+# So ignore a value of `no', otherwise this would lead to `EXEEXT = no'
+# in a Makefile.  We should not override ac_cv_exeext if it was cached,
+# so that the user can short-circuit this test for compilers unknown to
+# Autoconf.
+for ac_file in $ac_files ''
+do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj )
+	;;
+    [ab].out )
+	# We found the default executable, but exeext='' is most
+	# certainly right.
+	break;;
+    *.* )
+	if test "${ac_cv_exeext+set}" = set && test "$ac_cv_exeext" != no;
+	then :; else
+	   ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	fi
+	# We set ac_cv_exeext here because the later test for it is not
+	# safe: cross compilers may not add the suffix if given an `-o'
+	# argument, so we may need to know it at that point already.
+	# Even if this section looks crufty: it has the advantage of
+	# actually working.
+	break;;
+    * )
+	break;;
+  esac
+done
+test "$ac_cv_exeext" = no && ac_cv_exeext=
+
+else
+  ac_file=''
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_file" >&5
+$as_echo "$ac_file" >&6; }
+if test -z "$ac_file"; then :
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ as_fn_set_status 77
+as_fn_error "C compiler cannot create executables
+See \`config.log' for more details." "$LINENO" 5; }; }
+fi
+ac_exeext=$ac_cv_exeext
+
+# Check that the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the C compiler works" >&5
+$as_echo_n "checking whether the C compiler works... " >&6; }
+# If not cross compiling, check that we can run a simple program.
+if test "$cross_compiling" != yes; then
+  if { ac_try='./$ac_file'
+  { { case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }; then
+    cross_compiling=no
+  else
+    if test "$cross_compiling" = maybe; then
+	cross_compiling=yes
+    else
+	{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error "cannot run C compiled programs.
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details." "$LINENO" 5; }
+    fi
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+
+rm -f -r a.out a.out.dSYM a.exe conftest$ac_cv_exeext b.out conftest.out
+ac_clean_files=$ac_clean_files_save
+# Check that the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are cross compiling" >&5
+$as_echo_n "checking whether we are cross compiling... " >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $cross_compiling" >&5
+$as_echo "$cross_compiling" >&6; }
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of executables" >&5
+$as_echo_n "checking for suffix of executables... " >&6; }
+if { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then :
+  # If both `conftest.exe' and `conftest' are `present' (well, observable)
+# catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
+# work properly (i.e., refer to `conftest.exe'), while it won't with
+# `rm'.
+for ac_file in conftest.exe conftest conftest.*; do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
+    *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	  break;;
+    * ) break;;
+  esac
+done
+else
+  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error "cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details." "$LINENO" 5; }
+fi
+rm -f conftest$ac_cv_exeext
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_exeext" >&5
+$as_echo "$ac_cv_exeext" >&6; }
+
+rm -f conftest.$ac_ext
+EXEEXT=$ac_cv_exeext
+ac_exeext=$EXEEXT
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of object files" >&5
+$as_echo_n "checking for suffix of object files... " >&6; }
+if test "${ac_cv_objext+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.o conftest.obj
+if { { ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compile") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then :
+  for ac_file in conftest.o conftest.obj conftest.*; do
+  test -f "$ac_file" || continue;
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM ) ;;
+    *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
+       break;;
+  esac
+done
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error "cannot compute suffix of object files: cannot compile
+See \`config.log' for more details." "$LINENO" 5; }
+fi
+rm -f conftest.$ac_cv_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_objext" >&5
+$as_echo "$ac_cv_objext" >&6; }
+OBJEXT=$ac_cv_objext
+ac_objext=$OBJEXT
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C compiler" >&5
+$as_echo_n "checking whether we are using the GNU C compiler... " >&6; }
+if test "${ac_cv_c_compiler_gnu+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_compiler_gnu=yes
+else
+  ac_compiler_gnu=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_c_compiler_gnu=$ac_compiler_gnu
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_compiler_gnu" >&5
+$as_echo "$ac_cv_c_compiler_gnu" >&6; }
+if test $ac_compiler_gnu = yes; then
+  GCC=yes
+else
+  GCC=
+fi
+ac_test_CFLAGS=${CFLAGS+set}
+ac_save_CFLAGS=$CFLAGS
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
+$as_echo_n "checking whether $CC accepts -g... " >&6; }
+if test "${ac_cv_prog_cc_g+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_save_c_werror_flag=$ac_c_werror_flag
+   ac_c_werror_flag=yes
+   ac_cv_prog_cc_g=no
+   CFLAGS="-g"
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_g=yes
+else
+  CFLAGS=""
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+
+else
+  ac_c_werror_flag=$ac_save_c_werror_flag
+	 CFLAGS="-g"
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_g=yes
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+   ac_c_werror_flag=$ac_save_c_werror_flag
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_g" >&5
+$as_echo "$ac_cv_prog_cc_g" >&6; }
+if test "$ac_test_CFLAGS" = set; then
+  CFLAGS=$ac_save_CFLAGS
+elif test $ac_cv_prog_cc_g = yes; then
+  if test "$GCC" = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-g"
+  fi
+else
+  if test "$GCC" = yes; then
+    CFLAGS="-O2"
+  else
+    CFLAGS=
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $CC option to accept ISO C89" >&5
+$as_echo_n "checking for $CC option to accept ISO C89... " >&6; }
+if test "${ac_cv_prog_cc_c89+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_prog_cc_c89=no
+ac_save_CC=$CC
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdarg.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
+struct buf { int x; };
+FILE * (*rcsopen) (struct buf *, struct stat *, int);
+static char *e (p, i)
+     char **p;
+     int i;
+{
+  return p[i];
+}
+static char *f (char * (*g) (char **, int), char **p, ...)
+{
+  char *s;
+  va_list v;
+  va_start (v,p);
+  s = g (p, va_arg (v,int));
+  va_end (v);
+  return s;
+}
+
+/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
+   function prototypes and stuff, but not '\xHH' hex character constants.
+   These don't provoke an error unfortunately, instead are silently treated
+   as 'x'.  The following induces an error, until -std is added to get
+   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
+   array size at least.  It's necessary to write '\x00'==0 to get something
+   that's true only with -std.  */
+int osf4_cc_array ['\x00' == 0 ? 1 : -1];
+
+/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters
+   inside strings and character constants.  */
+#define FOO(x) 'x'
+int xlc6_cc_array[FOO(a) == 'x' ? 1 : -1];
+
+int test (int i, double x);
+struct s1 {int (*f) (int a);};
+struct s2 {int (*f) (double a);};
+int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
+int argc;
+char **argv;
+int
+main ()
+{
+return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
+  ;
+  return 0;
+}
+_ACEOF
+for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std \
+	-Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
+do
+  CC="$ac_save_CC $ac_arg"
+  if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_c89=$ac_arg
+fi
+rm -f core conftest.err conftest.$ac_objext
+  test "x$ac_cv_prog_cc_c89" != "xno" && break
+done
+rm -f conftest.$ac_ext
+CC=$ac_save_CC
+
+fi
+# AC_CACHE_VAL
+case "x$ac_cv_prog_cc_c89" in
+  x)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
+$as_echo "none needed" >&6; } ;;
+  xno)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
+$as_echo "unsupported" >&6; } ;;
+  *)
+    CC="$CC $ac_cv_prog_cc_c89"
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c89" >&5
+$as_echo "$ac_cv_prog_cc_c89" >&6; } ;;
+esac
+if test "x$ac_cv_prog_cc_c89" != xno; then :
+
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing strerror" >&5
+$as_echo_n "checking for library containing strerror... " >&6; }
+if test "${ac_cv_search_strerror+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_func_search_save_LIBS=$LIBS
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char strerror ();
+int
+main ()
+{
+return strerror ();
+  ;
+  return 0;
+}
+_ACEOF
+for ac_lib in '' cposix; do
+  if test -z "$ac_lib"; then
+    ac_res="none required"
+  else
+    ac_res=-l$ac_lib
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+  fi
+  if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_search_strerror=$ac_res
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext
+  if test "${ac_cv_search_strerror+set}" = set; then :
+  break
+fi
+done
+if test "${ac_cv_search_strerror+set}" = set; then :
+
+else
+  ac_cv_search_strerror=no
+fi
+rm conftest.$ac_ext
+LIBS=$ac_func_search_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_strerror" >&5
+$as_echo "$ac_cv_search_strerror" >&6; }
+ac_res=$ac_cv_search_strerror
+if test "$ac_res" != no; then :
+  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
+
+fi
+
+
+am__api_version='1.11'
+
+# Find a good install program.  We prefer a C program (faster),
+# so one script is as good as another.  But avoid the broken or
+# incompatible versions:
+# SysV /etc/install, /usr/sbin/install
+# SunOS /usr/etc/install
+# IRIX /sbin/install
+# AIX /bin/install
+# AmigaOS /C/install, which installs bootblocks on floppy discs
+# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
+# AFS /usr/afsws/bin/install, which mishandles nonexistent args
+# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# OS/2's system install, which has a completely different semantic
+# ./install, which can be erroneously created by make from ./install.sh.
+# Reject install programs that cannot install multiple files.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a BSD-compatible install" >&5
+$as_echo_n "checking for a BSD-compatible install... " >&6; }
+if test -z "$INSTALL"; then
+if test "${ac_cv_path_install+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    # Account for people who put trailing slashes in PATH elements.
+case $as_dir/ in #((
+  ./ | .// | /[cC]/* | \
+  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
+  ?:[\\/]os2[\\/]install[\\/]* | ?:[\\/]OS2[\\/]INSTALL[\\/]* | \
+  /usr/ucb/* ) ;;
+  *)
+    # OSF1 and SCO ODT 3.0 have their own names for install.
+    # Don't use installbsd from OSF since it installs stuff as root
+    # by default.
+    for ac_prog in ginstall scoinst install; do
+      for ac_exec_ext in '' $ac_executable_extensions; do
+	if { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; }; then
+	  if test $ac_prog = install &&
+	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # AIX install.  It has an incompatible calling convention.
+	    :
+	  elif test $ac_prog = install &&
+	    grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # program-specific install script used by HP pwplus--don't use.
+	    :
+	  else
+	    rm -rf conftest.one conftest.two conftest.dir
+	    echo one > conftest.one
+	    echo two > conftest.two
+	    mkdir conftest.dir
+	    if "$as_dir/$ac_prog$ac_exec_ext" -c conftest.one conftest.two "`pwd`/conftest.dir" &&
+	      test -s conftest.one && test -s conftest.two &&
+	      test -s conftest.dir/conftest.one &&
+	      test -s conftest.dir/conftest.two
+	    then
+	      ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
+	      break 3
+	    fi
+	  fi
+	fi
+      done
+    done
+    ;;
+esac
+
+  done
+IFS=$as_save_IFS
+
+rm -rf conftest.one conftest.two conftest.dir
+
+fi
+  if test "${ac_cv_path_install+set}" = set; then
+    INSTALL=$ac_cv_path_install
+  else
+    # As a last resort, use the slow shell script.  Don't cache a
+    # value for INSTALL within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the value is a relative name.
+    INSTALL=$ac_install_sh
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $INSTALL" >&5
+$as_echo "$INSTALL" >&6; }
+
+# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
+# It thinks the first close brace ends the variable substitution.
+test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
+
+test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
+
+test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether build environment is sane" >&5
+$as_echo_n "checking whether build environment is sane... " >&6; }
+# Just in case
+sleep 1
+echo timestamp > conftest.file
+# Reject unsafe characters in $srcdir or the absolute working directory
+# name.  Accept space and tab only in the latter.
+am_lf='
+'
+case `pwd` in
+  *[\\\"\#\$\&\'\`$am_lf]*)
+    as_fn_error "unsafe absolute working directory name" "$LINENO" 5;;
+esac
+case $srcdir in
+  *[\\\"\#\$\&\'\`$am_lf\ \	]*)
+    as_fn_error "unsafe srcdir value: \`$srcdir'" "$LINENO" 5;;
+esac
+
+# Do `set' in a subshell so we don't clobber the current shell's
+# arguments.  Must try -L first in case configure is actually a
+# symlink; some systems play weird games with the mod time of symlinks
+# (eg FreeBSD returns the mod time of the symlink's containing
+# directory).
+if (
+   set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
+   if test "$*" = "X"; then
+      # -L didn't work.
+      set X `ls -t "$srcdir/configure" conftest.file`
+   fi
+   rm -f conftest.file
+   if test "$*" != "X $srcdir/configure conftest.file" \
+      && test "$*" != "X conftest.file $srcdir/configure"; then
+
+      # If neither matched, then we have a broken ls.  This can happen
+      # if, for instance, CONFIG_SHELL is bash and it inherits a
+      # broken ls alias from the environment.  This has actually
+      # happened.  Such a system could not be considered "sane".
+      as_fn_error "ls -t appears to fail.  Make sure there is not a broken
+alias in your environment" "$LINENO" 5
+   fi
+
+   test "$2" = conftest.file
+   )
+then
+   # Ok.
+   :
+else
+   as_fn_error "newly created file is older than distributed files!
+Check your system clock" "$LINENO" 5
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+test "$program_prefix" != NONE &&
+  program_transform_name="s&^&$program_prefix&;$program_transform_name"
+# Use a double $ so make ignores it.
+test "$program_suffix" != NONE &&
+  program_transform_name="s&\$&$program_suffix&;$program_transform_name"
+# Double any \ or $.
+# By default was `s,x,x', remove it if useless.
+ac_script='s/[\\$]/&&/g;s/;s,x,x,$//'
+program_transform_name=`$as_echo "$program_transform_name" | sed "$ac_script"`
+
+# expand $ac_aux_dir to an absolute path
+am_aux_dir=`cd $ac_aux_dir && pwd`
+
+if test x"${MISSING+set}" != xset; then
+  case $am_aux_dir in
+  *\ * | *\	*)
+    MISSING="\${SHELL} \"$am_aux_dir/missing\"" ;;
+  *)
+    MISSING="\${SHELL} $am_aux_dir/missing" ;;
+  esac
+fi
+# Use eval to expand $SHELL
+if eval "$MISSING --run true"; then
+  am_missing_run="$MISSING --run "
+else
+  am_missing_run=
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`missing' script is too old or missing" >&5
+$as_echo "$as_me: WARNING: \`missing' script is too old or missing" >&2;}
+fi
+
+if test x"${install_sh}" != xset; then
+  case $am_aux_dir in
+  *\ * | *\	*)
+    install_sh="\${SHELL} '$am_aux_dir/install-sh'" ;;
+  *)
+    install_sh="\${SHELL} $am_aux_dir/install-sh"
+  esac
+fi
+
+# Installed binaries are usually stripped using `strip' when the user
+# run `make install-strip'.  However `strip' might not be the right
+# tool to use in cross-compilation environments, therefore Automake
+# will honor the `STRIP' environment variable to overrule this program.
+if test "$cross_compiling" != no; then
+  if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
+set dummy ${ac_tool_prefix}strip; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_STRIP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$STRIP"; then
+  ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_STRIP="${ac_tool_prefix}strip"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+STRIP=$ac_cv_prog_STRIP
+if test -n "$STRIP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $STRIP" >&5
+$as_echo "$STRIP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_STRIP"; then
+  ac_ct_STRIP=$STRIP
+  # Extract the first word of "strip", so it can be a program name with args.
+set dummy strip; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_STRIP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_STRIP"; then
+  ac_cv_prog_ac_ct_STRIP="$ac_ct_STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_STRIP="strip"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
+if test -n "$ac_ct_STRIP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_STRIP" >&5
+$as_echo "$ac_ct_STRIP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_STRIP" = x; then
+    STRIP=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    STRIP=$ac_ct_STRIP
+  fi
+else
+  STRIP="$ac_cv_prog_STRIP"
+fi
+
+fi
+INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a thread-safe mkdir -p" >&5
+$as_echo_n "checking for a thread-safe mkdir -p... " >&6; }
+if test -z "$MKDIR_P"; then
+  if test "${ac_cv_path_mkdir+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/opt/sfw/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in mkdir gmkdir; do
+	 for ac_exec_ext in '' $ac_executable_extensions; do
+	   { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; } || continue
+	   case `"$as_dir/$ac_prog$ac_exec_ext" --version 2>&1` in #(
+	     'mkdir (GNU coreutils) '* | \
+	     'mkdir (coreutils) '* | \
+	     'mkdir (fileutils) '4.1*)
+	       ac_cv_path_mkdir=$as_dir/$ac_prog$ac_exec_ext
+	       break 3;;
+	   esac
+	 done
+       done
+  done
+IFS=$as_save_IFS
+
+fi
+
+  if test "${ac_cv_path_mkdir+set}" = set; then
+    MKDIR_P="$ac_cv_path_mkdir -p"
+  else
+    # As a last resort, use the slow shell script.  Don't cache a
+    # value for MKDIR_P within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the value is a relative name.
+    test -d ./--version && rmdir ./--version
+    MKDIR_P="$ac_install_sh -d"
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $MKDIR_P" >&5
+$as_echo "$MKDIR_P" >&6; }
+
+mkdir_p="$MKDIR_P"
+case $mkdir_p in
+  [\\/$]* | ?:[\\/]*) ;;
+  */*) mkdir_p="\$(top_builddir)/$mkdir_p" ;;
+esac
+
+for ac_prog in gawk mawk nawk awk
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_AWK+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$AWK"; then
+  ac_cv_prog_AWK="$AWK" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_AWK="$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+AWK=$ac_cv_prog_AWK
+if test -n "$AWK"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $AWK" >&5
+$as_echo "$AWK" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$AWK" && break
+done
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether ${MAKE-make} sets \$(MAKE)" >&5
+$as_echo_n "checking whether ${MAKE-make} sets \$(MAKE)... " >&6; }
+set x ${MAKE-make}
+ac_make=`$as_echo "$2" | sed 's/+/p/g; s/[^a-zA-Z0-9_]/_/g'`
+if { as_var=ac_cv_prog_make_${ac_make}_set; eval "test \"\${$as_var+set}\" = set"; }; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.make <<\_ACEOF
+SHELL = /bin/sh
+all:
+	@echo '@@@%%%=$(MAKE)=@@@%%%'
+_ACEOF
+# GNU make sometimes prints "make[1]: Entering...", which would confuse us.
+case `${MAKE-make} -f conftest.make 2>/dev/null` in
+  *@@@%%%=?*=@@@%%%*)
+    eval ac_cv_prog_make_${ac_make}_set=yes;;
+  *)
+    eval ac_cv_prog_make_${ac_make}_set=no;;
+esac
+rm -f conftest.make
+fi
+if eval test \$ac_cv_prog_make_${ac_make}_set = yes; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+  SET_MAKE=
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+  SET_MAKE="MAKE=${MAKE-make}"
+fi
+
+rm -rf .tst 2>/dev/null
+mkdir .tst 2>/dev/null
+if test -d .tst; then
+  am__leading_dot=.
+else
+  am__leading_dot=_
+fi
+rmdir .tst 2>/dev/null
+
+DEPDIR="${am__leading_dot}deps"
+
+ac_config_commands="$ac_config_commands depfiles"
+
+
+am_make=${MAKE-make}
+cat > confinc << 'END'
+am__doit:
+	@echo this is the am__doit target
+.PHONY: am__doit
+END
+# If we don't find an include directive, just comment out the code.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for style of include used by $am_make" >&5
+$as_echo_n "checking for style of include used by $am_make... " >&6; }
+am__include="#"
+am__quote=
+_am_result=none
+# First try GNU make style include.
+echo "include confinc" > confmf
+# Ignore all kinds of additional output from `make'.
+case `$am_make -s -f confmf 2> /dev/null` in #(
+*the\ am__doit\ target*)
+  am__include=include
+  am__quote=
+  _am_result=GNU
+  ;;
+esac
+# Now try BSD make style include.
+if test "$am__include" = "#"; then
+   echo '.include "confinc"' > confmf
+   case `$am_make -s -f confmf 2> /dev/null` in #(
+   *the\ am__doit\ target*)
+     am__include=.include
+     am__quote="\""
+     _am_result=BSD
+     ;;
+   esac
+fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $_am_result" >&5
+$as_echo "$_am_result" >&6; }
+rm -f confinc confmf
+
+# Check whether --enable-dependency-tracking was given.
+if test "${enable_dependency_tracking+set}" = set; then :
+  enableval=$enable_dependency_tracking;
+fi
+
+if test "x$enable_dependency_tracking" != xno; then
+  am_depcomp="$ac_aux_dir/depcomp"
+  AMDEPBACKSLASH='\'
+fi
+ if test "x$enable_dependency_tracking" != xno; then
+  AMDEP_TRUE=
+  AMDEP_FALSE='#'
+else
+  AMDEP_TRUE='#'
+  AMDEP_FALSE=
+fi
+
+
+if test "`cd $srcdir && pwd`" != "`pwd`"; then
+  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output
+  # is not polluted with repeated "-I."
+  am__isrc=' -I$(srcdir)'
+  # test to see if srcdir already configured
+  if test -f $srcdir/config.status; then
+    as_fn_error "source directory already configured; run \"make distclean\" there first" "$LINENO" 5
+  fi
+fi
+
+# test whether we have cygpath
+if test -z "$CYGPATH_W"; then
+  if (cygpath --version) >/dev/null 2>/dev/null; then
+    CYGPATH_W='cygpath -w'
+  else
+    CYGPATH_W=echo
+  fi
+fi
+
+
+# Define the identity of the package.
+ PACKAGE='binutils'
+ VERSION='2.26'
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE "$PACKAGE"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define VERSION "$VERSION"
+_ACEOF
+
+# Some tools Automake needs.
+
+ACLOCAL=${ACLOCAL-"${am_missing_run}aclocal-${am__api_version}"}
+
+
+AUTOCONF=${AUTOCONF-"${am_missing_run}autoconf"}
+
+
+AUTOMAKE=${AUTOMAKE-"${am_missing_run}automake-${am__api_version}"}
+
+
+AUTOHEADER=${AUTOHEADER-"${am_missing_run}autoheader"}
+
+
+MAKEINFO=${MAKEINFO-"${am_missing_run}makeinfo"}
+
+# We need awk for the "check" target.  The system "awk" is bad on
+# some platforms.
+# Always define AMTAR for backward compatibility.
+
+AMTAR=${AMTAR-"${am_missing_run}tar"}
+
+am__tar='${AMTAR} chof - "$$tardir"'; am__untar='${AMTAR} xf -'
+
+
+
+
+depcc="$CC"   am_compiler_list=
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking dependency style of $depcc" >&5
+$as_echo_n "checking dependency style of $depcc... " >&6; }
+if test "${am_cv_CC_dependencies_compiler_type+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
+  # We make a subdir and do the tests there.  Otherwise we can end up
+  # making bogus files that we don't know about and never remove.  For
+  # instance it was reported that on HP-UX the gcc test will end up
+  # making a dummy file named `D' -- because `-MD' means `put the output
+  # in D'.
+  mkdir conftest.dir
+  # Copy depcomp to subdir because otherwise we won't find it if we're
+  # using a relative directory.
+  cp "$am_depcomp" conftest.dir
+  cd conftest.dir
+  # We will build objects and dependencies in a subdirectory because
+  # it helps to detect inapplicable dependency modes.  For instance
+  # both Tru64's cc and ICC support -MD to output dependencies as a
+  # side effect of compilation, but ICC will put the dependencies in
+  # the current directory while Tru64 will put them in the object
+  # directory.
+  mkdir sub
+
+  am_cv_CC_dependencies_compiler_type=none
+  if test "$am_compiler_list" = ""; then
+     am_compiler_list=`sed -n 's/^#*\([a-zA-Z0-9]*\))$/\1/p' < ./depcomp`
+  fi
+  am__universal=false
+  case " $depcc " in #(
+     *\ -arch\ *\ -arch\ *) am__universal=true ;;
+     esac
+
+  for depmode in $am_compiler_list; do
+    # Setup a source with many dependencies, because some compilers
+    # like to wrap large dependency lists on column 80 (with \), and
+    # we should not choose a depcomp mode which is confused by this.
+    #
+    # We need to recreate these files for each test, as the compiler may
+    # overwrite some of them when testing with obscure command lines.
+    # This happens at least with the AIX C compiler.
+    : > sub/conftest.c
+    for i in 1 2 3 4 5 6; do
+      echo '#include "conftst'$i'.h"' >> sub/conftest.c
+      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
+      # Solaris 8's {/usr,}/bin/sh.
+      touch sub/conftst$i.h
+    done
+    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
+
+    # We check with `-c' and `-o' for the sake of the "dashmstdout"
+    # mode.  It turns out that the SunPro C++ compiler does not properly
+    # handle `-M -o', and we need to detect this.  Also, some Intel
+    # versions had trouble with output in subdirs
+    am__obj=sub/conftest.${OBJEXT-o}
+    am__minus_obj="-o $am__obj"
+    case $depmode in
+    gcc)
+      # This depmode causes a compiler race in universal mode.
+      test "$am__universal" = false || continue
+      ;;
+    nosideeffect)
+      # after this tag, mechanisms are not by side-effect, so they'll
+      # only be used when explicitly requested
+      if test "x$enable_dependency_tracking" = xyes; then
+	continue
+      else
+	break
+      fi
+      ;;
+    msvisualcpp | msvcmsys)
+      # This compiler won't grok `-c -o', but also, the minuso test has
+      # not run yet.  These depmodes are late enough in the game, and
+      # so weak that their functioning should not be impacted.
+      am__obj=conftest.${OBJEXT-o}
+      am__minus_obj=
+      ;;
+    none) break ;;
+    esac
+    if depmode=$depmode \
+       source=sub/conftest.c object=$am__obj \
+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
+       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \
+         >/dev/null 2>conftest.err &&
+       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&
+       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
+      # icc doesn't choke on unknown options, it will just issue warnings
+      # or remarks (even with -Werror).  So we grep stderr for any message
+      # that says an option was ignored or not supported.
+      # When given -MP, icc 7.0 and 7.1 complain thusly:
+      #   icc: Command line warning: ignoring option '-M'; no argument required
+      # The diagnosis changed in icc 8.0:
+      #   icc: Command line remark: option '-MP' not supported
+      if (grep 'ignoring option' conftest.err ||
+          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else
+        am_cv_CC_dependencies_compiler_type=$depmode
+        break
+      fi
+    fi
+  done
+
+  cd ..
+  rm -rf conftest.dir
+else
+  am_cv_CC_dependencies_compiler_type=none
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $am_cv_CC_dependencies_compiler_type" >&5
+$as_echo "$am_cv_CC_dependencies_compiler_type" >&6; }
+CCDEPMODE=depmode=$am_cv_CC_dependencies_compiler_type
+
+ if
+  test "x$enable_dependency_tracking" != xno \
+  && test "$am_cv_CC_dependencies_compiler_type" = gcc3; then
+  am__fastdepCC_TRUE=
+  am__fastdepCC_FALSE='#'
+else
+  am__fastdepCC_TRUE='#'
+  am__fastdepCC_FALSE=
+fi
+
+
+
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}gcc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CC="${ac_tool_prefix}gcc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "gcc", so it can be a program name with args.
+set dummy gcc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_CC="gcc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
+$as_echo "$ac_ct_CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+else
+  CC="$ac_cv_prog_CC"
+fi
+
+if test -z "$CC"; then
+          if test -n "$ac_tool_prefix"; then
+    # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}cc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CC="${ac_tool_prefix}cc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  fi
+fi
+if test -z "$CC"; then
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  ac_prog_rejected=no
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
+       ac_prog_rejected=yes
+       continue
+     fi
+    ac_cv_prog_CC="cc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# != 0; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
+  fi
+fi
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  for ac_prog in cl.exe
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+    test -n "$CC" && break
+  done
+fi
+if test -z "$CC"; then
+  ac_ct_CC=$CC
+  for ac_prog in cl.exe
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_CC="$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
+$as_echo "$ac_ct_CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$ac_ct_CC" && break
+done
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+fi
+
+fi
+
+
+test -z "$CC" && { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error "no acceptable C compiler found in \$PATH
+See \`config.log' for more details." "$LINENO" 5; }
+
+# Provide some information about the compiler.
+$as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler version" >&5
+set X $ac_compile
+ac_compiler=$2
+for ac_option in --version -v -V -qversion; do
+  { { ac_try="$ac_compiler $ac_option >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compiler $ac_option >&5") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    sed '10a\
+... rest of stderr output deleted ...
+         10q' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    rm -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+done
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C compiler" >&5
+$as_echo_n "checking whether we are using the GNU C compiler... " >&6; }
+if test "${ac_cv_c_compiler_gnu+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_compiler_gnu=yes
+else
+  ac_compiler_gnu=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_c_compiler_gnu=$ac_compiler_gnu
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_compiler_gnu" >&5
+$as_echo "$ac_cv_c_compiler_gnu" >&6; }
+if test $ac_compiler_gnu = yes; then
+  GCC=yes
+else
+  GCC=
+fi
+ac_test_CFLAGS=${CFLAGS+set}
+ac_save_CFLAGS=$CFLAGS
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
+$as_echo_n "checking whether $CC accepts -g... " >&6; }
+if test "${ac_cv_prog_cc_g+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_save_c_werror_flag=$ac_c_werror_flag
+   ac_c_werror_flag=yes
+   ac_cv_prog_cc_g=no
+   CFLAGS="-g"
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_g=yes
+else
+  CFLAGS=""
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+
+else
+  ac_c_werror_flag=$ac_save_c_werror_flag
+	 CFLAGS="-g"
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_g=yes
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+   ac_c_werror_flag=$ac_save_c_werror_flag
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_g" >&5
+$as_echo "$ac_cv_prog_cc_g" >&6; }
+if test "$ac_test_CFLAGS" = set; then
+  CFLAGS=$ac_save_CFLAGS
+elif test $ac_cv_prog_cc_g = yes; then
+  if test "$GCC" = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-g"
+  fi
+else
+  if test "$GCC" = yes; then
+    CFLAGS="-O2"
+  else
+    CFLAGS=
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $CC option to accept ISO C89" >&5
+$as_echo_n "checking for $CC option to accept ISO C89... " >&6; }
+if test "${ac_cv_prog_cc_c89+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_prog_cc_c89=no
+ac_save_CC=$CC
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdarg.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
+struct buf { int x; };
+FILE * (*rcsopen) (struct buf *, struct stat *, int);
+static char *e (p, i)
+     char **p;
+     int i;
+{
+  return p[i];
+}
+static char *f (char * (*g) (char **, int), char **p, ...)
+{
+  char *s;
+  va_list v;
+  va_start (v,p);
+  s = g (p, va_arg (v,int));
+  va_end (v);
+  return s;
+}
+
+/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
+   function prototypes and stuff, but not '\xHH' hex character constants.
+   These don't provoke an error unfortunately, instead are silently treated
+   as 'x'.  The following induces an error, until -std is added to get
+   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
+   array size at least.  It's necessary to write '\x00'==0 to get something
+   that's true only with -std.  */
+int osf4_cc_array ['\x00' == 0 ? 1 : -1];
+
+/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters
+   inside strings and character constants.  */
+#define FOO(x) 'x'
+int xlc6_cc_array[FOO(a) == 'x' ? 1 : -1];
+
+int test (int i, double x);
+struct s1 {int (*f) (int a);};
+struct s2 {int (*f) (double a);};
+int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
+int argc;
+char **argv;
+int
+main ()
+{
+return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
+  ;
+  return 0;
+}
+_ACEOF
+for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std \
+	-Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
+do
+  CC="$ac_save_CC $ac_arg"
+  if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_c89=$ac_arg
+fi
+rm -f core conftest.err conftest.$ac_objext
+  test "x$ac_cv_prog_cc_c89" != "xno" && break
+done
+rm -f conftest.$ac_ext
+CC=$ac_save_CC
+
+fi
+# AC_CACHE_VAL
+case "x$ac_cv_prog_cc_c89" in
+  x)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
+$as_echo "none needed" >&6; } ;;
+  xno)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
+$as_echo "unsupported" >&6; } ;;
+  *)
+    CC="$CC $ac_cv_prog_cc_c89"
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c89" >&5
+$as_echo "$ac_cv_prog_cc_c89" >&6; } ;;
+esac
+if test "x$ac_cv_prog_cc_c89" != xno; then :
+
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to run the C preprocessor" >&5
+$as_echo_n "checking how to run the C preprocessor... " >&6; }
+# On Suns, sometimes $CPP names a directory.
+if test -n "$CPP" && test -d "$CPP"; then
+  CPP=
+fi
+if test -z "$CPP"; then
+  if test "${ac_cv_prog_CPP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+      # Double quotes because CPP needs to be expanded
+    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
+    do
+      ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+
+else
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+  # Broken: success on invalid input.
+continue
+else
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then :
+  break
+fi
+
+    done
+    ac_cv_prog_CPP=$CPP
+
+fi
+  CPP=$ac_cv_prog_CPP
+else
+  ac_cv_prog_CPP=$CPP
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $CPP" >&5
+$as_echo "$CPP" >&6; }
+ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+
+else
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+  # Broken: success on invalid input.
+continue
+else
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then :
+
+else
+  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error "C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details." "$LINENO" 5; }
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for grep that handles long lines and -e" >&5
+$as_echo_n "checking for grep that handles long lines and -e... " >&6; }
+if test "${ac_cv_path_GREP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -z "$GREP"; then
+  ac_path_GREP_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in grep ggrep; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
+      { test -f "$ac_path_GREP" && $as_test_x "$ac_path_GREP"; } || continue
+# Check for GNU ac_path_GREP and select it if it is found.
+  # Check for GNU $ac_path_GREP
+case `"$ac_path_GREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_GREP="$ac_path_GREP" ac_path_GREP_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo 'GREP' >> "conftest.nl"
+    "$ac_path_GREP" -e 'GREP$' -e '-(cannot match)-' < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
+    if test $ac_count -gt ${ac_path_GREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_GREP="$ac_path_GREP"
+      ac_path_GREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_GREP_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_GREP"; then
+    as_fn_error "no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+  fi
+else
+  ac_cv_path_GREP=$GREP
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_GREP" >&5
+$as_echo "$ac_cv_path_GREP" >&6; }
+ GREP="$ac_cv_path_GREP"
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for egrep" >&5
+$as_echo_n "checking for egrep... " >&6; }
+if test "${ac_cv_path_EGREP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if echo a | $GREP -E '(a|b)' >/dev/null 2>&1
+   then ac_cv_path_EGREP="$GREP -E"
+   else
+     if test -z "$EGREP"; then
+  ac_path_EGREP_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in egrep; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
+      { test -f "$ac_path_EGREP" && $as_test_x "$ac_path_EGREP"; } || continue
+# Check for GNU ac_path_EGREP and select it if it is found.
+  # Check for GNU $ac_path_EGREP
+case `"$ac_path_EGREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_EGREP="$ac_path_EGREP" ac_path_EGREP_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo 'EGREP' >> "conftest.nl"
+    "$ac_path_EGREP" 'EGREP$' < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
+    if test $ac_count -gt ${ac_path_EGREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_EGREP="$ac_path_EGREP"
+      ac_path_EGREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_EGREP_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_EGREP"; then
+    as_fn_error "no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+  fi
+else
+  ac_cv_path_EGREP=$EGREP
+fi
+
+   fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_EGREP" >&5
+$as_echo "$ac_cv_path_EGREP" >&6; }
+ EGREP="$ac_cv_path_EGREP"
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ANSI C header files" >&5
+$as_echo_n "checking for ANSI C header files... " >&6; }
+if test "${ac_cv_header_stdc+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <float.h>
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_header_stdc=yes
+else
+  ac_cv_header_stdc=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+if test $ac_cv_header_stdc = yes; then
+  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <string.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "memchr" >/dev/null 2>&1; then :
+
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdlib.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "free" >/dev/null 2>&1; then :
+
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
+  if test "$cross_compiling" = yes; then :
+  :
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ctype.h>
+#include <stdlib.h>
+#if ((' ' & 0x0FF) == 0x020)
+# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
+# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
+#else
+# define ISLOWER(c) \
+		   (('a' <= (c) && (c) <= 'i') \
+		     || ('j' <= (c) && (c) <= 'r') \
+		     || ('s' <= (c) && (c) <= 'z'))
+# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
+#endif
+
+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 256; i++)
+    if (XOR (islower (i), ISLOWER (i))
+	|| toupper (i) != TOUPPER (i))
+      return 2;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+
+else
+  ac_cv_header_stdc=no
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_header_stdc" >&5
+$as_echo "$ac_cv_header_stdc" >&6; }
+if test $ac_cv_header_stdc = yes; then
+
+$as_echo "#define STDC_HEADERS 1" >>confdefs.h
+
+fi
+
+# On IRIX 5.3, sys/types and inttypes.h are conflicting.
+for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
+		  inttypes.h stdint.h unistd.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default
+"
+eval as_val=\$$as_ac_Header
+   if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+  ac_fn_c_check_header_mongrel "$LINENO" "minix/config.h" "ac_cv_header_minix_config_h" "$ac_includes_default"
+if test "x$ac_cv_header_minix_config_h" = x""yes; then :
+  MINIX=yes
+else
+  MINIX=
+fi
+
+
+  if test "$MINIX" = yes; then
+
+$as_echo "#define _POSIX_SOURCE 1" >>confdefs.h
+
+
+$as_echo "#define _POSIX_1_SOURCE 2" >>confdefs.h
+
+
+$as_echo "#define _MINIX 1" >>confdefs.h
+
+  fi
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether it is safe to define __EXTENSIONS__" >&5
+$as_echo_n "checking whether it is safe to define __EXTENSIONS__... " >&6; }
+if test "${ac_cv_safe_to_define___extensions__+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#	  define __EXTENSIONS__ 1
+	  $ac_includes_default
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_safe_to_define___extensions__=yes
+else
+  ac_cv_safe_to_define___extensions__=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_safe_to_define___extensions__" >&5
+$as_echo "$ac_cv_safe_to_define___extensions__" >&6; }
+  test $ac_cv_safe_to_define___extensions__ = yes &&
+    $as_echo "#define __EXTENSIONS__ 1" >>confdefs.h
+
+  $as_echo "#define _ALL_SOURCE 1" >>confdefs.h
+
+  $as_echo "#define _GNU_SOURCE 1" >>confdefs.h
+
+  $as_echo "#define _POSIX_PTHREAD_SEMANTICS 1" >>confdefs.h
+
+  $as_echo "#define _TANDEM_SOURCE 1" >>confdefs.h
+
+
+
+
+
+case `pwd` in
+  *\ * | *\	*)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Libtool does not cope well with whitespace in \`pwd\`" >&5
+$as_echo "$as_me: WARNING: Libtool does not cope well with whitespace in \`pwd\`" >&2;} ;;
+esac
+
+
+
+macro_version='2.2.7a'
+macro_revision='1.3134'
+
+
+
+
+
+
+
+
+
+
+
+
+
+ltmain="$ac_aux_dir/ltmain.sh"
+
+# Backslashify metacharacters that are still active within
+# double-quoted strings.
+sed_quote_subst='s/\(["`$\\]\)/\\\1/g'
+
+# Same as above, but do not quote variable references.
+double_quote_subst='s/\(["`\\]\)/\\\1/g'
+
+# Sed substitution to delay expansion of an escaped shell variable in a
+# double_quote_subst'ed string.
+delay_variable_subst='s/\\\\\\\\\\\$/\\\\\\$/g'
+
+# Sed substitution to delay expansion of an escaped single quote.
+delay_single_quote_subst='s/'\''/'\'\\\\\\\'\''/g'
+
+# Sed substitution to avoid accidental globbing in evaled expressions
+no_glob_subst='s/\*/\\\*/g'
+
+ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO
+ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to print strings" >&5
+$as_echo_n "checking how to print strings... " >&6; }
+# Test print first, because it will be a builtin if present.
+if test "X`print -r -- -n 2>/dev/null`" = X-n && \
+   test "X`print -r -- $ECHO 2>/dev/null`" = "X$ECHO"; then
+  ECHO='print -r --'
+elif test "X`printf %s $ECHO 2>/dev/null`" = "X$ECHO"; then
+  ECHO='printf %s\n'
+else
+  # Use this function as a fallback that always works.
+  func_fallback_echo ()
+  {
+    eval 'cat <<_LTECHO_EOF
+$1
+_LTECHO_EOF'
+  }
+  ECHO='func_fallback_echo'
+fi
+
+# func_echo_all arg...
+# Invoke $ECHO with all args, space-separated.
+func_echo_all ()
+{
+    $ECHO ""
+}
+
+case "$ECHO" in
+  printf*) { $as_echo "$as_me:${as_lineno-$LINENO}: result: printf" >&5
+$as_echo "printf" >&6; } ;;
+  print*) { $as_echo "$as_me:${as_lineno-$LINENO}: result: print -r" >&5
+$as_echo "print -r" >&6; } ;;
+  *) { $as_echo "$as_me:${as_lineno-$LINENO}: result: cat" >&5
+$as_echo "cat" >&6; } ;;
+esac
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a sed that does not truncate output" >&5
+$as_echo_n "checking for a sed that does not truncate output... " >&6; }
+if test "${ac_cv_path_SED+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+            ac_script=s/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb/
+     for ac_i in 1 2 3 4 5 6 7; do
+       ac_script="$ac_script$as_nl$ac_script"
+     done
+     echo "$ac_script" 2>/dev/null | sed 99q >conftest.sed
+     { ac_script=; unset ac_script;}
+     if test -z "$SED"; then
+  ac_path_SED_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in sed gsed; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_SED="$as_dir/$ac_prog$ac_exec_ext"
+      { test -f "$ac_path_SED" && $as_test_x "$ac_path_SED"; } || continue
+# Check for GNU ac_path_SED and select it if it is found.
+  # Check for GNU $ac_path_SED
+case `"$ac_path_SED" --version 2>&1` in
+*GNU*)
+  ac_cv_path_SED="$ac_path_SED" ac_path_SED_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo '' >> "conftest.nl"
+    "$ac_path_SED" -f conftest.sed < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
+    if test $ac_count -gt ${ac_path_SED_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_SED="$ac_path_SED"
+      ac_path_SED_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_SED_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_SED"; then
+    as_fn_error "no acceptable sed could be found in \$PATH" "$LINENO" 5
+  fi
+else
+  ac_cv_path_SED=$SED
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_SED" >&5
+$as_echo "$ac_cv_path_SED" >&6; }
+ SED="$ac_cv_path_SED"
+  rm -f conftest.sed
+
+test -z "$SED" && SED=sed
+Xsed="$SED -e 1s/^X//"
+
+
+
+
+
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for fgrep" >&5
+$as_echo_n "checking for fgrep... " >&6; }
+if test "${ac_cv_path_FGREP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if echo 'ab*c' | $GREP -F 'ab*c' >/dev/null 2>&1
+   then ac_cv_path_FGREP="$GREP -F"
+   else
+     if test -z "$FGREP"; then
+  ac_path_FGREP_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in fgrep; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_FGREP="$as_dir/$ac_prog$ac_exec_ext"
+      { test -f "$ac_path_FGREP" && $as_test_x "$ac_path_FGREP"; } || continue
+# Check for GNU ac_path_FGREP and select it if it is found.
+  # Check for GNU $ac_path_FGREP
+case `"$ac_path_FGREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_FGREP="$ac_path_FGREP" ac_path_FGREP_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo 'FGREP' >> "conftest.nl"
+    "$ac_path_FGREP" FGREP < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
+    if test $ac_count -gt ${ac_path_FGREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_FGREP="$ac_path_FGREP"
+      ac_path_FGREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_FGREP_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_FGREP"; then
+    as_fn_error "no acceptable fgrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+  fi
+else
+  ac_cv_path_FGREP=$FGREP
+fi
+
+   fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_FGREP" >&5
+$as_echo "$ac_cv_path_FGREP" >&6; }
+ FGREP="$ac_cv_path_FGREP"
+
+
+test -z "$GREP" && GREP=grep
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+# Check whether --with-gnu-ld was given.
+if test "${with_gnu_ld+set}" = set; then :
+  withval=$with_gnu_ld; test "$withval" = no || with_gnu_ld=yes
+else
+  with_gnu_ld=no
+fi
+
+ac_prog=ld
+if test "$GCC" = yes; then
+  # Check if gcc -print-prog-name=ld gives a path.
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
+$as_echo_n "checking for ld used by $CC... " >&6; }
+  case $host in
+  *-*-mingw*)
+    # gcc leaves a trailing carriage return which upsets mingw
+    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
+  *)
+    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
+  esac
+  case $ac_prog in
+    # Accept absolute paths.
+    [\\/]* | ?:[\\/]*)
+      re_direlt='/[^/][^/]*/\.\./'
+      # Canonicalize the pathname of ld
+      ac_prog=`$ECHO "$ac_prog"| $SED 's%\\\\%/%g'`
+      while $ECHO "$ac_prog" | $GREP "$re_direlt" > /dev/null 2>&1; do
+	ac_prog=`$ECHO $ac_prog| $SED "s%$re_direlt%/%"`
+      done
+      test -z "$LD" && LD="$ac_prog"
+      ;;
+  "")
+    # If it fails, then pretend we aren't using GCC.
+    ac_prog=ld
+    ;;
+  *)
+    # If it is relative, then search for the first ld in PATH.
+    with_gnu_ld=unknown
+    ;;
+  esac
+elif test "$with_gnu_ld" = yes; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for GNU ld" >&5
+$as_echo_n "checking for GNU ld... " >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for non-GNU ld" >&5
+$as_echo_n "checking for non-GNU ld... " >&6; }
+fi
+if test "${lt_cv_path_LD+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -z "$LD"; then
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  for ac_dir in $PATH; do
+    IFS="$lt_save_ifs"
+    test -z "$ac_dir" && ac_dir=.
+    if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
+      lt_cv_path_LD="$ac_dir/$ac_prog"
+      # Check to see if the program is GNU ld.  I'd rather use --version,
+      # but apparently some variants of GNU ld only accept -v.
+      # Break only if it was the GNU/non-GNU ld that we prefer.
+      case `"$lt_cv_path_LD" -v 2>&1 </dev/null` in
+      *GNU* | *'with BFD'*)
+	test "$with_gnu_ld" != no && break
+	;;
+      *)
+	test "$with_gnu_ld" != yes && break
+	;;
+      esac
+    fi
+  done
+  IFS="$lt_save_ifs"
+else
+  lt_cv_path_LD="$LD" # Let the user override the test with a path.
+fi
+fi
+
+LD="$lt_cv_path_LD"
+if test -n "$LD"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LD" >&5
+$as_echo "$LD" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+test -z "$LD" && as_fn_error "no acceptable ld found in \$PATH" "$LINENO" 5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if the linker ($LD) is GNU ld" >&5
+$as_echo_n "checking if the linker ($LD) is GNU ld... " >&6; }
+if test "${lt_cv_prog_gnu_ld+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  # I'd rather use --version here, but apparently some GNU lds only accept -v.
+case `$LD -v 2>&1 </dev/null` in
+*GNU* | *'with BFD'*)
+  lt_cv_prog_gnu_ld=yes
+  ;;
+*)
+  lt_cv_prog_gnu_ld=no
+  ;;
+esac
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_gnu_ld" >&5
+$as_echo "$lt_cv_prog_gnu_ld" >&6; }
+with_gnu_ld=$lt_cv_prog_gnu_ld
+
+
+
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for BSD- or MS-compatible name lister (nm)" >&5
+$as_echo_n "checking for BSD- or MS-compatible name lister (nm)... " >&6; }
+if test "${lt_cv_path_NM+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$NM"; then
+  # Let the user override the test.
+  lt_cv_path_NM="$NM"
+else
+  lt_nm_to_check="${ac_tool_prefix}nm"
+  if test -n "$ac_tool_prefix" && test "$build" = "$host"; then
+    lt_nm_to_check="$lt_nm_to_check nm"
+  fi
+  for lt_tmp_nm in $lt_nm_to_check; do
+    lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+    for ac_dir in $PATH /usr/ccs/bin/elf /usr/ccs/bin /usr/ucb /bin; do
+      IFS="$lt_save_ifs"
+      test -z "$ac_dir" && ac_dir=.
+      tmp_nm="$ac_dir/$lt_tmp_nm"
+      if test -f "$tmp_nm" || test -f "$tmp_nm$ac_exeext" ; then
+	# Check to see if the nm accepts a BSD-compat flag.
+	# Adding the `sed 1q' prevents false positives on HP-UX, which says:
+	#   nm: unknown option "B" ignored
+	# Tru64's nm complains that /dev/null is an invalid object file
+	case `"$tmp_nm" -B /dev/null 2>&1 | sed '1q'` in
+	*/dev/null* | *'Invalid file or object type'*)
+	  lt_cv_path_NM="$tmp_nm -B"
+	  break
+	  ;;
+	*)
+	  case `"$tmp_nm" -p /dev/null 2>&1 | sed '1q'` in
+	  */dev/null*)
+	    lt_cv_path_NM="$tmp_nm -p"
+	    break
+	    ;;
+	  *)
+	    lt_cv_path_NM=${lt_cv_path_NM="$tmp_nm"} # keep the first match, but
+	    continue # so that we can try to find one that supports BSD flags
+	    ;;
+	  esac
+	  ;;
+	esac
+      fi
+    done
+    IFS="$lt_save_ifs"
+  done
+  : ${lt_cv_path_NM=no}
+fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_path_NM" >&5
+$as_echo "$lt_cv_path_NM" >&6; }
+if test "$lt_cv_path_NM" != "no"; then
+  NM="$lt_cv_path_NM"
+else
+  # Didn't find any BSD compatible name lister, look for dumpbin.
+  if test -n "$DUMPBIN"; then :
+    # Let the user override the test.
+  else
+    if test -n "$ac_tool_prefix"; then
+  for ac_prog in dumpbin "link -dump"
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_DUMPBIN+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$DUMPBIN"; then
+  ac_cv_prog_DUMPBIN="$DUMPBIN" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_DUMPBIN="$ac_tool_prefix$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+DUMPBIN=$ac_cv_prog_DUMPBIN
+if test -n "$DUMPBIN"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $DUMPBIN" >&5
+$as_echo "$DUMPBIN" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+    test -n "$DUMPBIN" && break
+  done
+fi
+if test -z "$DUMPBIN"; then
+  ac_ct_DUMPBIN=$DUMPBIN
+  for ac_prog in dumpbin "link -dump"
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_DUMPBIN+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_DUMPBIN"; then
+  ac_cv_prog_ac_ct_DUMPBIN="$ac_ct_DUMPBIN" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_DUMPBIN="$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_DUMPBIN=$ac_cv_prog_ac_ct_DUMPBIN
+if test -n "$ac_ct_DUMPBIN"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_DUMPBIN" >&5
+$as_echo "$ac_ct_DUMPBIN" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$ac_ct_DUMPBIN" && break
+done
+
+  if test "x$ac_ct_DUMPBIN" = x; then
+    DUMPBIN=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    DUMPBIN=$ac_ct_DUMPBIN
+  fi
+fi
+
+    case `$DUMPBIN -symbols /dev/null 2>&1 | sed '1q'` in
+    *COFF*)
+      DUMPBIN="$DUMPBIN -symbols"
+      ;;
+    *)
+      DUMPBIN=:
+      ;;
+    esac
+  fi
+
+  if test "$DUMPBIN" != ":"; then
+    NM="$DUMPBIN"
+  fi
+fi
+test -z "$NM" && NM=nm
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking the name lister ($NM) interface" >&5
+$as_echo_n "checking the name lister ($NM) interface... " >&6; }
+if test "${lt_cv_nm_interface+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_nm_interface="BSD nm"
+  echo "int some_variable = 0;" > conftest.$ac_ext
+  (eval echo "\"\$as_me:$LINENO: $ac_compile\"" >&5)
+  (eval "$ac_compile" 2>conftest.err)
+  cat conftest.err >&5
+  (eval echo "\"\$as_me:$LINENO: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
+  (eval "$NM \"conftest.$ac_objext\"" 2>conftest.err > conftest.out)
+  cat conftest.err >&5
+  (eval echo "\"\$as_me:$LINENO: output\"" >&5)
+  cat conftest.out >&5
+  if $GREP 'External.*some_variable' conftest.out > /dev/null; then
+    lt_cv_nm_interface="MS dumpbin"
+  fi
+  rm -f conftest*
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_nm_interface" >&5
+$as_echo "$lt_cv_nm_interface" >&6; }
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether ln -s works" >&5
+$as_echo_n "checking whether ln -s works... " >&6; }
+LN_S=$as_ln_s
+if test "$LN_S" = "ln -s"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no, using $LN_S" >&5
+$as_echo "no, using $LN_S" >&6; }
+fi
+
+# find the maximum length of command line arguments
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking the maximum length of command line arguments" >&5
+$as_echo_n "checking the maximum length of command line arguments... " >&6; }
+if test "${lt_cv_sys_max_cmd_len+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+    i=0
+  teststring="ABCD"
+
+  case $build_os in
+  msdosdjgpp*)
+    # On DJGPP, this test can blow up pretty badly due to problems in libc
+    # (any single argument exceeding 2000 bytes causes a buffer overrun
+    # during glob expansion).  Even if it were fixed, the result of this
+    # check would be larger than it should be.
+    lt_cv_sys_max_cmd_len=12288;    # 12K is about right
+    ;;
+
+  gnu*)
+    # Under GNU Hurd, this test is not required because there is
+    # no limit to the length of command line arguments.
+    # Libtool will interpret -1 as no limit whatsoever
+    lt_cv_sys_max_cmd_len=-1;
+    ;;
+
+  cygwin* | mingw* | cegcc*)
+    # On Win9x/ME, this test blows up -- it succeeds, but takes
+    # about 5 minutes as the teststring grows exponentially.
+    # Worse, since 9x/ME are not pre-emptively multitasking,
+    # you end up with a "frozen" computer, even though with patience
+    # the test eventually succeeds (with a max line length of 256k).
+    # Instead, let's just punt: use the minimum linelength reported by
+    # all of the supported platforms: 8192 (on NT/2K/XP).
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
+  mint*)
+    # On MiNT this can take a long time and run out of memory.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
+  amigaos*)
+    # On AmigaOS with pdksh, this test takes hours, literally.
+    # So we just punt and use a minimum line length of 8192.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
+  netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)
+    # This has been around since 386BSD, at least.  Likely further.
+    if test -x /sbin/sysctl; then
+      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`
+    elif test -x /usr/sbin/sysctl; then
+      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`
+    else
+      lt_cv_sys_max_cmd_len=65536	# usable default for all BSDs
+    fi
+    # And add a safety zone
+    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
+    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
+    ;;
+
+  interix*)
+    # We know the value 262144 and hardcode it with a safety zone (like BSD)
+    lt_cv_sys_max_cmd_len=196608
+    ;;
+
+  osf*)
+    # Dr. Hans Ekkehard Plesser reports seeing a kernel panic running configure
+    # due to this test when exec_disable_arg_limit is 1 on Tru64. It is not
+    # nice to cause kernel panics so lets avoid the loop below.
+    # First set a reasonable default.
+    lt_cv_sys_max_cmd_len=16384
+    #
+    if test -x /sbin/sysconfig; then
+      case `/sbin/sysconfig -q proc exec_disable_arg_limit` in
+        *1*) lt_cv_sys_max_cmd_len=-1 ;;
+      esac
+    fi
+    ;;
+  sco3.2v5*)
+    lt_cv_sys_max_cmd_len=102400
+    ;;
+  sysv5* | sco5v6* | sysv4.2uw2*)
+    kargmax=`grep ARG_MAX /etc/conf/cf.d/stune 2>/dev/null`
+    if test -n "$kargmax"; then
+      lt_cv_sys_max_cmd_len=`echo $kargmax | sed 's/.*[	 ]//'`
+    else
+      lt_cv_sys_max_cmd_len=32768
+    fi
+    ;;
+  *)
+    lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`
+    if test -n "$lt_cv_sys_max_cmd_len"; then
+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
+    else
+      # Make teststring a little bigger before we do anything with it.
+      # a 1K string should be a reasonable start.
+      for i in 1 2 3 4 5 6 7 8 ; do
+        teststring=$teststring$teststring
+      done
+      SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}
+      # If test is not a shell built-in, we'll probably end up computing a
+      # maximum length that is only half of the actual maximum length, but
+      # we can't tell.
+      while { test "X"`func_fallback_echo "$teststring$teststring" 2>/dev/null` \
+	         = "X$teststring$teststring"; } >/dev/null 2>&1 &&
+	      test $i != 17 # 1/2 MB should be enough
+      do
+        i=`expr $i + 1`
+        teststring=$teststring$teststring
+      done
+      # Only check the string length outside the loop.
+      lt_cv_sys_max_cmd_len=`expr "X$teststring" : ".*" 2>&1`
+      teststring=
+      # Add a significant safety factor because C++ compilers can tack on
+      # massive amounts of additional arguments before passing them to the
+      # linker.  It appears as though 1/2 is a usable value.
+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 2`
+    fi
+    ;;
+  esac
+
+fi
+
+if test -n $lt_cv_sys_max_cmd_len ; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_sys_max_cmd_len" >&5
+$as_echo "$lt_cv_sys_max_cmd_len" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: none" >&5
+$as_echo "none" >&6; }
+fi
+max_cmd_len=$lt_cv_sys_max_cmd_len
+
+
+
+
+
+
+: ${CP="cp -f"}
+: ${MV="mv -f"}
+: ${RM="rm -f"}
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the shell understands some XSI constructs" >&5
+$as_echo_n "checking whether the shell understands some XSI constructs... " >&6; }
+# Try some XSI features
+xsi_shell=no
+( _lt_dummy="a/b/c"
+  test "${_lt_dummy##*/},${_lt_dummy%/*},"${_lt_dummy%"$_lt_dummy"}, \
+      = c,a/b,, \
+    && eval 'test $(( 1 + 1 )) -eq 2 \
+    && test "${#_lt_dummy}" -eq 5' ) >/dev/null 2>&1 \
+  && xsi_shell=yes
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $xsi_shell" >&5
+$as_echo "$xsi_shell" >&6; }
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the shell understands \"+=\"" >&5
+$as_echo_n "checking whether the shell understands \"+=\"... " >&6; }
+lt_shell_append=no
+( foo=bar; set foo baz; eval "$1+=\$2" && test "$foo" = barbaz ) \
+    >/dev/null 2>&1 \
+  && lt_shell_append=yes
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_shell_append" >&5
+$as_echo "$lt_shell_append" >&6; }
+
+
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  lt_unset=unset
+else
+  lt_unset=false
+fi
+
+
+
+
+
+# test EBCDIC or ASCII
+case `echo X|tr X '\101'` in
+ A) # ASCII based system
+    # \n is not interpreted correctly by Solaris 8 /usr/ucb/tr
+  lt_SP2NL='tr \040 \012'
+  lt_NL2SP='tr \015\012 \040\040'
+  ;;
+ *) # EBCDIC based system
+  lt_SP2NL='tr \100 \n'
+  lt_NL2SP='tr \r\n \100\100'
+  ;;
+esac
+
+
+
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $LD option to reload object files" >&5
+$as_echo_n "checking for $LD option to reload object files... " >&6; }
+if test "${lt_cv_ld_reload_flag+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_ld_reload_flag='-r'
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ld_reload_flag" >&5
+$as_echo "$lt_cv_ld_reload_flag" >&6; }
+reload_flag=$lt_cv_ld_reload_flag
+case $reload_flag in
+"" | " "*) ;;
+*) reload_flag=" $reload_flag" ;;
+esac
+reload_cmds='$LD$reload_flag -o $output$reload_objs'
+case $host_os in
+  darwin*)
+    if test "$GCC" = yes; then
+      reload_cmds='$LTCC $LTCFLAGS -nostdlib ${wl}-r -o $output$reload_objs'
+    else
+      reload_cmds='$LD$reload_flag -o $output$reload_objs'
+    fi
+    ;;
+esac
+
+
+
+
+
+
+
+
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}objdump", so it can be a program name with args.
+set dummy ${ac_tool_prefix}objdump; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_OBJDUMP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$OBJDUMP"; then
+  ac_cv_prog_OBJDUMP="$OBJDUMP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_OBJDUMP="${ac_tool_prefix}objdump"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+OBJDUMP=$ac_cv_prog_OBJDUMP
+if test -n "$OBJDUMP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OBJDUMP" >&5
+$as_echo "$OBJDUMP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_OBJDUMP"; then
+  ac_ct_OBJDUMP=$OBJDUMP
+  # Extract the first word of "objdump", so it can be a program name with args.
+set dummy objdump; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_OBJDUMP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_OBJDUMP"; then
+  ac_cv_prog_ac_ct_OBJDUMP="$ac_ct_OBJDUMP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_OBJDUMP="objdump"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_OBJDUMP=$ac_cv_prog_ac_ct_OBJDUMP
+if test -n "$ac_ct_OBJDUMP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OBJDUMP" >&5
+$as_echo "$ac_ct_OBJDUMP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_OBJDUMP" = x; then
+    OBJDUMP="false"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    OBJDUMP=$ac_ct_OBJDUMP
+  fi
+else
+  OBJDUMP="$ac_cv_prog_OBJDUMP"
+fi
+
+test -z "$OBJDUMP" && OBJDUMP=objdump
+
+
+
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to recognize dependent libraries" >&5
+$as_echo_n "checking how to recognize dependent libraries... " >&6; }
+if test "${lt_cv_deplibs_check_method+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_file_magic_cmd='$MAGIC_CMD'
+lt_cv_file_magic_test_file=
+lt_cv_deplibs_check_method='unknown'
+# Need to set the preceding variable on all platforms that support
+# interlibrary dependencies.
+# 'none' -- dependencies not supported.
+# `unknown' -- same as none, but documents that we really don't know.
+# 'pass_all' -- all dependencies passed with no checks.
+# 'test_compile' -- check by making test program.
+# 'file_magic [[regex]]' -- check by looking for files in library path
+# which responds to the $file_magic_cmd with a given extended regex.
+# If you have `file' or equivalent on your system and you're not sure
+# whether `pass_all' will *always* work, you probably want this one.
+
+case $host_os in
+aix[4-9]*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+beos*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+bsdi[45]*)
+  lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (shared object|dynamic lib)'
+  lt_cv_file_magic_cmd='/usr/bin/file -L'
+  lt_cv_file_magic_test_file=/shlib/libc.so
+  ;;
+
+cygwin*)
+  # func_win32_libid is a shell function defined in ltmain.sh
+  lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
+  lt_cv_file_magic_cmd='func_win32_libid'
+  ;;
+
+mingw* | pw32*)
+  # Base MSYS/MinGW do not provide the 'file' command needed by
+  # func_win32_libid shell function, so use a weaker test based on 'objdump',
+  # unless we find 'file', for example because we are cross-compiling.
+  # func_win32_libid assumes BSD nm, so disallow it if using MS dumpbin.
+  if ( test "$lt_cv_nm_interface" = "BSD nm" && file / ) >/dev/null 2>&1; then
+    lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
+    lt_cv_file_magic_cmd='func_win32_libid'
+  else
+    lt_cv_deplibs_check_method='file_magic file format pei*-i386(.*architecture: i386)?'
+    lt_cv_file_magic_cmd='$OBJDUMP -f'
+  fi
+  ;;
+
+cegcc*)
+  # use the weaker test based on 'objdump'. See mingw*.
+  lt_cv_deplibs_check_method='file_magic file format pe-arm-.*little(.*architecture: arm)?'
+  lt_cv_file_magic_cmd='$OBJDUMP -f'
+  ;;
+
+darwin* | rhapsody*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+freebsd* | dragonfly*)
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
+    case $host_cpu in
+    i*86 )
+      # Not sure whether the presence of OpenBSD here was a mistake.
+      # Let's accept both of them until this is cleared up.
+      lt_cv_deplibs_check_method='file_magic (FreeBSD|OpenBSD|DragonFly)/i[3-9]86 (compact )?demand paged shared library'
+      lt_cv_file_magic_cmd=/usr/bin/file
+      lt_cv_file_magic_test_file=`echo /usr/lib/libc.so.*`
+      ;;
+    esac
+  else
+    lt_cv_deplibs_check_method=pass_all
+  fi
+  ;;
+
+gnu*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+haiku*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+hpux10.20* | hpux11*)
+  lt_cv_file_magic_cmd=/usr/bin/file
+  case $host_cpu in
+  ia64*)
+    lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF-[0-9][0-9]) shared object file - IA64'
+    lt_cv_file_magic_test_file=/usr/lib/hpux32/libc.so
+    ;;
+  hppa*64*)
+    lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF[ -][0-9][0-9])(-bit)?( [LM]SB)? shared object( file)?[, -]* PA-RISC [0-9]\.[0-9]'
+    lt_cv_file_magic_test_file=/usr/lib/pa20_64/libc.sl
+    ;;
+  *)
+    lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|PA-RISC[0-9]\.[0-9]) shared library'
+    lt_cv_file_magic_test_file=/usr/lib/libc.sl
+    ;;
+  esac
+  ;;
+
+interix[3-9]*)
+  # PIC code is broken on Interix 3.x, that's why |\.a not |_pic\.a here
+  lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so|\.a)$'
+  ;;
+
+irix5* | irix6* | nonstopux*)
+  case $LD in
+  *-32|*"-32 ") libmagic=32-bit;;
+  *-n32|*"-n32 ") libmagic=N32;;
+  *-64|*"-64 ") libmagic=64-bit;;
+  *) libmagic=never-match;;
+  esac
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+# This must be Linux ELF.
+linux* | k*bsd*-gnu | kopensolaris*-gnu)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+netbsd*)
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
+    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|_pic\.a)$'
+  else
+    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so|_pic\.a)$'
+  fi
+  ;;
+
+newos6*)
+  lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (executable|dynamic lib)'
+  lt_cv_file_magic_cmd=/usr/bin/file
+  lt_cv_file_magic_test_file=/usr/lib/libnls.so
+  ;;
+
+*nto* | *qnx*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+openbsd*)
+  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|\.so|_pic\.a)$'
+  else
+    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|_pic\.a)$'
+  fi
+  ;;
+
+osf3* | osf4* | osf5*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+rdos*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+solaris*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+sysv4 | sysv4.3*)
+  case $host_vendor in
+  motorola)
+    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (shared object|dynamic lib) M[0-9][0-9]* Version [0-9]'
+    lt_cv_file_magic_test_file=`echo /usr/lib/libc.so*`
+    ;;
+  ncr)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  sequent)
+    lt_cv_file_magic_cmd='/bin/file'
+    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )'
+    ;;
+  sni)
+    lt_cv_file_magic_cmd='/bin/file'
+    lt_cv_deplibs_check_method="file_magic ELF [0-9][0-9]*-bit [LM]SB dynamic lib"
+    lt_cv_file_magic_test_file=/lib/libc.so
+    ;;
+  siemens)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  pc)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  esac
+  ;;
+
+tpf*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+esac
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_deplibs_check_method" >&5
+$as_echo "$lt_cv_deplibs_check_method" >&6; }
+file_magic_cmd=$lt_cv_file_magic_cmd
+deplibs_check_method=$lt_cv_deplibs_check_method
+test -z "$deplibs_check_method" && deplibs_check_method=unknown
+
+
+
+
+
+
+
+
+
+
+
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}ar", so it can be a program name with args.
+set dummy ${ac_tool_prefix}ar; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_AR+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$AR"; then
+  ac_cv_prog_AR="$AR" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_AR="${ac_tool_prefix}ar"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+AR=$ac_cv_prog_AR
+if test -n "$AR"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $AR" >&5
+$as_echo "$AR" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_AR"; then
+  ac_ct_AR=$AR
+  # Extract the first word of "ar", so it can be a program name with args.
+set dummy ar; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_AR+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_AR"; then
+  ac_cv_prog_ac_ct_AR="$ac_ct_AR" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_AR="ar"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_AR=$ac_cv_prog_ac_ct_AR
+if test -n "$ac_ct_AR"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_AR" >&5
+$as_echo "$ac_ct_AR" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_AR" = x; then
+    AR="false"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    AR=$ac_ct_AR
+  fi
+else
+  AR="$ac_cv_prog_AR"
+fi
+
+test -z "$AR" && AR=ar
+test -z "$AR_FLAGS" && AR_FLAGS=cru
+
+
+
+
+
+
+
+
+
+
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
+set dummy ${ac_tool_prefix}strip; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_STRIP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$STRIP"; then
+  ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_STRIP="${ac_tool_prefix}strip"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+STRIP=$ac_cv_prog_STRIP
+if test -n "$STRIP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $STRIP" >&5
+$as_echo "$STRIP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_STRIP"; then
+  ac_ct_STRIP=$STRIP
+  # Extract the first word of "strip", so it can be a program name with args.
+set dummy strip; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_STRIP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_STRIP"; then
+  ac_cv_prog_ac_ct_STRIP="$ac_ct_STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_STRIP="strip"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
+if test -n "$ac_ct_STRIP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_STRIP" >&5
+$as_echo "$ac_ct_STRIP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_STRIP" = x; then
+    STRIP=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    STRIP=$ac_ct_STRIP
+  fi
+else
+  STRIP="$ac_cv_prog_STRIP"
+fi
+
+test -z "$STRIP" && STRIP=:
+
+
+
+
+
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
+set dummy ${ac_tool_prefix}ranlib; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_RANLIB+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$RANLIB"; then
+  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+RANLIB=$ac_cv_prog_RANLIB
+if test -n "$RANLIB"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $RANLIB" >&5
+$as_echo "$RANLIB" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_RANLIB"; then
+  ac_ct_RANLIB=$RANLIB
+  # Extract the first word of "ranlib", so it can be a program name with args.
+set dummy ranlib; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_RANLIB+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_RANLIB"; then
+  ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_RANLIB="ranlib"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
+if test -n "$ac_ct_RANLIB"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_RANLIB" >&5
+$as_echo "$ac_ct_RANLIB" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_RANLIB" = x; then
+    RANLIB=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    RANLIB=$ac_ct_RANLIB
+  fi
+else
+  RANLIB="$ac_cv_prog_RANLIB"
+fi
+
+test -z "$RANLIB" && RANLIB=:
+
+
+
+
+
+
+# Determine commands to create old-style static archives.
+old_archive_cmds='$AR $AR_FLAGS $oldlib$oldobjs'
+old_postinstall_cmds='chmod 644 $oldlib'
+old_postuninstall_cmds=
+
+if test -n "$RANLIB"; then
+  case $host_os in
+  openbsd*)
+    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB -t \$oldlib"
+    ;;
+  *)
+    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB \$oldlib"
+    ;;
+  esac
+  old_archive_cmds="$old_archive_cmds~\$RANLIB \$oldlib"
+fi
+
+case $host_os in
+  darwin*)
+    lock_old_archive_extraction=yes ;;
+  *)
+    lock_old_archive_extraction=no ;;
+esac
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+# If no C compiler was specified, use CC.
+LTCC=${LTCC-"$CC"}
+
+# If no C compiler flags were specified, use CFLAGS.
+LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
+
+# Allow CC to be a program name with arguments.
+compiler=$CC
+
+
+# Check for command to grab the raw symbol name followed by C symbol from nm.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking command to parse $NM output from $compiler object" >&5
+$as_echo_n "checking command to parse $NM output from $compiler object... " >&6; }
+if test "${lt_cv_sys_global_symbol_pipe+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+
+# These are sane defaults that work on at least a few old systems.
+# [They come from Ultrix.  What could be older than Ultrix?!! ;)]
+
+# Character class describing NM global symbol codes.
+symcode='[BCDEGRST]'
+
+# Regexp to match symbols that can be accessed directly from C.
+sympat='\([_A-Za-z][_A-Za-z0-9]*\)'
+
+# Define system-specific variables.
+case $host_os in
+aix*)
+  symcode='[BCDT]'
+  ;;
+cygwin* | mingw* | pw32* | cegcc*)
+  symcode='[ABCDGISTW]'
+  ;;
+hpux*)
+  if test "$host_cpu" = ia64; then
+    symcode='[ABCDEGRST]'
+  fi
+  ;;
+irix* | nonstopux*)
+  symcode='[BCDEGRST]'
+  ;;
+osf*)
+  symcode='[BCDEGQRST]'
+  ;;
+solaris*)
+  symcode='[BDRT]'
+  ;;
+sco3.2v5*)
+  symcode='[DT]'
+  ;;
+sysv4.2uw2*)
+  symcode='[DT]'
+  ;;
+sysv5* | sco5v6* | unixware* | OpenUNIX*)
+  symcode='[ABDT]'
+  ;;
+sysv4)
+  symcode='[DFNSTU]'
+  ;;
+esac
+
+# If we're using GNU nm, then use its standard symbol codes.
+case `$NM -V 2>&1` in
+*GNU* | *'with BFD'*)
+  symcode='[ABCDGIRSTW]' ;;
+esac
+
+# Transform an extracted symbol line into a proper C declaration.
+# Some systems (esp. on ia64) link data and code symbols differently,
+# so use this general approach.
+lt_cv_sys_global_symbol_to_cdecl="sed -n -e 's/^T .* \(.*\)$/extern int \1();/p' -e 's/^$symcode* .* \(.*\)$/extern char \1;/p'"
+
+# Transform an extracted symbol line into symbol name and symbol address
+lt_cv_sys_global_symbol_to_c_name_address="sed -n -e 's/^: \([^ ]*\) $/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([^ ]*\) \([^ ]*\)$/  {\"\2\", (void *) \&\2},/p'"
+lt_cv_sys_global_symbol_to_c_name_address_lib_prefix="sed -n -e 's/^: \([^ ]*\) $/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([^ ]*\) \(lib[^ ]*\)$/  {\"\2\", (void *) \&\2},/p' -e 's/^$symcode* \([^ ]*\) \([^ ]*\)$/  {\"lib\2\", (void *) \&\2},/p'"
+
+# Handle CRLF in mingw tool chain
+opt_cr=
+case $build_os in
+mingw*)
+  opt_cr=`$ECHO 'x\{0,1\}' | tr x '\015'` # option cr in regexp
+  ;;
+esac
+
+# Try without a prefix underscore, then with it.
+for ac_symprfx in "" "_"; do
+
+  # Transform symcode, sympat, and symprfx into a raw symbol and a C symbol.
+  symxfrm="\\1 $ac_symprfx\\2 \\2"
+
+  # Write the raw and C identifiers.
+  if test "$lt_cv_nm_interface" = "MS dumpbin"; then
+    # Fake it for dumpbin and say T for any non-static function
+    # and D for any global variable.
+    # Also find C++ and __fastcall symbols from MSVC++,
+    # which start with @ or ?.
+    lt_cv_sys_global_symbol_pipe="$AWK '"\
+"     {last_section=section; section=\$ 3};"\
+"     /Section length .*#relocs.*(pick any)/{hide[last_section]=1};"\
+"     \$ 0!~/External *\|/{next};"\
+"     / 0+ UNDEF /{next}; / UNDEF \([^|]\)*()/{next};"\
+"     {if(hide[section]) next};"\
+"     {f=0}; \$ 0~/\(\).*\|/{f=1}; {printf f ? \"T \" : \"D \"};"\
+"     {split(\$ 0, a, /\||\r/); split(a[2], s)};"\
+"     s[1]~/^[@?]/{print s[1], s[1]; next};"\
+"     s[1]~prfx {split(s[1],t,\"@\"); print t[1], substr(t[1],length(prfx))}"\
+"     ' prfx=^$ac_symprfx"
+  else
+    lt_cv_sys_global_symbol_pipe="sed -n -e 's/^.*[	 ]\($symcode$symcode*\)[	 ][	 ]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'"
+  fi
+
+  # Check to see that the pipe works correctly.
+  pipe_works=no
+
+  rm -f conftest*
+  cat > conftest.$ac_ext <<_LT_EOF
+#ifdef __cplusplus
+extern "C" {
+#endif
+char nm_test_var;
+void nm_test_func(void);
+void nm_test_func(void){}
+#ifdef __cplusplus
+}
+#endif
+int main(){nm_test_var='a';nm_test_func();return(0);}
+_LT_EOF
+
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+    # Now try to grab the symbols.
+    nlist=conftest.nm
+    if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$NM conftest.$ac_objext \| "$lt_cv_sys_global_symbol_pipe" \> $nlist\""; } >&5
+  (eval $NM conftest.$ac_objext \| "$lt_cv_sys_global_symbol_pipe" \> $nlist) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && test -s "$nlist"; then
+      # Try sorting and uniquifying the output.
+      if sort "$nlist" | uniq > "$nlist"T; then
+	mv -f "$nlist"T "$nlist"
+      else
+	rm -f "$nlist"T
+      fi
+
+      # Make sure that we snagged all the symbols we need.
+      if $GREP ' nm_test_var$' "$nlist" >/dev/null; then
+	if $GREP ' nm_test_func$' "$nlist" >/dev/null; then
+	  cat <<_LT_EOF > conftest.$ac_ext
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+_LT_EOF
+	  # Now generate the symbol file.
+	  eval "$lt_cv_sys_global_symbol_to_cdecl"' < "$nlist" | $GREP -v main >> conftest.$ac_ext'
+
+	  cat <<_LT_EOF >> conftest.$ac_ext
+
+/* The mapping between symbol names and symbols.  */
+const struct {
+  const char *name;
+  void       *address;
+}
+lt__PROGRAM__LTX_preloaded_symbols[] =
+{
+  { "@PROGRAM@", (void *) 0 },
+_LT_EOF
+	  $SED "s/^$symcode$symcode* \(.*\) \(.*\)$/  {\"\2\", (void *) \&\2},/" < "$nlist" | $GREP -v main >> conftest.$ac_ext
+	  cat <<\_LT_EOF >> conftest.$ac_ext
+  {0, (void *) 0}
+};
+
+/* This works around a problem in FreeBSD linker */
+#ifdef FREEBSD_WORKAROUND
+static const void *lt_preloaded_setup() {
+  return lt__PROGRAM__LTX_preloaded_symbols;
+}
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+_LT_EOF
+	  # Now try linking the two files.
+	  mv conftest.$ac_objext conftstm.$ac_objext
+	  lt_save_LIBS="$LIBS"
+	  lt_save_CFLAGS="$CFLAGS"
+	  LIBS="conftstm.$ac_objext"
+	  CFLAGS="$CFLAGS$lt_prog_compiler_no_builtin_flag"
+	  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && test -s conftest${ac_exeext}; then
+	    pipe_works=yes
+	  fi
+	  LIBS="$lt_save_LIBS"
+	  CFLAGS="$lt_save_CFLAGS"
+	else
+	  echo "cannot find nm_test_func in $nlist" >&5
+	fi
+      else
+	echo "cannot find nm_test_var in $nlist" >&5
+      fi
+    else
+      echo "cannot run $lt_cv_sys_global_symbol_pipe" >&5
+    fi
+  else
+    echo "$progname: failed program was:" >&5
+    cat conftest.$ac_ext >&5
+  fi
+  rm -rf conftest* conftst*
+
+  # Do not use the global_symbol_pipe unless it works.
+  if test "$pipe_works" = yes; then
+    break
+  else
+    lt_cv_sys_global_symbol_pipe=
+  fi
+done
+
+fi
+
+if test -z "$lt_cv_sys_global_symbol_pipe"; then
+  lt_cv_sys_global_symbol_to_cdecl=
+fi
+if test -z "$lt_cv_sys_global_symbol_pipe$lt_cv_sys_global_symbol_to_cdecl"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: failed" >&5
+$as_echo "failed" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: ok" >&5
+$as_echo "ok" >&6; }
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+# Check whether --enable-libtool-lock was given.
+if test "${enable_libtool_lock+set}" = set; then :
+  enableval=$enable_libtool_lock;
+fi
+
+test "x$enable_libtool_lock" != xno && enable_libtool_lock=yes
+
+# Some flags need to be propagated to the compiler or linker for good
+# libtool support.
+case $host in
+ia64-*-hpux*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+    case `/usr/bin/file conftest.$ac_objext` in
+      *ELF-32*)
+	HPUX_IA64_MODE="32"
+	;;
+      *ELF-64*)
+	HPUX_IA64_MODE="64"
+	;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+*-*-irix6*)
+  # Find out which ABI we are using.
+  echo '#line '$LINENO' "configure"' > conftest.$ac_ext
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+    if test "$lt_cv_prog_gnu_ld" = yes; then
+      case `/usr/bin/file conftest.$ac_objext` in
+	*32-bit*)
+	  LD="${LD-ld} -melf32bsmip"
+	  ;;
+	*N32*)
+	  LD="${LD-ld} -melf32bmipn32"
+	  ;;
+	*64-bit*)
+	  LD="${LD-ld} -melf64bmip"
+	;;
+      esac
+    else
+      case `/usr/bin/file conftest.$ac_objext` in
+	*32-bit*)
+	  LD="${LD-ld} -32"
+	  ;;
+	*N32*)
+	  LD="${LD-ld} -n32"
+	  ;;
+	*64-bit*)
+	  LD="${LD-ld} -64"
+	  ;;
+      esac
+    fi
+  fi
+  rm -rf conftest*
+  ;;
+
+x86_64-*kfreebsd*-gnu|x86_64-*linux*|powerpc*-*linux*| \
+s390*-*linux*|s390*-*tpf*|sparc*-*linux*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+    case `/usr/bin/file conftest.o` in
+      *32-bit*)
+	case $host in
+	  x86_64-*kfreebsd*-gnu)
+	    LD="${LD-ld} -m elf_i386_fbsd"
+	    ;;
+	  x86_64-*linux*)
+	    case `/usr/bin/file conftest.o` in
+	      *x86-64*)
+		LD="${LD-ld} -m elf32_x86_64"
+		;;
+	      *)
+		LD="${LD-ld} -m elf_i386"
+		;;
+	    esac
+	    ;;
+	  powerpc64le-*linux*)
+	    LD="${LD-ld} -m elf32lppclinux"
+	    ;;
+	  powerpc64-*linux*)
+	    LD="${LD-ld} -m elf32ppclinux"
+	    ;;
+	  s390x-*linux*)
+	    LD="${LD-ld} -m elf_s390"
+	    ;;
+	  sparc64-*linux*)
+	    LD="${LD-ld} -m elf32_sparc"
+	    ;;
+	esac
+	;;
+      *64-bit*)
+	case $host in
+	  x86_64-*kfreebsd*-gnu)
+	    LD="${LD-ld} -m elf_x86_64_fbsd"
+	    ;;
+	  x86_64-*linux*)
+	    LD="${LD-ld} -m elf_x86_64"
+	    ;;
+	  powerpcle-*linux*)
+	    LD="${LD-ld} -m elf64lppc"
+	    ;;
+	  powerpc-*linux*)
+	    LD="${LD-ld} -m elf64ppc"
+	    ;;
+	  s390*-*linux*|s390*-*tpf*)
+	    LD="${LD-ld} -m elf64_s390"
+	    ;;
+	  sparc*-*linux*)
+	    LD="${LD-ld} -m elf64_sparc"
+	    ;;
+	esac
+	;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+
+*-*-sco3.2v5*)
+  # On SCO OpenServer 5, we need -belf to get full-featured binaries.
+  SAVE_CFLAGS="$CFLAGS"
+  CFLAGS="$CFLAGS -belf"
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the C compiler needs -belf" >&5
+$as_echo_n "checking whether the C compiler needs -belf... " >&6; }
+if test "${lt_cv_cc_needs_belf+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+     cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  lt_cv_cc_needs_belf=yes
+else
+  lt_cv_cc_needs_belf=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+     ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_cc_needs_belf" >&5
+$as_echo "$lt_cv_cc_needs_belf" >&6; }
+  if test x"$lt_cv_cc_needs_belf" != x"yes"; then
+    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf
+    CFLAGS="$SAVE_CFLAGS"
+  fi
+  ;;
+sparc*-*solaris*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+    case `/usr/bin/file conftest.o` in
+    *64-bit*)
+      case $lt_cv_prog_gnu_ld in
+      yes*) LD="${LD-ld} -m elf64_sparc" ;;
+      *)
+	if ${LD-ld} -64 -r -o conftest2.o conftest.o >/dev/null 2>&1; then
+	  LD="${LD-ld} -64"
+	fi
+	;;
+      esac
+      ;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+esac
+
+need_locks="$enable_libtool_lock"
+
+
+  case $host_os in
+    rhapsody* | darwin*)
+    if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}dsymutil", so it can be a program name with args.
+set dummy ${ac_tool_prefix}dsymutil; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_DSYMUTIL+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$DSYMUTIL"; then
+  ac_cv_prog_DSYMUTIL="$DSYMUTIL" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_DSYMUTIL="${ac_tool_prefix}dsymutil"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+DSYMUTIL=$ac_cv_prog_DSYMUTIL
+if test -n "$DSYMUTIL"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $DSYMUTIL" >&5
+$as_echo "$DSYMUTIL" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_DSYMUTIL"; then
+  ac_ct_DSYMUTIL=$DSYMUTIL
+  # Extract the first word of "dsymutil", so it can be a program name with args.
+set dummy dsymutil; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_DSYMUTIL+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_DSYMUTIL"; then
+  ac_cv_prog_ac_ct_DSYMUTIL="$ac_ct_DSYMUTIL" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_DSYMUTIL="dsymutil"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_DSYMUTIL=$ac_cv_prog_ac_ct_DSYMUTIL
+if test -n "$ac_ct_DSYMUTIL"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_DSYMUTIL" >&5
+$as_echo "$ac_ct_DSYMUTIL" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_DSYMUTIL" = x; then
+    DSYMUTIL=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    DSYMUTIL=$ac_ct_DSYMUTIL
+  fi
+else
+  DSYMUTIL="$ac_cv_prog_DSYMUTIL"
+fi
+
+    if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}nmedit", so it can be a program name with args.
+set dummy ${ac_tool_prefix}nmedit; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_NMEDIT+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$NMEDIT"; then
+  ac_cv_prog_NMEDIT="$NMEDIT" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_NMEDIT="${ac_tool_prefix}nmedit"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+NMEDIT=$ac_cv_prog_NMEDIT
+if test -n "$NMEDIT"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $NMEDIT" >&5
+$as_echo "$NMEDIT" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_NMEDIT"; then
+  ac_ct_NMEDIT=$NMEDIT
+  # Extract the first word of "nmedit", so it can be a program name with args.
+set dummy nmedit; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_NMEDIT+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_NMEDIT"; then
+  ac_cv_prog_ac_ct_NMEDIT="$ac_ct_NMEDIT" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_NMEDIT="nmedit"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_NMEDIT=$ac_cv_prog_ac_ct_NMEDIT
+if test -n "$ac_ct_NMEDIT"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_NMEDIT" >&5
+$as_echo "$ac_ct_NMEDIT" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_NMEDIT" = x; then
+    NMEDIT=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    NMEDIT=$ac_ct_NMEDIT
+  fi
+else
+  NMEDIT="$ac_cv_prog_NMEDIT"
+fi
+
+    if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}lipo", so it can be a program name with args.
+set dummy ${ac_tool_prefix}lipo; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_LIPO+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$LIPO"; then
+  ac_cv_prog_LIPO="$LIPO" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_LIPO="${ac_tool_prefix}lipo"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+LIPO=$ac_cv_prog_LIPO
+if test -n "$LIPO"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LIPO" >&5
+$as_echo "$LIPO" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_LIPO"; then
+  ac_ct_LIPO=$LIPO
+  # Extract the first word of "lipo", so it can be a program name with args.
+set dummy lipo; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_LIPO+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_LIPO"; then
+  ac_cv_prog_ac_ct_LIPO="$ac_ct_LIPO" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_LIPO="lipo"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_LIPO=$ac_cv_prog_ac_ct_LIPO
+if test -n "$ac_ct_LIPO"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_LIPO" >&5
+$as_echo "$ac_ct_LIPO" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_LIPO" = x; then
+    LIPO=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    LIPO=$ac_ct_LIPO
+  fi
+else
+  LIPO="$ac_cv_prog_LIPO"
+fi
+
+    if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}otool", so it can be a program name with args.
+set dummy ${ac_tool_prefix}otool; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_OTOOL+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$OTOOL"; then
+  ac_cv_prog_OTOOL="$OTOOL" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_OTOOL="${ac_tool_prefix}otool"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+OTOOL=$ac_cv_prog_OTOOL
+if test -n "$OTOOL"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OTOOL" >&5
+$as_echo "$OTOOL" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_OTOOL"; then
+  ac_ct_OTOOL=$OTOOL
+  # Extract the first word of "otool", so it can be a program name with args.
+set dummy otool; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_OTOOL+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_OTOOL"; then
+  ac_cv_prog_ac_ct_OTOOL="$ac_ct_OTOOL" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_OTOOL="otool"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_OTOOL=$ac_cv_prog_ac_ct_OTOOL
+if test -n "$ac_ct_OTOOL"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OTOOL" >&5
+$as_echo "$ac_ct_OTOOL" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_OTOOL" = x; then
+    OTOOL=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    OTOOL=$ac_ct_OTOOL
+  fi
+else
+  OTOOL="$ac_cv_prog_OTOOL"
+fi
+
+    if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}otool64", so it can be a program name with args.
+set dummy ${ac_tool_prefix}otool64; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_OTOOL64+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$OTOOL64"; then
+  ac_cv_prog_OTOOL64="$OTOOL64" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_OTOOL64="${ac_tool_prefix}otool64"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+OTOOL64=$ac_cv_prog_OTOOL64
+if test -n "$OTOOL64"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OTOOL64" >&5
+$as_echo "$OTOOL64" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_OTOOL64"; then
+  ac_ct_OTOOL64=$OTOOL64
+  # Extract the first word of "otool64", so it can be a program name with args.
+set dummy otool64; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_OTOOL64+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_OTOOL64"; then
+  ac_cv_prog_ac_ct_OTOOL64="$ac_ct_OTOOL64" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_OTOOL64="otool64"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_OTOOL64=$ac_cv_prog_ac_ct_OTOOL64
+if test -n "$ac_ct_OTOOL64"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OTOOL64" >&5
+$as_echo "$ac_ct_OTOOL64" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_OTOOL64" = x; then
+    OTOOL64=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    OTOOL64=$ac_ct_OTOOL64
+  fi
+else
+  OTOOL64="$ac_cv_prog_OTOOL64"
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -single_module linker flag" >&5
+$as_echo_n "checking for -single_module linker flag... " >&6; }
+if test "${lt_cv_apple_cc_single_mod+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_apple_cc_single_mod=no
+      if test -z "${LT_MULTI_MODULE}"; then
+	# By default we will add the -single_module flag. You can override
+	# by either setting the environment variable LT_MULTI_MODULE
+	# non-empty at configure time, or by adding -multi_module to the
+	# link flags.
+	rm -rf libconftest.dylib*
+	echo "int foo(void){return 1;}" > conftest.c
+	echo "$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \
+-dynamiclib -Wl,-single_module conftest.c" >&5
+	$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \
+	  -dynamiclib -Wl,-single_module conftest.c 2>conftest.err
+        _lt_result=$?
+	if test -f libconftest.dylib && test ! -s conftest.err && test $_lt_result = 0; then
+	  lt_cv_apple_cc_single_mod=yes
+	else
+	  cat conftest.err >&5
+	fi
+	rm -rf libconftest.dylib*
+	rm -f conftest.*
+      fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_apple_cc_single_mod" >&5
+$as_echo "$lt_cv_apple_cc_single_mod" >&6; }
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -exported_symbols_list linker flag" >&5
+$as_echo_n "checking for -exported_symbols_list linker flag... " >&6; }
+if test "${lt_cv_ld_exported_symbols_list+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_ld_exported_symbols_list=no
+      save_LDFLAGS=$LDFLAGS
+      echo "_main" > conftest.sym
+      LDFLAGS="$LDFLAGS -Wl,-exported_symbols_list,conftest.sym"
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  lt_cv_ld_exported_symbols_list=yes
+else
+  lt_cv_ld_exported_symbols_list=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+	LDFLAGS="$save_LDFLAGS"
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ld_exported_symbols_list" >&5
+$as_echo "$lt_cv_ld_exported_symbols_list" >&6; }
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -force_load linker flag" >&5
+$as_echo_n "checking for -force_load linker flag... " >&6; }
+if test "${lt_cv_ld_force_load+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_ld_force_load=no
+      cat > conftest.c << _LT_EOF
+int forced_loaded() { return 2;}
+_LT_EOF
+      echo "$LTCC $LTCFLAGS -c -o conftest.o conftest.c" >&5
+      $LTCC $LTCFLAGS -c -o conftest.o conftest.c 2>&5
+      echo "$AR cru libconftest.a conftest.o" >&5
+      $AR cru libconftest.a conftest.o 2>&5
+      cat > conftest.c << _LT_EOF
+int main() { return 0;}
+_LT_EOF
+      echo "$LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a" >&5
+      $LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a 2>conftest.err
+      _lt_result=$?
+      if test -f conftest && test ! -s conftest.err && test $_lt_result = 0 && $GREP forced_load conftest 2>&1 >/dev/null; then
+	lt_cv_ld_force_load=yes
+      else
+	cat conftest.err >&5
+      fi
+        rm -f conftest.err libconftest.a conftest conftest.c
+        rm -rf conftest.dSYM
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ld_force_load" >&5
+$as_echo "$lt_cv_ld_force_load" >&6; }
+    case $host_os in
+    rhapsody* | darwin1.[012])
+      _lt_dar_allow_undefined='${wl}-undefined ${wl}suppress' ;;
+    darwin1.*)
+      _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
+    darwin*) # darwin 5.x on
+      # if running on 10.5 or later, the deployment target defaults
+      # to the OS version, if on x86, and 10.4, the deployment
+      # target defaults to 10.4. Don't you love it?
+      case ${MACOSX_DEPLOYMENT_TARGET-10.0},$host in
+	10.0,*86*-darwin8*|10.0,*-darwin[91]*)
+	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
+	10.[012][,.]*)
+	  _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
+	10.*)
+	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
+      esac
+    ;;
+  esac
+    if test "$lt_cv_apple_cc_single_mod" = "yes"; then
+      _lt_dar_single_mod='$single_module'
+    fi
+    if test "$lt_cv_ld_exported_symbols_list" = "yes"; then
+      _lt_dar_export_syms=' ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'
+    else
+      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/${libname}-symbols.expsym ${lib}'
+    fi
+    if test "$DSYMUTIL" != ":" && test "$lt_cv_ld_force_load" = "no"; then
+      _lt_dsymutil='~$DSYMUTIL $lib || :'
+    else
+      _lt_dsymutil=
+    fi
+    ;;
+  esac
+
+for ac_header in dlfcn.h
+do :
+  ac_fn_c_check_header_compile "$LINENO" "dlfcn.h" "ac_cv_header_dlfcn_h" "$ac_includes_default
+"
+if test "x$ac_cv_header_dlfcn_h" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_DLFCN_H 1
+_ACEOF
+
+fi
+
+done
+
+
+
+
+
+# Set options
+
+
+
+        enable_dlopen=no
+
+
+  enable_win32_dll=no
+
+
+            # Check whether --enable-shared was given.
+if test "${enable_shared+set}" = set; then :
+  enableval=$enable_shared; p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_shared=yes ;;
+    no) enable_shared=no ;;
+    *)
+      enable_shared=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_shared=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
+else
+  enable_shared=yes
+fi
+
+
+
+
+
+
+
+
+
+  # Check whether --enable-static was given.
+if test "${enable_static+set}" = set; then :
+  enableval=$enable_static; p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_static=yes ;;
+    no) enable_static=no ;;
+    *)
+     enable_static=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_static=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
+else
+  enable_static=yes
+fi
+
+
+
+
+
+
+
+
+
+
+# Check whether --with-pic was given.
+if test "${with_pic+set}" = set; then :
+  withval=$with_pic; pic_mode="$withval"
+else
+  pic_mode=default
+fi
+
+
+test -z "$pic_mode" && pic_mode=default
+
+
+
+
+
+
+
+  # Check whether --enable-fast-install was given.
+if test "${enable_fast_install+set}" = set; then :
+  enableval=$enable_fast_install; p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_fast_install=yes ;;
+    no) enable_fast_install=no ;;
+    *)
+      enable_fast_install=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_fast_install=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
+else
+  enable_fast_install=yes
+fi
+
+
+
+
+
+
+
+
+
+
+
+# This can be used to rebuild libtool when needed
+LIBTOOL_DEPS="$ltmain"
+
+# Always use our own libtool.
+LIBTOOL='$(SHELL) $(top_builddir)/libtool'
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+test -z "$LN_S" && LN_S="ln -s"
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+if test -n "${ZSH_VERSION+set}" ; then
+   setopt NO_GLOB_SUBST
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for objdir" >&5
+$as_echo_n "checking for objdir... " >&6; }
+if test "${lt_cv_objdir+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  rm -f .libs 2>/dev/null
+mkdir .libs 2>/dev/null
+if test -d .libs; then
+  lt_cv_objdir=.libs
+else
+  # MS-DOS does not allow filenames that begin with a dot.
+  lt_cv_objdir=_libs
+fi
+rmdir .libs 2>/dev/null
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_objdir" >&5
+$as_echo "$lt_cv_objdir" >&6; }
+objdir=$lt_cv_objdir
+
+
+
+
+
+cat >>confdefs.h <<_ACEOF
+#define LT_OBJDIR "$lt_cv_objdir/"
+_ACEOF
+
+
+
+
+case $host_os in
+aix3*)
+  # AIX sometimes has problems with the GCC collect2 program.  For some
+  # reason, if we set the COLLECT_NAMES environment variable, the problems
+  # vanish in a puff of smoke.
+  if test "X${COLLECT_NAMES+set}" != Xset; then
+    COLLECT_NAMES=
+    export COLLECT_NAMES
+  fi
+  ;;
+esac
+
+# Global variables:
+ofile=libtool
+can_build_shared=yes
+
+# All known linkers require a `.a' archive for static linking (except MSVC,
+# which needs '.lib').
+libext=a
+
+with_gnu_ld="$lt_cv_prog_gnu_ld"
+
+old_CC="$CC"
+old_CFLAGS="$CFLAGS"
+
+# Set sane defaults for various variables
+test -z "$CC" && CC=cc
+test -z "$LTCC" && LTCC=$CC
+test -z "$LTCFLAGS" && LTCFLAGS=$CFLAGS
+test -z "$LD" && LD=ld
+test -z "$ac_objext" && ac_objext=o
+
+for cc_temp in $compiler""; do
+  case $cc_temp in
+    compile | *[\\/]compile | ccache | *[\\/]ccache ) ;;
+    distcc | *[\\/]distcc | purify | *[\\/]purify ) ;;
+    \-*) ;;
+    *) break;;
+  esac
+done
+cc_basename=`$ECHO "$cc_temp" | $SED "s%.*/%%; s%^$host_alias-%%"`
+
+
+# Only perform the check for file, if the check method requires it
+test -z "$MAGIC_CMD" && MAGIC_CMD=file
+case $deplibs_check_method in
+file_magic*)
+  if test "$file_magic_cmd" = '$MAGIC_CMD'; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ${ac_tool_prefix}file" >&5
+$as_echo_n "checking for ${ac_tool_prefix}file... " >&6; }
+if test "${lt_cv_path_MAGIC_CMD+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $MAGIC_CMD in
+[\\/*] |  ?:[\\/]*)
+  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
+  ;;
+*)
+  lt_save_MAGIC_CMD="$MAGIC_CMD"
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  ac_dummy="/usr/bin$PATH_SEPARATOR$PATH"
+  for ac_dir in $ac_dummy; do
+    IFS="$lt_save_ifs"
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/${ac_tool_prefix}file; then
+      lt_cv_path_MAGIC_CMD="$ac_dir/${ac_tool_prefix}file"
+      if test -n "$file_magic_test_file"; then
+	case $deplibs_check_method in
+	"file_magic "*)
+	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
+	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
+	    $EGREP "$file_magic_regex" > /dev/null; then
+	    :
+	  else
+	    cat <<_LT_EOF 1>&2
+
+*** Warning: the command libtool uses to detect shared libraries,
+*** $file_magic_cmd, produces output that libtool cannot recognize.
+*** The result is that libtool may fail to recognize shared libraries
+*** as such.  This will affect the creation of libtool libraries that
+*** depend on shared libraries, but programs linked with such libtool
+*** libraries will work regardless of this problem.  Nevertheless, you
+*** may want to report the problem to your system manager and/or to
+*** bug-libtool@gnu.org
+
+_LT_EOF
+	  fi ;;
+	esac
+      fi
+      break
+    fi
+  done
+  IFS="$lt_save_ifs"
+  MAGIC_CMD="$lt_save_MAGIC_CMD"
+  ;;
+esac
+fi
+
+MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+if test -n "$MAGIC_CMD"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MAGIC_CMD" >&5
+$as_echo "$MAGIC_CMD" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+
+
+
+if test -z "$lt_cv_path_MAGIC_CMD"; then
+  if test -n "$ac_tool_prefix"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for file" >&5
+$as_echo_n "checking for file... " >&6; }
+if test "${lt_cv_path_MAGIC_CMD+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $MAGIC_CMD in
+[\\/*] |  ?:[\\/]*)
+  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
+  ;;
+*)
+  lt_save_MAGIC_CMD="$MAGIC_CMD"
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  ac_dummy="/usr/bin$PATH_SEPARATOR$PATH"
+  for ac_dir in $ac_dummy; do
+    IFS="$lt_save_ifs"
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/file; then
+      lt_cv_path_MAGIC_CMD="$ac_dir/file"
+      if test -n "$file_magic_test_file"; then
+	case $deplibs_check_method in
+	"file_magic "*)
+	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
+	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
+	    $EGREP "$file_magic_regex" > /dev/null; then
+	    :
+	  else
+	    cat <<_LT_EOF 1>&2
+
+*** Warning: the command libtool uses to detect shared libraries,
+*** $file_magic_cmd, produces output that libtool cannot recognize.
+*** The result is that libtool may fail to recognize shared libraries
+*** as such.  This will affect the creation of libtool libraries that
+*** depend on shared libraries, but programs linked with such libtool
+*** libraries will work regardless of this problem.  Nevertheless, you
+*** may want to report the problem to your system manager and/or to
+*** bug-libtool@gnu.org
+
+_LT_EOF
+	  fi ;;
+	esac
+      fi
+      break
+    fi
+  done
+  IFS="$lt_save_ifs"
+  MAGIC_CMD="$lt_save_MAGIC_CMD"
+  ;;
+esac
+fi
+
+MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+if test -n "$MAGIC_CMD"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MAGIC_CMD" >&5
+$as_echo "$MAGIC_CMD" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  else
+    MAGIC_CMD=:
+  fi
+fi
+
+  fi
+  ;;
+esac
+
+# Use C for the default configuration in the libtool script
+
+lt_save_CC="$CC"
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+# Source file extension for C test sources.
+ac_ext=c
+
+# Object file extension for compiled C test sources.
+objext=o
+objext=$objext
+
+# Code to be used in simple compile tests
+lt_simple_compile_test_code="int some_variable = 0;"
+
+# Code to be used in simple link tests
+lt_simple_link_test_code='int main(){return(0);}'
+
+
+
+
+
+
+
+# If no C compiler was specified, use CC.
+LTCC=${LTCC-"$CC"}
+
+# If no C compiler flags were specified, use CFLAGS.
+LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
+
+# Allow CC to be a program name with arguments.
+compiler=$CC
+
+# Save the default compiler, since it gets overwritten when the other
+# tags are being tested, and _LT_TAGVAR(compiler, []) is a NOP.
+compiler_DEFAULT=$CC
+
+# save warnings/boilerplate of simple test code
+ac_outfile=conftest.$ac_objext
+echo "$lt_simple_compile_test_code" >conftest.$ac_ext
+eval "$ac_compile" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_compiler_boilerplate=`cat conftest.err`
+$RM conftest*
+
+ac_outfile=conftest.$ac_objext
+echo "$lt_simple_link_test_code" >conftest.$ac_ext
+eval "$ac_link" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_linker_boilerplate=`cat conftest.err`
+$RM -r conftest*
+
+
+## CAVEAT EMPTOR:
+## There is no encapsulation within the following macros, do not change
+## the running order or otherwise move them around unless you know exactly
+## what you are doing...
+if test -n "$compiler"; then
+
+lt_prog_compiler_no_builtin_flag=
+
+if test "$GCC" = yes; then
+  case $cc_basename in
+  nvcc*)
+    lt_prog_compiler_no_builtin_flag=' -Xcompiler -fno-builtin' ;;
+  *)
+    lt_prog_compiler_no_builtin_flag=' -fno-builtin' ;;
+  esac
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -fno-rtti -fno-exceptions" >&5
+$as_echo_n "checking if $compiler supports -fno-rtti -fno-exceptions... " >&6; }
+if test "${lt_cv_prog_compiler_rtti_exceptions+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_rtti_exceptions=no
+   ac_outfile=conftest.$ac_objext
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+   lt_compiler_flag="-fno-rtti -fno-exceptions"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   # The option is referenced via a variable to avoid confusing sed.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>conftest.err)
+   ac_status=$?
+   cat conftest.err >&5
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s "$ac_outfile"; then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings other than the usual output.
+     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' >conftest.exp
+     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_rtti_exceptions=yes
+     fi
+   fi
+   $RM conftest*
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_rtti_exceptions" >&5
+$as_echo "$lt_cv_prog_compiler_rtti_exceptions" >&6; }
+
+if test x"$lt_cv_prog_compiler_rtti_exceptions" = xyes; then
+    lt_prog_compiler_no_builtin_flag="$lt_prog_compiler_no_builtin_flag -fno-rtti -fno-exceptions"
+else
+    :
+fi
+
+fi
+
+
+
+
+
+
+  lt_prog_compiler_wl=
+lt_prog_compiler_pic=
+lt_prog_compiler_static=
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $compiler option to produce PIC" >&5
+$as_echo_n "checking for $compiler option to produce PIC... " >&6; }
+
+  if test "$GCC" = yes; then
+    lt_prog_compiler_wl='-Wl,'
+    lt_prog_compiler_static='-static'
+
+    case $host_os in
+      aix*)
+      # All AIX code is PIC.
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	lt_prog_compiler_static='-Bstatic'
+      fi
+      lt_prog_compiler_pic='-fPIC'
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            lt_prog_compiler_pic='-fPIC'
+        ;;
+      m68k)
+            # FIXME: we need at least 68020 code to build shared libraries, but
+            # adding the `-m68020' flag to GCC prevents building anything better,
+            # like `-m68040'.
+            lt_prog_compiler_pic='-m68020 -resident32 -malways-restore-a4'
+        ;;
+      esac
+      ;;
+
+    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
+      # PIC is the default for these OSes.
+      ;;
+
+    mingw* | cygwin* | pw32* | os2* | cegcc*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      # Although the cygwin gcc ignores -fPIC, still need this for old-style
+      # (--disable-auto-import) libraries
+      lt_prog_compiler_pic='-DDLL_EXPORT'
+      ;;
+
+    darwin* | rhapsody*)
+      # PIC is the default on this platform
+      # Common symbols not allowed in MH_DYLIB files
+      lt_prog_compiler_pic='-fno-common'
+      ;;
+
+    haiku*)
+      # PIC is the default for Haiku.
+      # The "-static" flag exists, but is broken.
+      lt_prog_compiler_static=
+      ;;
+
+    hpux*)
+      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit
+      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag
+      # sets the default TLS model and affects inlining.
+      case $host_cpu in
+      hppa*64*)
+	# +Z the default
+	;;
+      *)
+	lt_prog_compiler_pic='-fPIC'
+	;;
+      esac
+      ;;
+
+    interix[3-9]*)
+      # Interix 3.x gcc -fpic/-fPIC options generate broken code.
+      # Instead, we relocate shared libraries at runtime.
+      ;;
+
+    msdosdjgpp*)
+      # Just because we use GCC doesn't mean we suddenly get shared libraries
+      # on systems that don't support them.
+      lt_prog_compiler_can_build_shared=no
+      enable_shared=no
+      ;;
+
+    *nto* | *qnx*)
+      # QNX uses GNU C++, but need to define -shared option too, otherwise
+      # it will coredump.
+      lt_prog_compiler_pic='-fPIC -shared'
+      ;;
+
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	lt_prog_compiler_pic=-Kconform_pic
+      fi
+      ;;
+
+    *)
+      lt_prog_compiler_pic='-fPIC'
+      ;;
+    esac
+
+    case $cc_basename in
+    nvcc*) # Cuda Compiler Driver 2.2
+      lt_prog_compiler_wl='-Xlinker '
+      lt_prog_compiler_pic='-Xcompiler -fPIC'
+      ;;
+    esac
+  else
+    # PORTME Check for flag to pass linker flags through the system compiler.
+    case $host_os in
+    aix*)
+      lt_prog_compiler_wl='-Wl,'
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	lt_prog_compiler_static='-Bstatic'
+      else
+	lt_prog_compiler_static='-bnso -bI:/lib/syscalls.exp'
+      fi
+      ;;
+
+    mingw* | cygwin* | pw32* | os2* | cegcc*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      lt_prog_compiler_pic='-DDLL_EXPORT'
+      ;;
+
+    hpux9* | hpux10* | hpux11*)
+      lt_prog_compiler_wl='-Wl,'
+      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but
+      # not for PA HP-UX.
+      case $host_cpu in
+      hppa*64*|ia64*)
+	# +Z the default
+	;;
+      *)
+	lt_prog_compiler_pic='+Z'
+	;;
+      esac
+      # Is there a better lt_prog_compiler_static that works with the bundled CC?
+      lt_prog_compiler_static='${wl}-a ${wl}archive'
+      ;;
+
+    irix5* | irix6* | nonstopux*)
+      lt_prog_compiler_wl='-Wl,'
+      # PIC (with -KPIC) is the default.
+      lt_prog_compiler_static='-non_shared'
+      ;;
+
+    linux* | k*bsd*-gnu | kopensolaris*-gnu)
+      case $cc_basename in
+      # old Intel for x86_64 which still supported -KPIC.
+      ecc*)
+	lt_prog_compiler_wl='-Wl,'
+	lt_prog_compiler_pic='-KPIC'
+	lt_prog_compiler_static='-static'
+        ;;
+      # icc used to be incompatible with GCC.
+      # ICC 10 doesn't accept -KPIC any more.
+      icc* | ifort*)
+	lt_prog_compiler_wl='-Wl,'
+	lt_prog_compiler_pic='-fPIC'
+	lt_prog_compiler_static='-static'
+        ;;
+      # Lahey Fortran 8.1.
+      lf95*)
+	lt_prog_compiler_wl='-Wl,'
+	lt_prog_compiler_pic='--shared'
+	lt_prog_compiler_static='--static'
+	;;
+      pgcc* | pgf77* | pgf90* | pgf95* | pgfortran*)
+        # Portland Group compilers (*not* the Pentium gcc compiler,
+	# which looks to be a dead project)
+	lt_prog_compiler_wl='-Wl,'
+	lt_prog_compiler_pic='-fpic'
+	lt_prog_compiler_static='-Bstatic'
+        ;;
+      ccc*)
+        lt_prog_compiler_wl='-Wl,'
+        # All Alpha code is PIC.
+        lt_prog_compiler_static='-non_shared'
+        ;;
+      xl* | bgxl* | bgf* | mpixl*)
+	# IBM XL C 8.0/Fortran 10.1, 11.1 on PPC and BlueGene
+	lt_prog_compiler_wl='-Wl,'
+	lt_prog_compiler_pic='-qpic'
+	lt_prog_compiler_static='-qstaticlink'
+	;;
+      *)
+	case `$CC -V 2>&1 | sed 5q` in
+	*Sun\ F* | *Sun*Fortran*)
+	  # Sun Fortran 8.3 passes all unrecognized flags to the linker
+	  lt_prog_compiler_pic='-KPIC'
+	  lt_prog_compiler_static='-Bstatic'
+	  lt_prog_compiler_wl=''
+	  ;;
+	*Sun\ C*)
+	  # Sun C 5.9
+	  lt_prog_compiler_pic='-KPIC'
+	  lt_prog_compiler_static='-Bstatic'
+	  lt_prog_compiler_wl='-Wl,'
+	  ;;
+	esac
+	;;
+      esac
+      ;;
+
+    newsos6)
+      lt_prog_compiler_pic='-KPIC'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
+
+    *nto* | *qnx*)
+      # QNX uses GNU C++, but need to define -shared option too, otherwise
+      # it will coredump.
+      lt_prog_compiler_pic='-fPIC -shared'
+      ;;
+
+    osf3* | osf4* | osf5*)
+      lt_prog_compiler_wl='-Wl,'
+      # All OSF/1 code is PIC.
+      lt_prog_compiler_static='-non_shared'
+      ;;
+
+    rdos*)
+      lt_prog_compiler_static='-non_shared'
+      ;;
+
+    solaris*)
+      lt_prog_compiler_pic='-KPIC'
+      lt_prog_compiler_static='-Bstatic'
+      case $cc_basename in
+      f77* | f90* | f95*)
+	lt_prog_compiler_wl='-Qoption ld ';;
+      *)
+	lt_prog_compiler_wl='-Wl,';;
+      esac
+      ;;
+
+    sunos4*)
+      lt_prog_compiler_wl='-Qoption ld '
+      lt_prog_compiler_pic='-PIC'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
+
+    sysv4 | sysv4.2uw2* | sysv4.3*)
+      lt_prog_compiler_wl='-Wl,'
+      lt_prog_compiler_pic='-KPIC'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
+
+    sysv4*MP*)
+      if test -d /usr/nec ;then
+	lt_prog_compiler_pic='-Kconform_pic'
+	lt_prog_compiler_static='-Bstatic'
+      fi
+      ;;
+
+    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
+      lt_prog_compiler_wl='-Wl,'
+      lt_prog_compiler_pic='-KPIC'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
+
+    unicos*)
+      lt_prog_compiler_wl='-Wl,'
+      lt_prog_compiler_can_build_shared=no
+      ;;
+
+    uts4*)
+      lt_prog_compiler_pic='-pic'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
+
+    *)
+      lt_prog_compiler_can_build_shared=no
+      ;;
+    esac
+  fi
+
+case $host_os in
+  # For platforms which do not support PIC, -DPIC is meaningless:
+  *djgpp*)
+    lt_prog_compiler_pic=
+    ;;
+  *)
+    lt_prog_compiler_pic="$lt_prog_compiler_pic -DPIC"
+    ;;
+esac
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_prog_compiler_pic" >&5
+$as_echo "$lt_prog_compiler_pic" >&6; }
+
+
+
+
+
+
+#
+# Check to make sure the PIC flag actually works.
+#
+if test -n "$lt_prog_compiler_pic"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler PIC flag $lt_prog_compiler_pic works" >&5
+$as_echo_n "checking if $compiler PIC flag $lt_prog_compiler_pic works... " >&6; }
+if test "${lt_cv_prog_compiler_pic_works+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_pic_works=no
+   ac_outfile=conftest.$ac_objext
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+   lt_compiler_flag="$lt_prog_compiler_pic -DPIC"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   # The option is referenced via a variable to avoid confusing sed.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>conftest.err)
+   ac_status=$?
+   cat conftest.err >&5
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s "$ac_outfile"; then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings other than the usual output.
+     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' >conftest.exp
+     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_pic_works=yes
+     fi
+   fi
+   $RM conftest*
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_pic_works" >&5
+$as_echo "$lt_cv_prog_compiler_pic_works" >&6; }
+
+if test x"$lt_cv_prog_compiler_pic_works" = xyes; then
+    case $lt_prog_compiler_pic in
+     "" | " "*) ;;
+     *) lt_prog_compiler_pic=" $lt_prog_compiler_pic" ;;
+     esac
+else
+    lt_prog_compiler_pic=
+     lt_prog_compiler_can_build_shared=no
+fi
+
+fi
+
+
+
+
+
+
+#
+# Check to make sure the static flag actually works.
+#
+wl=$lt_prog_compiler_wl eval lt_tmp_static_flag=\"$lt_prog_compiler_static\"
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler static flag $lt_tmp_static_flag works" >&5
+$as_echo_n "checking if $compiler static flag $lt_tmp_static_flag works... " >&6; }
+if test "${lt_cv_prog_compiler_static_works+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_static_works=no
+   save_LDFLAGS="$LDFLAGS"
+   LDFLAGS="$LDFLAGS $lt_tmp_static_flag"
+   echo "$lt_simple_link_test_code" > conftest.$ac_ext
+   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
+     # The linker can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     if test -s conftest.err; then
+       # Append any errors to the config.log.
+       cat conftest.err 1>&5
+       $ECHO "$_lt_linker_boilerplate" | $SED '/^$/d' > conftest.exp
+       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+       if diff conftest.exp conftest.er2 >/dev/null; then
+         lt_cv_prog_compiler_static_works=yes
+       fi
+     else
+       lt_cv_prog_compiler_static_works=yes
+     fi
+   fi
+   $RM -r conftest*
+   LDFLAGS="$save_LDFLAGS"
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_static_works" >&5
+$as_echo "$lt_cv_prog_compiler_static_works" >&6; }
+
+if test x"$lt_cv_prog_compiler_static_works" = xyes; then
+    :
+else
+    lt_prog_compiler_static=
+fi
+
+
+
+
+
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
+$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
+if test "${lt_cv_prog_compiler_c_o+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_c_o=no
+   $RM -r conftest 2>/dev/null
+   mkdir conftest
+   cd conftest
+   mkdir out
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+
+   lt_compiler_flag="-o out/conftest2.$ac_objext"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>out/conftest.err)
+   ac_status=$?
+   cat out/conftest.err >&5
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s out/conftest2.$ac_objext
+   then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' > out/conftest.exp
+     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
+     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_c_o=yes
+     fi
+   fi
+   chmod u+w . 2>&5
+   $RM conftest*
+   # SGI C++ compiler will create directory out/ii_files/ for
+   # template instantiation
+   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
+   $RM out/* && rmdir out
+   cd ..
+   $RM -r conftest
+   $RM conftest*
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_c_o" >&5
+$as_echo "$lt_cv_prog_compiler_c_o" >&6; }
+
+
+
+
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
+$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
+if test "${lt_cv_prog_compiler_c_o+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_c_o=no
+   $RM -r conftest 2>/dev/null
+   mkdir conftest
+   cd conftest
+   mkdir out
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+
+   lt_compiler_flag="-o out/conftest2.$ac_objext"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>out/conftest.err)
+   ac_status=$?
+   cat out/conftest.err >&5
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s out/conftest2.$ac_objext
+   then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' > out/conftest.exp
+     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
+     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_c_o=yes
+     fi
+   fi
+   chmod u+w . 2>&5
+   $RM conftest*
+   # SGI C++ compiler will create directory out/ii_files/ for
+   # template instantiation
+   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
+   $RM out/* && rmdir out
+   cd ..
+   $RM -r conftest
+   $RM conftest*
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_c_o" >&5
+$as_echo "$lt_cv_prog_compiler_c_o" >&6; }
+
+
+
+
+hard_links="nottested"
+if test "$lt_cv_prog_compiler_c_o" = no && test "$need_locks" != no; then
+  # do not overwrite the value of need_locks provided by the user
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if we can lock with hard links" >&5
+$as_echo_n "checking if we can lock with hard links... " >&6; }
+  hard_links=yes
+  $RM conftest*
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  touch conftest.a
+  ln conftest.a conftest.b 2>&5 || hard_links=no
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $hard_links" >&5
+$as_echo "$hard_links" >&6; }
+  if test "$hard_links" = no; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&5
+$as_echo "$as_me: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&2;}
+    need_locks=warn
+  fi
+else
+  need_locks=no
+fi
+
+
+
+
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the $compiler linker ($LD) supports shared libraries" >&5
+$as_echo_n "checking whether the $compiler linker ($LD) supports shared libraries... " >&6; }
+
+  runpath_var=
+  allow_undefined_flag=
+  always_export_symbols=no
+  archive_cmds=
+  archive_expsym_cmds=
+  compiler_needs_object=no
+  enable_shared_with_static_runtimes=no
+  export_dynamic_flag_spec=
+  export_symbols_cmds='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
+  hardcode_automatic=no
+  hardcode_direct=no
+  hardcode_direct_absolute=no
+  hardcode_libdir_flag_spec=
+  hardcode_libdir_flag_spec_ld=
+  hardcode_libdir_separator=
+  hardcode_minus_L=no
+  hardcode_shlibpath_var=unsupported
+  inherit_rpath=no
+  link_all_deplibs=unknown
+  module_cmds=
+  module_expsym_cmds=
+  old_archive_from_new_cmds=
+  old_archive_from_expsyms_cmds=
+  thread_safe_flag_spec=
+  whole_archive_flag_spec=
+  # include_expsyms should be a list of space-separated symbols to be *always*
+  # included in the symbol list
+  include_expsyms=
+  # exclude_expsyms can be an extended regexp of symbols to exclude
+  # it will be wrapped by ` (' and `)$', so one must not match beginning or
+  # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',
+  # as well as any symbol that contains `d'.
+  exclude_expsyms='_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*'
+  # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out
+  # platforms (ab)use it in PIC code, but their linkers get confused if
+  # the symbol is explicitly referenced.  Since portable code cannot
+  # rely on this symbol name, it's probably fine to never include it in
+  # preloaded symbol tables.
+  # Exclude shared library initialization/finalization symbols.
+  extract_expsyms_cmds=
+
+  case $host_os in
+  cygwin* | mingw* | pw32* | cegcc*)
+    # FIXME: the MSVC++ port hasn't been tested in a loooong time
+    # When not using gcc, we currently assume that we are using
+    # Microsoft Visual C++.
+    if test "$GCC" != yes; then
+      with_gnu_ld=no
+    fi
+    ;;
+  interix*)
+    # we just hope/assume this is gcc and not c89 (= MSVC++)
+    with_gnu_ld=yes
+    ;;
+  openbsd*)
+    with_gnu_ld=no
+    ;;
+  esac
+
+  ld_shlibs=yes
+
+  # On some targets, GNU ld is compatible enough with the native linker
+  # that we're better off using the native interface for both.
+  lt_use_gnu_ld_interface=no
+  if test "$with_gnu_ld" = yes; then
+    case $host_os in
+      aix*)
+	# The AIX port of GNU ld has always aspired to compatibility
+	# with the native linker.  However, as the warning in the GNU ld
+	# block says, versions before 2.19.5* couldn't really create working
+	# shared libraries, regardless of the interface used.
+	case `$LD -v 2>&1` in
+	  *\ \(GNU\ Binutils\)\ 2.19.5*) ;;
+	  *\ \(GNU\ Binutils\)\ 2.[2-9]*) ;;
+	  *\ \(GNU\ Binutils\)\ [3-9]*) ;;
+	  *)
+	    lt_use_gnu_ld_interface=yes
+	    ;;
+	esac
+	;;
+      *)
+	lt_use_gnu_ld_interface=yes
+	;;
+    esac
+  fi
+
+  if test "$lt_use_gnu_ld_interface" = yes; then
+    # If archive_cmds runs LD, not CC, wlarc should be empty
+    wlarc='${wl}'
+
+    # Set some defaults for GNU ld with shared library support. These
+    # are reset later if shared libraries are not supported. Putting them
+    # here allows them to be overridden if necessary.
+    runpath_var=LD_RUN_PATH
+    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+    export_dynamic_flag_spec='${wl}--export-dynamic'
+    # ancient GNU ld didn't support --whole-archive et. al.
+    if $LD --help 2>&1 | $GREP 'no-whole-archive' > /dev/null; then
+      whole_archive_flag_spec="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+    else
+      whole_archive_flag_spec=
+    fi
+    supports_anon_versioning=no
+    case `$LD -v 2>&1` in
+      *GNU\ gold*) supports_anon_versioning=yes ;;
+      *\ [01].* | *\ 2.[0-9].* | *\ 2.10.*) ;; # catch versions < 2.11
+      *\ 2.11.93.0.2\ *) supports_anon_versioning=yes ;; # RH7.3 ...
+      *\ 2.11.92.0.12\ *) supports_anon_versioning=yes ;; # Mandrake 8.2 ...
+      *\ 2.11.*) ;; # other 2.11 versions
+      *) supports_anon_versioning=yes ;;
+    esac
+
+    # See if GNU ld supports shared libraries.
+    case $host_os in
+    aix[3-9]*)
+      # On AIX/PPC, the GNU linker is very broken
+      if test "$host_cpu" != ia64; then
+	ld_shlibs=no
+	cat <<_LT_EOF 1>&2
+
+*** Warning: the GNU linker, at least up to release 2.19, is reported
+*** to be unable to reliably create shared libraries on AIX.
+*** Therefore, libtool is disabling shared libraries support.  If you
+*** really care for shared libraries, you may want to install binutils
+*** 2.20 or above, or modify your PATH so that a non-GNU linker is found.
+*** You will then need to restart the configuration process.
+
+_LT_EOF
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+            archive_expsym_cmds=''
+        ;;
+      m68k)
+            archive_cmds='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
+            hardcode_libdir_flag_spec='-L$libdir'
+            hardcode_minus_L=yes
+        ;;
+      esac
+      ;;
+
+    beos*)
+      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	allow_undefined_flag=unsupported
+	# Joseph Beckenbach <jrb3@best.com> says some releases of gcc
+	# support --undefined.  This deserves some investigation.  FIXME
+	archive_cmds='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+      else
+	ld_shlibs=no
+      fi
+      ;;
+
+    cygwin* | mingw* | pw32* | cegcc*)
+      # _LT_TAGVAR(hardcode_libdir_flag_spec, ) is actually meaningless,
+      # as there is no search path for DLLs.
+      hardcode_libdir_flag_spec='-L$libdir'
+      export_dynamic_flag_spec='${wl}--export-all-symbols'
+      allow_undefined_flag=unsupported
+      always_export_symbols=no
+      enable_shared_with_static_runtimes=yes
+      export_symbols_cmds='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[BCDGRS][ ]/s/.*[ ]\([^ ]*\)/\1 DATA/'\'' | $SED -e '\''/^[AITW][ ]/s/.*[ ]//'\'' | sort | uniq > $export_symbols'
+
+      if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then
+        archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+	# If the export-symbols file already is a .def file (1st line
+	# is EXPORTS), use it as is; otherwise, prepend...
+	archive_expsym_cmds='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
+	  cp $export_symbols $output_objdir/$soname.def;
+	else
+	  echo EXPORTS > $output_objdir/$soname.def;
+	  cat $export_symbols >> $output_objdir/$soname.def;
+	fi~
+	$CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+      else
+	ld_shlibs=no
+      fi
+      ;;
+
+    haiku*)
+      archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+      link_all_deplibs=yes
+      ;;
+
+    interix[3-9]*)
+      hardcode_direct=no
+      hardcode_shlibpath_var=no
+      hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+      export_dynamic_flag_spec='${wl}-E'
+      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
+      # Instead, shared libraries are loaded at an image base (0x10000000 by
+      # default) and relocated if they conflict, which is a slow very memory
+      # consuming and fragmenting process.  To avoid this, we pick a random,
+      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
+      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.
+      archive_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+      archive_expsym_cmds='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+      ;;
+
+    gnu* | linux* | tpf* | k*bsd*-gnu | kopensolaris*-gnu)
+      tmp_diet=no
+      if test "$host_os" = linux-dietlibc; then
+	case $cc_basename in
+	  diet\ *) tmp_diet=yes;;	# linux-dietlibc with static linking (!diet-dyn)
+	esac
+      fi
+      if $LD --help 2>&1 | $EGREP ': supported targets:.* elf' > /dev/null \
+	 && test "$tmp_diet" = no
+      then
+	tmp_addflag=' $pic_flag'
+	tmp_sharedflag='-shared'
+	case $cc_basename,$host_cpu in
+        pgcc*)				# Portland Group C compiler
+	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  tmp_addflag=' $pic_flag'
+	  ;;
+	pgf77* | pgf90* | pgf95* | pgfortran*)
+					# Portland Group f77 and f90 compilers
+	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  tmp_addflag=' $pic_flag -Mnomain' ;;
+	ecc*,ia64* | icc*,ia64*)	# Intel C compiler on ia64
+	  tmp_addflag=' -i_dynamic' ;;
+	efc*,ia64* | ifort*,ia64*)	# Intel Fortran compiler on ia64
+	  tmp_addflag=' -i_dynamic -nofor_main' ;;
+	ifc* | ifort*)			# Intel Fortran compiler
+	  tmp_addflag=' -nofor_main' ;;
+	lf95*)				# Lahey Fortran 8.1
+	  whole_archive_flag_spec=
+	  tmp_sharedflag='--shared' ;;
+	xl[cC]* | bgxl[cC]* | mpixl[cC]*) # IBM XL C 8.0 on PPC (deal with xlf below)
+	  tmp_sharedflag='-qmkshrobj'
+	  tmp_addflag= ;;
+	nvcc*)	# Cuda Compiler Driver 2.2
+	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  compiler_needs_object=yes
+	  ;;
+	esac
+	case `$CC -V 2>&1 | sed 5q` in
+	*Sun\ C*)			# Sun C 5.9
+	  whole_archive_flag_spec='${wl}--whole-archive`new_convenience=; for conv in $convenience\"\"; do test -z \"$conv\" || new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  compiler_needs_object=yes
+	  tmp_sharedflag='-G' ;;
+	*Sun\ F*)			# Sun Fortran 8.3
+	  tmp_sharedflag='-G' ;;
+	esac
+	archive_cmds='$CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+
+        if test "x$supports_anon_versioning" = xyes; then
+          archive_expsym_cmds='echo "{ global:" > $output_objdir/$libname.ver~
+	    cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+	    echo "local: *; };" >> $output_objdir/$libname.ver~
+	    $CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'
+        fi
+
+	case $cc_basename in
+	xlf* | bgf* | bgxlf* | mpixlf*)
+	  # IBM XL Fortran 10.1 on PPC cannot create shared libs itself
+	  whole_archive_flag_spec='--whole-archive$convenience --no-whole-archive'
+	  hardcode_libdir_flag_spec=
+	  hardcode_libdir_flag_spec_ld='-rpath $libdir'
+	  archive_cmds='$LD -shared $libobjs $deplibs $compiler_flags -soname $soname -o $lib'
+	  if test "x$supports_anon_versioning" = xyes; then
+	    archive_expsym_cmds='echo "{ global:" > $output_objdir/$libname.ver~
+	      cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+	      echo "local: *; };" >> $output_objdir/$libname.ver~
+	      $LD -shared $libobjs $deplibs $compiler_flags -soname $soname -version-script $output_objdir/$libname.ver -o $lib'
+	  fi
+	  ;;
+	esac
+      else
+        ld_shlibs=no
+      fi
+      ;;
+
+    netbsd*)
+      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+	archive_cmds='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'
+	wlarc=
+      else
+	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      fi
+      ;;
+
+    solaris*)
+      if $LD -v 2>&1 | $GREP 'BFD 2\.8' > /dev/null; then
+	ld_shlibs=no
+	cat <<_LT_EOF 1>&2
+
+*** Warning: The releases 2.8.* of the GNU linker cannot reliably
+*** create shared libraries on Solaris systems.  Therefore, libtool
+*** is disabling shared libraries support.  We urge you to upgrade GNU
+*** binutils to release 2.9.1 or newer.  Another option is to modify
+*** your PATH or compiler configuration so that the native linker is
+*** used, and then restart.
+
+_LT_EOF
+      elif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      else
+	ld_shlibs=no
+      fi
+      ;;
+
+    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)
+      case `$LD -v 2>&1` in
+        *\ [01].* | *\ 2.[0-9].* | *\ 2.1[0-5].*)
+	ld_shlibs=no
+	cat <<_LT_EOF 1>&2
+
+*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 can not
+*** reliably create shared libraries on SCO systems.  Therefore, libtool
+*** is disabling shared libraries support.  We urge you to upgrade GNU
+*** binutils to release 2.16.91.0.3 or newer.  Another option is to modify
+*** your PATH or compiler configuration so that the native linker is
+*** used, and then restart.
+
+_LT_EOF
+	;;
+	*)
+	  # For security reasons, it is highly recommended that you always
+	  # use absolute paths for naming shared libraries, and exclude the
+	  # DT_RUNPATH tag from executables and libraries.  But doing so
+	  # requires that you compile everything twice, which is a pain.
+	  if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+	    archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	    archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+	  else
+	    ld_shlibs=no
+	  fi
+	;;
+      esac
+      ;;
+
+    sunos4*)
+      archive_cmds='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+      wlarc=
+      hardcode_direct=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    *)
+      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      else
+	ld_shlibs=no
+      fi
+      ;;
+    esac
+
+    if test "$ld_shlibs" = no; then
+      runpath_var=
+      hardcode_libdir_flag_spec=
+      export_dynamic_flag_spec=
+      whole_archive_flag_spec=
+    fi
+  else
+    # PORTME fill in a description of your system's linker (not GNU ld)
+    case $host_os in
+    aix3*)
+      allow_undefined_flag=unsupported
+      always_export_symbols=yes
+      archive_expsym_cmds='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'
+      # Note: this linker hardcodes the directories in LIBPATH if there
+      # are no directories specified by -L.
+      hardcode_minus_L=yes
+      if test "$GCC" = yes && test -z "$lt_prog_compiler_static"; then
+	# Neither direct hardcoding nor static linking is supported with a
+	# broken collect2.
+	hardcode_direct=unsupported
+      fi
+      ;;
+
+    aix[4-9]*)
+      if test "$host_cpu" = ia64; then
+	# On IA64, the linker does run time linking by default, so we don't
+	# have to do anything special.
+	aix_use_runtimelinking=no
+	exp_sym_flag='-Bexport'
+	no_entry_flag=""
+      else
+	# If we're using GNU nm, then we don't want the "-C" option.
+	# -C means demangle to AIX nm, but means don't demangle with GNU nm
+	# Also, AIX nm treats weak defined symbols like other global
+	# defined symbols, whereas GNU nm marks them as "W".
+	if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then
+	  export_symbols_cmds='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B") || (\$ 2 == "W")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+	else
+	  export_symbols_cmds='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+	fi
+	aix_use_runtimelinking=no
+
+	# Test if we are trying to use run time linking or normal
+	# AIX style linking. If -brtl is somewhere in LDFLAGS, we
+	# need to do runtime linking.
+	case $host_os in aix4.[23]|aix4.[23].*|aix[5-9]*)
+	  for ld_flag in $LDFLAGS; do
+	  if (test $ld_flag = "-brtl" || test $ld_flag = "-Wl,-brtl"); then
+	    aix_use_runtimelinking=yes
+	    break
+	  fi
+	  done
+	  ;;
+	esac
+
+	exp_sym_flag='-bexport'
+	no_entry_flag='-bnoentry'
+      fi
+
+      # When large executables or shared objects are built, AIX ld can
+      # have problems creating the table of contents.  If linking a library
+      # or program results in "error TOC overflow" add -mminimal-toc to
+      # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not
+      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
+
+      archive_cmds=''
+      hardcode_direct=yes
+      hardcode_direct_absolute=yes
+      hardcode_libdir_separator=':'
+      link_all_deplibs=yes
+      file_list_spec='${wl}-f,'
+
+      if test "$GCC" = yes; then
+	case $host_os in aix4.[012]|aix4.[012].*)
+	# We only want to do this on AIX 4.2 and lower, the check
+	# below for broken collect2 doesn't work under 4.3+
+	  collect2name=`${CC} -print-prog-name=collect2`
+	  if test -f "$collect2name" &&
+	   strings "$collect2name" | $GREP resolve_lib_name >/dev/null
+	  then
+	  # We have reworked collect2
+	  :
+	  else
+	  # We have old collect2
+	  hardcode_direct=unsupported
+	  # It fails to find uninstalled libraries when the uninstalled
+	  # path is not listed in the libpath.  Setting hardcode_minus_L
+	  # to unsupported forces relinking
+	  hardcode_minus_L=yes
+	  hardcode_libdir_flag_spec='-L$libdir'
+	  hardcode_libdir_separator=
+	  fi
+	  ;;
+	esac
+	shared_flag='-shared'
+	if test "$aix_use_runtimelinking" = yes; then
+	  shared_flag="$shared_flag "'${wl}-G'
+	fi
+      else
+	# not using gcc
+	if test "$host_cpu" = ia64; then
+	# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release
+	# chokes on -Wl,-G. The following line is correct:
+	  shared_flag='-G'
+	else
+	  if test "$aix_use_runtimelinking" = yes; then
+	    shared_flag='${wl}-G'
+	  else
+	    shared_flag='${wl}-bM:SRE'
+	  fi
+	fi
+      fi
+
+      export_dynamic_flag_spec='${wl}-bexpall'
+      # It seems that -bexpall does not export symbols beginning with
+      # underscore (_), so it is better to generate a list of symbols to export.
+      always_export_symbols=yes
+      if test "$aix_use_runtimelinking" = yes; then
+	# Warning - without using the other runtime loading flags (-brtl),
+	# -berok will link without error, but may produce a broken library.
+	allow_undefined_flag='-berok'
+        # Determine the default libpath from the value encoded in an
+        # empty executable.
+        cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+
+lt_aix_libpath_sed='
+    /Import File Strings/,/^$/ {
+	/^0/ {
+	    s/^0  *\(.*\)$/\1/
+	    p
+	}
+    }'
+aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+# Check for a 64-bit object if we didn't find anything.
+if test -z "$aix_libpath"; then
+  aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+fi
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
+
+        hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
+        archive_expsym_cmds='$CC -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then func_echo_all "${wl}${allow_undefined_flag}"; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
+      else
+	if test "$host_cpu" = ia64; then
+	  hardcode_libdir_flag_spec='${wl}-R $libdir:/usr/lib:/lib'
+	  allow_undefined_flag="-z nodefs"
+	  archive_expsym_cmds="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
+	else
+	 # Determine the default libpath from the value encoded in an
+	 # empty executable.
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+
+lt_aix_libpath_sed='
+    /Import File Strings/,/^$/ {
+	/^0/ {
+	    s/^0  *\(.*\)$/\1/
+	    p
+	}
+    }'
+aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+# Check for a 64-bit object if we didn't find anything.
+if test -z "$aix_libpath"; then
+  aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+fi
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
+
+	 hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
+	  # Warning - without using the other run time loading flags,
+	  # -berok will link without error, but may produce a broken library.
+	  no_undefined_flag=' ${wl}-bernotok'
+	  allow_undefined_flag=' ${wl}-berok'
+	  if test "$with_gnu_ld" = yes; then
+	    # We only use this code for GNU lds that support --whole-archive.
+	    whole_archive_flag_spec='${wl}--whole-archive$convenience ${wl}--no-whole-archive'
+	  else
+	    # Exported symbols can be pulled into shared objects from archives
+	    whole_archive_flag_spec='$convenience'
+	  fi
+	  archive_cmds_need_lc=yes
+	  # This is similar to how AIX traditionally builds its shared libraries.
+	  archive_expsym_cmds="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
+	fi
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+            archive_expsym_cmds=''
+        ;;
+      m68k)
+            archive_cmds='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
+            hardcode_libdir_flag_spec='-L$libdir'
+            hardcode_minus_L=yes
+        ;;
+      esac
+      ;;
+
+    bsdi[45]*)
+      export_dynamic_flag_spec=-rdynamic
+      ;;
+
+    cygwin* | mingw* | pw32* | cegcc*)
+      # When not using gcc, we currently assume that we are using
+      # Microsoft Visual C++.
+      # hardcode_libdir_flag_spec is actually meaningless, as there is
+      # no search path for DLLs.
+      hardcode_libdir_flag_spec=' '
+      allow_undefined_flag=unsupported
+      # Tell ltmain to make .lib files, not .a files.
+      libext=lib
+      # Tell ltmain to make .dll files, not .so files.
+      shrext_cmds=".dll"
+      # FIXME: Setting linknames here is a bad hack.
+      archive_cmds='$CC -o $lib $libobjs $compiler_flags `func_echo_all "$deplibs" | $SED '\''s/ -lc$//'\''` -link -dll~linknames='
+      # The linker will automatically build a .lib file if we build a DLL.
+      old_archive_from_new_cmds='true'
+      # FIXME: Should let the user specify the lib program.
+      old_archive_cmds='lib -OUT:$oldlib$oldobjs$old_deplibs'
+      fix_srcfile_path='`cygpath -w "$srcfile"`'
+      enable_shared_with_static_runtimes=yes
+      ;;
+
+    darwin* | rhapsody*)
+
+
+  archive_cmds_need_lc=no
+  hardcode_direct=no
+  hardcode_automatic=yes
+  hardcode_shlibpath_var=unsupported
+  if test "$lt_cv_ld_force_load" = "yes"; then
+    whole_archive_flag_spec='`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience ${wl}-force_load,$conv\"; done; func_echo_all \"$new_convenience\"`'
+  else
+    whole_archive_flag_spec=''
+  fi
+  link_all_deplibs=yes
+  allow_undefined_flag="$_lt_dar_allow_undefined"
+  case $cc_basename in
+     ifort*) _lt_dar_can_shared=yes ;;
+     *) _lt_dar_can_shared=$GCC ;;
+  esac
+  if test "$_lt_dar_can_shared" = "yes"; then
+    output_verbose_link_cmd=func_echo_all
+    archive_cmds="\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring $_lt_dar_single_mod${_lt_dsymutil}"
+    module_cmds="\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dsymutil}"
+    archive_expsym_cmds="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}"
+    module_expsym_cmds="sed -e 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}"
+
+  else
+  ld_shlibs=no
+  fi
+
+      ;;
+
+    dgux*)
+      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_shlibpath_var=no
+      ;;
+
+    # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor
+    # support.  Future versions do this automatically, but an explicit c++rt0.o
+    # does not break anything, and helps significantly (at the cost of a little
+    # extra space).
+    freebsd2.2*)
+      archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    # Unfortunately, older versions of FreeBSD 2 do not have this feature.
+    freebsd2.*)
+      archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_direct=yes
+      hardcode_minus_L=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    # FreeBSD 3 and greater uses gcc -shared to do shared libraries.
+    freebsd* | dragonfly*)
+      archive_cmds='$CC -shared -o $lib $libobjs $deplibs $compiler_flags'
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    hpux9*)
+      if test "$GCC" = yes; then
+	archive_cmds='$RM $output_objdir/$soname~$CC -shared -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+      else
+	archive_cmds='$RM $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+      fi
+      hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+      hardcode_libdir_separator=:
+      hardcode_direct=yes
+
+      # hardcode_minus_L: Not really in the search PATH,
+      # but as the default location of the library.
+      hardcode_minus_L=yes
+      export_dynamic_flag_spec='${wl}-E'
+      ;;
+
+    hpux10*)
+      if test "$GCC" = yes && test "$with_gnu_ld" = no; then
+	archive_cmds='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'
+      fi
+      if test "$with_gnu_ld" = no; then
+	hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+	hardcode_libdir_flag_spec_ld='+b $libdir'
+	hardcode_libdir_separator=:
+	hardcode_direct=yes
+	hardcode_direct_absolute=yes
+	export_dynamic_flag_spec='${wl}-E'
+	# hardcode_minus_L: Not really in the search PATH,
+	# but as the default location of the library.
+	hardcode_minus_L=yes
+      fi
+      ;;
+
+    hpux11*)
+      if test "$GCC" = yes && test "$with_gnu_ld" = no; then
+	case $host_cpu in
+	hppa*64*)
+	  archive_cmds='$CC -shared ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	ia64*)
+	  archive_cmds='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+	  archive_cmds='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	esac
+      else
+	case $host_cpu in
+	hppa*64*)
+	  archive_cmds='$CC -b ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	ia64*)
+	  archive_cmds='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+
+	  # Older versions of the 11.00 compiler do not understand -b yet
+	  # (HP92453-01 A.11.01.20 doesn't, HP92453-01 B.11.X.35175-35176.GP does)
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $CC understands -b" >&5
+$as_echo_n "checking if $CC understands -b... " >&6; }
+if test "${lt_cv_prog_compiler__b+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler__b=no
+   save_LDFLAGS="$LDFLAGS"
+   LDFLAGS="$LDFLAGS -b"
+   echo "$lt_simple_link_test_code" > conftest.$ac_ext
+   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
+     # The linker can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     if test -s conftest.err; then
+       # Append any errors to the config.log.
+       cat conftest.err 1>&5
+       $ECHO "$_lt_linker_boilerplate" | $SED '/^$/d' > conftest.exp
+       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+       if diff conftest.exp conftest.er2 >/dev/null; then
+         lt_cv_prog_compiler__b=yes
+       fi
+     else
+       lt_cv_prog_compiler__b=yes
+     fi
+   fi
+   $RM -r conftest*
+   LDFLAGS="$save_LDFLAGS"
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler__b" >&5
+$as_echo "$lt_cv_prog_compiler__b" >&6; }
+
+if test x"$lt_cv_prog_compiler__b" = xyes; then
+    archive_cmds='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+else
+    archive_cmds='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'
+fi
+
+	  ;;
+	esac
+      fi
+      if test "$with_gnu_ld" = no; then
+	hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+	hardcode_libdir_separator=:
+
+	case $host_cpu in
+	hppa*64*|ia64*)
+	  hardcode_direct=no
+	  hardcode_shlibpath_var=no
+	  ;;
+	*)
+	  hardcode_direct=yes
+	  hardcode_direct_absolute=yes
+	  export_dynamic_flag_spec='${wl}-E'
+
+	  # hardcode_minus_L: Not really in the search PATH,
+	  # but as the default location of the library.
+	  hardcode_minus_L=yes
+	  ;;
+	esac
+      fi
+      ;;
+
+    irix5* | irix6* | nonstopux*)
+      if test "$GCC" = yes; then
+	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	# Try to use the -exported_symbol ld option, if it does not
+	# work, assume that -exports_file does not work either and
+	# implicitly export all symbols.
+        save_LDFLAGS="$LDFLAGS"
+        LDFLAGS="$LDFLAGS -shared ${wl}-exported_symbol ${wl}foo ${wl}-update_registry ${wl}/dev/null"
+        cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int foo(void) {}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations ${wl}-exports_file ${wl}$export_symbols -o $lib'
+
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+        LDFLAGS="$save_LDFLAGS"
+      else
+	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -exports_file $export_symbols -o $lib'
+      fi
+      archive_cmds_need_lc='no'
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      inherit_rpath=yes
+      link_all_deplibs=yes
+      ;;
+
+    netbsd*)
+      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+	archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out
+      else
+	archive_cmds='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF
+      fi
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    newsos6)
+      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_direct=yes
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      hardcode_shlibpath_var=no
+      ;;
+
+    *nto* | *qnx*)
+      ;;
+
+    openbsd*)
+      if test -f /usr/libexec/ld.so; then
+	hardcode_direct=yes
+	hardcode_shlibpath_var=no
+	hardcode_direct_absolute=yes
+	if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+	  archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+	  archive_expsym_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-retain-symbols-file,$export_symbols'
+	  hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+	  export_dynamic_flag_spec='${wl}-E'
+	else
+	  case $host_os in
+	   openbsd[01].* | openbsd2.[0-7] | openbsd2.[0-7].*)
+	     archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+	     hardcode_libdir_flag_spec='-R$libdir'
+	     ;;
+	   *)
+	     archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+	     hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+	     ;;
+	  esac
+	fi
+      else
+	ld_shlibs=no
+      fi
+      ;;
+
+    os2*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_minus_L=yes
+      allow_undefined_flag=unsupported
+      archive_cmds='$ECHO "LIBRARY $libname INITINSTANCE" > $output_objdir/$libname.def~$ECHO "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~echo DATA >> $output_objdir/$libname.def~echo " SINGLE NONSHARED" >> $output_objdir/$libname.def~echo EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'
+      old_archive_from_new_cmds='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'
+      ;;
+
+    osf3*)
+      if test "$GCC" = yes; then
+	allow_undefined_flag=' ${wl}-expect_unresolved ${wl}\*'
+	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+      else
+	allow_undefined_flag=' -expect_unresolved \*'
+	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+      fi
+      archive_cmds_need_lc='no'
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      ;;
+
+    osf4* | osf5*)	# as osf3* with the addition of -msym flag
+      if test "$GCC" = yes; then
+	allow_undefined_flag=' ${wl}-expect_unresolved ${wl}\*'
+	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      else
+	allow_undefined_flag=' -expect_unresolved \*'
+	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -msym -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+	archive_expsym_cmds='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done; printf "%s\\n" "-hidden">> $lib.exp~
+	$CC -shared${allow_undefined_flag} ${wl}-input ${wl}$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n "$verstring" && $ECHO "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib~$RM $lib.exp'
+
+	# Both c and cxx compiler support -rpath directly
+	hardcode_libdir_flag_spec='-rpath $libdir'
+      fi
+      archive_cmds_need_lc='no'
+      hardcode_libdir_separator=:
+      ;;
+
+    solaris*)
+      no_undefined_flag=' -z defs'
+      if test "$GCC" = yes; then
+	wlarc='${wl}'
+	archive_cmds='$CC -shared ${wl}-z ${wl}text ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	  $CC -shared ${wl}-z ${wl}text ${wl}-M ${wl}$lib.exp ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
+      else
+	case `$CC -V 2>&1` in
+	*"Compilers 5.0"*)
+	  wlarc=''
+	  archive_cmds='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	  $LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'
+	  ;;
+	*)
+	  wlarc='${wl}'
+	  archive_cmds='$CC -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $compiler_flags'
+	  archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	  $CC -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
+	  ;;
+	esac
+      fi
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_shlibpath_var=no
+      case $host_os in
+      solaris2.[0-5] | solaris2.[0-5].*) ;;
+      *)
+	# The compiler driver will combine and reorder linker options,
+	# but understands `-z linker_flag'.  GCC discards it without `$wl',
+	# but is careful enough not to reorder.
+	# Supported since Solaris 2.6 (maybe 2.5.1?)
+	if test "$GCC" = yes; then
+	  whole_archive_flag_spec='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'
+	else
+	  whole_archive_flag_spec='-z allextract$convenience -z defaultextract'
+	fi
+	;;
+      esac
+      link_all_deplibs=yes
+      ;;
+
+    sunos4*)
+      if test "x$host_vendor" = xsequent; then
+	# Use $CC to link under sequent, because it throws in some extra .o
+	# files that make .init and .fini sections work.
+	archive_cmds='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'
+      fi
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_direct=yes
+      hardcode_minus_L=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    sysv4)
+      case $host_vendor in
+	sni)
+	  archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  hardcode_direct=yes # is this really true???
+	;;
+	siemens)
+	  ## LD is ld it makes a PLAMLIB
+	  ## CC just makes a GrossModule.
+	  archive_cmds='$LD -G -o $lib $libobjs $deplibs $linker_flags'
+	  reload_cmds='$CC -r -o $output$reload_objs'
+	  hardcode_direct=no
+        ;;
+	motorola)
+	  archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  hardcode_direct=no #Motorola manual says yes, but my tests say they lie
+	;;
+      esac
+      runpath_var='LD_RUN_PATH'
+      hardcode_shlibpath_var=no
+      ;;
+
+    sysv4.3*)
+      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_shlibpath_var=no
+      export_dynamic_flag_spec='-Bexport'
+      ;;
+
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	hardcode_shlibpath_var=no
+	runpath_var=LD_RUN_PATH
+	hardcode_runpath_var=yes
+	ld_shlibs=yes
+      fi
+      ;;
+
+    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[01].[10]* | unixware7* | sco3.2v5.0.[024]*)
+      no_undefined_flag='${wl}-z,text'
+      archive_cmds_need_lc=no
+      hardcode_shlibpath_var=no
+      runpath_var='LD_RUN_PATH'
+
+      if test "$GCC" = yes; then
+	archive_cmds='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      fi
+      ;;
+
+    sysv5* | sco3.2v5* | sco5v6*)
+      # Note: We can NOT use -z defs as we might desire, because we do not
+      # link with -lc, and that would cause any symbols used from libc to
+      # always be unresolved, which means just about no library would
+      # ever link correctly.  If we're not using GNU ld we use -z text
+      # though, which does catch some bad symbols but isn't as heavy-handed
+      # as -z defs.
+      no_undefined_flag='${wl}-z,text'
+      allow_undefined_flag='${wl}-z,nodefs'
+      archive_cmds_need_lc=no
+      hardcode_shlibpath_var=no
+      hardcode_libdir_flag_spec='${wl}-R,$libdir'
+      hardcode_libdir_separator=':'
+      link_all_deplibs=yes
+      export_dynamic_flag_spec='${wl}-Bexport'
+      runpath_var='LD_RUN_PATH'
+
+      if test "$GCC" = yes; then
+	archive_cmds='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      fi
+      ;;
+
+    uts4*)
+      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_shlibpath_var=no
+      ;;
+
+    *)
+      ld_shlibs=no
+      ;;
+    esac
+
+    if test x$host_vendor = xsni; then
+      case $host in
+      sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
+	export_dynamic_flag_spec='${wl}-Blargedynsym'
+	;;
+      esac
+    fi
+  fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ld_shlibs" >&5
+$as_echo "$ld_shlibs" >&6; }
+test "$ld_shlibs" = no && can_build_shared=no
+
+with_gnu_ld=$with_gnu_ld
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#
+# Do we need to explicitly link libc?
+#
+case "x$archive_cmds_need_lc" in
+x|xyes)
+  # Assume -lc should be added
+  archive_cmds_need_lc=yes
+
+  if test "$enable_shared" = yes && test "$GCC" = yes; then
+    case $archive_cmds in
+    *'~'*)
+      # FIXME: we may have to deal with multi-command sequences.
+      ;;
+    '$CC '*)
+      # Test whether the compiler implicitly links with -lc since on some
+      # systems, -lgcc has to come before -lc. If gcc already passes -lc
+      # to ld, don't add -lc before -lgcc.
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -lc should be explicitly linked in" >&5
+$as_echo_n "checking whether -lc should be explicitly linked in... " >&6; }
+if test "${lt_cv_archive_cmds_need_lc+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  $RM conftest*
+	echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+
+	if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } 2>conftest.err; then
+	  soname=conftest
+	  lib=conftest
+	  libobjs=conftest.$ac_objext
+	  deplibs=
+	  wl=$lt_prog_compiler_wl
+	  pic_flag=$lt_prog_compiler_pic
+	  compiler_flags=-v
+	  linker_flags=-v
+	  verstring=
+	  output_objdir=.
+	  libname=conftest
+	  lt_save_allow_undefined_flag=$allow_undefined_flag
+	  allow_undefined_flag=
+	  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$archive_cmds 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1\""; } >&5
+  (eval $archive_cmds 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+	  then
+	    lt_cv_archive_cmds_need_lc=no
+	  else
+	    lt_cv_archive_cmds_need_lc=yes
+	  fi
+	  allow_undefined_flag=$lt_save_allow_undefined_flag
+	else
+	  cat conftest.err 1>&5
+	fi
+	$RM conftest*
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_archive_cmds_need_lc" >&5
+$as_echo "$lt_cv_archive_cmds_need_lc" >&6; }
+      archive_cmds_need_lc=$lt_cv_archive_cmds_need_lc
+      ;;
+    esac
+  fi
+  ;;
+esac
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking dynamic linker characteristics" >&5
+$as_echo_n "checking dynamic linker characteristics... " >&6; }
+
+if test "$GCC" = yes; then
+  case $host_os in
+    darwin*) lt_awk_arg="/^libraries:/,/LR/" ;;
+    *) lt_awk_arg="/^libraries:/" ;;
+  esac
+  case $host_os in
+    mingw* | cegcc*) lt_sed_strip_eq="s,=\([A-Za-z]:\),\1,g" ;;
+    *) lt_sed_strip_eq="s,=/,/,g" ;;
+  esac
+  lt_search_path_spec=`$CC -print-search-dirs | awk $lt_awk_arg | $SED -e "s/^libraries://" -e $lt_sed_strip_eq`
+  case $lt_search_path_spec in
+  *\;*)
+    # if the path contains ";" then we assume it to be the separator
+    # otherwise default to the standard path separator (i.e. ":") - it is
+    # assumed that no part of a normal pathname contains ";" but that should
+    # okay in the real world where ";" in dirpaths is itself problematic.
+    lt_search_path_spec=`$ECHO "$lt_search_path_spec" | $SED 's/;/ /g'`
+    ;;
+  *)
+    lt_search_path_spec=`$ECHO "$lt_search_path_spec" | $SED "s/$PATH_SEPARATOR/ /g"`
+    ;;
+  esac
+  # Ok, now we have the path, separated by spaces, we can step through it
+  # and add multilib dir if necessary.
+  lt_tmp_lt_search_path_spec=
+  lt_multi_os_dir=`$CC $CPPFLAGS $CFLAGS $LDFLAGS -print-multi-os-directory 2>/dev/null`
+  for lt_sys_path in $lt_search_path_spec; do
+    if test -d "$lt_sys_path/$lt_multi_os_dir"; then
+      lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path/$lt_multi_os_dir"
+    else
+      test -d "$lt_sys_path" && \
+	lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path"
+    fi
+  done
+  lt_search_path_spec=`$ECHO "$lt_tmp_lt_search_path_spec" | awk '
+BEGIN {RS=" "; FS="/|\n";} {
+  lt_foo="";
+  lt_count=0;
+  for (lt_i = NF; lt_i > 0; lt_i--) {
+    if ($lt_i != "" && $lt_i != ".") {
+      if ($lt_i == "..") {
+        lt_count++;
+      } else {
+        if (lt_count == 0) {
+          lt_foo="/" $lt_i lt_foo;
+        } else {
+          lt_count--;
+        }
+      }
+    }
+  }
+  if (lt_foo != "") { lt_freq[lt_foo]++; }
+  if (lt_freq[lt_foo] == 1) { print lt_foo; }
+}'`
+  # AWK program above erroneously prepends '/' to C:/dos/paths
+  # for these hosts.
+  case $host_os in
+    mingw* | cegcc*) lt_search_path_spec=`$ECHO "$lt_search_path_spec" |\
+      $SED 's,/\([A-Za-z]:\),\1,g'` ;;
+  esac
+  sys_lib_search_path_spec=`$ECHO "$lt_search_path_spec" | $lt_NL2SP`
+else
+  sys_lib_search_path_spec="/lib /usr/lib /usr/local/lib"
+fi
+library_names_spec=
+libname_spec='lib$name'
+soname_spec=
+shrext_cmds=".so"
+postinstall_cmds=
+postuninstall_cmds=
+finish_cmds=
+finish_eval=
+shlibpath_var=
+shlibpath_overrides_runpath=unknown
+version_type=none
+dynamic_linker="$host_os ld.so"
+sys_lib_dlsearch_path_spec="/lib /usr/lib"
+need_lib_prefix=unknown
+hardcode_into_libs=no
+
+# when you set need_version to no, make sure it does not cause -set_version
+# flags to be left without arguments
+need_version=unknown
+
+case $host_os in
+aix3*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'
+  shlibpath_var=LIBPATH
+
+  # AIX 3 has no versioning support, so we append a major version to the name.
+  soname_spec='${libname}${release}${shared_ext}$major'
+  ;;
+
+aix[4-9]*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  hardcode_into_libs=yes
+  if test "$host_cpu" = ia64; then
+    # AIX 5 supports IA64
+    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
+    shlibpath_var=LD_LIBRARY_PATH
+  else
+    # With GCC up to 2.95.x, collect2 would create an import file
+    # for dependence libraries.  The import file would start with
+    # the line `#! .'.  This would cause the generated library to
+    # depend on `.', always an invalid library.  This was fixed in
+    # development snapshots of GCC prior to 3.0.
+    case $host_os in
+      aix4 | aix4.[01] | aix4.[01].*)
+      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'
+	   echo ' yes '
+	   echo '#endif'; } | ${CC} -E - | $GREP yes > /dev/null; then
+	:
+      else
+	can_build_shared=no
+      fi
+      ;;
+    esac
+    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct
+    # soname into executable. Probably we can add versioning support to
+    # collect2, so additional links can be useful in future.
+    if test "$aix_use_runtimelinking" = yes; then
+      # If using run time linking (on AIX 4.2 or later) use lib<name>.so
+      # instead of lib<name>.a to let people know that these are not
+      # typical AIX shared libraries.
+      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    else
+      # We preserve .a as extension for shared libraries through AIX4.2
+      # and later when we are not doing run time linking.
+      library_names_spec='${libname}${release}.a $libname.a'
+      soname_spec='${libname}${release}${shared_ext}$major'
+    fi
+    shlibpath_var=LIBPATH
+  fi
+  ;;
+
+amigaos*)
+  case $host_cpu in
+  powerpc)
+    # Since July 2007 AmigaOS4 officially supports .so libraries.
+    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    ;;
+  m68k)
+    library_names_spec='$libname.ixlibrary $libname.a'
+    # Create ${libname}_ixlibrary.a entries in /sys/libs.
+    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`func_echo_all "$lib" | $SED '\''s%^.*/\([^/]*\)\.ixlibrary$%\1%'\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show "cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'
+    ;;
+  esac
+  ;;
+
+beos*)
+  library_names_spec='${libname}${shared_ext}'
+  dynamic_linker="$host_os ld.so"
+  shlibpath_var=LIBRARY_PATH
+  ;;
+
+bsdi[45]*)
+  version_type=linux
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib"
+  sys_lib_dlsearch_path_spec="/shlib /usr/lib /usr/local/lib"
+  # the default ld.so.conf also contains /usr/contrib/lib and
+  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow
+  # libtool to hard-code these into programs
+  ;;
+
+cygwin* | mingw* | pw32* | cegcc*)
+  version_type=windows
+  shrext_cmds=".dll"
+  need_version=no
+  need_lib_prefix=no
+
+  case $GCC,$host_os in
+  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+    library_names_spec='$libname.dll.a'
+    # DLL is installed to $(libdir)/../bin by postinstall_cmds
+    postinstall_cmds='base_file=`basename \${file}`~
+      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i; echo \$dlname'\''`~
+      dldir=$destdir/`dirname \$dlpath`~
+      test -d \$dldir || mkdir -p \$dldir~
+      $install_prog $dir/$dlname \$dldir/$dlname~
+      chmod a+x \$dldir/$dlname~
+      if test -n '\''$stripme'\'' && test -n '\''$striplib'\''; then
+        eval '\''$striplib \$dldir/$dlname'\'' || exit \$?;
+      fi'
+    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\''. $file; echo \$dlname'\''`~
+      dlpath=$dir/\$dldll~
+       $RM \$dlpath'
+    shlibpath_overrides_runpath=yes
+
+    case $host_os in
+    cygwin*)
+      # Cygwin DLLs use 'cyg' prefix rather than 'lib'
+      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+
+      sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/lib/w32api"
+      ;;
+    mingw* | cegcc*)
+      # MinGW DLLs use traditional 'lib' prefix
+      soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      ;;
+    pw32*)
+      # pw32 DLLs use 'pw' prefix rather than 'lib'
+      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      ;;
+    esac
+    ;;
+
+  *)
+    library_names_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext} $libname.lib'
+    ;;
+  esac
+  dynamic_linker='Win32 ld.exe'
+  # FIXME: first we should search . and the directory the executable is in
+  shlibpath_var=PATH
+  ;;
+
+darwin* | rhapsody*)
+  dynamic_linker="$host_os dyld"
+  version_type=darwin
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'
+  soname_spec='${libname}${release}${major}$shared_ext'
+  shlibpath_overrides_runpath=yes
+  shlibpath_var=DYLD_LIBRARY_PATH
+  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'
+
+  sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/local/lib"
+  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'
+  ;;
+
+dgux*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+freebsd* | dragonfly*)
+  # DragonFly does not have aout.  When/if they implement a new
+  # versioning mechanism, adjust this.
+  if test -x /usr/bin/objformat; then
+    objformat=`/usr/bin/objformat`
+  else
+    case $host_os in
+    freebsd[23].*) objformat=aout ;;
+    *) objformat=elf ;;
+    esac
+  fi
+  version_type=freebsd-$objformat
+  case $version_type in
+    freebsd-elf*)
+      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+      need_version=no
+      need_lib_prefix=no
+      ;;
+    freebsd-*)
+      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'
+      need_version=yes
+      ;;
+  esac
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_os in
+  freebsd2.*)
+    shlibpath_overrides_runpath=yes
+    ;;
+  freebsd3.[01]* | freebsdelf3.[01]*)
+    shlibpath_overrides_runpath=yes
+    hardcode_into_libs=yes
+    ;;
+  freebsd3.[2-9]* | freebsdelf3.[2-9]* | \
+  freebsd4.[0-5] | freebsdelf4.[0-5] | freebsd4.1.1 | freebsdelf4.1.1)
+    shlibpath_overrides_runpath=no
+    hardcode_into_libs=yes
+    ;;
+  *) # from 4.6 on, and DragonFly
+    shlibpath_overrides_runpath=yes
+    hardcode_into_libs=yes
+    ;;
+  esac
+  ;;
+
+gnu*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  hardcode_into_libs=yes
+  ;;
+
+haiku*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  dynamic_linker="$host_os runtime_loader"
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  sys_lib_dlsearch_path_spec='/boot/home/config/lib /boot/common/lib /boot/beos/system/lib'
+  hardcode_into_libs=yes
+  ;;
+
+hpux9* | hpux10* | hpux11*)
+  # Give a soname corresponding to the major version so that dld.sl refuses to
+  # link against other versions.
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  case $host_cpu in
+  ia64*)
+    shrext_cmds='.so'
+    hardcode_into_libs=yes
+    dynamic_linker="$host_os dld.so"
+    shlibpath_var=LD_LIBRARY_PATH
+    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    if test "X$HPUX_IA64_MODE" = X32; then
+      sys_lib_search_path_spec="/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib"
+    else
+      sys_lib_search_path_spec="/usr/lib/hpux64 /usr/local/lib/hpux64"
+    fi
+    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+    ;;
+  hppa*64*)
+    shrext_cmds='.sl'
+    hardcode_into_libs=yes
+    dynamic_linker="$host_os dld.sl"
+    shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH
+    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    sys_lib_search_path_spec="/usr/lib/pa20_64 /usr/ccs/lib/pa20_64"
+    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+    ;;
+  *)
+    shrext_cmds='.sl'
+    dynamic_linker="$host_os dld.sl"
+    shlibpath_var=SHLIB_PATH
+    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    ;;
+  esac
+  # HP-UX runs *really* slowly unless shared libraries are mode 555, ...
+  postinstall_cmds='chmod 555 $lib'
+  # or fails outright, so override atomically:
+  install_override_mode=555
+  ;;
+
+interix[3-9]*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  ;;
+
+irix5* | irix6* | nonstopux*)
+  case $host_os in
+    nonstopux*) version_type=nonstopux ;;
+    *)
+	if test "$lt_cv_prog_gnu_ld" = yes; then
+		version_type=linux
+	else
+		version_type=irix
+	fi ;;
+  esac
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'
+  case $host_os in
+  irix5* | nonstopux*)
+    libsuff= shlibsuff=
+    ;;
+  *)
+    case $LD in # libtool.m4 will add one of these switches to LD
+    *-32|*"-32 "|*-melf32bsmip|*"-melf32bsmip ")
+      libsuff= shlibsuff= libmagic=32-bit;;
+    *-n32|*"-n32 "|*-melf32bmipn32|*"-melf32bmipn32 ")
+      libsuff=32 shlibsuff=N32 libmagic=N32;;
+    *-64|*"-64 "|*-melf64bmip|*"-melf64bmip ")
+      libsuff=64 shlibsuff=64 libmagic=64-bit;;
+    *) libsuff= shlibsuff= libmagic=never-match;;
+    esac
+    ;;
+  esac
+  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH
+  shlibpath_overrides_runpath=no
+  sys_lib_search_path_spec="/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}"
+  sys_lib_dlsearch_path_spec="/usr/lib${libsuff} /lib${libsuff}"
+  hardcode_into_libs=yes
+  ;;
+
+# No shared lib support for Linux oldld, aout, or coff.
+linux*oldld* | linux*aout* | linux*coff*)
+  dynamic_linker=no
+  ;;
+
+# This must be Linux ELF.
+linux* | k*bsd*-gnu | kopensolaris*-gnu)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -n $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+
+  # Some binutils ld are patched to set DT_RUNPATH
+  if test "${lt_cv_shlibpath_overrides_runpath+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_shlibpath_overrides_runpath=no
+    save_LDFLAGS=$LDFLAGS
+    save_libdir=$libdir
+    eval "libdir=/foo; wl=\"$lt_prog_compiler_wl\"; \
+	 LDFLAGS=\"\$LDFLAGS $hardcode_libdir_flag_spec\""
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  if  ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep "RUNPATH.*$libdir" >/dev/null; then :
+  lt_cv_shlibpath_overrides_runpath=yes
+fi
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+    LDFLAGS=$save_LDFLAGS
+    libdir=$save_libdir
+
+fi
+
+  shlibpath_overrides_runpath=$lt_cv_shlibpath_overrides_runpath
+
+  # This implies no fast_install, which is unacceptable.
+  # Some rework will be needed to allow for fast_install
+  # before this can be enabled.
+  hardcode_into_libs=yes
+
+  # Append ld.so.conf contents to the search path
+  if test -f /etc/ld.so.conf; then
+    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;s/"//g;/^$/d' | tr '\n' ' '`
+    sys_lib_dlsearch_path_spec="/lib /usr/lib $lt_ld_extra"
+  fi
+
+  # We used to test for /lib/ld.so.1 and disable shared libraries on
+  # powerpc, because MkLinux only supported shared libraries with the
+  # GNU dynamic linker.  Since this was broken with cross compilers,
+  # most powerpc-linux boxes support dynamic linking these days and
+  # people can always --disable-shared, the test was removed, and we
+  # assume the GNU/Linux dynamic linker is in use.
+  dynamic_linker='GNU/Linux ld.so'
+  ;;
+
+netbsd*)
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+    finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+    dynamic_linker='NetBSD (a.out) ld.so'
+  else
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    dynamic_linker='NetBSD ld.elf_so'
+  fi
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  ;;
+
+newsos6)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  ;;
+
+*nto* | *qnx*)
+  version_type=qnx
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  dynamic_linker='ldqnx.so'
+  ;;
+
+openbsd*)
+  version_type=sunos
+  sys_lib_dlsearch_path_spec="/usr/lib"
+  need_lib_prefix=no
+  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.
+  case $host_os in
+    openbsd3.3 | openbsd3.3.*)	need_version=yes ;;
+    *)				need_version=no  ;;
+  esac
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+    case $host_os in
+      openbsd2.[89] | openbsd2.[89].*)
+	shlibpath_overrides_runpath=no
+	;;
+      *)
+	shlibpath_overrides_runpath=yes
+	;;
+      esac
+  else
+    shlibpath_overrides_runpath=yes
+  fi
+  ;;
+
+os2*)
+  libname_spec='$name'
+  shrext_cmds=".dll"
+  need_lib_prefix=no
+  library_names_spec='$libname${shared_ext} $libname.a'
+  dynamic_linker='OS/2 ld.exe'
+  shlibpath_var=LIBPATH
+  ;;
+
+osf3* | osf4* | osf5*)
+  version_type=osf
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib"
+  sys_lib_dlsearch_path_spec="$sys_lib_search_path_spec"
+  ;;
+
+rdos*)
+  dynamic_linker=no
+  ;;
+
+solaris*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  # ldd complains unless libraries are executable
+  postinstall_cmds='chmod +x $lib'
+  ;;
+
+sunos4*)
+  version_type=sunos
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  finish_cmds='PATH="\$PATH:/usr/etc" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  if test "$with_gnu_ld" = yes; then
+    need_lib_prefix=no
+  fi
+  need_version=yes
+  ;;
+
+sysv4 | sysv4.3*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_vendor in
+    sni)
+      shlibpath_overrides_runpath=no
+      need_lib_prefix=no
+      runpath_var=LD_RUN_PATH
+      ;;
+    siemens)
+      need_lib_prefix=no
+      ;;
+    motorola)
+      need_lib_prefix=no
+      need_version=no
+      shlibpath_overrides_runpath=no
+      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'
+      ;;
+  esac
+  ;;
+
+sysv4*MP*)
+  if test -d /usr/nec ;then
+    version_type=linux
+    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'
+    soname_spec='$libname${shared_ext}.$major'
+    shlibpath_var=LD_LIBRARY_PATH
+  fi
+  ;;
+
+sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+  version_type=freebsd-elf
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  if test "$with_gnu_ld" = yes; then
+    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'
+  else
+    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'
+    case $host_os in
+      sco3.2v5*)
+        sys_lib_search_path_spec="$sys_lib_search_path_spec /lib"
+	;;
+    esac
+  fi
+  sys_lib_dlsearch_path_spec='/usr/lib'
+  ;;
+
+tpf*)
+  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  ;;
+
+uts4*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+*)
+  dynamic_linker=no
+  ;;
+esac
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $dynamic_linker" >&5
+$as_echo "$dynamic_linker" >&6; }
+test "$dynamic_linker" = no && can_build_shared=no
+
+variables_saved_for_relink="PATH $shlibpath_var $runpath_var"
+if test "$GCC" = yes; then
+  variables_saved_for_relink="$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"
+fi
+
+if test "${lt_cv_sys_lib_search_path_spec+set}" = set; then
+  sys_lib_search_path_spec="$lt_cv_sys_lib_search_path_spec"
+fi
+if test "${lt_cv_sys_lib_dlsearch_path_spec+set}" = set; then
+  sys_lib_dlsearch_path_spec="$lt_cv_sys_lib_dlsearch_path_spec"
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking how to hardcode library paths into programs" >&5
+$as_echo_n "checking how to hardcode library paths into programs... " >&6; }
+hardcode_action=
+if test -n "$hardcode_libdir_flag_spec" ||
+   test -n "$runpath_var" ||
+   test "X$hardcode_automatic" = "Xyes" ; then
+
+  # We can hardcode non-existent directories.
+  if test "$hardcode_direct" != no &&
+     # If the only mechanism to avoid hardcoding is shlibpath_var, we
+     # have to relink, otherwise we might link with an installed library
+     # when we should be linking with a yet-to-be-installed one
+     ## test "$_LT_TAGVAR(hardcode_shlibpath_var, )" != no &&
+     test "$hardcode_minus_L" != no; then
+    # Linking always hardcodes the temporary library directory.
+    hardcode_action=relink
+  else
+    # We can link without hardcoding, and we can hardcode nonexisting dirs.
+    hardcode_action=immediate
+  fi
+else
+  # We cannot hardcode anything, or else we can only hardcode existing
+  # directories.
+  hardcode_action=unsupported
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $hardcode_action" >&5
+$as_echo "$hardcode_action" >&6; }
+
+if test "$hardcode_action" = relink ||
+   test "$inherit_rpath" = yes; then
+  # Fast installation is not supported
+  enable_fast_install=no
+elif test "$shlibpath_overrides_runpath" = yes ||
+     test "$enable_shared" = no; then
+  # Fast installation is not necessary
+  enable_fast_install=needless
+fi
+
+
+
+
+
+
+  if test "x$enable_dlopen" != xyes; then
+  enable_dlopen=unknown
+  enable_dlopen_self=unknown
+  enable_dlopen_self_static=unknown
+else
+  lt_cv_dlopen=no
+  lt_cv_dlopen_libs=
+
+  case $host_os in
+  beos*)
+    lt_cv_dlopen="load_add_on"
+    lt_cv_dlopen_libs=
+    lt_cv_dlopen_self=yes
+    ;;
+
+  mingw* | pw32* | cegcc*)
+    lt_cv_dlopen="LoadLibrary"
+    lt_cv_dlopen_libs=
+    ;;
+
+  cygwin*)
+    lt_cv_dlopen="dlopen"
+    lt_cv_dlopen_libs=
+    ;;
+
+  darwin*)
+  # if libdl is installed we need to link against it
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -ldl" >&5
+$as_echo_n "checking for dlopen in -ldl... " >&6; }
+if test "${ac_cv_lib_dl_dlopen+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldl  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dlopen ();
+int
+main ()
+{
+return dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_dl_dlopen=yes
+else
+  ac_cv_lib_dl_dlopen=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dl_dlopen" >&5
+$as_echo "$ac_cv_lib_dl_dlopen" >&6; }
+if test "x$ac_cv_lib_dl_dlopen" = x""yes; then :
+  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"
+else
+
+    lt_cv_dlopen="dyld"
+    lt_cv_dlopen_libs=
+    lt_cv_dlopen_self=yes
+
+fi
+
+    ;;
+
+  *)
+    ac_fn_c_check_func "$LINENO" "shl_load" "ac_cv_func_shl_load"
+if test "x$ac_cv_func_shl_load" = x""yes; then :
+  lt_cv_dlopen="shl_load"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for shl_load in -ldld" >&5
+$as_echo_n "checking for shl_load in -ldld... " >&6; }
+if test "${ac_cv_lib_dld_shl_load+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldld  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char shl_load ();
+int
+main ()
+{
+return shl_load ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_dld_shl_load=yes
+else
+  ac_cv_lib_dld_shl_load=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dld_shl_load" >&5
+$as_echo "$ac_cv_lib_dld_shl_load" >&6; }
+if test "x$ac_cv_lib_dld_shl_load" = x""yes; then :
+  lt_cv_dlopen="shl_load" lt_cv_dlopen_libs="-ldld"
+else
+  ac_fn_c_check_func "$LINENO" "dlopen" "ac_cv_func_dlopen"
+if test "x$ac_cv_func_dlopen" = x""yes; then :
+  lt_cv_dlopen="dlopen"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -ldl" >&5
+$as_echo_n "checking for dlopen in -ldl... " >&6; }
+if test "${ac_cv_lib_dl_dlopen+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldl  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dlopen ();
+int
+main ()
+{
+return dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_dl_dlopen=yes
+else
+  ac_cv_lib_dl_dlopen=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dl_dlopen" >&5
+$as_echo "$ac_cv_lib_dl_dlopen" >&6; }
+if test "x$ac_cv_lib_dl_dlopen" = x""yes; then :
+  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -lsvld" >&5
+$as_echo_n "checking for dlopen in -lsvld... " >&6; }
+if test "${ac_cv_lib_svld_dlopen+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsvld  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dlopen ();
+int
+main ()
+{
+return dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_svld_dlopen=yes
+else
+  ac_cv_lib_svld_dlopen=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_svld_dlopen" >&5
+$as_echo "$ac_cv_lib_svld_dlopen" >&6; }
+if test "x$ac_cv_lib_svld_dlopen" = x""yes; then :
+  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-lsvld"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dld_link in -ldld" >&5
+$as_echo_n "checking for dld_link in -ldld... " >&6; }
+if test "${ac_cv_lib_dld_dld_link+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldld  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dld_link ();
+int
+main ()
+{
+return dld_link ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_dld_dld_link=yes
+else
+  ac_cv_lib_dld_dld_link=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dld_dld_link" >&5
+$as_echo "$ac_cv_lib_dld_dld_link" >&6; }
+if test "x$ac_cv_lib_dld_dld_link" = x""yes; then :
+  lt_cv_dlopen="dld_link" lt_cv_dlopen_libs="-ldld"
+fi
+
+
+fi
+
+
+fi
+
+
+fi
+
+
+fi
+
+
+fi
+
+    ;;
+  esac
+
+  if test "x$lt_cv_dlopen" != xno; then
+    enable_dlopen=yes
+  else
+    enable_dlopen=no
+  fi
+
+  case $lt_cv_dlopen in
+  dlopen)
+    save_CPPFLAGS="$CPPFLAGS"
+    test "x$ac_cv_header_dlfcn_h" = xyes && CPPFLAGS="$CPPFLAGS -DHAVE_DLFCN_H"
+
+    save_LDFLAGS="$LDFLAGS"
+    wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $export_dynamic_flag_spec\"
+
+    save_LIBS="$LIBS"
+    LIBS="$lt_cv_dlopen_libs $LIBS"
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether a program can dlopen itself" >&5
+$as_echo_n "checking whether a program can dlopen itself... " >&6; }
+if test "${lt_cv_dlopen_self+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  	  if test "$cross_compiling" = yes; then :
+  lt_cv_dlopen_self=cross
+else
+  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
+  lt_status=$lt_dlunknown
+  cat > conftest.$ac_ext <<_LT_EOF
+#line 11224 "configure"
+#include "confdefs.h"
+
+#if HAVE_DLFCN_H
+#include <dlfcn.h>
+#endif
+
+#include <stdio.h>
+
+#ifdef RTLD_GLOBAL
+#  define LT_DLGLOBAL		RTLD_GLOBAL
+#else
+#  ifdef DL_GLOBAL
+#    define LT_DLGLOBAL		DL_GLOBAL
+#  else
+#    define LT_DLGLOBAL		0
+#  endif
+#endif
+
+/* We may have to define LT_DLLAZY_OR_NOW in the command line if we
+   find out it does not work in some platform. */
+#ifndef LT_DLLAZY_OR_NOW
+#  ifdef RTLD_LAZY
+#    define LT_DLLAZY_OR_NOW		RTLD_LAZY
+#  else
+#    ifdef DL_LAZY
+#      define LT_DLLAZY_OR_NOW		DL_LAZY
+#    else
+#      ifdef RTLD_NOW
+#        define LT_DLLAZY_OR_NOW	RTLD_NOW
+#      else
+#        ifdef DL_NOW
+#          define LT_DLLAZY_OR_NOW	DL_NOW
+#        else
+#          define LT_DLLAZY_OR_NOW	0
+#        endif
+#      endif
+#    endif
+#  endif
+#endif
+
+/* When -fvisbility=hidden is used, assume the code has been annotated
+   correspondingly for the symbols needed.  */
+#if defined(__GNUC__) && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))
+void fnord () __attribute__((visibility("default")));
+#endif
+
+void fnord () { int i=42; }
+int main ()
+{
+  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);
+  int status = $lt_dlunknown;
+
+  if (self)
+    {
+      if (dlsym (self,"fnord"))       status = $lt_dlno_uscore;
+      else
+        {
+	  if (dlsym( self,"_fnord"))  status = $lt_dlneed_uscore;
+          else puts (dlerror ());
+	}
+      /* dlclose (self); */
+    }
+  else
+    puts (dlerror ());
+
+  return status;
+}
+_LT_EOF
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && test -s conftest${ac_exeext} 2>/dev/null; then
+    (./conftest; exit; ) >&5 2>/dev/null
+    lt_status=$?
+    case x$lt_status in
+      x$lt_dlno_uscore) lt_cv_dlopen_self=yes ;;
+      x$lt_dlneed_uscore) lt_cv_dlopen_self=yes ;;
+      x$lt_dlunknown|x*) lt_cv_dlopen_self=no ;;
+    esac
+  else :
+    # compilation failed
+    lt_cv_dlopen_self=no
+  fi
+fi
+rm -fr conftest*
+
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_dlopen_self" >&5
+$as_echo "$lt_cv_dlopen_self" >&6; }
+
+    if test "x$lt_cv_dlopen_self" = xyes; then
+      wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $lt_prog_compiler_static\"
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether a statically linked program can dlopen itself" >&5
+$as_echo_n "checking whether a statically linked program can dlopen itself... " >&6; }
+if test "${lt_cv_dlopen_self_static+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  	  if test "$cross_compiling" = yes; then :
+  lt_cv_dlopen_self_static=cross
+else
+  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
+  lt_status=$lt_dlunknown
+  cat > conftest.$ac_ext <<_LT_EOF
+#line 11330 "configure"
+#include "confdefs.h"
+
+#if HAVE_DLFCN_H
+#include <dlfcn.h>
+#endif
+
+#include <stdio.h>
+
+#ifdef RTLD_GLOBAL
+#  define LT_DLGLOBAL		RTLD_GLOBAL
+#else
+#  ifdef DL_GLOBAL
+#    define LT_DLGLOBAL		DL_GLOBAL
+#  else
+#    define LT_DLGLOBAL		0
+#  endif
+#endif
+
+/* We may have to define LT_DLLAZY_OR_NOW in the command line if we
+   find out it does not work in some platform. */
+#ifndef LT_DLLAZY_OR_NOW
+#  ifdef RTLD_LAZY
+#    define LT_DLLAZY_OR_NOW		RTLD_LAZY
+#  else
+#    ifdef DL_LAZY
+#      define LT_DLLAZY_OR_NOW		DL_LAZY
+#    else
+#      ifdef RTLD_NOW
+#        define LT_DLLAZY_OR_NOW	RTLD_NOW
+#      else
+#        ifdef DL_NOW
+#          define LT_DLLAZY_OR_NOW	DL_NOW
+#        else
+#          define LT_DLLAZY_OR_NOW	0
+#        endif
+#      endif
+#    endif
+#  endif
+#endif
+
+/* When -fvisbility=hidden is used, assume the code has been annotated
+   correspondingly for the symbols needed.  */
+#if defined(__GNUC__) && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))
+void fnord () __attribute__((visibility("default")));
+#endif
+
+void fnord () { int i=42; }
+int main ()
+{
+  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);
+  int status = $lt_dlunknown;
+
+  if (self)
+    {
+      if (dlsym (self,"fnord"))       status = $lt_dlno_uscore;
+      else
+        {
+	  if (dlsym( self,"_fnord"))  status = $lt_dlneed_uscore;
+          else puts (dlerror ());
+	}
+      /* dlclose (self); */
+    }
+  else
+    puts (dlerror ());
+
+  return status;
+}
+_LT_EOF
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && test -s conftest${ac_exeext} 2>/dev/null; then
+    (./conftest; exit; ) >&5 2>/dev/null
+    lt_status=$?
+    case x$lt_status in
+      x$lt_dlno_uscore) lt_cv_dlopen_self_static=yes ;;
+      x$lt_dlneed_uscore) lt_cv_dlopen_self_static=yes ;;
+      x$lt_dlunknown|x*) lt_cv_dlopen_self_static=no ;;
+    esac
+  else :
+    # compilation failed
+    lt_cv_dlopen_self_static=no
+  fi
+fi
+rm -fr conftest*
+
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_dlopen_self_static" >&5
+$as_echo "$lt_cv_dlopen_self_static" >&6; }
+    fi
+
+    CPPFLAGS="$save_CPPFLAGS"
+    LDFLAGS="$save_LDFLAGS"
+    LIBS="$save_LIBS"
+    ;;
+  esac
+
+  case $lt_cv_dlopen_self in
+  yes|no) enable_dlopen_self=$lt_cv_dlopen_self ;;
+  *) enable_dlopen_self=unknown ;;
+  esac
+
+  case $lt_cv_dlopen_self_static in
+  yes|no) enable_dlopen_self_static=$lt_cv_dlopen_self_static ;;
+  *) enable_dlopen_self_static=unknown ;;
+  esac
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+striplib=
+old_striplib=
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether stripping libraries is possible" >&5
+$as_echo_n "checking whether stripping libraries is possible... " >&6; }
+if test -n "$STRIP" && $STRIP -V 2>&1 | $GREP "GNU strip" >/dev/null; then
+  test -z "$old_striplib" && old_striplib="$STRIP --strip-debug"
+  test -z "$striplib" && striplib="$STRIP --strip-unneeded"
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+# FIXME - insert some real tests, host_os isn't really good enough
+  case $host_os in
+  darwin*)
+    if test -n "$STRIP" ; then
+      striplib="$STRIP -x"
+      old_striplib="$STRIP -S"
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+    else
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+    fi
+    ;;
+  *)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+    ;;
+  esac
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+  # Report which library types will actually be built
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if libtool supports shared libraries" >&5
+$as_echo_n "checking if libtool supports shared libraries... " >&6; }
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $can_build_shared" >&5
+$as_echo "$can_build_shared" >&6; }
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to build shared libraries" >&5
+$as_echo_n "checking whether to build shared libraries... " >&6; }
+  test "$can_build_shared" = "no" && enable_shared=no
+
+  # On AIX, shared libraries and static libraries use the same namespace, and
+  # are all built from PIC.
+  case $host_os in
+  aix3*)
+    test "$enable_shared" = yes && enable_static=no
+    if test -n "$RANLIB"; then
+      archive_cmds="$archive_cmds~\$RANLIB \$lib"
+      postinstall_cmds='$RANLIB $lib'
+    fi
+    ;;
+
+  aix[4-9]*)
+    if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
+      test "$enable_shared" = yes && enable_static=no
+    fi
+    ;;
+  esac
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_shared" >&5
+$as_echo "$enable_shared" >&6; }
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to build static libraries" >&5
+$as_echo_n "checking whether to build static libraries... " >&6; }
+  # Make sure either enable_shared or enable_static is yes.
+  test "$enable_shared" = yes || enable_static=yes
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_static" >&5
+$as_echo "$enable_static" >&6; }
+
+
+
+
+fi
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+CC="$lt_save_CC"
+
+
+
+
+
+
+
+
+
+
+
+
+
+        ac_config_commands="$ac_config_commands libtool"
+
+
+
+
+# Only expand once:
+
+
+
+# The tests for host and target for $enable_largefile require
+# canonical names.
+
+
+
+# As the $enable_largefile decision depends on --enable-plugins we must set it
+# even in directories otherwise not depending on the $plugins option.
+
+
+  maybe_plugins=no
+  for ac_header in dlfcn.h
+do :
+  ac_fn_c_check_header_compile "$LINENO" "dlfcn.h" "ac_cv_header_dlfcn_h" "$ac_includes_default
+"
+if test "x$ac_cv_header_dlfcn_h" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_DLFCN_H 1
+_ACEOF
+ maybe_plugins=yes
+fi
+
+done
+
+  for ac_header in windows.h
+do :
+  ac_fn_c_check_header_compile "$LINENO" "windows.h" "ac_cv_header_windows_h" "$ac_includes_default
+"
+if test "x$ac_cv_header_windows_h" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_WINDOWS_H 1
+_ACEOF
+ maybe_plugins=yes
+fi
+
+done
+
+
+  # Check whether --enable-plugins was given.
+if test "${enable_plugins+set}" = set; then :
+  enableval=$enable_plugins; case "${enableval}" in
+      no) plugins=no ;;
+      *) plugins=yes
+         if test "$maybe_plugins" != "yes" ; then
+	   as_fn_error "Building with plugin support requires a host that supports dlopen." "$LINENO" 5
+	 fi ;;
+     esac
+else
+  plugins=$maybe_plugins
+
+fi
+
+  if test "$plugins" = "yes"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing dlopen" >&5
+$as_echo_n "checking for library containing dlopen... " >&6; }
+if test "${ac_cv_search_dlopen+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_func_search_save_LIBS=$LIBS
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dlopen ();
+int
+main ()
+{
+return dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+for ac_lib in '' dl; do
+  if test -z "$ac_lib"; then
+    ac_res="none required"
+  else
+    ac_res=-l$ac_lib
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+  fi
+  if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_search_dlopen=$ac_res
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext
+  if test "${ac_cv_search_dlopen+set}" = set; then :
+  break
+fi
+done
+if test "${ac_cv_search_dlopen+set}" = set; then :
+
+else
+  ac_cv_search_dlopen=no
+fi
+rm conftest.$ac_ext
+LIBS=$ac_func_search_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_dlopen" >&5
+$as_echo "$ac_cv_search_dlopen" >&6; }
+ac_res=$ac_cv_search_dlopen
+if test "$ac_res" != no; then :
+  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
+
+fi
+
+  fi
+
+
+case "${host}" in
+  sparc-*-solaris*|i[3-7]86-*-solaris*)
+    # On native 32bit sparc and ia32 solaris, large-file and procfs support
+    # are mutually exclusive; and without procfs support, the bfd/ elf module
+    # cannot provide certain routines such as elfcore_write_prpsinfo
+    # or elfcore_write_prstatus.  So unless the user explicitly requested
+    # large-file support through the --enable-largefile switch, disable
+    # large-file support in favor of procfs support.
+    test "${target}" = "${host}" -a "x$plugins" = xno \
+      && : ${enable_largefile="no"}
+    ;;
+esac
+
+# Check whether --enable-largefile was given.
+if test "${enable_largefile+set}" = set; then :
+  enableval=$enable_largefile;
+fi
+
+if test "$enable_largefile" != no; then
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for special C compiler options needed for large files" >&5
+$as_echo_n "checking for special C compiler options needed for large files... " >&6; }
+if test "${ac_cv_sys_largefile_CC+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_sys_largefile_CC=no
+     if test "$GCC" != yes; then
+       ac_save_CC=$CC
+       while :; do
+	 # IRIX 6.2 and later do not support large files by default,
+	 # so use the C compiler's -n32 option if that helps.
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+ /* Check that off_t can represent 2**63 - 1 correctly.
+    We can't simply define LARGE_OFF_T to be 9223372036854775807,
+    since some C++ compilers masquerading as C compilers
+    incorrectly reject 9223372036854775807.  */
+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
+  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
+		       && LARGE_OFF_T % 2147483647 == 1)
+		      ? 1 : -1];
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+	 if ac_fn_c_try_compile "$LINENO"; then :
+  break
+fi
+rm -f core conftest.err conftest.$ac_objext
+	 CC="$CC -n32"
+	 if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_sys_largefile_CC=' -n32'; break
+fi
+rm -f core conftest.err conftest.$ac_objext
+	 break
+       done
+       CC=$ac_save_CC
+       rm -f conftest.$ac_ext
+    fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sys_largefile_CC" >&5
+$as_echo "$ac_cv_sys_largefile_CC" >&6; }
+  if test "$ac_cv_sys_largefile_CC" != no; then
+    CC=$CC$ac_cv_sys_largefile_CC
+  fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for _FILE_OFFSET_BITS value needed for large files" >&5
+$as_echo_n "checking for _FILE_OFFSET_BITS value needed for large files... " >&6; }
+if test "${ac_cv_sys_file_offset_bits+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  while :; do
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+ /* Check that off_t can represent 2**63 - 1 correctly.
+    We can't simply define LARGE_OFF_T to be 9223372036854775807,
+    since some C++ compilers masquerading as C compilers
+    incorrectly reject 9223372036854775807.  */
+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
+  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
+		       && LARGE_OFF_T % 2147483647 == 1)
+		      ? 1 : -1];
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_sys_file_offset_bits=no; break
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#define _FILE_OFFSET_BITS 64
+#include <sys/types.h>
+ /* Check that off_t can represent 2**63 - 1 correctly.
+    We can't simply define LARGE_OFF_T to be 9223372036854775807,
+    since some C++ compilers masquerading as C compilers
+    incorrectly reject 9223372036854775807.  */
+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
+  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
+		       && LARGE_OFF_T % 2147483647 == 1)
+		      ? 1 : -1];
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_sys_file_offset_bits=64; break
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  ac_cv_sys_file_offset_bits=unknown
+  break
+done
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sys_file_offset_bits" >&5
+$as_echo "$ac_cv_sys_file_offset_bits" >&6; }
+case $ac_cv_sys_file_offset_bits in #(
+  no | unknown) ;;
+  *)
+cat >>confdefs.h <<_ACEOF
+#define _FILE_OFFSET_BITS $ac_cv_sys_file_offset_bits
+_ACEOF
+;;
+esac
+rm -rf conftest*
+  if test $ac_cv_sys_file_offset_bits = unknown; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for _LARGE_FILES value needed for large files" >&5
+$as_echo_n "checking for _LARGE_FILES value needed for large files... " >&6; }
+if test "${ac_cv_sys_large_files+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  while :; do
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+ /* Check that off_t can represent 2**63 - 1 correctly.
+    We can't simply define LARGE_OFF_T to be 9223372036854775807,
+    since some C++ compilers masquerading as C compilers
+    incorrectly reject 9223372036854775807.  */
+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
+  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
+		       && LARGE_OFF_T % 2147483647 == 1)
+		      ? 1 : -1];
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_sys_large_files=no; break
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#define _LARGE_FILES 1
+#include <sys/types.h>
+ /* Check that off_t can represent 2**63 - 1 correctly.
+    We can't simply define LARGE_OFF_T to be 9223372036854775807,
+    since some C++ compilers masquerading as C compilers
+    incorrectly reject 9223372036854775807.  */
+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
+  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
+		       && LARGE_OFF_T % 2147483647 == 1)
+		      ? 1 : -1];
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_sys_large_files=1; break
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  ac_cv_sys_large_files=unknown
+  break
+done
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sys_large_files" >&5
+$as_echo "$ac_cv_sys_large_files" >&6; }
+case $ac_cv_sys_large_files in #(
+  no | unknown) ;;
+  *)
+cat >>confdefs.h <<_ACEOF
+#define _LARGE_FILES $ac_cv_sys_large_files
+_ACEOF
+;;
+esac
+rm -rf conftest*
+  fi
+fi
+
+
+
+# Check whether --enable-targets was given.
+if test "${enable_targets+set}" = set; then :
+  enableval=$enable_targets; case "${enableval}" in
+  yes | "") as_fn_error "enable-targets option must specify target names or 'all'" "$LINENO" 5
+            ;;
+  no)       enable_targets= ;;
+  *)        enable_targets=$enableval ;;
+esac
+fi
+
+# Check whether --enable-deterministic-archives was given.
+if test "${enable_deterministic_archives+set}" = set; then :
+  enableval=$enable_deterministic_archives;
+if test "${enableval}" = no; then
+  default_ar_deterministic=0
+else
+  default_ar_deterministic=1
+fi
+else
+  default_ar_deterministic=0
+fi
+
+
+
+cat >>confdefs.h <<_ACEOF
+#define DEFAULT_AR_DETERMINISTIC $default_ar_deterministic
+_ACEOF
+
+
+# Check whether --enable-default-strings-all was given.
+if test "${enable_default_strings_all+set}" = set; then :
+  enableval=$enable_default_strings_all;
+if test "${enableval}" = no; then
+  default_strings_all=0
+else
+  default_strings_all=1
+fi
+else
+  default_strings_all=1
+fi
+
+
+
+cat >>confdefs.h <<_ACEOF
+#define DEFAULT_STRINGS_ALL $default_strings_all
+_ACEOF
+
+
+
+# Set the 'development' global.
+. $srcdir/../bfd/development.sh
+
+GCC_WARN_CFLAGS="-W -Wall -Wstrict-prototypes -Wmissing-prototypes"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+__GNUC__
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "^[0-3]$" >/dev/null 2>&1; then :
+
+else
+  GCC_WARN_CFLAGS="$GCC_WARN_CFLAGS -Wshadow"
+fi
+rm -f conftest*
+
+
+# Check whether --enable-werror was given.
+if test "${enable_werror+set}" = set; then :
+  enableval=$enable_werror; case "${enableval}" in
+     yes | y) ERROR_ON_WARNING="yes" ;;
+     no | n)  ERROR_ON_WARNING="no" ;;
+     *) as_fn_error "bad value ${enableval} for --enable-werror" "$LINENO" 5 ;;
+   esac
+fi
+
+
+# Disable -Wformat by default when using gcc on mingw
+case "${host}" in
+  *-*-mingw32*)
+    if test "${GCC}" = yes -a -z "${ERROR_ON_WARNING}" ; then
+      GCC_WARN_CFLAGS="$GCC_WARN_CFLAGS -Wno-format"
+    fi
+    ;;
+  *) ;;
+esac
+
+# Enable -Werror by default when using gcc.  Turn it off for releases.
+if test "${GCC}" = yes -a -z "${ERROR_ON_WARNING}" -a "$development" = true ; then
+    ERROR_ON_WARNING=yes
+fi
+
+NO_WERROR=
+if test "${ERROR_ON_WARNING}" = yes ; then
+    GCC_WARN_CFLAGS="$GCC_WARN_CFLAGS -Werror"
+    NO_WERROR="-Wno-error"
+fi
+
+if test "${GCC}" = yes ; then
+  WARN_CFLAGS="${GCC_WARN_CFLAGS}"
+fi
+
+# Check whether --enable-build-warnings was given.
+if test "${enable_build_warnings+set}" = set; then :
+  enableval=$enable_build_warnings; case "${enableval}" in
+  yes)	WARN_CFLAGS="${GCC_WARN_CFLAGS}";;
+  no)	if test "${GCC}" = yes ; then
+	  WARN_CFLAGS="-w"
+	fi;;
+  ,*)   t=`echo "${enableval}" | sed -e "s/,/ /g"`
+        WARN_CFLAGS="${GCC_WARN_CFLAGS} ${t}";;
+  *,)   t=`echo "${enableval}" | sed -e "s/,/ /g"`
+        WARN_CFLAGS="${t} ${GCC_WARN_CFLAGS}";;
+  *)    WARN_CFLAGS=`echo "${enableval}" | sed -e "s/,/ /g"`;;
+esac
+fi
+
+
+if test x"$silent" != x"yes" && test x"$WARN_CFLAGS" != x""; then
+  echo "Setting warning flags = $WARN_CFLAGS" 6>&1
+fi
+
+
+
+
+
+ac_config_headers="$ac_config_headers config.h:config.in"
+
+
+
+
+if test -z "$target" ; then
+    as_fn_error "Unrecognized target system type; please check config.sub." "$LINENO" 5
+fi
+if test -z "$host" ; then
+    as_fn_error "Unrecognized host system type; please check config.sub." "$LINENO" 5
+fi
+
+for ac_prog in 'bison -y' byacc
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_YACC+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$YACC"; then
+  ac_cv_prog_YACC="$YACC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_YACC="$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+YACC=$ac_cv_prog_YACC
+if test -n "$YACC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $YACC" >&5
+$as_echo "$YACC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$YACC" && break
+done
+test -n "$YACC" || YACC="yacc"
+
+for ac_prog in flex lex
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_LEX+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$LEX"; then
+  ac_cv_prog_LEX="$LEX" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_LEX="$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+LEX=$ac_cv_prog_LEX
+if test -n "$LEX"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LEX" >&5
+$as_echo "$LEX" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$LEX" && break
+done
+test -n "$LEX" || LEX=":"
+
+case "$LEX" in
+  :|*"missing "*) ;;
+  *) cat >conftest.l <<_ACEOF
+%%
+a { ECHO; }
+b { REJECT; }
+c { yymore (); }
+d { yyless (1); }
+e { yyless (input () != 0); }
+f { unput (yytext[0]); }
+. { BEGIN INITIAL; }
+%%
+#ifdef YYTEXT_POINTER
+extern char *yytext;
+#endif
+int
+main (void)
+{
+  return ! yylex () + ! yywrap ();
+}
+_ACEOF
+{ { ac_try="$LEX conftest.l"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$LEX conftest.l") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking lex output file root" >&5
+$as_echo_n "checking lex output file root... " >&6; }
+if test "${ac_cv_prog_lex_root+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+
+if test -f lex.yy.c; then
+  ac_cv_prog_lex_root=lex.yy
+elif test -f lexyy.c; then
+  ac_cv_prog_lex_root=lexyy
+else
+  as_fn_error "cannot find output from $LEX; giving up" "$LINENO" 5
+fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_lex_root" >&5
+$as_echo "$ac_cv_prog_lex_root" >&6; }
+LEX_OUTPUT_ROOT=$ac_cv_prog_lex_root
+
+if test -z "${LEXLIB+set}"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking lex library" >&5
+$as_echo_n "checking lex library... " >&6; }
+if test "${ac_cv_lib_lex+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+
+    ac_save_LIBS=$LIBS
+    ac_cv_lib_lex='none needed'
+    for ac_lib in '' -lfl -ll; do
+      LIBS="$ac_lib $ac_save_LIBS"
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+`cat $LEX_OUTPUT_ROOT.c`
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_lex=$ac_lib
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+      test "$ac_cv_lib_lex" != 'none needed' && break
+    done
+    LIBS=$ac_save_LIBS
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_lex" >&5
+$as_echo "$ac_cv_lib_lex" >&6; }
+  test "$ac_cv_lib_lex" != 'none needed' && LEXLIB=$ac_cv_lib_lex
+fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether yytext is a pointer" >&5
+$as_echo_n "checking whether yytext is a pointer... " >&6; }
+if test "${ac_cv_prog_lex_yytext_pointer+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  # POSIX says lex can declare yytext either as a pointer or an array; the
+# default is implementation-dependent.  Figure out which it is, since
+# not all implementations provide the %pointer and %array declarations.
+ac_cv_prog_lex_yytext_pointer=no
+ac_save_LIBS=$LIBS
+LIBS="$LEXLIB $ac_save_LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#define YYTEXT_POINTER 1
+`cat $LEX_OUTPUT_ROOT.c`
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_prog_lex_yytext_pointer=yes
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_save_LIBS
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_lex_yytext_pointer" >&5
+$as_echo "$ac_cv_prog_lex_yytext_pointer" >&6; }
+if test $ac_cv_prog_lex_yytext_pointer = yes; then
+
+$as_echo "#define YYTEXT_POINTER 1" >>confdefs.h
+
+fi
+rm -f conftest.l $LEX_OUTPUT_ROOT.c
+ ;;
+esac
+if test "$LEX" = :; then
+  LEX=${am_missing_run}flex
+fi
+
+ALL_LINGUAS="bg ca da es fi fr id it ja ro ru rw sk sv tr uk vi zh_CN zh_TW hr"
+# If we haven't got the data from the intl directory,
+# assume NLS is disabled.
+USE_NLS=no
+LIBINTL=
+LIBINTL_DEP=
+INCINTL=
+XGETTEXT=
+GMSGFMT=
+POSUB=
+
+if test -f  ../intl/config.intl; then
+  .  ../intl/config.intl
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether NLS is requested" >&5
+$as_echo_n "checking whether NLS is requested... " >&6; }
+if test x"$USE_NLS" != xyes; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+
+$as_echo "#define ENABLE_NLS 1" >>confdefs.h
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for catalogs to be installed" >&5
+$as_echo_n "checking for catalogs to be installed... " >&6; }
+  # Look for .po and .gmo files in the source directory.
+  CATALOGS=
+  XLINGUAS=
+  for cat in $srcdir/po/*.gmo $srcdir/po/*.po; do
+    # If there aren't any .gmo files the shell will give us the
+    # literal string "../path/to/srcdir/po/*.gmo" which has to be
+    # weeded out.
+    case "$cat" in *\**)
+      continue;;
+    esac
+    # The quadruple backslash is collapsed to a double backslash
+    # by the backticks, then collapsed again by the double quotes,
+    # leaving us with one backslash in the sed expression (right
+    # before the dot that mustn't act as a wildcard).
+    cat=`echo $cat | sed -e "s!$srcdir/po/!!" -e "s!\\\\.po!.gmo!"`
+    lang=`echo $cat | sed -e "s!\\\\.gmo!!"`
+    # The user is allowed to set LINGUAS to a list of languages to
+    # install catalogs for.  If it's empty that means "all of them."
+    if test "x$LINGUAS" = x; then
+      CATALOGS="$CATALOGS $cat"
+      XLINGUAS="$XLINGUAS $lang"
+    else
+      case "$LINGUAS" in *$lang*)
+        CATALOGS="$CATALOGS $cat"
+        XLINGUAS="$XLINGUAS $lang"
+        ;;
+      esac
+    fi
+  done
+  LINGUAS="$XLINGUAS"
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LINGUAS" >&5
+$as_echo "$LINGUAS" >&6; }
+
+
+    DATADIRNAME=share
+
+  INSTOBJEXT=.mo
+
+  GENCAT=gencat
+
+  CATOBJEXT=.gmo
+
+fi
+
+        MKINSTALLDIRS=
+  if test -n "$ac_aux_dir"; then
+    case "$ac_aux_dir" in
+      /*) MKINSTALLDIRS="$ac_aux_dir/mkinstalldirs" ;;
+      *) MKINSTALLDIRS="\$(top_builddir)/$ac_aux_dir/mkinstalldirs" ;;
+    esac
+  fi
+  if test -z "$MKINSTALLDIRS"; then
+    MKINSTALLDIRS="\$(top_srcdir)/mkinstalldirs"
+  fi
+
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether NLS is requested" >&5
+$as_echo_n "checking whether NLS is requested... " >&6; }
+    # Check whether --enable-nls was given.
+if test "${enable_nls+set}" = set; then :
+  enableval=$enable_nls; USE_NLS=$enableval
+else
+  USE_NLS=yes
+fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $USE_NLS" >&5
+$as_echo "$USE_NLS" >&6; }
+
+
+
+
+
+
+# Prepare PATH_SEPARATOR.
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+# Find out how to test for executable files. Don't use a zero-byte file,
+# as systems may use methods other than mode bits to determine executability.
+cat >conf$$.file <<_ASEOF
+#! /bin/sh
+exit 0
+_ASEOF
+chmod +x conf$$.file
+if test -x conf$$.file >/dev/null 2>&1; then
+  ac_executable_p="test -x"
+else
+  ac_executable_p="test -f"
+fi
+rm -f conf$$.file
+
+# Extract the first word of "msgfmt", so it can be a program name with args.
+set dummy msgfmt; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_path_MSGFMT+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  case "$MSGFMT" in
+  [\\/]* | ?:[\\/]*)
+    ac_cv_path_MSGFMT="$MSGFMT" # Let the user override the test with a path.
+    ;;
+  *)
+    ac_save_IFS="$IFS"; IFS=$PATH_SEPARATOR
+    for ac_dir in $PATH; do
+      IFS="$ac_save_IFS"
+      test -z "$ac_dir" && ac_dir=.
+      for ac_exec_ext in '' $ac_executable_extensions; do
+        if $ac_executable_p "$ac_dir/$ac_word$ac_exec_ext"; then
+          if $ac_dir/$ac_word --statistics /dev/null >/dev/null 2>&1 &&
+     (if $ac_dir/$ac_word --statistics /dev/null 2>&1 >/dev/null | grep usage >/dev/null; then exit 1; else exit 0; fi); then
+            ac_cv_path_MSGFMT="$ac_dir/$ac_word$ac_exec_ext"
+            break 2
+          fi
+        fi
+      done
+    done
+    IFS="$ac_save_IFS"
+  test -z "$ac_cv_path_MSGFMT" && ac_cv_path_MSGFMT=":"
+    ;;
+esac
+fi
+MSGFMT="$ac_cv_path_MSGFMT"
+if test "$MSGFMT" != ":"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MSGFMT" >&5
+$as_echo "$MSGFMT" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  # Extract the first word of "gmsgfmt", so it can be a program name with args.
+set dummy gmsgfmt; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_path_GMSGFMT+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $GMSGFMT in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_GMSGFMT="$GMSGFMT" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_path_GMSGFMT="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_path_GMSGFMT" && ac_cv_path_GMSGFMT="$MSGFMT"
+  ;;
+esac
+fi
+GMSGFMT=$ac_cv_path_GMSGFMT
+if test -n "$GMSGFMT"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $GMSGFMT" >&5
+$as_echo "$GMSGFMT" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+
+
+# Prepare PATH_SEPARATOR.
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+# Find out how to test for executable files. Don't use a zero-byte file,
+# as systems may use methods other than mode bits to determine executability.
+cat >conf$$.file <<_ASEOF
+#! /bin/sh
+exit 0
+_ASEOF
+chmod +x conf$$.file
+if test -x conf$$.file >/dev/null 2>&1; then
+  ac_executable_p="test -x"
+else
+  ac_executable_p="test -f"
+fi
+rm -f conf$$.file
+
+# Extract the first word of "xgettext", so it can be a program name with args.
+set dummy xgettext; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_path_XGETTEXT+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  case "$XGETTEXT" in
+  [\\/]* | ?:[\\/]*)
+    ac_cv_path_XGETTEXT="$XGETTEXT" # Let the user override the test with a path.
+    ;;
+  *)
+    ac_save_IFS="$IFS"; IFS=$PATH_SEPARATOR
+    for ac_dir in $PATH; do
+      IFS="$ac_save_IFS"
+      test -z "$ac_dir" && ac_dir=.
+      for ac_exec_ext in '' $ac_executable_extensions; do
+        if $ac_executable_p "$ac_dir/$ac_word$ac_exec_ext"; then
+          if $ac_dir/$ac_word --omit-header --copyright-holder= --msgid-bugs-address= /dev/null >/dev/null 2>&1 &&
+     (if $ac_dir/$ac_word --omit-header --copyright-holder= --msgid-bugs-address= /dev/null 2>&1 >/dev/null | grep usage >/dev/null; then exit 1; else exit 0; fi); then
+            ac_cv_path_XGETTEXT="$ac_dir/$ac_word$ac_exec_ext"
+            break 2
+          fi
+        fi
+      done
+    done
+    IFS="$ac_save_IFS"
+  test -z "$ac_cv_path_XGETTEXT" && ac_cv_path_XGETTEXT=":"
+    ;;
+esac
+fi
+XGETTEXT="$ac_cv_path_XGETTEXT"
+if test "$XGETTEXT" != ":"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $XGETTEXT" >&5
+$as_echo "$XGETTEXT" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+    rm -f messages.po
+
+
+# Prepare PATH_SEPARATOR.
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+# Find out how to test for executable files. Don't use a zero-byte file,
+# as systems may use methods other than mode bits to determine executability.
+cat >conf$$.file <<_ASEOF
+#! /bin/sh
+exit 0
+_ASEOF
+chmod +x conf$$.file
+if test -x conf$$.file >/dev/null 2>&1; then
+  ac_executable_p="test -x"
+else
+  ac_executable_p="test -f"
+fi
+rm -f conf$$.file
+
+# Extract the first word of "msgmerge", so it can be a program name with args.
+set dummy msgmerge; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_path_MSGMERGE+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  case "$MSGMERGE" in
+  [\\/]* | ?:[\\/]*)
+    ac_cv_path_MSGMERGE="$MSGMERGE" # Let the user override the test with a path.
+    ;;
+  *)
+    ac_save_IFS="$IFS"; IFS=$PATH_SEPARATOR
+    for ac_dir in $PATH; do
+      IFS="$ac_save_IFS"
+      test -z "$ac_dir" && ac_dir=.
+      for ac_exec_ext in '' $ac_executable_extensions; do
+        if $ac_executable_p "$ac_dir/$ac_word$ac_exec_ext"; then
+          if $ac_dir/$ac_word --update -q /dev/null /dev/null >/dev/null 2>&1; then
+            ac_cv_path_MSGMERGE="$ac_dir/$ac_word$ac_exec_ext"
+            break 2
+          fi
+        fi
+      done
+    done
+    IFS="$ac_save_IFS"
+  test -z "$ac_cv_path_MSGMERGE" && ac_cv_path_MSGMERGE=":"
+    ;;
+esac
+fi
+MSGMERGE="$ac_cv_path_MSGMERGE"
+if test "$MSGMERGE" != ":"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MSGMERGE" >&5
+$as_echo "$MSGMERGE" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+      if test "$GMSGFMT" != ":"; then
+            if $GMSGFMT --statistics /dev/null >/dev/null 2>&1 &&
+       (if $GMSGFMT --statistics /dev/null 2>&1 >/dev/null | grep usage >/dev/null; then exit 1; else exit 0; fi); then
+      : ;
+    else
+      GMSGFMT=`echo "$GMSGFMT" | sed -e 's,^.*/,,'`
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: found $GMSGFMT program is not GNU msgfmt; ignore it" >&5
+$as_echo "found $GMSGFMT program is not GNU msgfmt; ignore it" >&6; }
+      GMSGFMT=":"
+    fi
+  fi
+
+      if test "$XGETTEXT" != ":"; then
+            if $XGETTEXT --omit-header --copyright-holder= --msgid-bugs-address= /dev/null >/dev/null 2>&1 &&
+       (if $XGETTEXT --omit-header --copyright-holder= --msgid-bugs-address= /dev/null 2>&1 >/dev/null | grep usage >/dev/null; then exit 1; else exit 0; fi); then
+      : ;
+    else
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: found xgettext program is not GNU xgettext; ignore it" >&5
+$as_echo "found xgettext program is not GNU xgettext; ignore it" >&6; }
+      XGETTEXT=":"
+    fi
+        rm -f messages.po
+  fi
+
+  ac_config_commands="$ac_config_commands default-1"
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to enable maintainer-specific portions of Makefiles" >&5
+$as_echo_n "checking whether to enable maintainer-specific portions of Makefiles... " >&6; }
+    # Check whether --enable-maintainer-mode was given.
+if test "${enable_maintainer_mode+set}" = set; then :
+  enableval=$enable_maintainer_mode; USE_MAINTAINER_MODE=$enableval
+else
+  USE_MAINTAINER_MODE=no
+fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $USE_MAINTAINER_MODE" >&5
+$as_echo "$USE_MAINTAINER_MODE" >&6; }
+   if test $USE_MAINTAINER_MODE = yes; then
+  MAINTAINER_MODE_TRUE=
+  MAINTAINER_MODE_FALSE='#'
+else
+  MAINTAINER_MODE_TRUE='#'
+  MAINTAINER_MODE_FALSE=
+fi
+
+  MAINT=$MAINTAINER_MODE_TRUE
+
+
+ if false; then
+  GENINSRC_NEVER_TRUE=
+  GENINSRC_NEVER_FALSE='#'
+else
+  GENINSRC_NEVER_TRUE='#'
+  GENINSRC_NEVER_FALSE=
+fi
+
+
+if test -n "$EXEEXT"; then
+
+$as_echo "#define HAVE_EXECUTABLE_SUFFIX 1" >>confdefs.h
+
+fi
+
+cat >>confdefs.h <<_ACEOF
+#define EXECUTABLE_SUFFIX "${EXEEXT}"
+_ACEOF
+
+
+# host-specific stuff:
+
+HDEFINES=
+
+. ${srcdir}/../bfd/configure.host
+
+
+AR=${AR-ar}
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
+set dummy ${ac_tool_prefix}ranlib; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_RANLIB+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$RANLIB"; then
+  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+RANLIB=$ac_cv_prog_RANLIB
+if test -n "$RANLIB"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $RANLIB" >&5
+$as_echo "$RANLIB" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_RANLIB"; then
+  ac_ct_RANLIB=$RANLIB
+  # Extract the first word of "ranlib", so it can be a program name with args.
+set dummy ranlib; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_RANLIB+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_RANLIB"; then
+  ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_RANLIB="ranlib"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
+if test -n "$ac_ct_RANLIB"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_RANLIB" >&5
+$as_echo "$ac_ct_RANLIB" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_RANLIB" = x; then
+    RANLIB=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    RANLIB=$ac_ct_RANLIB
+  fi
+else
+  RANLIB="$ac_cv_prog_RANLIB"
+fi
+
+
+
+# Put a plausible default for CC_FOR_BUILD in Makefile.
+if test -z "$CC_FOR_BUILD"; then
+  if test "x$cross_compiling" = "xno"; then
+    CC_FOR_BUILD='$(CC)'
+  else
+    CC_FOR_BUILD=gcc
+  fi
+fi
+
+# Also set EXEEXT_FOR_BUILD.
+if test "x$cross_compiling" = "xno"; then
+  EXEEXT_FOR_BUILD='$(EXEEXT)'
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for build system executable suffix" >&5
+$as_echo_n "checking for build system executable suffix... " >&6; }
+if test "${bfd_cv_build_exeext+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  rm -f conftest*
+     echo 'int main () { return 0; }' > conftest.c
+     bfd_cv_build_exeext=
+     ${CC_FOR_BUILD} -o conftest conftest.c 1>&5 2>&5
+     for file in conftest.*; do
+       case $file in
+       *.c | *.o | *.obj | *.ilk | *.pdb) ;;
+       *) bfd_cv_build_exeext=`echo $file | sed -e s/conftest//` ;;
+       esac
+     done
+     rm -f conftest*
+     test x"${bfd_cv_build_exeext}" = x && bfd_cv_build_exeext=no
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $bfd_cv_build_exeext" >&5
+$as_echo "$bfd_cv_build_exeext" >&6; }
+  EXEEXT_FOR_BUILD=""
+  test x"${bfd_cv_build_exeext}" != xno && EXEEXT_FOR_BUILD=${bfd_cv_build_exeext}
+fi
+
+
+DEMANGLER_NAME=c++filt
+case "${host}" in
+  *-*-go32* | *-*-msdos*)
+    DEMANGLER_NAME=cxxfilt
+esac
+
+
+# The cast to long int works around a bug in the HP C Compiler
+# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
+# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
+# This bug is HP SR number 8606223364.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking size of long" >&5
+$as_echo_n "checking size of long... " >&6; }
+if test "${ac_cv_sizeof_long+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (long))" "ac_cv_sizeof_long"        "$ac_includes_default"; then :
+
+else
+  if test "$ac_cv_type_long" = yes; then
+     { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ as_fn_set_status 77
+as_fn_error "cannot compute sizeof (long)
+See \`config.log' for more details." "$LINENO" 5; }; }
+   else
+     ac_cv_sizeof_long=0
+   fi
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sizeof_long" >&5
+$as_echo "$ac_cv_sizeof_long" >&6; }
+
+
+
+cat >>confdefs.h <<_ACEOF
+#define SIZEOF_LONG $ac_cv_sizeof_long
+_ACEOF
+
+
+ac_fn_c_check_type "$LINENO" "long long" "ac_cv_type_long_long" "$ac_includes_default"
+if test "x$ac_cv_type_long_long" = x""yes; then :
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_LONG_LONG 1
+_ACEOF
+
+# The cast to long int works around a bug in the HP C Compiler
+# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
+# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
+# This bug is HP SR number 8606223364.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking size of long long" >&5
+$as_echo_n "checking size of long long... " >&6; }
+if test "${ac_cv_sizeof_long_long+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (long long))" "ac_cv_sizeof_long_long"        "$ac_includes_default"; then :
+
+else
+  if test "$ac_cv_type_long_long" = yes; then
+     { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ as_fn_set_status 77
+as_fn_error "cannot compute sizeof (long long)
+See \`config.log' for more details." "$LINENO" 5; }; }
+   else
+     ac_cv_sizeof_long_long=0
+   fi
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sizeof_long_long" >&5
+$as_echo "$ac_cv_sizeof_long_long" >&6; }
+
+
+
+cat >>confdefs.h <<_ACEOF
+#define SIZEOF_LONG_LONG $ac_cv_sizeof_long_long
+_ACEOF
+
+
+fi
+
+
+for ac_header in string.h strings.h stdlib.h unistd.h fcntl.h sys/file.h limits.h locale.h sys/param.h wchar.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+eval as_val=\$$as_ac_Header
+   if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for sys/wait.h that is POSIX.1 compatible" >&5
+$as_echo_n "checking for sys/wait.h that is POSIX.1 compatible... " >&6; }
+if test "${ac_cv_header_sys_wait_h+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <sys/wait.h>
+#ifndef WEXITSTATUS
+# define WEXITSTATUS(stat_val) ((unsigned int) (stat_val) >> 8)
+#endif
+#ifndef WIFEXITED
+# define WIFEXITED(stat_val) (((stat_val) & 255) == 0)
+#endif
+
+int
+main ()
+{
+  int s;
+  wait (&s);
+  s = WIFEXITED (s) ? WEXITSTATUS (s) : 1;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_header_sys_wait_h=yes
+else
+  ac_cv_header_sys_wait_h=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_header_sys_wait_h" >&5
+$as_echo "$ac_cv_header_sys_wait_h" >&6; }
+if test $ac_cv_header_sys_wait_h = yes; then
+
+$as_echo "#define HAVE_SYS_WAIT_H 1" >>confdefs.h
+
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether string.h and strings.h may both be included" >&5
+$as_echo_n "checking whether string.h and strings.h may both be included... " >&6; }
+if test "${gcc_cv_header_string+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <string.h>
+#include <strings.h>
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  gcc_cv_header_string=yes
+else
+  gcc_cv_header_string=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $gcc_cv_header_string" >&5
+$as_echo "$gcc_cv_header_string" >&6; }
+if test $gcc_cv_header_string = yes; then
+
+$as_echo "#define STRING_WITH_STRINGS 1" >>confdefs.h
+
+fi
+
+# The Ultrix 4.2 mips builtin alloca declared by alloca.h only works
+# for constant arguments.  Useless!
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for working alloca.h" >&5
+$as_echo_n "checking for working alloca.h... " >&6; }
+if test "${ac_cv_working_alloca_h+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <alloca.h>
+int
+main ()
+{
+char *p = (char *) alloca (2 * sizeof (int));
+			  if (p) return 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_working_alloca_h=yes
+else
+  ac_cv_working_alloca_h=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_working_alloca_h" >&5
+$as_echo "$ac_cv_working_alloca_h" >&6; }
+if test $ac_cv_working_alloca_h = yes; then
+
+$as_echo "#define HAVE_ALLOCA_H 1" >>confdefs.h
+
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for alloca" >&5
+$as_echo_n "checking for alloca... " >&6; }
+if test "${ac_cv_func_alloca_works+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifdef __GNUC__
+# define alloca __builtin_alloca
+#else
+# ifdef _MSC_VER
+#  include <malloc.h>
+#  define alloca _alloca
+# else
+#  ifdef HAVE_ALLOCA_H
+#   include <alloca.h>
+#  else
+#   ifdef _AIX
+ #pragma alloca
+#   else
+#    ifndef alloca /* predefined by HP cc +Olibcalls */
+char *alloca ();
+#    endif
+#   endif
+#  endif
+# endif
+#endif
+
+int
+main ()
+{
+char *p = (char *) alloca (1);
+				    if (p) return 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_func_alloca_works=yes
+else
+  ac_cv_func_alloca_works=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_func_alloca_works" >&5
+$as_echo "$ac_cv_func_alloca_works" >&6; }
+
+if test $ac_cv_func_alloca_works = yes; then
+
+$as_echo "#define HAVE_ALLOCA 1" >>confdefs.h
+
+else
+  # The SVR3 libPW and SVR4 libucb both contain incompatible functions
+# that cause trouble.  Some versions do not even contain alloca or
+# contain a buggy version.  If you still want to use their alloca,
+# use ar to extract alloca.o from them instead of compiling alloca.c.
+
+ALLOCA=\${LIBOBJDIR}alloca.$ac_objext
+
+$as_echo "#define C_ALLOCA 1" >>confdefs.h
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether \`alloca.c' needs Cray hooks" >&5
+$as_echo_n "checking whether \`alloca.c' needs Cray hooks... " >&6; }
+if test "${ac_cv_os_cray+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#if defined CRAY && ! defined CRAY2
+webecray
+#else
+wenotbecray
+#endif
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "webecray" >/dev/null 2>&1; then :
+  ac_cv_os_cray=yes
+else
+  ac_cv_os_cray=no
+fi
+rm -f conftest*
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_os_cray" >&5
+$as_echo "$ac_cv_os_cray" >&6; }
+if test $ac_cv_os_cray = yes; then
+  for ac_func in _getb67 GETB67 getb67; do
+    as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+eval as_val=\$$as_ac_var
+   if test "x$as_val" = x""yes; then :
+
+cat >>confdefs.h <<_ACEOF
+#define CRAY_STACKSEG_END $ac_func
+_ACEOF
+
+    break
+fi
+
+  done
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking stack direction for C alloca" >&5
+$as_echo_n "checking stack direction for C alloca... " >&6; }
+if test "${ac_cv_c_stack_direction+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test "$cross_compiling" = yes; then :
+  ac_cv_c_stack_direction=0
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$ac_includes_default
+int
+find_stack_direction ()
+{
+  static char *addr = 0;
+  auto char dummy;
+  if (addr == 0)
+    {
+      addr = &dummy;
+      return find_stack_direction ();
+    }
+  else
+    return (&dummy > addr) ? 1 : -1;
+}
+
+int
+main ()
+{
+  return find_stack_direction () < 0;
+}
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+  ac_cv_c_stack_direction=1
+else
+  ac_cv_c_stack_direction=-1
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_stack_direction" >&5
+$as_echo "$ac_cv_c_stack_direction" >&6; }
+cat >>confdefs.h <<_ACEOF
+#define STACK_DIRECTION $ac_cv_c_stack_direction
+_ACEOF
+
+
+fi
+
+for ac_func in sbrk utimes setmode getc_unlocked strcoll setlocale
+do :
+  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+eval as_val=\$$as_ac_var
+   if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+ac_fn_c_check_func "$LINENO" "mkstemp" "ac_cv_func_mkstemp"
+if test "x$ac_cv_func_mkstemp" = x""yes; then :
+
+$as_echo "#define HAVE_MKSTEMP 1" >>confdefs.h
+
+fi
+
+ac_fn_c_check_func "$LINENO" "mkdtemp" "ac_cv_func_mkdtemp"
+if test "x$ac_cv_func_mkdtemp" = x""yes; then :
+
+$as_echo "#define HAVE_MKDTEMP 1" >>confdefs.h
+
+fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for mbstate_t" >&5
+$as_echo_n "checking for mbstate_t... " >&6; }
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <wchar.h>
+int
+main ()
+{
+mbstate_t teststate;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  have_mbstate_t=yes
+else
+  have_mbstate_t=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $have_mbstate_t" >&5
+$as_echo "$have_mbstate_t" >&6; }
+  if test x"$have_mbstate_t" = xyes; then
+
+$as_echo "#define HAVE_MBSTATE_T 1" >>confdefs.h
+
+  fi
+
+# Some systems have frexp only in -lm, not in -lc.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing frexp" >&5
+$as_echo_n "checking for library containing frexp... " >&6; }
+if test "${ac_cv_search_frexp+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_func_search_save_LIBS=$LIBS
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char frexp ();
+int
+main ()
+{
+return frexp ();
+  ;
+  return 0;
+}
+_ACEOF
+for ac_lib in '' m; do
+  if test -z "$ac_lib"; then
+    ac_res="none required"
+  else
+    ac_res=-l$ac_lib
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+  fi
+  if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_search_frexp=$ac_res
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext
+  if test "${ac_cv_search_frexp+set}" = set; then :
+  break
+fi
+done
+if test "${ac_cv_search_frexp+set}" = set; then :
+
+else
+  ac_cv_search_frexp=no
+fi
+rm conftest.$ac_ext
+LIBS=$ac_func_search_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_frexp" >&5
+$as_echo "$ac_cv_search_frexp" >&6; }
+ac_res=$ac_cv_search_frexp
+if test "$ac_res" != no; then :
+  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
+
+fi
+
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for LC_MESSAGES" >&5
+$as_echo_n "checking for LC_MESSAGES... " >&6; }
+if test "${am_cv_val_LC_MESSAGES+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <locale.h>
+int
+main ()
+{
+return LC_MESSAGES
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  am_cv_val_LC_MESSAGES=yes
+else
+  am_cv_val_LC_MESSAGES=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $am_cv_val_LC_MESSAGES" >&5
+$as_echo "$am_cv_val_LC_MESSAGES" >&6; }
+  if test $am_cv_val_LC_MESSAGES = yes; then
+
+$as_echo "#define HAVE_LC_MESSAGES 1" >>confdefs.h
+
+  fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for time_t in time.h" >&5
+$as_echo_n "checking for time_t in time.h... " >&6; }
+if test "${bu_cv_decl_time_t_time_h+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <time.h>
+int
+main ()
+{
+time_t i;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  bu_cv_decl_time_t_time_h=yes
+else
+  bu_cv_decl_time_t_time_h=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $bu_cv_decl_time_t_time_h" >&5
+$as_echo "$bu_cv_decl_time_t_time_h" >&6; }
+if test $bu_cv_decl_time_t_time_h = yes; then
+
+$as_echo "#define HAVE_TIME_T_IN_TIME_H 1" >>confdefs.h
+
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for time_t in sys/types.h" >&5
+$as_echo_n "checking for time_t in sys/types.h... " >&6; }
+if test "${bu_cv_decl_time_t_types_h+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+int
+main ()
+{
+time_t i;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  bu_cv_decl_time_t_types_h=yes
+else
+  bu_cv_decl_time_t_types_h=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $bu_cv_decl_time_t_types_h" >&5
+$as_echo "$bu_cv_decl_time_t_types_h" >&6; }
+if test $bu_cv_decl_time_t_types_h = yes; then
+
+$as_echo "#define HAVE_TIME_T_IN_TYPES_H 1" >>confdefs.h
+
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a known getopt prototype in unistd.h" >&5
+$as_echo_n "checking for a known getopt prototype in unistd.h... " >&6; }
+if test "${bu_cv_decl_getopt_unistd_h+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <unistd.h>
+int
+main ()
+{
+extern int getopt (int, char *const*, const char *);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  bu_cv_decl_getopt_unistd_h=yes
+else
+  bu_cv_decl_getopt_unistd_h=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $bu_cv_decl_getopt_unistd_h" >&5
+$as_echo "$bu_cv_decl_getopt_unistd_h" >&6; }
+if test $bu_cv_decl_getopt_unistd_h = yes; then
+
+$as_echo "#define HAVE_DECL_GETOPT 1" >>confdefs.h
+
+fi
+
+# Under Next 3.2 <utime.h> apparently does not define struct utimbuf
+# by default.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for utime.h" >&5
+$as_echo_n "checking for utime.h... " >&6; }
+if test "${bu_cv_header_utime_h+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+#ifdef HAVE_TIME_H
+#include <time.h>
+#endif
+#include <utime.h>
+int
+main ()
+{
+struct utimbuf s;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  bu_cv_header_utime_h=yes
+else
+  bu_cv_header_utime_h=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $bu_cv_header_utime_h" >&5
+$as_echo "$bu_cv_header_utime_h" >&6; }
+if test $bu_cv_header_utime_h = yes; then
+
+$as_echo "#define HAVE_GOOD_UTIME_H 1" >>confdefs.h
+
+fi
+
+ac_fn_c_check_decl "$LINENO" "environ" "ac_cv_have_decl_environ" "$ac_includes_default"
+if test "x$ac_cv_have_decl_environ" = x""yes; then :
+  ac_have_decl=1
+else
+  ac_have_decl=0
+fi
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_DECL_ENVIRON $ac_have_decl
+_ACEOF
+ac_fn_c_check_decl "$LINENO" "fprintf" "ac_cv_have_decl_fprintf" "$ac_includes_default"
+if test "x$ac_cv_have_decl_fprintf" = x""yes; then :
+  ac_have_decl=1
+else
+  ac_have_decl=0
+fi
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_DECL_FPRINTF $ac_have_decl
+_ACEOF
+ac_fn_c_check_decl "$LINENO" "getc_unlocked" "ac_cv_have_decl_getc_unlocked" "$ac_includes_default"
+if test "x$ac_cv_have_decl_getc_unlocked" = x""yes; then :
+  ac_have_decl=1
+else
+  ac_have_decl=0
+fi
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_DECL_GETC_UNLOCKED $ac_have_decl
+_ACEOF
+ac_fn_c_check_decl "$LINENO" "getenv" "ac_cv_have_decl_getenv" "$ac_includes_default"
+if test "x$ac_cv_have_decl_getenv" = x""yes; then :
+  ac_have_decl=1
+else
+  ac_have_decl=0
+fi
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_DECL_GETENV $ac_have_decl
+_ACEOF
+ac_fn_c_check_decl "$LINENO" "sbrk" "ac_cv_have_decl_sbrk" "$ac_includes_default"
+if test "x$ac_cv_have_decl_sbrk" = x""yes; then :
+  ac_have_decl=1
+else
+  ac_have_decl=0
+fi
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_DECL_SBRK $ac_have_decl
+_ACEOF
+ac_fn_c_check_decl "$LINENO" "snprintf" "ac_cv_have_decl_snprintf" "$ac_includes_default"
+if test "x$ac_cv_have_decl_snprintf" = x""yes; then :
+  ac_have_decl=1
+else
+  ac_have_decl=0
+fi
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_DECL_SNPRINTF $ac_have_decl
+_ACEOF
+ac_fn_c_check_decl "$LINENO" "stpcpy" "ac_cv_have_decl_stpcpy" "$ac_includes_default"
+if test "x$ac_cv_have_decl_stpcpy" = x""yes; then :
+  ac_have_decl=1
+else
+  ac_have_decl=0
+fi
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_DECL_STPCPY $ac_have_decl
+_ACEOF
+ac_fn_c_check_decl "$LINENO" "strnlen" "ac_cv_have_decl_strnlen" "$ac_includes_default"
+if test "x$ac_cv_have_decl_strnlen" = x""yes; then :
+  ac_have_decl=1
+else
+  ac_have_decl=0
+fi
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_DECL_STRNLEN $ac_have_decl
+_ACEOF
+ac_fn_c_check_decl "$LINENO" "strstr" "ac_cv_have_decl_strstr" "$ac_includes_default"
+if test "x$ac_cv_have_decl_strstr" = x""yes; then :
+  ac_have_decl=1
+else
+  ac_have_decl=0
+fi
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_DECL_STRSTR $ac_have_decl
+_ACEOF
+ac_fn_c_check_decl "$LINENO" "vsnprintf" "ac_cv_have_decl_vsnprintf" "$ac_includes_default"
+if test "x$ac_cv_have_decl_vsnprintf" = x""yes; then :
+  ac_have_decl=1
+else
+  ac_have_decl=0
+fi
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_DECL_VSNPRINTF $ac_have_decl
+_ACEOF
+
+
+# Link in zlib if we can.  This allows us to read compressed debug
+# sections.  This is used only by readelf.c (objdump uses bfd for
+# reading compressed sections).
+
+  # Use the system's zlib library.
+  zlibdir="-L\$(top_builddir)/../zlib"
+  zlibinc="-I\$(top_srcdir)/../zlib"
+
+# Check whether --with-system-zlib was given.
+if test "${with_system_zlib+set}" = set; then :
+  withval=$with_system_zlib; if test x$with_system_zlib = xyes ; then
+    zlibdir=
+    zlibinc=
+  fi
+
+fi
+
+
+
+
+
+
+case "${host}" in
+*-*-msdos* | *-*-go32* | *-*-mingw32* | *-*-cygwin* | *-*-windows*)
+
+$as_echo "#define USE_BINARY_FOPEN 1" >>confdefs.h
+ ;;
+esac
+
+# target-specific stuff:
+
+# Canonicalize the secondary target names.
+if test -n "$enable_targets"; then
+    for targ in `echo $enable_targets | sed 's/,/ /g'`
+    do
+	result=`$ac_config_sub $targ 2>/dev/null`
+	if test -n "$result"; then
+	    canon_targets="$canon_targets $result"
+	else
+	    # Allow targets that config.sub doesn't recognize, like "all".
+	    canon_targets="$canon_targets $targ"
+	fi
+    done
+fi
+
+ac_fn_c_check_header_mongrel "$LINENO" "iconv.h" "ac_cv_header_iconv_h" "$ac_includes_default"
+if test "x$ac_cv_header_iconv_h" = x""yes; then :
+
+fi
+
+
+
+      if test "X$prefix" = "XNONE"; then
+    acl_final_prefix="$ac_default_prefix"
+  else
+    acl_final_prefix="$prefix"
+  fi
+  if test "X$exec_prefix" = "XNONE"; then
+    acl_final_exec_prefix='${prefix}'
+  else
+    acl_final_exec_prefix="$exec_prefix"
+  fi
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  eval acl_final_exec_prefix=\"$acl_final_exec_prefix\"
+  prefix="$acl_save_prefix"
+
+
+# Check whether --with-gnu-ld was given.
+if test "${with_gnu_ld+set}" = set; then :
+  withval=$with_gnu_ld; test "$withval" = no || with_gnu_ld=yes
+else
+  with_gnu_ld=no
+fi
+
+# Prepare PATH_SEPARATOR.
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+ac_prog=ld
+if test "$GCC" = yes; then
+  # Check if gcc -print-prog-name=ld gives a path.
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by GCC" >&5
+$as_echo_n "checking for ld used by GCC... " >&6; }
+  case $host in
+  *-*-mingw*)
+    # gcc leaves a trailing carriage return which upsets mingw
+    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
+  *)
+    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
+  esac
+  case $ac_prog in
+    # Accept absolute paths.
+    [\\/]* | [A-Za-z]:[\\/]*)
+      re_direlt='/[^/][^/]*/\.\./'
+      # Canonicalize the path of ld
+      ac_prog=`echo $ac_prog| sed 's%\\\\%/%g'`
+      while echo $ac_prog | grep "$re_direlt" > /dev/null 2>&1; do
+	ac_prog=`echo $ac_prog| sed "s%$re_direlt%/%"`
+      done
+      test -z "$LD" && LD="$ac_prog"
+      ;;
+  "")
+    # If it fails, then pretend we aren't using GCC.
+    ac_prog=ld
+    ;;
+  *)
+    # If it is relative, then search for the first ld in PATH.
+    with_gnu_ld=unknown
+    ;;
+  esac
+elif test "$with_gnu_ld" = yes; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for GNU ld" >&5
+$as_echo_n "checking for GNU ld... " >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for non-GNU ld" >&5
+$as_echo_n "checking for non-GNU ld... " >&6; }
+fi
+if test "${acl_cv_path_LD+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -z "$LD"; then
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}${PATH_SEPARATOR-:}"
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
+      acl_cv_path_LD="$ac_dir/$ac_prog"
+      # Check to see if the program is GNU ld.  I'd rather use --version,
+      # but apparently some GNU ld's only accept -v.
+      # Break only if it was the GNU/non-GNU ld that we prefer.
+      if "$acl_cv_path_LD" -v 2>&1 < /dev/null | egrep '(GNU|with BFD)' > /dev/null; then
+	test "$with_gnu_ld" != no && break
+      else
+	test "$with_gnu_ld" != yes && break
+      fi
+    fi
+  done
+  IFS="$ac_save_ifs"
+else
+  acl_cv_path_LD="$LD" # Let the user override the test with a path.
+fi
+fi
+
+LD="$acl_cv_path_LD"
+if test -n "$LD"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LD" >&5
+$as_echo "$LD" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+test -z "$LD" && as_fn_error "no acceptable ld found in \$PATH" "$LINENO" 5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if the linker ($LD) is GNU ld" >&5
+$as_echo_n "checking if the linker ($LD) is GNU ld... " >&6; }
+if test "${acl_cv_prog_gnu_ld+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  # I'd rather use --version here, but apparently some GNU ld's only accept -v.
+if $LD -v 2>&1 </dev/null | egrep '(GNU|with BFD)' 1>&5; then
+  acl_cv_prog_gnu_ld=yes
+else
+  acl_cv_prog_gnu_ld=no
+fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $acl_cv_prog_gnu_ld" >&5
+$as_echo "$acl_cv_prog_gnu_ld" >&6; }
+with_gnu_ld=$acl_cv_prog_gnu_ld
+
+
+
+                                                { $as_echo "$as_me:${as_lineno-$LINENO}: checking for shared library run path origin" >&5
+$as_echo_n "checking for shared library run path origin... " >&6; }
+if test "${acl_cv_rpath+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+
+    CC="$CC" GCC="$GCC" LDFLAGS="$LDFLAGS" LD="$LD" with_gnu_ld="$with_gnu_ld" \
+    ${CONFIG_SHELL-/bin/sh} "$ac_aux_dir/config.rpath" "$host" > conftest.sh
+    . ./conftest.sh
+    rm -f ./conftest.sh
+    acl_cv_rpath=done
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $acl_cv_rpath" >&5
+$as_echo "$acl_cv_rpath" >&6; }
+  wl="$acl_cv_wl"
+  libext="$acl_cv_libext"
+  shlibext="$acl_cv_shlibext"
+  hardcode_libdir_flag_spec="$acl_cv_hardcode_libdir_flag_spec"
+  hardcode_libdir_separator="$acl_cv_hardcode_libdir_separator"
+  hardcode_direct="$acl_cv_hardcode_direct"
+  hardcode_minus_L="$acl_cv_hardcode_minus_L"
+    # Check whether --enable-rpath was given.
+if test "${enable_rpath+set}" = set; then :
+  enableval=$enable_rpath; :
+else
+  enable_rpath=yes
+fi
+
+
+
+
+
+
+
+
+    use_additional=yes
+
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  acl_save_exec_prefix="$exec_prefix"
+  exec_prefix="$acl_final_exec_prefix"
+
+    eval additional_includedir=\"$includedir\"
+    eval additional_libdir=\"$libdir\"
+
+  exec_prefix="$acl_save_exec_prefix"
+  prefix="$acl_save_prefix"
+
+
+# Check whether --with-libiconv-prefix was given.
+if test "${with_libiconv_prefix+set}" = set; then :
+  withval=$with_libiconv_prefix;
+    if test "X$withval" = "Xno"; then
+      use_additional=no
+    else
+      if test "X$withval" = "X"; then
+
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  acl_save_exec_prefix="$exec_prefix"
+  exec_prefix="$acl_final_exec_prefix"
+
+          eval additional_includedir=\"$includedir\"
+          eval additional_libdir=\"$libdir\"
+
+  exec_prefix="$acl_save_exec_prefix"
+  prefix="$acl_save_prefix"
+
+      else
+        additional_includedir="$withval/include"
+        additional_libdir="$withval/lib"
+      fi
+    fi
+
+fi
+
+      LIBICONV=
+  LTLIBICONV=
+  INCICONV=
+  rpathdirs=
+  ltrpathdirs=
+  names_already_handled=
+  names_next_round='iconv '
+  while test -n "$names_next_round"; do
+    names_this_round="$names_next_round"
+    names_next_round=
+    for name in $names_this_round; do
+      already_handled=
+      for n in $names_already_handled; do
+        if test "$n" = "$name"; then
+          already_handled=yes
+          break
+        fi
+      done
+      if test -z "$already_handled"; then
+        names_already_handled="$names_already_handled $name"
+                        uppername=`echo "$name" | sed -e 'y|abcdefghijklmnopqrstuvwxyz./-|ABCDEFGHIJKLMNOPQRSTUVWXYZ___|'`
+        eval value=\"\$HAVE_LIB$uppername\"
+        if test -n "$value"; then
+          if test "$value" = yes; then
+            eval value=\"\$LIB$uppername\"
+            test -z "$value" || LIBICONV="${LIBICONV}${LIBICONV:+ }$value"
+            eval value=\"\$LTLIB$uppername\"
+            test -z "$value" || LTLIBICONV="${LTLIBICONV}${LTLIBICONV:+ }$value"
+          else
+                                    :
+          fi
+        else
+                              found_dir=
+          found_la=
+          found_so=
+          found_a=
+          if test $use_additional = yes; then
+            if test -n "$shlibext" && test -f "$additional_libdir/lib$name.$shlibext"; then
+              found_dir="$additional_libdir"
+              found_so="$additional_libdir/lib$name.$shlibext"
+              if test -f "$additional_libdir/lib$name.la"; then
+                found_la="$additional_libdir/lib$name.la"
+              fi
+            else
+              if test -f "$additional_libdir/lib$name.$libext"; then
+                found_dir="$additional_libdir"
+                found_a="$additional_libdir/lib$name.$libext"
+                if test -f "$additional_libdir/lib$name.la"; then
+                  found_la="$additional_libdir/lib$name.la"
+                fi
+              fi
+            fi
+          fi
+          if test "X$found_dir" = "X"; then
+            for x in $LDFLAGS $LTLIBICONV; do
+
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  acl_save_exec_prefix="$exec_prefix"
+  exec_prefix="$acl_final_exec_prefix"
+  eval x=\"$x\"
+  exec_prefix="$acl_save_exec_prefix"
+  prefix="$acl_save_prefix"
+
+              case "$x" in
+                -L*)
+                  dir=`echo "X$x" | sed -e 's/^X-L//'`
+                  if test -n "$shlibext" && test -f "$dir/lib$name.$shlibext"; then
+                    found_dir="$dir"
+                    found_so="$dir/lib$name.$shlibext"
+                    if test -f "$dir/lib$name.la"; then
+                      found_la="$dir/lib$name.la"
+                    fi
+                  else
+                    if test -f "$dir/lib$name.$libext"; then
+                      found_dir="$dir"
+                      found_a="$dir/lib$name.$libext"
+                      if test -f "$dir/lib$name.la"; then
+                        found_la="$dir/lib$name.la"
+                      fi
+                    fi
+                  fi
+                  ;;
+              esac
+              if test "X$found_dir" != "X"; then
+                break
+              fi
+            done
+          fi
+          if test "X$found_dir" != "X"; then
+                        LTLIBICONV="${LTLIBICONV}${LTLIBICONV:+ }-L$found_dir -l$name"
+            if test "X$found_so" != "X"; then
+                                                        if test "$enable_rpath" = no || test "X$found_dir" = "X/usr/lib"; then
+                                LIBICONV="${LIBICONV}${LIBICONV:+ }$found_so"
+              else
+                                                                                haveit=
+                for x in $ltrpathdirs; do
+                  if test "X$x" = "X$found_dir"; then
+                    haveit=yes
+                    break
+                  fi
+                done
+                if test -z "$haveit"; then
+                  ltrpathdirs="$ltrpathdirs $found_dir"
+                fi
+                                if test "$hardcode_direct" = yes; then
+                                                      LIBICONV="${LIBICONV}${LIBICONV:+ }$found_so"
+                else
+                  if test -n "$hardcode_libdir_flag_spec" && test "$hardcode_minus_L" = no; then
+                                                            LIBICONV="${LIBICONV}${LIBICONV:+ }$found_so"
+                                                            haveit=
+                    for x in $rpathdirs; do
+                      if test "X$x" = "X$found_dir"; then
+                        haveit=yes
+                        break
+                      fi
+                    done
+                    if test -z "$haveit"; then
+                      rpathdirs="$rpathdirs $found_dir"
+                    fi
+                  else
+                                                                                haveit=
+                    for x in $LDFLAGS $LIBICONV; do
+
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  acl_save_exec_prefix="$exec_prefix"
+  exec_prefix="$acl_final_exec_prefix"
+  eval x=\"$x\"
+  exec_prefix="$acl_save_exec_prefix"
+  prefix="$acl_save_prefix"
+
+                      if test "X$x" = "X-L$found_dir"; then
+                        haveit=yes
+                        break
+                      fi
+                    done
+                    if test -z "$haveit"; then
+                      LIBICONV="${LIBICONV}${LIBICONV:+ }-L$found_dir"
+                    fi
+                    if test "$hardcode_minus_L" != no; then
+                                                                                        LIBICONV="${LIBICONV}${LIBICONV:+ }$found_so"
+                    else
+                                                                                                                                                                                LIBICONV="${LIBICONV}${LIBICONV:+ }-l$name"
+                    fi
+                  fi
+                fi
+              fi
+            else
+              if test "X$found_a" != "X"; then
+                                LIBICONV="${LIBICONV}${LIBICONV:+ }$found_a"
+              else
+                                                LIBICONV="${LIBICONV}${LIBICONV:+ }-L$found_dir -l$name"
+              fi
+            fi
+                        additional_includedir=
+            case "$found_dir" in
+              */lib | */lib/)
+                basedir=`echo "X$found_dir" | sed -e 's,^X,,' -e 's,/lib/*$,,'`
+                additional_includedir="$basedir/include"
+                ;;
+            esac
+            if test "X$additional_includedir" != "X"; then
+                                                                                                                if test "X$additional_includedir" != "X/usr/include"; then
+                haveit=
+                if test "X$additional_includedir" = "X/usr/local/include"; then
+                  if test -n "$GCC"; then
+                    case $host_os in
+                      linux*) haveit=yes;;
+                    esac
+                  fi
+                fi
+                if test -z "$haveit"; then
+                  for x in $CPPFLAGS $INCICONV; do
+
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  acl_save_exec_prefix="$exec_prefix"
+  exec_prefix="$acl_final_exec_prefix"
+  eval x=\"$x\"
+  exec_prefix="$acl_save_exec_prefix"
+  prefix="$acl_save_prefix"
+
+                    if test "X$x" = "X-I$additional_includedir"; then
+                      haveit=yes
+                      break
+                    fi
+                  done
+                  if test -z "$haveit"; then
+                    if test -d "$additional_includedir"; then
+                                            INCICONV="${INCICONV}${INCICONV:+ }-I$additional_includedir"
+                    fi
+                  fi
+                fi
+              fi
+            fi
+                        if test -n "$found_la"; then
+                                                        save_libdir="$libdir"
+              case "$found_la" in
+                */* | *\\*) . "$found_la" ;;
+                *) . "./$found_la" ;;
+              esac
+              libdir="$save_libdir"
+                            for dep in $dependency_libs; do
+                case "$dep" in
+                  -L*)
+                    additional_libdir=`echo "X$dep" | sed -e 's/^X-L//'`
+                                                                                                                                                                if test "X$additional_libdir" != "X/usr/lib"; then
+                      haveit=
+                      if test "X$additional_libdir" = "X/usr/local/lib"; then
+                        if test -n "$GCC"; then
+                          case $host_os in
+                            linux*) haveit=yes;;
+                          esac
+                        fi
+                      fi
+                      if test -z "$haveit"; then
+                        haveit=
+                        for x in $LDFLAGS $LIBICONV; do
+
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  acl_save_exec_prefix="$exec_prefix"
+  exec_prefix="$acl_final_exec_prefix"
+  eval x=\"$x\"
+  exec_prefix="$acl_save_exec_prefix"
+  prefix="$acl_save_prefix"
+
+                          if test "X$x" = "X-L$additional_libdir"; then
+                            haveit=yes
+                            break
+                          fi
+                        done
+                        if test -z "$haveit"; then
+                          if test -d "$additional_libdir"; then
+                                                        LIBICONV="${LIBICONV}${LIBICONV:+ }-L$additional_libdir"
+                          fi
+                        fi
+                        haveit=
+                        for x in $LDFLAGS $LTLIBICONV; do
+
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  acl_save_exec_prefix="$exec_prefix"
+  exec_prefix="$acl_final_exec_prefix"
+  eval x=\"$x\"
+  exec_prefix="$acl_save_exec_prefix"
+  prefix="$acl_save_prefix"
+
+                          if test "X$x" = "X-L$additional_libdir"; then
+                            haveit=yes
+                            break
+                          fi
+                        done
+                        if test -z "$haveit"; then
+                          if test -d "$additional_libdir"; then
+                                                        LTLIBICONV="${LTLIBICONV}${LTLIBICONV:+ }-L$additional_libdir"
+                          fi
+                        fi
+                      fi
+                    fi
+                    ;;
+                  -R*)
+                    dir=`echo "X$dep" | sed -e 's/^X-R//'`
+                    if test "$enable_rpath" != no; then
+                                                                  haveit=
+                      for x in $rpathdirs; do
+                        if test "X$x" = "X$dir"; then
+                          haveit=yes
+                          break
+                        fi
+                      done
+                      if test -z "$haveit"; then
+                        rpathdirs="$rpathdirs $dir"
+                      fi
+                                                                  haveit=
+                      for x in $ltrpathdirs; do
+                        if test "X$x" = "X$dir"; then
+                          haveit=yes
+                          break
+                        fi
+                      done
+                      if test -z "$haveit"; then
+                        ltrpathdirs="$ltrpathdirs $dir"
+                      fi
+                    fi
+                    ;;
+                  -l*)
+                                        names_next_round="$names_next_round "`echo "X$dep" | sed -e 's/^X-l//'`
+                    ;;
+                  *.la)
+                                                                                names_next_round="$names_next_round "`echo "X$dep" | sed -e 's,^X.*/,,' -e 's,^lib,,' -e 's,\.la$,,'`
+                    ;;
+                  *)
+                                        LIBICONV="${LIBICONV}${LIBICONV:+ }$dep"
+                    LTLIBICONV="${LTLIBICONV}${LTLIBICONV:+ }$dep"
+                    ;;
+                esac
+              done
+            fi
+          else
+                                                            LIBICONV="${LIBICONV}${LIBICONV:+ }-l$name"
+            LTLIBICONV="${LTLIBICONV}${LTLIBICONV:+ }-l$name"
+          fi
+        fi
+      fi
+    done
+  done
+  if test "X$rpathdirs" != "X"; then
+    if test -n "$hardcode_libdir_separator"; then
+                        alldirs=
+      for found_dir in $rpathdirs; do
+        alldirs="${alldirs}${alldirs:+$hardcode_libdir_separator}$found_dir"
+      done
+            acl_save_libdir="$libdir"
+      libdir="$alldirs"
+      eval flag=\"$hardcode_libdir_flag_spec\"
+      libdir="$acl_save_libdir"
+      LIBICONV="${LIBICONV}${LIBICONV:+ }$flag"
+    else
+            for found_dir in $rpathdirs; do
+        acl_save_libdir="$libdir"
+        libdir="$found_dir"
+        eval flag=\"$hardcode_libdir_flag_spec\"
+        libdir="$acl_save_libdir"
+        LIBICONV="${LIBICONV}${LIBICONV:+ }$flag"
+      done
+    fi
+  fi
+  if test "X$ltrpathdirs" != "X"; then
+            for found_dir in $ltrpathdirs; do
+      LTLIBICONV="${LTLIBICONV}${LTLIBICONV:+ }-R$found_dir"
+    done
+  fi
+
+
+
+
+
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for iconv" >&5
+$as_echo_n "checking for iconv... " >&6; }
+if test "${am_cv_func_iconv+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+
+    am_cv_func_iconv="no, consider installing GNU libiconv"
+    am_cv_lib_iconv=no
+                    am_save_CPPFLAGS="$CPPFLAGS"
+    CPPFLAGS="$CPPFLAGS $INCICONV"
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdlib.h>
+#include <iconv.h>
+int
+main ()
+{
+iconv_t cd = iconv_open("","");
+       iconv(cd,NULL,NULL,NULL,NULL);
+       iconv_close(cd);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  am_cv_func_iconv=yes
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+    CPPFLAGS="$am_save_CPPFLAGS"
+
+    if test "$am_cv_func_iconv" != yes && test -d ../libiconv; then
+      for _libs in .libs _libs; do
+        am_save_CPPFLAGS="$CPPFLAGS"
+        am_save_LIBS="$LIBS"
+        CPPFLAGS="$CPPFLAGS -I../libiconv/include"
+        LIBS="$LIBS ../libiconv/lib/$_libs/libiconv.a"
+        cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdlib.h>
+#include <iconv.h>
+int
+main ()
+{
+iconv_t cd = iconv_open("","");
+           iconv(cd,NULL,NULL,NULL,NULL);
+           iconv_close(cd);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  INCICONV="-I../libiconv/include"
+          LIBICONV='${top_builddir}'/../libiconv/lib/$_libs/libiconv.a
+          LTLIBICONV='${top_builddir}'/../libiconv/lib/libiconv.la
+          am_cv_lib_iconv=yes
+          am_cv_func_iconv=yes
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+        CPPFLAGS="$am_save_CPPFLAGS"
+        LIBS="$am_save_LIBS"
+        if test "$am_cv_func_iconv" = "yes"; then
+          break
+        fi
+      done
+    fi
+
+    if test "$am_cv_func_iconv" != yes; then
+      am_save_CPPFLAGS="$CPPFLAGS"
+      am_save_LIBS="$LIBS"
+      CPPFLAGS="$LIBS $INCICONV"
+      LIBS="$LIBS $LIBICONV"
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdlib.h>
+#include <iconv.h>
+int
+main ()
+{
+iconv_t cd = iconv_open("","");
+         iconv(cd,NULL,NULL,NULL,NULL);
+         iconv_close(cd);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  am_cv_lib_iconv=yes
+        am_cv_func_iconv=yes
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+      CPPFLAGS="$am_save_CPPFLAGS"
+      LIBS="$am_save_LIBS"
+    fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $am_cv_func_iconv" >&5
+$as_echo "$am_cv_func_iconv" >&6; }
+  if test "$am_cv_func_iconv" = yes; then
+
+$as_echo "#define HAVE_ICONV 1" >>confdefs.h
+
+  fi
+  if test "$am_cv_lib_iconv" = yes; then
+
+  for element in $INCICONV; do
+    haveit=
+    for x in $CPPFLAGS; do
+
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  acl_save_exec_prefix="$exec_prefix"
+  exec_prefix="$acl_final_exec_prefix"
+  eval x=\"$x\"
+  exec_prefix="$acl_save_exec_prefix"
+  prefix="$acl_save_prefix"
+
+      if test "X$x" = "X$element"; then
+        haveit=yes
+        break
+      fi
+    done
+    if test -z "$haveit"; then
+      CPPFLAGS="${CPPFLAGS}${CPPFLAGS:+ }$element"
+    fi
+  done
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking how to link with libiconv" >&5
+$as_echo_n "checking how to link with libiconv... " >&6; }
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LIBICONV" >&5
+$as_echo "$LIBICONV" >&6; }
+  else
+    LIBICONV=
+    LTLIBICONV=
+  fi
+
+
+
+  if test "$am_cv_func_iconv" = yes; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for iconv declaration" >&5
+$as_echo_n "checking for iconv declaration... " >&6; }
+    if test "${am_cv_proto_iconv+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <stdlib.h>
+#include <iconv.h>
+extern
+#ifdef __cplusplus
+"C"
+#endif
+#if defined(__STDC__) || defined(__cplusplus)
+size_t iconv (iconv_t cd, char * *inbuf, size_t *inbytesleft, char * *outbuf, size_t *outbytesleft);
+#else
+size_t iconv();
+#endif
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  am_cv_proto_iconv_arg1=""
+else
+  am_cv_proto_iconv_arg1="const"
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+      am_cv_proto_iconv="extern size_t iconv (iconv_t cd, $am_cv_proto_iconv_arg1 char * *inbuf, size_t *inbytesleft, char * *outbuf, size_t *outbytesleft);"
+fi
+
+    am_cv_proto_iconv=`echo "$am_cv_proto_iconv" | tr -s ' ' | sed -e 's/( /(/'`
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: ${ac_t:-
+         }$am_cv_proto_iconv" >&5
+$as_echo "${ac_t:-
+         }$am_cv_proto_iconv" >&6; }
+
+cat >>confdefs.h <<_ACEOF
+#define ICONV_CONST $am_cv_proto_iconv_arg1
+_ACEOF
+
+  fi
+
+
+all_targets=false
+BUILD_NLMCONV=
+NLMCONV_DEFS=
+BUILD_SRCONV=
+BUILD_DLLTOOL=
+DLLTOOL_DEFS=
+DLLTOOL_DEFAULT=
+BUILD_WINDRES=
+BUILD_WINDMC=
+BUILD_DLLWRAP=
+BUILD_MISC=
+BUILD_INSTALL_MISC=
+OBJDUMP_DEFS=
+OBJDUMP_PRIVATE_VECTORS=
+OBJDUMP_PRIVATE_OFILES=
+od_vectors=
+
+for targ in $target $canon_targets
+do
+    if test "x$targ" = "xall"; then
+        all_targets=true
+	BUILD_NLMCONV='$(NLMCONV_PROG)$(EXEEXT)'
+	BUILD_SRCONV='$(SRCONV_PROG)'
+	NLMCONV_DEFS="-DNLMCONV_I386 -DNLMCONV_ALPHA -DNLMCONV_POWERPC -DNLMCONV_SPARC"
+	BUILD_MISC="${BUILD_MISC} "'bin2c$(EXEEXT_FOR_BUILD)'
+	BUILD_WINDRES='$(WINDRES_PROG)$(EXEEXT)'
+	BUILD_WINDMC='$(WINDMC_PROG)$(EXEEXT)'
+	BUILD_DLLTOOL='$(DLLTOOL_PROG)$(EXEEXT)'
+	if test -z "$DLLTOOL_DEFAULT"; then
+	  DLLTOOL_DEFAULT="-DDLLTOOL_DEFAULT_I386"
+	fi
+	DLLTOOL_DEFS="$DLLTOOL_DEFS -DDLLTOOL_I386"
+	BUILD_DLLWRAP='$(DLLWRAP_PROG)$(EXEEXT)'
+	od_vectors="$od_vectors objdump_private_desc_xcoff"
+    else
+	case $targ in
+	i[3-7]86*-*-netware*)
+	  BUILD_NLMCONV='$(NLMCONV_PROG)$(EXEEXT)'
+	  NLMCONV_DEFS="$NLMCONV_DEFS -DNLMCONV_I386"
+	  ;;
+	alpha*-*-netware*)
+	  BUILD_NLMCONV='$(NLMCONV_PROG)$(EXEEXT)'
+	  NLMCONV_DEFS="$NLMCONV_DEFS -DNLMCONV_ALPHA"
+	  ;;
+	powerpc*-*-netware*)
+	  BUILD_NLMCONV='$(NLMCONV_PROG)$(EXEEXT)'
+	  NLMCONV_DEFS="$NLMCONV_DEFS -DNLMCONV_POWERPC"
+	  ;;
+	sparc*-*-netware*)
+	  BUILD_NLMCONV='$(NLMCONV_PROG)$(EXEEXT)'
+	  NLMCONV_DEFS="$NLMCONV_DEFS -DNLMCONV_SPARC"
+	  ;;
+	esac
+
+	case $targ in
+	*-*-hms*) BUILD_SRCONV='$(SRCONV_PROG)' ;;
+	esac
+
+	case $targ in
+	arm-epoc-pe*)
+  	  BUILD_DLLTOOL='$(DLLTOOL_PROG)$(EXEEXT)'
+	  if test -z "$DLLTOOL_DEFAULT"; then
+	    DLLTOOL_DEFAULT="-DDLLTOOL_DEFAULT_ARM_EPOC"
+	  fi
+	  DLLTOOL_DEFS="$DLLTOOL_DEFS -DDLLTOOL_ARM_EPOC -DDLLTOOL_ARM"
+	  BUILD_WINDRES='$(WINDRES_PROG)$(EXEEXT)'
+	  BUILD_WINDMC='$(WINDMC_PROG)$(EXEEXT)'
+	  ;;
+	arm-wince-pe* | arm-*-wince | arm*-*-cegcc* | arm*-*-mingw32ce*)
+  	  BUILD_DLLTOOL='$(DLLTOOL_PROG)$(EXEEXT)'
+	  if test -z "$DLLTOOL_DEFAULT"; then
+	    DLLTOOL_DEFAULT="-DDLLTOOL_DEFAULT_ARM_WINCE"
+	  fi
+	  DLLTOOL_DEFS="$DLLTOOL_DEFS -DDLLTOOL_ARM_WINCE -DDLLTOOL_ARM"
+	  BUILD_WINDRES='$(WINDRES_PROG)$(EXEEXT)'
+	  BUILD_WINDMC='$(WINDMC_PROG)$(EXEEXT)'
+	  ;;
+	arm-*-pe*)
+  	  BUILD_DLLTOOL='$(DLLTOOL_PROG)$(EXEEXT)'
+	  if test -z "$DLLTOOL_DEFAULT"; then
+	    DLLTOOL_DEFAULT="-DDLLTOOL_DEFAULT_ARM"
+	  fi
+	  DLLTOOL_DEFS="$DLLTOOL_DEFS -DDLLTOOL_ARM"
+	  BUILD_WINDRES='$(WINDRES_PROG)$(EXEEXT)'
+	  BUILD_WINDMC='$(WINDMC_PROG)$(EXEEXT)'
+	  ;;
+	x86_64-*-mingw* | x86_64-*-cygwin*)
+  	  BUILD_DLLTOOL='$(DLLTOOL_PROG)$(EXEEXT)'
+	  if test -z "$DLLTOOL_DEFAULT"; then
+	    DLLTOOL_DEFAULT="-DDLLTOOL_DEFAULT_MX86_64"
+	  fi
+	  DLLTOOL_DEFS="$DLLTOOL_DEFS -DDLLTOOL_MX86_64"
+	  BUILD_WINDRES='$(WINDRES_PROG)$(EXEEXT)'
+	  BUILD_WINDMC='$(WINDMC_PROG)$(EXEEXT)'
+	  BUILD_DLLWRAP='$(DLLWRAP_PROG)$(EXEEXT)'
+	  ;;
+	i[3-7]86-*-pe* | i[3-7]86-*-cygwin* | i[3-7]86-*-mingw32** | i[3-7]86-*-netbsdpe*)
+  	  BUILD_DLLTOOL='$(DLLTOOL_PROG)$(EXEEXT)'
+	  if test -z "$DLLTOOL_DEFAULT"; then
+	    DLLTOOL_DEFAULT="-DDLLTOOL_DEFAULT_I386"
+	  fi
+	  DLLTOOL_DEFS="$DLLTOOL_DEFS -DDLLTOOL_I386"
+	  BUILD_WINDRES='$(WINDRES_PROG)$(EXEEXT)'
+	  BUILD_WINDMC='$(WINDMC_PROG)$(EXEEXT)'
+	  BUILD_DLLWRAP='$(DLLWRAP_PROG)$(EXEEXT)'
+	  ;;
+	i[3-7]86-*-interix)
+	  BUILD_DLLTOOL='$(DLLTOOL_PROG)'
+	  if test -z "$DLLTOOL_DEFAULT"; then
+	    DLLTOOL_DEFAULT="-DDLLTOOL_DEFAULT_I386"
+	  fi
+	  DLLTOOL_DEFS="$DLLTOOL_DEFS -DDLLTOOL_I386"
+	  ;;
+	powerpc*-aix5.[01])
+	  ;;
+	powerpc*-aix[5-9].*)
+	  OBJDUMP_DEFS="-DAIX_WEAK_SUPPORT"
+	  ;;
+	powerpc*-*-pe* | powerpc*-*-cygwin*)
+  	  BUILD_DLLTOOL='$(DLLTOOL_PROG)$(EXEEXT)'
+	  if test -z "$DLLTOOL_DEFAULT"; then
+	    DLLTOOL_DEFAULT="-DDLLTOOL_DEFAULT_PPC"
+	  fi
+	  DLLTOOL_DEFS="$DLLTOOL_DEFS -DDLLTOOL_PPC"
+	  BUILD_WINDRES='$(WINDRES_PROG)$(EXEEXT)'
+	  BUILD_WINDMC='$(WINDMC_PROG)$(EXEEXT)'
+	  ;;
+	powerpc*-*-linux* | powerpc*-*-elf* | powerpc*-*-eabi*)
+	  case "$BUILD_INSTALL_MISC" in
+	    *embedspu*) ;;
+	    *) BUILD_INSTALL_MISC="${BUILD_INSTALL_MISC} embedspu"
+	  esac
+	  ;;
+	sh*-*-pe)
+  	  BUILD_DLLTOOL='$(DLLTOOL_PROG)$(EXEEXT)'
+	  if test -z "$DLLTOOL_DEFAULT"; then
+	    DLLTOOL_DEFAULT="-DDLLTOOL_DEFAULT_SH"
+	  fi
+	  DLLTOOL_DEFS="$DLLTOOL_DEFS -DDLLTOOL_SH"
+	  BUILD_WINDRES='$(WINDRES_PROG)$(EXEEXT)'
+	  BUILD_WINDMC='$(WINDMC_PROG)$(EXEEXT)'
+	  ;;
+	spu-*-*)
+	  BUILD_MISC="${BUILD_MISC} "'bin2c$(EXEEXT_FOR_BUILD)'
+	  ;;
+	mips*-*-pe)
+  	  BUILD_DLLTOOL='$(DLLTOOL_PROG)$(EXEEXT)'
+	  if test -z "$DLLTOOL_DEFAULT"; then
+	    DLLTOOL_DEFAULT="-DDLLTOOL_DEFAULT_MIPS"
+	  fi
+	  DLLTOOL_DEFS="$DLLTOOL_DEFS -DDLLTOOL_MIPS"
+	  BUILD_WINDRES='$(WINDRES_PROG)$(EXEEXT)'
+	  BUILD_WINDMC='$(WINDMC_PROG)$(EXEEXT)'
+	  ;;
+	mcore-*-pe)
+  	  BUILD_DLLTOOL='$(DLLTOOL_PROG)$(EXEEXT)'
+	  if test -z "$DLLTOOL_DEFAULT"; then
+	    DLLTOOL_DEFAULT="-DDLLTOOL_DEFAULT_MCORE"
+	  fi
+	  DLLTOOL_DEFS="$DLLTOOL_DEFS -DDLLTOOL_MCORE"
+	  BUILD_WINDRES='$(WINDRES_PROG)$(EXEEXT)'
+	  BUILD_WINDMC='$(WINDMC_PROG)$(EXEEXT)'
+	  ;;
+	mcore-*-elf)
+  	  BUILD_DLLTOOL='$(DLLTOOL_PROG)$(EXEEXT)'
+	  if test -z "$DLLTOOL_DEFAULT"; then
+	    DLLTOOL_DEFAULT="-DDLLTOOL_DEFAULT_MCORE_ELF"
+	  fi
+	  DLLTOOL_DEFS="$DLLTOOL_DEFS -DDLLTOOL_MCORE_ELF"
+	  ;;
+  	mep-*)
+	  OBJDUMP_DEFS="-DSKIP_ZEROES=256 -DSKIP_ZEROES_AT_END=0"
+	  ;;
+	esac
+
+	# Add objdump private vectors.
+	case $targ in
+	avr-*-*)
+	  od_vectors="$od_vectors objdump_private_desc_elf32_avr"
+	  ;;
+	powerpc-*-aix*)
+	  od_vectors="$od_vectors objdump_private_desc_xcoff"
+	  ;;
+        *-*-darwin*)
+	  od_vectors="$od_vectors objdump_private_desc_mach_o"
+	  ;;
+	esac
+    fi
+done
+
+# Uniq objdump private vector, build objdump target ofiles.
+od_files=
+f=""
+for i in $od_vectors ; do
+    case " $f " in
+    *" $i "*) ;;
+    *)
+	f="$f $i"
+	OBJDUMP_PRIVATE_VECTORS="$OBJDUMP_PRIVATE_VECTORS &$i,"
+	case $i in
+	objdump_private_desc_elf32_avr)
+	    od_files="$od_files od-elf32_avr" ;;
+	objdump_private_desc_xcoff)
+	    od_files="$od_files od-xcoff" ;;
+	objdump_private_desc_mach_o)
+	    od_files="$od_files od-macho" ;;
+	*) as_fn_error "*** unknown private vector $i" "$LINENO" 5 ;;
+	esac
+	;;
+    esac
+done
+
+# Uniq objdump target ofiles
+f=""
+for i in $od_files ; do
+    case " $f " in
+    *" $i "*) ;;
+    *)
+	f="$f $i"
+	OBJDUMP_PRIVATE_OFILES="$OBJDUMP_PRIVATE_OFILES $i.$objext"
+	;;
+    esac
+done
+
+DLLTOOL_DEFS="$DLLTOOL_DEFS $DLLTOOL_DEFAULT"
+
+if test "${with_windres+set}" = set; then
+	  BUILD_WINDRES='$(WINDRES_PROG)$(EXEEXT)'
+fi
+
+if test "${with_windmc+set}" = set; then
+	  BUILD_WINDMC='$(WINDMC_PROG)$(EXEEXT)'
+fi
+
+OBJDUMP_DEFS="${OBJDUMP_DEFS} -DOBJDUMP_PRIVATE_VECTORS=\"${OBJDUMP_PRIVATE_VECTORS}\""
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+cat >>confdefs.h <<_ACEOF
+#define TARGET "${target}"
+_ACEOF
+
+
+targ=$target
+. $srcdir/../bfd/config.bfd
+if test "x$targ_underscore" = "xyes"; then
+    UNDERSCORE=1
+else
+    UNDERSCORE=0
+fi
+
+cat >>confdefs.h <<_ACEOF
+#define TARGET_PREPENDS_UNDERSCORE $UNDERSCORE
+_ACEOF
+
+
+# Emulation
+targ=$target
+. ${srcdir}/configure.tgt
+EMULATION=$targ_emul
+EMULATION_VECTOR=$targ_emul_vector
+
+
+
+
+# Required for html and install-html
+
+
+
+
+
+ac_config_files="$ac_config_files Makefile doc/Makefile po/Makefile.in:po/Make-in"
+
+cat >confcache <<\_ACEOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs, see configure's option --config-cache.
+# It is not useful on other systems.  If it contains results you don't
+# want to keep, you may remove or edit it.
+#
+# config.status only pays attention to the cache file if you give it
+# the --recheck option to rerun configure.
+#
+# `ac_cv_env_foo' variables (set or unset) will be overridden when
+# loading this file, other *unset* `ac_cv_foo' will be assigned the
+# following values.
+
+_ACEOF
+
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, we kill variables containing newlines.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+(
+  for ac_var in `(set) 2>&1 | sed -n 's/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'`; do
+    eval ac_val=\$$ac_var
+    case $ac_val in #(
+    *${as_nl}*)
+      case $ac_var in #(
+      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
+$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
+      esac
+      case $ac_var in #(
+      _ | IFS | as_nl) ;; #(
+      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
+      *) { eval $ac_var=; unset $ac_var;} ;;
+      esac ;;
+    esac
+  done
+
+  (set) 2>&1 |
+    case $as_nl`(ac_space=' '; set) 2>&1` in #(
+    *${as_nl}ac_space=\ *)
+      # `set' does not quote correctly, so add quotes: double-quote
+      # substitution turns \\\\ into \\, and sed turns \\ into \.
+      sed -n \
+	"s/'/'\\\\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
+      ;; #(
+    *)
+      # `set' quotes correctly as required by POSIX, so do not add quotes.
+      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
+      ;;
+    esac |
+    sort
+) |
+  sed '
+     /^ac_cv_env_/b end
+     t clear
+     :clear
+     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
+     t end
+     s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
+     :end' >>confcache
+if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
+  if test -w "$cache_file"; then
+    test "x$cache_file" != "x/dev/null" &&
+      { $as_echo "$as_me:${as_lineno-$LINENO}: updating cache $cache_file" >&5
+$as_echo "$as_me: updating cache $cache_file" >&6;}
+    cat confcache >$cache_file
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file" >&5
+$as_echo "$as_me: not updating unwritable cache $cache_file" >&6;}
+  fi
+fi
+rm -f confcache
+
+test "x$prefix" = xNONE && prefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
+
+DEFS=-DHAVE_CONFIG_H
+
+ac_libobjs=
+ac_ltlibobjs=
+for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
+  # 1. Remove the extension, and $U if already installed.
+  ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
+  ac_i=`$as_echo "$ac_i" | sed "$ac_script"`
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  as_fn_append ac_libobjs " \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  as_fn_append ac_ltlibobjs " \${LIBOBJDIR}$ac_i"'$U.lo'
+done
+LIBOBJS=$ac_libobjs
+
+LTLIBOBJS=$ac_ltlibobjs
+
+
+if test -z "${AMDEP_TRUE}" && test -z "${AMDEP_FALSE}"; then
+  as_fn_error "conditional \"AMDEP\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+if test -z "${am__fastdepCC_TRUE}" && test -z "${am__fastdepCC_FALSE}"; then
+  as_fn_error "conditional \"am__fastdepCC\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+ if test -n "$EXEEXT"; then
+  am__EXEEXT_TRUE=
+  am__EXEEXT_FALSE='#'
+else
+  am__EXEEXT_TRUE='#'
+  am__EXEEXT_FALSE=
+fi
+
+if test -z "${MAINTAINER_MODE_TRUE}" && test -z "${MAINTAINER_MODE_FALSE}"; then
+  as_fn_error "conditional \"MAINTAINER_MODE\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+if test -z "${GENINSRC_NEVER_TRUE}" && test -z "${GENINSRC_NEVER_FALSE}"; then
+  as_fn_error "conditional \"GENINSRC_NEVER\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+
+: ${CONFIG_STATUS=./config.status}
+ac_write_fail=0
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files $CONFIG_STATUS"
+{ $as_echo "$as_me:${as_lineno-$LINENO}: creating $CONFIG_STATUS" >&5
+$as_echo "$as_me: creating $CONFIG_STATUS" >&6;}
+as_write_fail=0
+cat >$CONFIG_STATUS <<_ASEOF || as_write_fail=1
+#! $SHELL
+# Generated by $as_me.
+# Run this file to recreate the current configuration.
+# Compiler output produced by configure, useful for debugging
+# configure, is in config.log if it exists.
+
+debug=false
+ac_cs_recheck=false
+ac_cs_silent=false
+
+SHELL=\${CONFIG_SHELL-$SHELL}
+export SHELL
+_ASEOF
+cat >>$CONFIG_STATUS <<\_ASEOF || as_write_fail=1
+## -------------------- ##
+## M4sh Initialization. ##
+## -------------------- ##
+
+# Be more Bourne compatible
+DUALCASE=1; export DUALCASE # for MKS sh
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
+esac
+fi
+
+
+as_nl='
+'
+export as_nl
+# Printing a long string crashes Solaris 7 /usr/bin/printf.
+as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
+# Prefer a ksh shell builtin over an external printf program on Solaris,
+# but without wasting forks for bash or zsh.
+if test -z "$BASH_VERSION$ZSH_VERSION" \
+    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='print -r --'
+  as_echo_n='print -rn --'
+elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='printf %s\n'
+  as_echo_n='printf %s'
+else
+  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
+    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
+    as_echo_n='/usr/ucb/echo -n'
+  else
+    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
+    as_echo_n_body='eval
+      arg=$1;
+      case $arg in #(
+      *"$as_nl"*)
+	expr "X$arg" : "X\\(.*\\)$as_nl";
+	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
+      esac;
+      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
+    '
+    export as_echo_n_body
+    as_echo_n='sh -c $as_echo_n_body as_echo'
+  fi
+  export as_echo_body
+  as_echo='sh -c $as_echo_body as_echo'
+fi
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  PATH_SEPARATOR=:
+  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
+    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
+      PATH_SEPARATOR=';'
+  }
+fi
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.  Quoting is
+# there to prevent editors from complaining about space-tab.
+# (If _AS_PATH_WALK were called with IFS unset, it would disable word
+# splitting by setting IFS to empty value.)
+IFS=" ""	$as_nl"
+
+# Find who we are.  Look in the path if we contain no directory separator.
+case $0 in #((
+  *[\\/]* ) as_myself=$0 ;;
+  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+  done
+IFS=$as_save_IFS
+
+     ;;
+esac
+# We did not find ourselves, most probably we were run as `sh COMMAND'
+# in which case we are not to be found in the path.
+if test "x$as_myself" = x; then
+  as_myself=$0
+fi
+if test ! -f "$as_myself"; then
+  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  exit 1
+fi
+
+# Unset variables that we do not need and which cause bugs (e.g. in
+# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
+# suppresses any "Segmentation fault" message there.  '((' could
+# trigger a bug in pdksh 5.2.14.
+for as_var in BASH_ENV ENV MAIL MAILPATH
+do eval test x\${$as_var+set} = xset \
+  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
+done
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+LC_ALL=C
+export LC_ALL
+LANGUAGE=C
+export LANGUAGE
+
+# CDPATH.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+
+# as_fn_error ERROR [LINENO LOG_FD]
+# ---------------------------------
+# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
+# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
+# script with status $?, using 1 if that was 0.
+as_fn_error ()
+{
+  as_status=$?; test $as_status -eq 0 && as_status=1
+  if test "$3"; then
+    as_lineno=${as_lineno-"$2"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    $as_echo "$as_me:${as_lineno-$LINENO}: error: $1" >&$3
+  fi
+  $as_echo "$as_me: error: $1" >&2
+  as_fn_exit $as_status
+} # as_fn_error
+
+
+# as_fn_set_status STATUS
+# -----------------------
+# Set $? to STATUS, without forking.
+as_fn_set_status ()
+{
+  return $1
+} # as_fn_set_status
+
+# as_fn_exit STATUS
+# -----------------
+# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
+as_fn_exit ()
+{
+  set +e
+  as_fn_set_status $1
+  exit $1
+} # as_fn_exit
+
+# as_fn_unset VAR
+# ---------------
+# Portably unset VAR.
+as_fn_unset ()
+{
+  { eval $1=; unset $1;}
+}
+as_unset=as_fn_unset
+# as_fn_append VAR VALUE
+# ----------------------
+# Append the text in VALUE to the end of the definition contained in VAR. Take
+# advantage of any shell optimizations that allow amortized linear growth over
+# repeated appends, instead of the typical quadratic growth present in naive
+# implementations.
+if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
+  eval 'as_fn_append ()
+  {
+    eval $1+=\$2
+  }'
+else
+  as_fn_append ()
+  {
+    eval $1=\$$1\$2
+  }
+fi # as_fn_append
+
+# as_fn_arith ARG...
+# ------------------
+# Perform arithmetic evaluation on the ARGs, and store the result in the
+# global $as_val. Take advantage of shells that can avoid forks. The arguments
+# must be portable across $(()) and expr.
+if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
+  eval 'as_fn_arith ()
+  {
+    as_val=$(( $* ))
+  }'
+else
+  as_fn_arith ()
+  {
+    as_val=`expr "$@" || test $? -eq 1`
+  }
+fi # as_fn_arith
+
+
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
+  as_dirname=dirname
+else
+  as_dirname=false
+fi
+
+as_me=`$as_basename -- "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+ECHO_C= ECHO_N= ECHO_T=
+case `echo -n x` in #(((((
+-n*)
+  case `echo 'xy\c'` in
+  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
+  xy)  ECHO_C='\c';;
+  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
+       ECHO_T='	';;
+  esac;;
+*)
+  ECHO_N='-n';;
+esac
+
+rm -f conf$$ conf$$.exe conf$$.file
+if test -d conf$$.dir; then
+  rm -f conf$$.dir/conf$$.file
+else
+  rm -f conf$$.dir
+  mkdir conf$$.dir 2>/dev/null
+fi
+if (echo >conf$$.file) 2>/dev/null; then
+  if ln -s conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s='ln -s'
+    # ... but there are two gotchas:
+    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
+    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
+    # In both cases, we have to default to `cp -p'.
+    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
+      as_ln_s='cp -p'
+  elif ln conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s=ln
+  else
+    as_ln_s='cp -p'
+  fi
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
+rmdir conf$$.dir 2>/dev/null
+
+
+# as_fn_mkdir_p
+# -------------
+# Create "$as_dir" as a directory, including parents if necessary.
+as_fn_mkdir_p ()
+{
+
+  case $as_dir in #(
+  -*) as_dir=./$as_dir;;
+  esac
+  test -d "$as_dir" || eval $as_mkdir_p || {
+    as_dirs=
+    while :; do
+      case $as_dir in #(
+      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
+      *) as_qdir=$as_dir;;
+      esac
+      as_dirs="'$as_qdir' $as_dirs"
+      as_dir=`$as_dirname -- "$as_dir" ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      test -d "$as_dir" && break
+    done
+    test -z "$as_dirs" || eval "mkdir $as_dirs"
+  } || test -d "$as_dir" || as_fn_error "cannot create directory $as_dir"
+
+
+} # as_fn_mkdir_p
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p='mkdir -p "$as_dir"'
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+if test -x / >/dev/null 2>&1; then
+  as_test_x='test -x'
+else
+  if ls -dL / >/dev/null 2>&1; then
+    as_ls_L_option=L
+  else
+    as_ls_L_option=
+  fi
+  as_test_x='
+    eval sh -c '\''
+      if test -d "$1"; then
+	test -d "$1/.";
+      else
+	case $1 in #(
+	-*)set "./$1";;
+	esac;
+	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
+	???[sx]*):;;*)false;;esac;fi
+    '\'' sh
+  '
+fi
+as_executable_p=$as_test_x
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+exec 6>&1
+## ----------------------------------- ##
+## Main body of $CONFIG_STATUS script. ##
+## ----------------------------------- ##
+_ASEOF
+test $as_write_fail = 0 && chmod +x $CONFIG_STATUS || ac_write_fail=1
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# Save the log message, to keep $0 and so on meaningful, and to
+# report actual input values of CONFIG_FILES etc. instead of their
+# values after options handling.
+ac_log="
+This file was extended by binutils $as_me 2.26, which was
+generated by GNU Autoconf 2.64.  Invocation command line was
+
+  CONFIG_FILES    = $CONFIG_FILES
+  CONFIG_HEADERS  = $CONFIG_HEADERS
+  CONFIG_LINKS    = $CONFIG_LINKS
+  CONFIG_COMMANDS = $CONFIG_COMMANDS
+  $ $0 $@
+
+on `(hostname || uname -n) 2>/dev/null | sed 1q`
+"
+
+_ACEOF
+
+case $ac_config_files in *"
+"*) set x $ac_config_files; shift; ac_config_files=$*;;
+esac
+
+case $ac_config_headers in *"
+"*) set x $ac_config_headers; shift; ac_config_headers=$*;;
+esac
+
+
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+# Files that config.status was made for.
+config_files="$ac_config_files"
+config_headers="$ac_config_headers"
+config_commands="$ac_config_commands"
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+ac_cs_usage="\
+\`$as_me' instantiates files and other configuration actions
+from templates according to the current configuration.  Unless the files
+and actions are specified as TAGs, all are instantiated by default.
+
+Usage: $0 [OPTION]... [TAG]...
+
+  -h, --help       print this help, then exit
+  -V, --version    print version number and configuration settings, then exit
+  -q, --quiet, --silent
+                   do not print progress messages
+  -d, --debug      don't remove temporary files
+      --recheck    update $as_me by reconfiguring in the same conditions
+      --file=FILE[:TEMPLATE]
+                   instantiate the configuration file FILE
+      --header=FILE[:TEMPLATE]
+                   instantiate the configuration header FILE
+
+Configuration files:
+$config_files
+
+Configuration headers:
+$config_headers
+
+Configuration commands:
+$config_commands
+
+Report bugs to the package provider."
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+ac_cs_version="\\
+binutils config.status 2.26
+configured by $0, generated by GNU Autoconf 2.64,
+  with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
+
+Copyright (C) 2009 Free Software Foundation, Inc.
+This config.status script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it."
+
+ac_pwd='$ac_pwd'
+srcdir='$srcdir'
+INSTALL='$INSTALL'
+MKDIR_P='$MKDIR_P'
+AWK='$AWK'
+test -n "\$AWK" || AWK=awk
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# The default lists apply if the user does not specify any file.
+ac_need_defaults=:
+while test $# != 0
+do
+  case $1 in
+  --*=*)
+    ac_option=`expr "X$1" : 'X\([^=]*\)='`
+    ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
+    ac_shift=:
+    ;;
+  *)
+    ac_option=$1
+    ac_optarg=$2
+    ac_shift=shift
+    ;;
+  esac
+
+  case $ac_option in
+  # Handling of the options.
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    ac_cs_recheck=: ;;
+  --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
+    $as_echo "$ac_cs_version"; exit ;;
+  --debug | --debu | --deb | --de | --d | -d )
+    debug=: ;;
+  --file | --fil | --fi | --f )
+    $ac_shift
+    case $ac_optarg in
+    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    as_fn_append CONFIG_FILES " '$ac_optarg'"
+    ac_need_defaults=false;;
+  --header | --heade | --head | --hea )
+    $ac_shift
+    case $ac_optarg in
+    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    as_fn_append CONFIG_HEADERS " '$ac_optarg'"
+    ac_need_defaults=false;;
+  --he | --h)
+    # Conflict between --help and --header
+    as_fn_error "ambiguous option: \`$1'
+Try \`$0 --help' for more information.";;
+  --help | --hel | -h )
+    $as_echo "$ac_cs_usage"; exit ;;
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil | --si | --s)
+    ac_cs_silent=: ;;
+
+  # This is an error.
+  -*) as_fn_error "unrecognized option: \`$1'
+Try \`$0 --help' for more information." ;;
+
+  *) as_fn_append ac_config_targets " $1"
+     ac_need_defaults=false ;;
+
+  esac
+  shift
+done
+
+ac_configure_extra_args=
+
+if $ac_cs_silent; then
+  exec 6>/dev/null
+  ac_configure_extra_args="$ac_configure_extra_args --silent"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+if \$ac_cs_recheck; then
+  set X '$SHELL' '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+  shift
+  \$as_echo "running CONFIG_SHELL=$SHELL \$*" >&6
+  CONFIG_SHELL='$SHELL'
+  export CONFIG_SHELL
+  exec "\$@"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+exec 5>>config.log
+{
+  echo
+  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
+## Running $as_me. ##
+_ASBOX
+  $as_echo "$ac_log"
+} >&5
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+#
+# INIT-COMMANDS
+#
+AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"
+
+
+# The HP-UX ksh and POSIX shell print the target directory to stdout
+# if CDPATH is set.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+sed_quote_subst='$sed_quote_subst'
+double_quote_subst='$double_quote_subst'
+delay_variable_subst='$delay_variable_subst'
+macro_version='`$ECHO "$macro_version" | $SED "$delay_single_quote_subst"`'
+macro_revision='`$ECHO "$macro_revision" | $SED "$delay_single_quote_subst"`'
+enable_shared='`$ECHO "$enable_shared" | $SED "$delay_single_quote_subst"`'
+enable_static='`$ECHO "$enable_static" | $SED "$delay_single_quote_subst"`'
+pic_mode='`$ECHO "$pic_mode" | $SED "$delay_single_quote_subst"`'
+enable_fast_install='`$ECHO "$enable_fast_install" | $SED "$delay_single_quote_subst"`'
+SHELL='`$ECHO "$SHELL" | $SED "$delay_single_quote_subst"`'
+ECHO='`$ECHO "$ECHO" | $SED "$delay_single_quote_subst"`'
+host_alias='`$ECHO "$host_alias" | $SED "$delay_single_quote_subst"`'
+host='`$ECHO "$host" | $SED "$delay_single_quote_subst"`'
+host_os='`$ECHO "$host_os" | $SED "$delay_single_quote_subst"`'
+build_alias='`$ECHO "$build_alias" | $SED "$delay_single_quote_subst"`'
+build='`$ECHO "$build" | $SED "$delay_single_quote_subst"`'
+build_os='`$ECHO "$build_os" | $SED "$delay_single_quote_subst"`'
+SED='`$ECHO "$SED" | $SED "$delay_single_quote_subst"`'
+Xsed='`$ECHO "$Xsed" | $SED "$delay_single_quote_subst"`'
+GREP='`$ECHO "$GREP" | $SED "$delay_single_quote_subst"`'
+EGREP='`$ECHO "$EGREP" | $SED "$delay_single_quote_subst"`'
+FGREP='`$ECHO "$FGREP" | $SED "$delay_single_quote_subst"`'
+LD='`$ECHO "$LD" | $SED "$delay_single_quote_subst"`'
+NM='`$ECHO "$NM" | $SED "$delay_single_quote_subst"`'
+LN_S='`$ECHO "$LN_S" | $SED "$delay_single_quote_subst"`'
+max_cmd_len='`$ECHO "$max_cmd_len" | $SED "$delay_single_quote_subst"`'
+ac_objext='`$ECHO "$ac_objext" | $SED "$delay_single_quote_subst"`'
+exeext='`$ECHO "$exeext" | $SED "$delay_single_quote_subst"`'
+lt_unset='`$ECHO "$lt_unset" | $SED "$delay_single_quote_subst"`'
+lt_SP2NL='`$ECHO "$lt_SP2NL" | $SED "$delay_single_quote_subst"`'
+lt_NL2SP='`$ECHO "$lt_NL2SP" | $SED "$delay_single_quote_subst"`'
+reload_flag='`$ECHO "$reload_flag" | $SED "$delay_single_quote_subst"`'
+reload_cmds='`$ECHO "$reload_cmds" | $SED "$delay_single_quote_subst"`'
+OBJDUMP='`$ECHO "$OBJDUMP" | $SED "$delay_single_quote_subst"`'
+deplibs_check_method='`$ECHO "$deplibs_check_method" | $SED "$delay_single_quote_subst"`'
+file_magic_cmd='`$ECHO "$file_magic_cmd" | $SED "$delay_single_quote_subst"`'
+AR='`$ECHO "$AR" | $SED "$delay_single_quote_subst"`'
+AR_FLAGS='`$ECHO "$AR_FLAGS" | $SED "$delay_single_quote_subst"`'
+STRIP='`$ECHO "$STRIP" | $SED "$delay_single_quote_subst"`'
+RANLIB='`$ECHO "$RANLIB" | $SED "$delay_single_quote_subst"`'
+old_postinstall_cmds='`$ECHO "$old_postinstall_cmds" | $SED "$delay_single_quote_subst"`'
+old_postuninstall_cmds='`$ECHO "$old_postuninstall_cmds" | $SED "$delay_single_quote_subst"`'
+old_archive_cmds='`$ECHO "$old_archive_cmds" | $SED "$delay_single_quote_subst"`'
+lock_old_archive_extraction='`$ECHO "$lock_old_archive_extraction" | $SED "$delay_single_quote_subst"`'
+CC='`$ECHO "$CC" | $SED "$delay_single_quote_subst"`'
+CFLAGS='`$ECHO "$CFLAGS" | $SED "$delay_single_quote_subst"`'
+compiler='`$ECHO "$compiler" | $SED "$delay_single_quote_subst"`'
+GCC='`$ECHO "$GCC" | $SED "$delay_single_quote_subst"`'
+lt_cv_sys_global_symbol_pipe='`$ECHO "$lt_cv_sys_global_symbol_pipe" | $SED "$delay_single_quote_subst"`'
+lt_cv_sys_global_symbol_to_cdecl='`$ECHO "$lt_cv_sys_global_symbol_to_cdecl" | $SED "$delay_single_quote_subst"`'
+lt_cv_sys_global_symbol_to_c_name_address='`$ECHO "$lt_cv_sys_global_symbol_to_c_name_address" | $SED "$delay_single_quote_subst"`'
+lt_cv_sys_global_symbol_to_c_name_address_lib_prefix='`$ECHO "$lt_cv_sys_global_symbol_to_c_name_address_lib_prefix" | $SED "$delay_single_quote_subst"`'
+objdir='`$ECHO "$objdir" | $SED "$delay_single_quote_subst"`'
+MAGIC_CMD='`$ECHO "$MAGIC_CMD" | $SED "$delay_single_quote_subst"`'
+lt_prog_compiler_no_builtin_flag='`$ECHO "$lt_prog_compiler_no_builtin_flag" | $SED "$delay_single_quote_subst"`'
+lt_prog_compiler_wl='`$ECHO "$lt_prog_compiler_wl" | $SED "$delay_single_quote_subst"`'
+lt_prog_compiler_pic='`$ECHO "$lt_prog_compiler_pic" | $SED "$delay_single_quote_subst"`'
+lt_prog_compiler_static='`$ECHO "$lt_prog_compiler_static" | $SED "$delay_single_quote_subst"`'
+lt_cv_prog_compiler_c_o='`$ECHO "$lt_cv_prog_compiler_c_o" | $SED "$delay_single_quote_subst"`'
+need_locks='`$ECHO "$need_locks" | $SED "$delay_single_quote_subst"`'
+DSYMUTIL='`$ECHO "$DSYMUTIL" | $SED "$delay_single_quote_subst"`'
+NMEDIT='`$ECHO "$NMEDIT" | $SED "$delay_single_quote_subst"`'
+LIPO='`$ECHO "$LIPO" | $SED "$delay_single_quote_subst"`'
+OTOOL='`$ECHO "$OTOOL" | $SED "$delay_single_quote_subst"`'
+OTOOL64='`$ECHO "$OTOOL64" | $SED "$delay_single_quote_subst"`'
+libext='`$ECHO "$libext" | $SED "$delay_single_quote_subst"`'
+shrext_cmds='`$ECHO "$shrext_cmds" | $SED "$delay_single_quote_subst"`'
+extract_expsyms_cmds='`$ECHO "$extract_expsyms_cmds" | $SED "$delay_single_quote_subst"`'
+archive_cmds_need_lc='`$ECHO "$archive_cmds_need_lc" | $SED "$delay_single_quote_subst"`'
+enable_shared_with_static_runtimes='`$ECHO "$enable_shared_with_static_runtimes" | $SED "$delay_single_quote_subst"`'
+export_dynamic_flag_spec='`$ECHO "$export_dynamic_flag_spec" | $SED "$delay_single_quote_subst"`'
+whole_archive_flag_spec='`$ECHO "$whole_archive_flag_spec" | $SED "$delay_single_quote_subst"`'
+compiler_needs_object='`$ECHO "$compiler_needs_object" | $SED "$delay_single_quote_subst"`'
+old_archive_from_new_cmds='`$ECHO "$old_archive_from_new_cmds" | $SED "$delay_single_quote_subst"`'
+old_archive_from_expsyms_cmds='`$ECHO "$old_archive_from_expsyms_cmds" | $SED "$delay_single_quote_subst"`'
+archive_cmds='`$ECHO "$archive_cmds" | $SED "$delay_single_quote_subst"`'
+archive_expsym_cmds='`$ECHO "$archive_expsym_cmds" | $SED "$delay_single_quote_subst"`'
+module_cmds='`$ECHO "$module_cmds" | $SED "$delay_single_quote_subst"`'
+module_expsym_cmds='`$ECHO "$module_expsym_cmds" | $SED "$delay_single_quote_subst"`'
+with_gnu_ld='`$ECHO "$with_gnu_ld" | $SED "$delay_single_quote_subst"`'
+allow_undefined_flag='`$ECHO "$allow_undefined_flag" | $SED "$delay_single_quote_subst"`'
+no_undefined_flag='`$ECHO "$no_undefined_flag" | $SED "$delay_single_quote_subst"`'
+hardcode_libdir_flag_spec='`$ECHO "$hardcode_libdir_flag_spec" | $SED "$delay_single_quote_subst"`'
+hardcode_libdir_flag_spec_ld='`$ECHO "$hardcode_libdir_flag_spec_ld" | $SED "$delay_single_quote_subst"`'
+hardcode_libdir_separator='`$ECHO "$hardcode_libdir_separator" | $SED "$delay_single_quote_subst"`'
+hardcode_direct='`$ECHO "$hardcode_direct" | $SED "$delay_single_quote_subst"`'
+hardcode_direct_absolute='`$ECHO "$hardcode_direct_absolute" | $SED "$delay_single_quote_subst"`'
+hardcode_minus_L='`$ECHO "$hardcode_minus_L" | $SED "$delay_single_quote_subst"`'
+hardcode_shlibpath_var='`$ECHO "$hardcode_shlibpath_var" | $SED "$delay_single_quote_subst"`'
+hardcode_automatic='`$ECHO "$hardcode_automatic" | $SED "$delay_single_quote_subst"`'
+inherit_rpath='`$ECHO "$inherit_rpath" | $SED "$delay_single_quote_subst"`'
+link_all_deplibs='`$ECHO "$link_all_deplibs" | $SED "$delay_single_quote_subst"`'
+fix_srcfile_path='`$ECHO "$fix_srcfile_path" | $SED "$delay_single_quote_subst"`'
+always_export_symbols='`$ECHO "$always_export_symbols" | $SED "$delay_single_quote_subst"`'
+export_symbols_cmds='`$ECHO "$export_symbols_cmds" | $SED "$delay_single_quote_subst"`'
+exclude_expsyms='`$ECHO "$exclude_expsyms" | $SED "$delay_single_quote_subst"`'
+include_expsyms='`$ECHO "$include_expsyms" | $SED "$delay_single_quote_subst"`'
+prelink_cmds='`$ECHO "$prelink_cmds" | $SED "$delay_single_quote_subst"`'
+file_list_spec='`$ECHO "$file_list_spec" | $SED "$delay_single_quote_subst"`'
+variables_saved_for_relink='`$ECHO "$variables_saved_for_relink" | $SED "$delay_single_quote_subst"`'
+need_lib_prefix='`$ECHO "$need_lib_prefix" | $SED "$delay_single_quote_subst"`'
+need_version='`$ECHO "$need_version" | $SED "$delay_single_quote_subst"`'
+version_type='`$ECHO "$version_type" | $SED "$delay_single_quote_subst"`'
+runpath_var='`$ECHO "$runpath_var" | $SED "$delay_single_quote_subst"`'
+shlibpath_var='`$ECHO "$shlibpath_var" | $SED "$delay_single_quote_subst"`'
+shlibpath_overrides_runpath='`$ECHO "$shlibpath_overrides_runpath" | $SED "$delay_single_quote_subst"`'
+libname_spec='`$ECHO "$libname_spec" | $SED "$delay_single_quote_subst"`'
+library_names_spec='`$ECHO "$library_names_spec" | $SED "$delay_single_quote_subst"`'
+soname_spec='`$ECHO "$soname_spec" | $SED "$delay_single_quote_subst"`'
+install_override_mode='`$ECHO "$install_override_mode" | $SED "$delay_single_quote_subst"`'
+postinstall_cmds='`$ECHO "$postinstall_cmds" | $SED "$delay_single_quote_subst"`'
+postuninstall_cmds='`$ECHO "$postuninstall_cmds" | $SED "$delay_single_quote_subst"`'
+finish_cmds='`$ECHO "$finish_cmds" | $SED "$delay_single_quote_subst"`'
+finish_eval='`$ECHO "$finish_eval" | $SED "$delay_single_quote_subst"`'
+hardcode_into_libs='`$ECHO "$hardcode_into_libs" | $SED "$delay_single_quote_subst"`'
+sys_lib_search_path_spec='`$ECHO "$sys_lib_search_path_spec" | $SED "$delay_single_quote_subst"`'
+sys_lib_dlsearch_path_spec='`$ECHO "$sys_lib_dlsearch_path_spec" | $SED "$delay_single_quote_subst"`'
+hardcode_action='`$ECHO "$hardcode_action" | $SED "$delay_single_quote_subst"`'
+enable_dlopen='`$ECHO "$enable_dlopen" | $SED "$delay_single_quote_subst"`'
+enable_dlopen_self='`$ECHO "$enable_dlopen_self" | $SED "$delay_single_quote_subst"`'
+enable_dlopen_self_static='`$ECHO "$enable_dlopen_self_static" | $SED "$delay_single_quote_subst"`'
+old_striplib='`$ECHO "$old_striplib" | $SED "$delay_single_quote_subst"`'
+striplib='`$ECHO "$striplib" | $SED "$delay_single_quote_subst"`'
+
+LTCC='$LTCC'
+LTCFLAGS='$LTCFLAGS'
+compiler='$compiler_DEFAULT'
+
+# A function that is used when there is no print builtin or printf.
+func_fallback_echo ()
+{
+  eval 'cat <<_LTECHO_EOF
+\$1
+_LTECHO_EOF'
+}
+
+# Quote evaled strings.
+for var in SHELL \
+ECHO \
+SED \
+GREP \
+EGREP \
+FGREP \
+LD \
+NM \
+LN_S \
+lt_SP2NL \
+lt_NL2SP \
+reload_flag \
+OBJDUMP \
+deplibs_check_method \
+file_magic_cmd \
+AR \
+AR_FLAGS \
+STRIP \
+RANLIB \
+CC \
+CFLAGS \
+compiler \
+lt_cv_sys_global_symbol_pipe \
+lt_cv_sys_global_symbol_to_cdecl \
+lt_cv_sys_global_symbol_to_c_name_address \
+lt_cv_sys_global_symbol_to_c_name_address_lib_prefix \
+lt_prog_compiler_no_builtin_flag \
+lt_prog_compiler_wl \
+lt_prog_compiler_pic \
+lt_prog_compiler_static \
+lt_cv_prog_compiler_c_o \
+need_locks \
+DSYMUTIL \
+NMEDIT \
+LIPO \
+OTOOL \
+OTOOL64 \
+shrext_cmds \
+export_dynamic_flag_spec \
+whole_archive_flag_spec \
+compiler_needs_object \
+with_gnu_ld \
+allow_undefined_flag \
+no_undefined_flag \
+hardcode_libdir_flag_spec \
+hardcode_libdir_flag_spec_ld \
+hardcode_libdir_separator \
+fix_srcfile_path \
+exclude_expsyms \
+include_expsyms \
+file_list_spec \
+variables_saved_for_relink \
+libname_spec \
+library_names_spec \
+soname_spec \
+install_override_mode \
+finish_eval \
+old_striplib \
+striplib; do
+    case \`eval \\\\\$ECHO \\\\""\\\\\$\$var"\\\\"\` in
+    *[\\\\\\\`\\"\\\$]*)
+      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"\\\$\$var\\" | \\\$SED \\"\\\$sed_quote_subst\\"\\\`\\\\\\""
+      ;;
+    *)
+      eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
+      ;;
+    esac
+done
+
+# Double-quote double-evaled strings.
+for var in reload_cmds \
+old_postinstall_cmds \
+old_postuninstall_cmds \
+old_archive_cmds \
+extract_expsyms_cmds \
+old_archive_from_new_cmds \
+old_archive_from_expsyms_cmds \
+archive_cmds \
+archive_expsym_cmds \
+module_cmds \
+module_expsym_cmds \
+export_symbols_cmds \
+prelink_cmds \
+postinstall_cmds \
+postuninstall_cmds \
+finish_cmds \
+sys_lib_search_path_spec \
+sys_lib_dlsearch_path_spec; do
+    case \`eval \\\\\$ECHO \\\\""\\\\\$\$var"\\\\"\` in
+    *[\\\\\\\`\\"\\\$]*)
+      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"\\\$\$var\\" | \\\$SED -e \\"\\\$double_quote_subst\\" -e \\"\\\$sed_quote_subst\\" -e \\"\\\$delay_variable_subst\\"\\\`\\\\\\""
+      ;;
+    *)
+      eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
+      ;;
+    esac
+done
+
+ac_aux_dir='$ac_aux_dir'
+xsi_shell='$xsi_shell'
+lt_shell_append='$lt_shell_append'
+
+# See if we are running on zsh, and set the options which allow our
+# commands through without removal of \ escapes INIT.
+if test -n "\${ZSH_VERSION+set}" ; then
+   setopt NO_GLOB_SUBST
+fi
+
+
+    PACKAGE='$PACKAGE'
+    VERSION='$VERSION'
+    TIMESTAMP='$TIMESTAMP'
+    RM='$RM'
+    ofile='$ofile'
+
+
+
+# Capture the value of obsolete ALL_LINGUAS because we need it to compute
+    # POFILES, GMOFILES, UPDATEPOFILES, DUMMYPOFILES, CATALOGS. But hide it
+    # from automake.
+    eval 'OBSOLETE_ALL_LINGUAS''="$ALL_LINGUAS"'
+    # Capture the value of LINGUAS because we need it to compute CATALOGS.
+    LINGUAS="${LINGUAS-%UNSET%}"
+
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+
+# Handling of arguments.
+for ac_config_target in $ac_config_targets
+do
+  case $ac_config_target in
+    "depfiles") CONFIG_COMMANDS="$CONFIG_COMMANDS depfiles" ;;
+    "libtool") CONFIG_COMMANDS="$CONFIG_COMMANDS libtool" ;;
+    "config.h") CONFIG_HEADERS="$CONFIG_HEADERS config.h:config.in" ;;
+    "default-1") CONFIG_COMMANDS="$CONFIG_COMMANDS default-1" ;;
+    "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
+    "doc/Makefile") CONFIG_FILES="$CONFIG_FILES doc/Makefile" ;;
+    "po/Makefile.in") CONFIG_FILES="$CONFIG_FILES po/Makefile.in:po/Make-in" ;;
+
+  *) as_fn_error "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
+  esac
+done
+
+
+# If the user did not use the arguments to specify the items to instantiate,
+# then the envvar interface is used.  Set only those that are not.
+# We use the long form for the default assignment because of an extremely
+# bizarre bug on SunOS 4.1.3.
+if $ac_need_defaults; then
+  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
+  test "${CONFIG_HEADERS+set}" = set || CONFIG_HEADERS=$config_headers
+  test "${CONFIG_COMMANDS+set}" = set || CONFIG_COMMANDS=$config_commands
+fi
+
+# Have a temporary directory for convenience.  Make it in the build tree
+# simply because there is no reason against having it here, and in addition,
+# creating and moving files from /tmp can sometimes cause problems.
+# Hook for its removal unless debugging.
+# Note that there is a small window in which the directory will not be cleaned:
+# after its creation but before its name has been assigned to `$tmp'.
+$debug ||
+{
+  tmp=
+  trap 'exit_status=$?
+  { test -z "$tmp" || test ! -d "$tmp" || rm -fr "$tmp"; } && exit $exit_status
+' 0
+  trap 'as_fn_exit 1' 1 2 13 15
+}
+# Create a (secure) tmp directory for tmp files.
+
+{
+  tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
+  test -n "$tmp" && test -d "$tmp"
+}  ||
+{
+  tmp=./conf$$-$RANDOM
+  (umask 077 && mkdir "$tmp")
+} || as_fn_error "cannot create a temporary directory in ." "$LINENO" 5
+
+# Set up the scripts for CONFIG_FILES section.
+# No need to generate them if there are no CONFIG_FILES.
+# This happens for instance with `./config.status config.h'.
+if test -n "$CONFIG_FILES"; then
+
+
+ac_cr=`echo X | tr X '\015'`
+# On cygwin, bash can eat \r inside `` if the user requested igncr.
+# But we know of no other shell where ac_cr would be empty at this
+# point, so we can use a bashism as a fallback.
+if test "x$ac_cr" = x; then
+  eval ac_cr=\$\'\\r\'
+fi
+ac_cs_awk_cr=`$AWK 'BEGIN { print "a\rb" }' </dev/null 2>/dev/null`
+if test "$ac_cs_awk_cr" = "a${ac_cr}b"; then
+  ac_cs_awk_cr='\r'
+else
+  ac_cs_awk_cr=$ac_cr
+fi
+
+echo 'BEGIN {' >"$tmp/subs1.awk" &&
+_ACEOF
+
+
+{
+  echo "cat >conf$$subs.awk <<_ACEOF" &&
+  echo "$ac_subst_vars" | sed 's/.*/&!$&$ac_delim/' &&
+  echo "_ACEOF"
+} >conf$$subs.sh ||
+  as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
+ac_delim_num=`echo "$ac_subst_vars" | grep -c '$'`
+ac_delim='%!_!# '
+for ac_last_try in false false false false false :; do
+  . ./conf$$subs.sh ||
+    as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
+
+  ac_delim_n=`sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X`
+  if test $ac_delim_n = $ac_delim_num; then
+    break
+  elif $ac_last_try; then
+    as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
+  else
+    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
+  fi
+done
+rm -f conf$$subs.sh
+
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+cat >>"\$tmp/subs1.awk" <<\\_ACAWK &&
+_ACEOF
+sed -n '
+h
+s/^/S["/; s/!.*/"]=/
+p
+g
+s/^[^!]*!//
+:repl
+t repl
+s/'"$ac_delim"'$//
+t delim
+:nl
+h
+s/\(.\{148\}\).*/\1/
+t more1
+s/["\\]/\\&/g; s/^/"/; s/$/\\n"\\/
+p
+n
+b repl
+:more1
+s/["\\]/\\&/g; s/^/"/; s/$/"\\/
+p
+g
+s/.\{148\}//
+t nl
+:delim
+h
+s/\(.\{148\}\).*/\1/
+t more2
+s/["\\]/\\&/g; s/^/"/; s/$/"/
+p
+b
+:more2
+s/["\\]/\\&/g; s/^/"/; s/$/"\\/
+p
+g
+s/.\{148\}//
+t delim
+' <conf$$subs.awk | sed '
+/^[^""]/{
+  N
+  s/\n//
+}
+' >>$CONFIG_STATUS || ac_write_fail=1
+rm -f conf$$subs.awk
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+_ACAWK
+cat >>"\$tmp/subs1.awk" <<_ACAWK &&
+  for (key in S) S_is_set[key] = 1
+  FS = ""
+
+}
+{
+  line = $ 0
+  nfields = split(line, field, "@")
+  substed = 0
+  len = length(field[1])
+  for (i = 2; i < nfields; i++) {
+    key = field[i]
+    keylen = length(key)
+    if (S_is_set[key]) {
+      value = S[key]
+      line = substr(line, 1, len) "" value "" substr(line, len + keylen + 3)
+      len += length(value) + length(field[++i])
+      substed = 1
+    } else
+      len += 1 + keylen
+  }
+
+  print line
+}
+
+_ACAWK
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+if sed "s/$ac_cr//" < /dev/null > /dev/null 2>&1; then
+  sed "s/$ac_cr\$//; s/$ac_cr/$ac_cs_awk_cr/g"
+else
+  cat
+fi < "$tmp/subs1.awk" > "$tmp/subs.awk" \
+  || as_fn_error "could not setup config files machinery" "$LINENO" 5
+_ACEOF
+
+# VPATH may cause trouble with some makes, so we remove $(srcdir),
+# ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
+# trailing colons and then remove the whole line if VPATH becomes empty
+# (actually we leave an empty line to preserve line numbers).
+if test "x$srcdir" = x.; then
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
+s/:*\$(srcdir):*/:/
+s/:*\${srcdir}:*/:/
+s/:*@srcdir@:*/:/
+s/^\([^=]*=[	 ]*\):*/\1/
+s/:*$//
+s/^[^=]*=[	 ]*$//
+}'
+fi
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+fi # test -n "$CONFIG_FILES"
+
+# Set up the scripts for CONFIG_HEADERS section.
+# No need to generate them if there are no CONFIG_HEADERS.
+# This happens for instance with `./config.status Makefile'.
+if test -n "$CONFIG_HEADERS"; then
+cat >"$tmp/defines.awk" <<\_ACAWK ||
+BEGIN {
+_ACEOF
+
+# Transform confdefs.h into an awk script `defines.awk', embedded as
+# here-document in config.status, that substitutes the proper values into
+# config.h.in to produce config.h.
+
+# Create a delimiter string that does not exist in confdefs.h, to ease
+# handling of long lines.
+ac_delim='%!_!# '
+for ac_last_try in false false :; do
+  ac_t=`sed -n "/$ac_delim/p" confdefs.h`
+  if test -z "$ac_t"; then
+    break
+  elif $ac_last_try; then
+    as_fn_error "could not make $CONFIG_HEADERS" "$LINENO" 5
+  else
+    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
+  fi
+done
+
+# For the awk script, D is an array of macro values keyed by name,
+# likewise P contains macro parameters if any.  Preserve backslash
+# newline sequences.
+
+ac_word_re=[_$as_cr_Letters][_$as_cr_alnum]*
+sed -n '
+s/.\{148\}/&'"$ac_delim"'/g
+t rset
+:rset
+s/^[	 ]*#[	 ]*define[	 ][	 ]*/ /
+t def
+d
+:def
+s/\\$//
+t bsnl
+s/["\\]/\\&/g
+s/^ \('"$ac_word_re"'\)\(([^()]*)\)[	 ]*\(.*\)/P["\1"]="\2"\
+D["\1"]=" \3"/p
+s/^ \('"$ac_word_re"'\)[	 ]*\(.*\)/D["\1"]=" \2"/p
+d
+:bsnl
+s/["\\]/\\&/g
+s/^ \('"$ac_word_re"'\)\(([^()]*)\)[	 ]*\(.*\)/P["\1"]="\2"\
+D["\1"]=" \3\\\\\\n"\\/p
+t cont
+s/^ \('"$ac_word_re"'\)[	 ]*\(.*\)/D["\1"]=" \2\\\\\\n"\\/p
+t cont
+d
+:cont
+n
+s/.\{148\}/&'"$ac_delim"'/g
+t clear
+:clear
+s/\\$//
+t bsnlc
+s/["\\]/\\&/g; s/^/"/; s/$/"/p
+d
+:bsnlc
+s/["\\]/\\&/g; s/^/"/; s/$/\\\\\\n"\\/p
+b cont
+' <confdefs.h | sed '
+s/'"$ac_delim"'/"\\\
+"/g' >>$CONFIG_STATUS || ac_write_fail=1
+
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+  for (key in D) D_is_set[key] = 1
+  FS = ""
+}
+/^[\t ]*#[\t ]*(define|undef)[\t ]+$ac_word_re([\t (]|\$)/ {
+  line = \$ 0
+  split(line, arg, " ")
+  if (arg[1] == "#") {
+    defundef = arg[2]
+    mac1 = arg[3]
+  } else {
+    defundef = substr(arg[1], 2)
+    mac1 = arg[2]
+  }
+  split(mac1, mac2, "(") #)
+  macro = mac2[1]
+  prefix = substr(line, 1, index(line, defundef) - 1)
+  if (D_is_set[macro]) {
+    # Preserve the white space surrounding the "#".
+    print prefix "define", macro P[macro] D[macro]
+    next
+  } else {
+    # Replace #undef with comments.  This is necessary, for example,
+    # in the case of _POSIX_SOURCE, which is predefined and required
+    # on some systems where configure will not decide to define it.
+    if (defundef == "undef") {
+      print "/*", prefix defundef, macro, "*/"
+      next
+    }
+  }
+}
+{ print }
+_ACAWK
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+  as_fn_error "could not setup config headers machinery" "$LINENO" 5
+fi # test -n "$CONFIG_HEADERS"
+
+
+eval set X "  :F $CONFIG_FILES  :H $CONFIG_HEADERS    :C $CONFIG_COMMANDS"
+shift
+for ac_tag
+do
+  case $ac_tag in
+  :[FHLC]) ac_mode=$ac_tag; continue;;
+  esac
+  case $ac_mode$ac_tag in
+  :[FHL]*:*);;
+  :L* | :C*:*) as_fn_error "invalid tag \`$ac_tag'" "$LINENO" 5;;
+  :[FH]-) ac_tag=-:-;;
+  :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
+  esac
+  ac_save_IFS=$IFS
+  IFS=:
+  set x $ac_tag
+  IFS=$ac_save_IFS
+  shift
+  ac_file=$1
+  shift
+
+  case $ac_mode in
+  :L) ac_source=$1;;
+  :[FH])
+    ac_file_inputs=
+    for ac_f
+    do
+      case $ac_f in
+      -) ac_f="$tmp/stdin";;
+      *) # Look for the file first in the build tree, then in the source tree
+	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
+	 # because $ac_f cannot contain `:'.
+	 test -f "$ac_f" ||
+	   case $ac_f in
+	   [\\/$]*) false;;
+	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
+	   esac ||
+	   as_fn_error "cannot find input file: \`$ac_f'" "$LINENO" 5;;
+      esac
+      case $ac_f in *\'*) ac_f=`$as_echo "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
+      as_fn_append ac_file_inputs " '$ac_f'"
+    done
+
+    # Let's still pretend it is `configure' which instantiates (i.e., don't
+    # use $as_me), people would be surprised to read:
+    #    /* config.h.  Generated by config.status.  */
+    configure_input='Generated from '`
+	  $as_echo "$*" | sed 's|^[^:]*/||;s|:[^:]*/|, |g'
+	`' by configure.'
+    if test x"$ac_file" != x-; then
+      configure_input="$ac_file.  $configure_input"
+      { $as_echo "$as_me:${as_lineno-$LINENO}: creating $ac_file" >&5
+$as_echo "$as_me: creating $ac_file" >&6;}
+    fi
+    # Neutralize special characters interpreted by sed in replacement strings.
+    case $configure_input in #(
+    *\&* | *\|* | *\\* )
+       ac_sed_conf_input=`$as_echo "$configure_input" |
+       sed 's/[\\\\&|]/\\\\&/g'`;; #(
+    *) ac_sed_conf_input=$configure_input;;
+    esac
+
+    case $ac_tag in
+    *:-:* | *:-) cat >"$tmp/stdin" \
+      || as_fn_error "could not create $ac_file" "$LINENO" 5 ;;
+    esac
+    ;;
+  esac
+
+  ac_dir=`$as_dirname -- "$ac_file" ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+  as_dir="$ac_dir"; as_fn_mkdir_p
+  ac_builddir=.
+
+case "$ac_dir" in
+.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
+*)
+  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
+  # A ".." for each directory in $ac_dir_suffix.
+  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
+  case $ac_top_builddir_sub in
+  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
+  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
+  esac ;;
+esac
+ac_abs_top_builddir=$ac_pwd
+ac_abs_builddir=$ac_pwd$ac_dir_suffix
+# for backward compatibility:
+ac_top_builddir=$ac_top_build_prefix
+
+case $srcdir in
+  .)  # We are building in place.
+    ac_srcdir=.
+    ac_top_srcdir=$ac_top_builddir_sub
+    ac_abs_top_srcdir=$ac_pwd ;;
+  [\\/]* | ?:[\\/]* )  # Absolute name.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir
+    ac_abs_top_srcdir=$srcdir ;;
+  *) # Relative name.
+    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_build_prefix$srcdir
+    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
+esac
+ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
+
+
+  case $ac_mode in
+  :F)
+  #
+  # CONFIG_FILE
+  #
+
+  case $INSTALL in
+  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
+  *) ac_INSTALL=$ac_top_build_prefix$INSTALL ;;
+  esac
+  ac_MKDIR_P=$MKDIR_P
+  case $MKDIR_P in
+  [\\/$]* | ?:[\\/]* ) ;;
+  */*) ac_MKDIR_P=$ac_top_build_prefix$MKDIR_P ;;
+  esac
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# If the template does not know about datarootdir, expand it.
+# FIXME: This hack should be removed a few years after 2.60.
+ac_datarootdir_hack=; ac_datarootdir_seen=
+ac_sed_dataroot='
+/datarootdir/ {
+  p
+  q
+}
+/@datadir@/p
+/@docdir@/p
+/@infodir@/p
+/@localedir@/p
+/@mandir@/p'
+case `eval "sed -n \"\$ac_sed_dataroot\" $ac_file_inputs"` in
+*datarootdir*) ac_datarootdir_seen=yes;;
+*@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
+$as_echo "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+  ac_datarootdir_hack='
+  s&@datadir@&$datadir&g
+  s&@docdir@&$docdir&g
+  s&@infodir@&$infodir&g
+  s&@localedir@&$localedir&g
+  s&@mandir@&$mandir&g
+  s&\\\${datarootdir}&$datarootdir&g' ;;
+esac
+_ACEOF
+
+# Neutralize VPATH when `$srcdir' = `.'.
+# Shell code in configure.ac might set extrasub.
+# FIXME: do we really want to maintain this feature?
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+ac_sed_extra="$ac_vpsub
+$extrasub
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+:t
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
+s|@configure_input@|$ac_sed_conf_input|;t t
+s&@top_builddir@&$ac_top_builddir_sub&;t t
+s&@top_build_prefix@&$ac_top_build_prefix&;t t
+s&@srcdir@&$ac_srcdir&;t t
+s&@abs_srcdir@&$ac_abs_srcdir&;t t
+s&@top_srcdir@&$ac_top_srcdir&;t t
+s&@abs_top_srcdir@&$ac_abs_top_srcdir&;t t
+s&@builddir@&$ac_builddir&;t t
+s&@abs_builddir@&$ac_abs_builddir&;t t
+s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
+s&@INSTALL@&$ac_INSTALL&;t t
+s&@MKDIR_P@&$ac_MKDIR_P&;t t
+$ac_datarootdir_hack
+"
+eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$tmp/subs.awk" >$tmp/out \
+  || as_fn_error "could not create $ac_file" "$LINENO" 5
+
+test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
+  { ac_out=`sed -n '/\${datarootdir}/p' "$tmp/out"`; test -n "$ac_out"; } &&
+  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' "$tmp/out"`; test -z "$ac_out"; } &&
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+which seems to be undefined.  Please make sure it is defined." >&5
+$as_echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+which seems to be undefined.  Please make sure it is defined." >&2;}
+
+  rm -f "$tmp/stdin"
+  case $ac_file in
+  -) cat "$tmp/out" && rm -f "$tmp/out";;
+  *) rm -f "$ac_file" && mv "$tmp/out" "$ac_file";;
+  esac \
+  || as_fn_error "could not create $ac_file" "$LINENO" 5
+ ;;
+  :H)
+  #
+  # CONFIG_HEADER
+  #
+  if test x"$ac_file" != x-; then
+    {
+      $as_echo "/* $configure_input  */" \
+      && eval '$AWK -f "$tmp/defines.awk"' "$ac_file_inputs"
+    } >"$tmp/config.h" \
+      || as_fn_error "could not create $ac_file" "$LINENO" 5
+    if diff "$ac_file" "$tmp/config.h" >/dev/null 2>&1; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: $ac_file is unchanged" >&5
+$as_echo "$as_me: $ac_file is unchanged" >&6;}
+    else
+      rm -f "$ac_file"
+      mv "$tmp/config.h" "$ac_file" \
+	|| as_fn_error "could not create $ac_file" "$LINENO" 5
+    fi
+  else
+    $as_echo "/* $configure_input  */" \
+      && eval '$AWK -f "$tmp/defines.awk"' "$ac_file_inputs" \
+      || as_fn_error "could not create -" "$LINENO" 5
+  fi
+# Compute "$ac_file"'s index in $config_headers.
+_am_arg="$ac_file"
+_am_stamp_count=1
+for _am_header in $config_headers :; do
+  case $_am_header in
+    $_am_arg | $_am_arg:* )
+      break ;;
+    * )
+      _am_stamp_count=`expr $_am_stamp_count + 1` ;;
+  esac
+done
+echo "timestamp for $_am_arg" >`$as_dirname -- "$_am_arg" ||
+$as_expr X"$_am_arg" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$_am_arg" : 'X\(//\)[^/]' \| \
+	 X"$_am_arg" : 'X\(//\)$' \| \
+	 X"$_am_arg" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$_am_arg" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`/stamp-h$_am_stamp_count
+ ;;
+
+  :C)  { $as_echo "$as_me:${as_lineno-$LINENO}: executing $ac_file commands" >&5
+$as_echo "$as_me: executing $ac_file commands" >&6;}
+ ;;
+  esac
+
+
+  case $ac_file$ac_mode in
+    "depfiles":C) test x"$AMDEP_TRUE" != x"" || {
+  # Autoconf 2.62 quotes --file arguments for eval, but not when files
+  # are listed without --file.  Let's play safe and only enable the eval
+  # if we detect the quoting.
+  case $CONFIG_FILES in
+  *\'*) eval set x "$CONFIG_FILES" ;;
+  *)   set x $CONFIG_FILES ;;
+  esac
+  shift
+  for mf
+  do
+    # Strip MF so we end up with the name of the file.
+    mf=`echo "$mf" | sed -e 's/:.*$//'`
+    # Check whether this is an Automake generated Makefile or not.
+    # We used to match only the files named `Makefile.in', but
+    # some people rename them; so instead we look at the file content.
+    # Grep'ing the first line is not enough: some people post-process
+    # each Makefile.in and add a new line on top of each file to say so.
+    # Grep'ing the whole file is not good either: AIX grep has a line
+    # limit of 2048, but all sed's we know have understand at least 4000.
+    if sed -n 's,^#.*generated by automake.*,X,p' "$mf" | grep X >/dev/null 2>&1; then
+      dirpart=`$as_dirname -- "$mf" ||
+$as_expr X"$mf" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$mf" : 'X\(//\)[^/]' \| \
+	 X"$mf" : 'X\(//\)$' \| \
+	 X"$mf" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$mf" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+    else
+      continue
+    fi
+    # Extract the definition of DEPDIR, am__include, and am__quote
+    # from the Makefile without running `make'.
+    DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
+    test -z "$DEPDIR" && continue
+    am__include=`sed -n 's/^am__include = //p' < "$mf"`
+    test -z "am__include" && continue
+    am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
+    # When using ansi2knr, U may be empty or an underscore; expand it
+    U=`sed -n 's/^U = //p' < "$mf"`
+    # Find all dependency output files, they are included files with
+    # $(DEPDIR) in their names.  We invoke sed twice because it is the
+    # simplest approach to changing $(DEPDIR) to its actual value in the
+    # expansion.
+    for file in `sed -n "
+      s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
+	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
+      # Make sure the directory exists.
+      test -f "$dirpart/$file" && continue
+      fdir=`$as_dirname -- "$file" ||
+$as_expr X"$file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$file" : 'X\(//\)[^/]' \| \
+	 X"$file" : 'X\(//\)$' \| \
+	 X"$file" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      as_dir=$dirpart/$fdir; as_fn_mkdir_p
+      # echo "creating $dirpart/$file"
+      echo '# dummy' > "$dirpart/$file"
+    done
+  done
+}
+ ;;
+    "libtool":C)
+
+    # See if we are running on zsh, and set the options which allow our
+    # commands through without removal of \ escapes.
+    if test -n "${ZSH_VERSION+set}" ; then
+      setopt NO_GLOB_SUBST
+    fi
+
+    cfgfile="${ofile}T"
+    trap "$RM \"$cfgfile\"; exit 1" 1 2 15
+    $RM "$cfgfile"
+
+    cat <<_LT_EOF >> "$cfgfile"
+#! $SHELL
+
+# `$ECHO "$ofile" | sed 's%^.*/%%'` - Provide generalized library-building support services.
+# Generated automatically by $as_me ($PACKAGE$TIMESTAMP) $VERSION
+# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
+# NOTE: Changes made to this file will be lost: look at ltmain.sh.
+#
+#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,
+#                 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
+#   Written by Gordon Matzigkeit, 1996
+#
+#   This file is part of GNU Libtool.
+#
+# GNU Libtool is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# As a special exception to the GNU General Public License,
+# if you distribute this file as part of a program or library that
+# is built using GNU Libtool, you may include this file under the
+# same distribution terms that you use for the rest of that program.
+#
+# GNU Libtool is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GNU Libtool; see the file COPYING.  If not, a copy
+# can be downloaded from http://www.gnu.org/licenses/gpl.html, or
+# obtained by writing to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+
+
+# The names of the tagged configurations supported by this script.
+available_tags=""
+
+# ### BEGIN LIBTOOL CONFIG
+
+# Which release of libtool.m4 was used?
+macro_version=$macro_version
+macro_revision=$macro_revision
+
+# Whether or not to build shared libraries.
+build_libtool_libs=$enable_shared
+
+# Whether or not to build static libraries.
+build_old_libs=$enable_static
+
+# What type of objects to build.
+pic_mode=$pic_mode
+
+# Whether or not to optimize for fast installation.
+fast_install=$enable_fast_install
+
+# Shell to use when invoking shell scripts.
+SHELL=$lt_SHELL
+
+# An echo program that protects backslashes.
+ECHO=$lt_ECHO
+
+# The host system.
+host_alias=$host_alias
+host=$host
+host_os=$host_os
+
+# The build system.
+build_alias=$build_alias
+build=$build
+build_os=$build_os
+
+# A sed program that does not truncate output.
+SED=$lt_SED
+
+# Sed that helps us avoid accidentally triggering echo(1) options like -n.
+Xsed="\$SED -e 1s/^X//"
+
+# A grep program that handles long lines.
+GREP=$lt_GREP
+
+# An ERE matcher.
+EGREP=$lt_EGREP
+
+# A literal string matcher.
+FGREP=$lt_FGREP
+
+# A BSD- or MS-compatible name lister.
+NM=$lt_NM
+
+# Whether we need soft or hard links.
+LN_S=$lt_LN_S
+
+# What is the maximum length of a command?
+max_cmd_len=$max_cmd_len
+
+# Object file suffix (normally "o").
+objext=$ac_objext
+
+# Executable file suffix (normally "").
+exeext=$exeext
+
+# whether the shell understands "unset".
+lt_unset=$lt_unset
+
+# turn spaces into newlines.
+SP2NL=$lt_lt_SP2NL
+
+# turn newlines into spaces.
+NL2SP=$lt_lt_NL2SP
+
+# An object symbol dumper.
+OBJDUMP=$lt_OBJDUMP
+
+# Method to check whether dependent libraries are shared objects.
+deplibs_check_method=$lt_deplibs_check_method
+
+# Command to use when deplibs_check_method == "file_magic".
+file_magic_cmd=$lt_file_magic_cmd
+
+# The archiver.
+AR=$lt_AR
+AR_FLAGS=$lt_AR_FLAGS
+
+# A symbol stripping program.
+STRIP=$lt_STRIP
+
+# Commands used to install an old-style archive.
+RANLIB=$lt_RANLIB
+old_postinstall_cmds=$lt_old_postinstall_cmds
+old_postuninstall_cmds=$lt_old_postuninstall_cmds
+
+# Whether to use a lock for old archive extraction.
+lock_old_archive_extraction=$lock_old_archive_extraction
+
+# A C compiler.
+LTCC=$lt_CC
+
+# LTCC compiler flags.
+LTCFLAGS=$lt_CFLAGS
+
+# Take the output of nm and produce a listing of raw symbols and C names.
+global_symbol_pipe=$lt_lt_cv_sys_global_symbol_pipe
+
+# Transform the output of nm in a proper C declaration.
+global_symbol_to_cdecl=$lt_lt_cv_sys_global_symbol_to_cdecl
+
+# Transform the output of nm in a C name address pair.
+global_symbol_to_c_name_address=$lt_lt_cv_sys_global_symbol_to_c_name_address
+
+# Transform the output of nm in a C name address pair when lib prefix is needed.
+global_symbol_to_c_name_address_lib_prefix=$lt_lt_cv_sys_global_symbol_to_c_name_address_lib_prefix
+
+# The name of the directory that contains temporary libtool files.
+objdir=$objdir
+
+# Used to examine libraries when file_magic_cmd begins with "file".
+MAGIC_CMD=$MAGIC_CMD
+
+# Must we lock files when doing compilation?
+need_locks=$lt_need_locks
+
+# Tool to manipulate archived DWARF debug symbol files on Mac OS X.
+DSYMUTIL=$lt_DSYMUTIL
+
+# Tool to change global to local symbols on Mac OS X.
+NMEDIT=$lt_NMEDIT
+
+# Tool to manipulate fat objects and archives on Mac OS X.
+LIPO=$lt_LIPO
+
+# ldd/readelf like tool for Mach-O binaries on Mac OS X.
+OTOOL=$lt_OTOOL
+
+# ldd/readelf like tool for 64 bit Mach-O binaries on Mac OS X 10.4.
+OTOOL64=$lt_OTOOL64
+
+# Old archive suffix (normally "a").
+libext=$libext
+
+# Shared library suffix (normally ".so").
+shrext_cmds=$lt_shrext_cmds
+
+# The commands to extract the exported symbol list from a shared archive.
+extract_expsyms_cmds=$lt_extract_expsyms_cmds
+
+# Variables whose values should be saved in libtool wrapper scripts and
+# restored at link time.
+variables_saved_for_relink=$lt_variables_saved_for_relink
+
+# Do we need the "lib" prefix for modules?
+need_lib_prefix=$need_lib_prefix
+
+# Do we need a version for libraries?
+need_version=$need_version
+
+# Library versioning type.
+version_type=$version_type
+
+# Shared library runtime path variable.
+runpath_var=$runpath_var
+
+# Shared library path variable.
+shlibpath_var=$shlibpath_var
+
+# Is shlibpath searched before the hard-coded library search path?
+shlibpath_overrides_runpath=$shlibpath_overrides_runpath
+
+# Format of library name prefix.
+libname_spec=$lt_libname_spec
+
+# List of archive names.  First name is the real one, the rest are links.
+# The last name is the one that the linker finds with -lNAME
+library_names_spec=$lt_library_names_spec
+
+# The coded name of the library, if different from the real name.
+soname_spec=$lt_soname_spec
+
+# Permission mode override for installation of shared libraries.
+install_override_mode=$lt_install_override_mode
+
+# Command to use after installation of a shared archive.
+postinstall_cmds=$lt_postinstall_cmds
+
+# Command to use after uninstallation of a shared archive.
+postuninstall_cmds=$lt_postuninstall_cmds
+
+# Commands used to finish a libtool library installation in a directory.
+finish_cmds=$lt_finish_cmds
+
+# As "finish_cmds", except a single script fragment to be evaled but
+# not shown.
+finish_eval=$lt_finish_eval
+
+# Whether we should hardcode library paths into libraries.
+hardcode_into_libs=$hardcode_into_libs
+
+# Compile-time system search path for libraries.
+sys_lib_search_path_spec=$lt_sys_lib_search_path_spec
+
+# Run-time system search path for libraries.
+sys_lib_dlsearch_path_spec=$lt_sys_lib_dlsearch_path_spec
+
+# Whether dlopen is supported.
+dlopen_support=$enable_dlopen
+
+# Whether dlopen of programs is supported.
+dlopen_self=$enable_dlopen_self
+
+# Whether dlopen of statically linked programs is supported.
+dlopen_self_static=$enable_dlopen_self_static
+
+# Commands to strip libraries.
+old_striplib=$lt_old_striplib
+striplib=$lt_striplib
+
+
+# The linker used to build libraries.
+LD=$lt_LD
+
+# How to create reloadable object files.
+reload_flag=$lt_reload_flag
+reload_cmds=$lt_reload_cmds
+
+# Commands used to build an old-style archive.
+old_archive_cmds=$lt_old_archive_cmds
+
+# A language specific compiler.
+CC=$lt_compiler
+
+# Is the compiler the GNU compiler?
+with_gcc=$GCC
+
+# Compiler flag to turn off builtin functions.
+no_builtin_flag=$lt_lt_prog_compiler_no_builtin_flag
+
+# How to pass a linker flag through the compiler.
+wl=$lt_lt_prog_compiler_wl
+
+# Additional compiler flags for building library objects.
+pic_flag=$lt_lt_prog_compiler_pic
+
+# Compiler flag to prevent dynamic linking.
+link_static_flag=$lt_lt_prog_compiler_static
+
+# Does compiler simultaneously support -c and -o options?
+compiler_c_o=$lt_lt_cv_prog_compiler_c_o
+
+# Whether or not to add -lc for building shared libraries.
+build_libtool_need_lc=$archive_cmds_need_lc
+
+# Whether or not to disallow shared libs when runtime libs are static.
+allow_libtool_libs_with_static_runtimes=$enable_shared_with_static_runtimes
+
+# Compiler flag to allow reflexive dlopens.
+export_dynamic_flag_spec=$lt_export_dynamic_flag_spec
+
+# Compiler flag to generate shared objects directly from archives.
+whole_archive_flag_spec=$lt_whole_archive_flag_spec
+
+# Whether the compiler copes with passing no objects directly.
+compiler_needs_object=$lt_compiler_needs_object
+
+# Create an old-style archive from a shared archive.
+old_archive_from_new_cmds=$lt_old_archive_from_new_cmds
+
+# Create a temporary old-style archive to link instead of a shared archive.
+old_archive_from_expsyms_cmds=$lt_old_archive_from_expsyms_cmds
+
+# Commands used to build a shared archive.
+archive_cmds=$lt_archive_cmds
+archive_expsym_cmds=$lt_archive_expsym_cmds
+
+# Commands used to build a loadable module if different from building
+# a shared archive.
+module_cmds=$lt_module_cmds
+module_expsym_cmds=$lt_module_expsym_cmds
+
+# Whether we are building with GNU ld or not.
+with_gnu_ld=$lt_with_gnu_ld
+
+# Flag that allows shared libraries with undefined symbols to be built.
+allow_undefined_flag=$lt_allow_undefined_flag
+
+# Flag that enforces no undefined symbols.
+no_undefined_flag=$lt_no_undefined_flag
+
+# Flag to hardcode \$libdir into a binary during linking.
+# This must work even if \$libdir does not exist
+hardcode_libdir_flag_spec=$lt_hardcode_libdir_flag_spec
+
+# If ld is used when linking, flag to hardcode \$libdir into a binary
+# during linking.  This must work even if \$libdir does not exist.
+hardcode_libdir_flag_spec_ld=$lt_hardcode_libdir_flag_spec_ld
+
+# Whether we need a single "-rpath" flag with a separated argument.
+hardcode_libdir_separator=$lt_hardcode_libdir_separator
+
+# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
+# DIR into the resulting binary.
+hardcode_direct=$hardcode_direct
+
+# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
+# DIR into the resulting binary and the resulting library dependency is
+# "absolute",i.e impossible to change by setting \${shlibpath_var} if the
+# library is relocated.
+hardcode_direct_absolute=$hardcode_direct_absolute
+
+# Set to "yes" if using the -LDIR flag during linking hardcodes DIR
+# into the resulting binary.
+hardcode_minus_L=$hardcode_minus_L
+
+# Set to "yes" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR
+# into the resulting binary.
+hardcode_shlibpath_var=$hardcode_shlibpath_var
+
+# Set to "yes" if building a shared library automatically hardcodes DIR
+# into the library and all subsequent libraries and executables linked
+# against it.
+hardcode_automatic=$hardcode_automatic
+
+# Set to yes if linker adds runtime paths of dependent libraries
+# to runtime path list.
+inherit_rpath=$inherit_rpath
+
+# Whether libtool must link a program against all its dependency libraries.
+link_all_deplibs=$link_all_deplibs
+
+# Fix the shell variable \$srcfile for the compiler.
+fix_srcfile_path=$lt_fix_srcfile_path
+
+# Set to "yes" if exported symbols are required.
+always_export_symbols=$always_export_symbols
+
+# The commands to list exported symbols.
+export_symbols_cmds=$lt_export_symbols_cmds
+
+# Symbols that should not be listed in the preloaded symbols.
+exclude_expsyms=$lt_exclude_expsyms
+
+# Symbols that must always be exported.
+include_expsyms=$lt_include_expsyms
+
+# Commands necessary for linking programs (against libraries) with templates.
+prelink_cmds=$lt_prelink_cmds
+
+# Specify filename containing input files.
+file_list_spec=$lt_file_list_spec
+
+# How to hardcode a shared library path into an executable.
+hardcode_action=$hardcode_action
+
+# ### END LIBTOOL CONFIG
+
+_LT_EOF
+
+  case $host_os in
+  aix3*)
+    cat <<\_LT_EOF >> "$cfgfile"
+# AIX sometimes has problems with the GCC collect2 program.  For some
+# reason, if we set the COLLECT_NAMES environment variable, the problems
+# vanish in a puff of smoke.
+if test "X${COLLECT_NAMES+set}" != Xset; then
+  COLLECT_NAMES=
+  export COLLECT_NAMES
+fi
+_LT_EOF
+    ;;
+  esac
+
+
+ltmain="$ac_aux_dir/ltmain.sh"
+
+
+  # We use sed instead of cat because bash on DJGPP gets confused if
+  # if finds mixed CR/LF and LF-only lines.  Since sed operates in
+  # text mode, it properly converts lines to CR/LF.  This bash problem
+  # is reportedly fixed, but why not run on old versions too?
+  sed '/^# Generated shell functions inserted here/q' "$ltmain" >> "$cfgfile" \
+    || (rm -f "$cfgfile"; exit 1)
+
+  case $xsi_shell in
+  yes)
+    cat << \_LT_EOF >> "$cfgfile"
+
+# func_dirname file append nondir_replacement
+# Compute the dirname of FILE.  If nonempty, add APPEND to the result,
+# otherwise set result to NONDIR_REPLACEMENT.
+func_dirname ()
+{
+  case ${1} in
+    */*) func_dirname_result="${1%/*}${2}" ;;
+    *  ) func_dirname_result="${3}" ;;
+  esac
+}
+
+# func_basename file
+func_basename ()
+{
+  func_basename_result="${1##*/}"
+}
+
+# func_dirname_and_basename file append nondir_replacement
+# perform func_basename and func_dirname in a single function
+# call:
+#   dirname:  Compute the dirname of FILE.  If nonempty,
+#             add APPEND to the result, otherwise set result
+#             to NONDIR_REPLACEMENT.
+#             value returned in "$func_dirname_result"
+#   basename: Compute filename of FILE.
+#             value retuned in "$func_basename_result"
+# Implementation must be kept synchronized with func_dirname
+# and func_basename. For efficiency, we do not delegate to
+# those functions but instead duplicate the functionality here.
+func_dirname_and_basename ()
+{
+  case ${1} in
+    */*) func_dirname_result="${1%/*}${2}" ;;
+    *  ) func_dirname_result="${3}" ;;
+  esac
+  func_basename_result="${1##*/}"
+}
+
+# func_stripname prefix suffix name
+# strip PREFIX and SUFFIX off of NAME.
+# PREFIX and SUFFIX must not contain globbing or regex special
+# characters, hashes, percent signs, but SUFFIX may contain a leading
+# dot (in which case that matches only a dot).
+func_stripname ()
+{
+  # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are
+  # positional parameters, so assign one to ordinary parameter first.
+  func_stripname_result=${3}
+  func_stripname_result=${func_stripname_result#"${1}"}
+  func_stripname_result=${func_stripname_result%"${2}"}
+}
+
+# func_opt_split
+func_opt_split ()
+{
+  func_opt_split_opt=${1%%=*}
+  func_opt_split_arg=${1#*=}
+}
+
+# func_lo2o object
+func_lo2o ()
+{
+  case ${1} in
+    *.lo) func_lo2o_result=${1%.lo}.${objext} ;;
+    *)    func_lo2o_result=${1} ;;
+  esac
+}
+
+# func_xform libobj-or-source
+func_xform ()
+{
+  func_xform_result=${1%.*}.lo
+}
+
+# func_arith arithmetic-term...
+func_arith ()
+{
+  func_arith_result=$(( $* ))
+}
+
+# func_len string
+# STRING may not start with a hyphen.
+func_len ()
+{
+  func_len_result=${#1}
+}
+
+_LT_EOF
+    ;;
+  *) # Bourne compatible functions.
+    cat << \_LT_EOF >> "$cfgfile"
+
+# func_dirname file append nondir_replacement
+# Compute the dirname of FILE.  If nonempty, add APPEND to the result,
+# otherwise set result to NONDIR_REPLACEMENT.
+func_dirname ()
+{
+  # Extract subdirectory from the argument.
+  func_dirname_result=`$ECHO "${1}" | $SED "$dirname"`
+  if test "X$func_dirname_result" = "X${1}"; then
+    func_dirname_result="${3}"
+  else
+    func_dirname_result="$func_dirname_result${2}"
+  fi
+}
+
+# func_basename file
+func_basename ()
+{
+  func_basename_result=`$ECHO "${1}" | $SED "$basename"`
+}
+
+
+# func_stripname prefix suffix name
+# strip PREFIX and SUFFIX off of NAME.
+# PREFIX and SUFFIX must not contain globbing or regex special
+# characters, hashes, percent signs, but SUFFIX may contain a leading
+# dot (in which case that matches only a dot).
+# func_strip_suffix prefix name
+func_stripname ()
+{
+  case ${2} in
+    .*) func_stripname_result=`$ECHO "${3}" | $SED "s%^${1}%%; s%\\\\${2}\$%%"`;;
+    *)  func_stripname_result=`$ECHO "${3}" | $SED "s%^${1}%%; s%${2}\$%%"`;;
+  esac
+}
+
+# sed scripts:
+my_sed_long_opt='1s/^\(-[^=]*\)=.*/\1/;q'
+my_sed_long_arg='1s/^-[^=]*=//'
+
+# func_opt_split
+func_opt_split ()
+{
+  func_opt_split_opt=`$ECHO "${1}" | $SED "$my_sed_long_opt"`
+  func_opt_split_arg=`$ECHO "${1}" | $SED "$my_sed_long_arg"`
+}
+
+# func_lo2o object
+func_lo2o ()
+{
+  func_lo2o_result=`$ECHO "${1}" | $SED "$lo2o"`
+}
+
+# func_xform libobj-or-source
+func_xform ()
+{
+  func_xform_result=`$ECHO "${1}" | $SED 's/\.[^.]*$/.lo/'`
+}
+
+# func_arith arithmetic-term...
+func_arith ()
+{
+  func_arith_result=`expr "$@"`
+}
+
+# func_len string
+# STRING may not start with a hyphen.
+func_len ()
+{
+  func_len_result=`expr "$1" : ".*" 2>/dev/null || echo $max_cmd_len`
+}
+
+_LT_EOF
+esac
+
+case $lt_shell_append in
+  yes)
+    cat << \_LT_EOF >> "$cfgfile"
+
+# func_append var value
+# Append VALUE to the end of shell variable VAR.
+func_append ()
+{
+  eval "$1+=\$2"
+}
+_LT_EOF
+    ;;
+  *)
+    cat << \_LT_EOF >> "$cfgfile"
+
+# func_append var value
+# Append VALUE to the end of shell variable VAR.
+func_append ()
+{
+  eval "$1=\$$1\$2"
+}
+
+_LT_EOF
+    ;;
+  esac
+
+
+  sed -n '/^# Generated shell functions inserted here/,$p' "$ltmain" >> "$cfgfile" \
+    || (rm -f "$cfgfile"; exit 1)
+
+  mv -f "$cfgfile" "$ofile" ||
+    (rm -f "$ofile" && cp "$cfgfile" "$ofile" && rm -f "$cfgfile")
+  chmod +x "$ofile"
+
+ ;;
+    "default-1":C)
+    for ac_file in $CONFIG_FILES; do
+      # Support "outfile[:infile[:infile...]]"
+      case "$ac_file" in
+        *:*) ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
+      esac
+      # PO directories have a Makefile.in generated from Makefile.in.in.
+      case "$ac_file" in */Makefile.in)
+        # Adjust a relative srcdir.
+        ac_dir=`echo "$ac_file"|sed 's%/[^/][^/]*$%%'`
+        ac_dir_suffix=/`echo "$ac_dir"|sed 's%^\./%%'`
+        ac_dots=`echo "$ac_dir_suffix"|sed 's%/[^/]*%../%g'`
+        # In autoconf-2.13 it is called $ac_given_srcdir.
+        # In autoconf-2.50 it is called $srcdir.
+        test -n "$ac_given_srcdir" || ac_given_srcdir="$srcdir"
+        case "$ac_given_srcdir" in
+          .)  top_srcdir=`echo $ac_dots|sed 's%/$%%'` ;;
+          /*) top_srcdir="$ac_given_srcdir" ;;
+          *)  top_srcdir="$ac_dots$ac_given_srcdir" ;;
+        esac
+        if test -f "$ac_given_srcdir/$ac_dir/POTFILES.in"; then
+          rm -f "$ac_dir/POTFILES"
+          test -n "$as_me" && echo "$as_me: creating $ac_dir/POTFILES" || echo "creating $ac_dir/POTFILES"
+          cat "$ac_given_srcdir/$ac_dir/POTFILES.in" | sed -e "/^#/d" -e "/^[ 	]*\$/d" -e "s,.*,     $top_srcdir/& \\\\," | sed -e "\$s/\(.*\) \\\\/\1/" > "$ac_dir/POTFILES"
+          POMAKEFILEDEPS="POTFILES.in"
+          # ALL_LINGUAS, POFILES, GMOFILES, UPDATEPOFILES, DUMMYPOFILES depend
+          # on $ac_dir but don't depend on user-specified configuration
+          # parameters.
+          if test -f "$ac_given_srcdir/$ac_dir/LINGUAS"; then
+            # The LINGUAS file contains the set of available languages.
+            if test -n "$OBSOLETE_ALL_LINGUAS"; then
+              test -n "$as_me" && echo "$as_me: setting ALL_LINGUAS in configure.ac is obsolete" || echo "setting ALL_LINGUAS in configure.ac is obsolete"
+            fi
+            ALL_LINGUAS_=`sed -e "/^#/d" "$ac_given_srcdir/$ac_dir/LINGUAS"`
+            # Hide the ALL_LINGUAS assigment from automake.
+            eval 'ALL_LINGUAS''=$ALL_LINGUAS_'
+            POMAKEFILEDEPS="$POMAKEFILEDEPS LINGUAS"
+          else
+            # The set of available languages was given in configure.ac.
+            eval 'ALL_LINGUAS''=$OBSOLETE_ALL_LINGUAS'
+          fi
+          case "$ac_given_srcdir" in
+            .) srcdirpre= ;;
+            *) srcdirpre='$(srcdir)/' ;;
+          esac
+          POFILES=
+          GMOFILES=
+          UPDATEPOFILES=
+          DUMMYPOFILES=
+          for lang in $ALL_LINGUAS; do
+            POFILES="$POFILES $srcdirpre$lang.po"
+            GMOFILES="$GMOFILES $srcdirpre$lang.gmo"
+            UPDATEPOFILES="$UPDATEPOFILES $lang.po-update"
+            DUMMYPOFILES="$DUMMYPOFILES $lang.nop"
+          done
+          # CATALOGS depends on both $ac_dir and the user's LINGUAS
+          # environment variable.
+          INST_LINGUAS=
+          if test -n "$ALL_LINGUAS"; then
+            for presentlang in $ALL_LINGUAS; do
+              useit=no
+              if test "%UNSET%" != "$LINGUAS"; then
+                desiredlanguages="$LINGUAS"
+              else
+                desiredlanguages="$ALL_LINGUAS"
+              fi
+              for desiredlang in $desiredlanguages; do
+                # Use the presentlang catalog if desiredlang is
+                #   a. equal to presentlang, or
+                #   b. a variant of presentlang (because in this case,
+                #      presentlang can be used as a fallback for messages
+                #      which are not translated in the desiredlang catalog).
+                case "$desiredlang" in
+                  "$presentlang"*) useit=yes;;
+                esac
+              done
+              if test $useit = yes; then
+                INST_LINGUAS="$INST_LINGUAS $presentlang"
+              fi
+            done
+          fi
+          CATALOGS=
+          if test -n "$INST_LINGUAS"; then
+            for lang in $INST_LINGUAS; do
+              CATALOGS="$CATALOGS $lang.gmo"
+            done
+          fi
+          test -n "$as_me" && echo "$as_me: creating $ac_dir/Makefile" || echo "creating $ac_dir/Makefile"
+          sed -e "/^POTFILES =/r $ac_dir/POTFILES" -e "/^# Makevars/r $ac_given_srcdir/$ac_dir/Makevars" -e "s|@POFILES@|$POFILES|g" -e "s|@GMOFILES@|$GMOFILES|g" -e "s|@UPDATEPOFILES@|$UPDATEPOFILES|g" -e "s|@DUMMYPOFILES@|$DUMMYPOFILES|g" -e "s|@CATALOGS@|$CATALOGS|g" -e "s|@POMAKEFILEDEPS@|$POMAKEFILEDEPS|g" "$ac_dir/Makefile.in" > "$ac_dir/Makefile"
+          for f in "$ac_given_srcdir/$ac_dir"/Rules-*; do
+            if test -f "$f"; then
+              case "$f" in
+                *.orig | *.bak | *~) ;;
+                *) cat "$f" >> "$ac_dir/Makefile" ;;
+              esac
+            fi
+          done
+        fi
+        ;;
+      esac
+    done ;;
+
+  esac
+done # for ac_tag
+
+
+as_fn_exit 0
+_ACEOF
+ac_clean_files=$ac_clean_files_save
+
+test $ac_write_fail = 0 ||
+  as_fn_error "write failure creating $CONFIG_STATUS" "$LINENO" 5
+
+
+# configure is writing to config.log, and then calls config.status.
+# config.status does its own redirection, appending to config.log.
+# Unfortunately, on DOS this fails, as config.log is still kept open
+# by configure, so config.status won't be able to write to it; its
+# output is simply discarded.  So we exec the FD to /dev/null,
+# effectively closing config.log, so it can be properly (re)opened and
+# appended to by config.status.  When coming back to configure, we
+# need to make the FD available again.
+if test "$no_create" != yes; then
+  ac_cs_success=:
+  ac_config_status_args=
+  test "$silent" = yes &&
+    ac_config_status_args="$ac_config_status_args --quiet"
+  exec 5>/dev/null
+  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
+  exec 5>>config.log
+  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
+  # would make configure fail if this is the last instruction.
+  $ac_cs_success || as_fn_exit $?
+fi
+if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
+$as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2;}
+fi
+
diff -Naur binutils-2.26/binutils/dlltool.c binutils-2.26.0007/binutils/dlltool.c
--- binutils-2.26/binutils/dlltool.c	2015-11-13 09:27:40.000000000 +0100
+++ binutils-2.26.0007/binutils/dlltool.c	2016-03-10 17:02:24.250718476 +0100
@@ -444,6 +444,10 @@
 static const char *mname = "arm-wince";
 #endif
 
+#ifdef DLLTOOL_DEFAULT_ARM_WINNT
+static const char *mname = "arm-winnt";
+#endif
+
 #ifdef DLLTOOL_DEFAULT_I386
 static const char *mname = "i386";
 #endif
@@ -529,6 +533,14 @@
   0,    0,    0,    0
 };
 
+static const unsigned char thumb2_jtab[] =
+{
+  0x40, 0xf2, 0x00, 0x0c, /* mov.w ip, #0   */
+  0xc0, 0xf2, 0x00, 0x0c, /* mov.t ip, #0   */
+  0xdc, 0xf8, 0x00, 0xf0, /* ldr.w pc, [ip] */
+  0,    0,    0,    0
+};
+
 static const unsigned char arm_interwork_jtab[] =
 {
   0x04, 0xc0, 0x9f, 0xe5,	/* ldr  ip, [pc] */
@@ -761,6 +773,16 @@
     i386_x64_dljtab, sizeof (i386_x64_dljtab), 2, 9, 14, i386_x64_trampoline
   }
   ,
+  {
+#define MARM_WINNT 12
+    "arm-winnt", ".byte", ".short", ".long", ".asciz", "@",
+    "mov.w\tip,:lower16:\t.short\nmov.t\tip,:upper16:\t.short\nldr.w\tpc,[ip]",
+    ".global", ".space", ".align\t2",".align\t4", "",
+    "pe-arm-winnt-little", bfd_arch_arm,
+    thumb2_jtab, sizeof (thumb2_jtab), 0,
+    0, 0, 0, 0, 0, 0
+  }
+  ,
   { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
 };
 
@@ -911,6 +933,7 @@
     case MMCORE_ELF_LE:
     case MARM_EPOC:
     case MARM_WINCE:
+    case MARM_WINNT:
       break;
     default:
       /* xgettext:c-format */
@@ -937,6 +960,7 @@
     case MMCORE_ELF_LE:
     case MARM_EPOC:
     case MARM_WINCE:
+    case MARM_WINNT:
       return ".rva\t";
     default:
       /* xgettext:c-format */
@@ -961,6 +985,7 @@
     case MMCORE_ELF_LE:
     case MARM_EPOC:
     case MARM_WINCE:
+    case MARM_WINNT:
       break;
     case M386:
     case MX86:
diff -Naur binutils-2.26/configure.ac binutils-2.26.0007/configure.ac
--- binutils-2.26/configure.ac	2016-01-25 09:57:16.000000000 +0100
+++ binutils-2.26.0007/configure.ac	2016-03-10 17:02:24.254051736 +0100
@@ -873,6 +873,9 @@
   x86_64-*-mingw*)
     noconfigdirs="$noconfigdirs ${libgcj}"
     ;;
+  arm*-w64-mingw*)
+    noconfigdirs="$noconfigdirs ${libgcj}"
+    ;;
   mmix-*-*)
     noconfigdirs="$noconfigdirs target-libffi target-boehm-gc"
     ;;
diff -Naur binutils-2.26/configure.ac.orig binutils-2.26.0007/configure.ac.orig
--- binutils-2.26/configure.ac.orig	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.26.0007/configure.ac.orig	2016-03-10 17:02:05.424466697 +0100
@@ -0,0 +1,3606 @@
+#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
+#   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012,
+#   2014, 2015 Free Software Foundation, Inc.
+#
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+##############################################################################
+### WARNING: this file contains embedded tabs.  Do not run untabify on this file.
+
+m4_include(config/acx.m4)
+m4_include(config/override.m4)
+m4_include(config/proginstall.m4)
+m4_include(config/elf.m4)
+m4_include([libtool.m4])
+m4_include([ltoptions.m4])
+m4_include([ltsugar.m4])
+m4_include([ltversion.m4])
+m4_include([lt~obsolete.m4])
+m4_include([config/isl.m4])
+
+AC_INIT(move-if-change)
+AC_PREREQ(2.64)
+AC_DISABLE_OPTION_CHECKING
+
+progname=$0
+# if PWD already has a value, it is probably wrong.
+if test -n "$PWD" ; then PWD=`${PWDCMD-pwd}`; fi
+
+# Export original configure arguments for use by sub-configures.
+# Quote arguments with shell meta charatcers.
+TOPLEVEL_CONFIGURE_ARGUMENTS=
+set -- "$progname" "$@"
+for ac_arg
+do
+  case "$ac_arg" in
+  *" "*|*"	"*|*[[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?\']]*)
+    ac_arg=`echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"`
+    # if the argument is of the form -foo=baz, quote the baz part only
+    ac_arg=`echo "'$ac_arg'" | sed "s/^'\([[-a-zA-Z0-9]]*=\)/\\1'/"` ;;
+  *) ;;
+  esac
+  # Add the quoted argument to the list.
+  TOPLEVEL_CONFIGURE_ARGUMENTS="$TOPLEVEL_CONFIGURE_ARGUMENTS $ac_arg"
+done
+if test "$silent" = yes; then
+  TOPLEVEL_CONFIGURE_ARGUMENTS="$TOPLEVEL_CONFIGURE_ARGUMENTS --silent"
+fi
+# Remove the initial space we just introduced and, as these will be
+# expanded by make, quote '$'.
+TOPLEVEL_CONFIGURE_ARGUMENTS=`echo "x$TOPLEVEL_CONFIGURE_ARGUMENTS" | sed -e 's/^x *//' -e 's,\\$,$$,g'`
+AC_SUBST(TOPLEVEL_CONFIGURE_ARGUMENTS)
+
+# Find the build, host, and target systems.
+ACX_NONCANONICAL_BUILD
+ACX_NONCANONICAL_HOST
+ACX_NONCANONICAL_TARGET
+
+dnl Autoconf 2.5x and later will set a default program prefix if
+dnl --target was used, even if it was the same as --host.  Disable
+dnl that behavior.  This must be done before AC_CANONICAL_SYSTEM
+dnl to take effect.
+test "$host_noncanonical" = "$target_noncanonical" &&
+  test "$program_prefix$program_suffix$program_transform_name" = \
+    NONENONEs,x,x, &&
+  program_transform_name=s,y,y,
+
+AC_CANONICAL_SYSTEM
+AC_ARG_PROGRAM
+
+m4_pattern_allow([^AS_FOR_TARGET$])dnl
+m4_pattern_allow([^AS_FOR_BUILD$])dnl
+
+# Get 'install' or 'install-sh' and its variants.
+AC_PROG_INSTALL
+ACX_PROG_LN
+AC_PROG_LN_S
+AC_PROG_SED
+AC_PROG_AWK
+
+srcpwd=`cd ${srcdir} ; ${PWDCMD-pwd}`
+
+# We pass INSTALL explicitly to sub-makes.  Make sure that it is not
+# a relative path.
+if test "$INSTALL" = "${srcdir}/install-sh -c"; then
+  INSTALL="${srcpwd}/install-sh -c"
+fi
+
+# Set srcdir to "." if that's what it is.
+# This is important for multilib support.
+pwd=`${PWDCMD-pwd}`
+if test "${pwd}" = "${srcpwd}" ; then
+  srcdir=.
+fi
+
+topsrcdir=$srcpwd
+
+extra_host_args=
+
+### To add a new directory to the tree, first choose whether it is a target
+### or a host dependent tool.  Then put it into the appropriate list
+### (library or tools, host or target), doing a dependency sort.
+
+# Subdirs will be configured in the order listed in build_configdirs, 
+# configdirs, or target_configdirs; see the serialization section below.
+
+# Dependency sorting is only needed when *configuration* must be done in 
+# a particular order.  In all cases a dependency should be specified in 
+# the Makefile, whether or not it's implicitly specified here.
+
+# Double entries in build_configdirs, configdirs, or target_configdirs may
+# cause circular dependencies and break everything horribly.
+
+# these library is used by various programs built for the build
+# environment
+#
+build_libs="build-libiberty build-libcpp"
+
+# these tools are built for the build environment
+build_tools="build-texinfo build-flex build-bison build-m4 build-fixincludes"
+
+# these libraries are used by various programs built for the host environment
+#f
+host_libs="intl libiberty opcodes bfd readline tcl tk itcl libgui zlib libbacktrace libcpp libdecnumber gmp mpfr mpc isl libelf libiconv"
+
+# these tools are built for the host environment
+# Note, the powerpc-eabi build depends on sim occurring before gdb in order to
+# know that we are building the simulator.
+# binutils, gas and ld appear in that order because it makes sense to run
+# "make check" in that particular order.
+# If --enable-gold is used, "gold" may replace "ld".
+host_tools="flex bison binutils gas ld fixincludes gcc cgen sid sim gdb gprof etc expect dejagnu m4 utils guile fastjar gnattools libcc1 gotools"
+
+# libgcj represents the runtime libraries only used by gcj.
+libgcj="target-libffi \
+	target-zlib \
+	target-libjava"
+
+# these libraries are built for the target environment, and are built after
+# the host libraries and the host tools (which may be a cross compiler)
+# Note that libiberty is not a target library.
+target_libraries="target-libgcc \
+		target-libbacktrace \
+		target-libgloss \
+		target-newlib \
+		target-libgomp \
+		target-libcilkrts \
+		target-liboffloadmic \
+		target-libatomic \
+		target-libitm \
+		target-libstdc++-v3 \
+		target-libsanitizer \
+		target-libvtv \
+		target-libmpx \
+		target-libssp \
+		target-libquadmath \
+		target-libgfortran \
+		target-boehm-gc \
+		${libgcj} \
+		target-libobjc \
+		target-libada \
+		target-libgo"
+
+# these tools are built using the target libraries, and are intended to
+# run only in the target environment
+#
+# note: any program that *uses* libraries that are in the "target_libraries"
+# list belongs in this list.
+#
+target_tools="target-rda"
+
+################################################################################
+
+## All tools belong in one of the four categories, and are assigned above
+## We assign ${configdirs} this way to remove all embedded newlines.  This
+## is important because configure will choke if they ever get through.
+## ${configdirs} is directories we build using the host tools.
+## ${target_configdirs} is directories we build using the target tools.
+configdirs=`echo ${host_libs} ${host_tools}`
+target_configdirs=`echo ${target_libraries} ${target_tools}`
+build_configdirs=`echo ${build_libs} ${build_tools}`
+
+m4_divert_text([PARSE_ARGS],
+[case $srcdir in
+  *" "*)
+m4_pushdef([AS_MESSAGE_LOG_FD], [])dnl
+    AC_MSG_ERROR([path to source, $srcdir, contains spaces])
+m4_popdef([AS_MESSAGE_LOG_FD])dnl
+    ;;
+esac
+ac_subdirs_all=`cd $srcdir && echo */configure | sed 's,/configure,,g'`
+])
+
+################################################################################
+
+srcname="gnu development package"
+
+# This gets set non-empty for some net releases of packages.
+appdirs=""
+
+# Define is_cross_compiler to save on calls to 'test'.
+is_cross_compiler=
+if test x"${host}" = x"${target}" ; then
+  is_cross_compiler=no
+else
+  is_cross_compiler=yes
+fi	
+
+# Find the build and target subdir names.
+GCC_TOPLEV_SUBDIRS
+# Be sure to cover against remnants of an in-tree build.
+if test $srcdir != .  && test -d $srcdir/host-${host_noncanonical}; then
+  AC_MSG_ERROR([building out of tree but $srcdir contains host-${host_noncanonical}.
+Use a pristine source tree when building in a separate tree])
+fi
+
+# Skipdirs are removed silently.
+skipdirs=
+# Noconfigdirs are removed loudly.
+noconfigdirs=""
+
+use_gnu_ld=
+# Make sure we don't let GNU ld be added if we didn't want it.
+if test x$with_gnu_ld = xno ; then
+  use_gnu_ld=no
+  noconfigdirs="$noconfigdirs ld gold"
+fi
+
+use_gnu_as=
+# Make sure we don't let GNU as be added if we didn't want it.
+if test x$with_gnu_as = xno ; then
+  use_gnu_as=no
+  noconfigdirs="$noconfigdirs gas"
+fi
+
+use_included_zlib=
+AC_ARG_WITH(system-zlib,
+[AS_HELP_STRING([--with-system-zlib], [use installed libz])])
+# Make sure we don't let ZLIB be added if we didn't want it.
+if test x$with_system_zlib = xyes ; then
+  use_included_zlib=no
+  noconfigdirs="$noconfigdirs zlib"
+fi
+
+# some tools are so dependent upon X11 that if we're not building with X, 
+# it's not even worth trying to configure, much less build, that tool.
+
+case ${with_x} in
+  yes | "") ;; # the default value for this tree is that X11 is available
+  no)
+    skipdirs="${skipdirs} tk itcl libgui"
+    # We won't be able to build gdbtk without X.
+    enable_gdbtk=no 
+    ;;
+  *)  echo "*** bad value \"${with_x}\" for -with-x flag; ignored" 1>&2 ;;
+esac
+
+# Some are only suitable for cross toolchains.
+# Remove these if host=target.
+cross_only="target-libgloss target-newlib target-opcodes"
+
+case $is_cross_compiler in
+  no) skipdirs="${skipdirs} ${cross_only}" ;;
+esac
+
+# If both --with-headers and --with-libs are specified, default to
+# --without-newlib.
+if test x"${with_headers}" != x && test x"${with_headers}" != xno \
+   && test x"${with_libs}" != x && test x"${with_libs}" != xno ; then
+  if test x"${with_newlib}" = x ; then
+    with_newlib=no
+  fi
+fi
+
+# Recognize --with-newlib/--without-newlib.
+case ${with_newlib} in
+  no) skipdirs="${skipdirs} target-newlib" ;;
+  yes) skipdirs=`echo " ${skipdirs} " | sed -e 's/ target-newlib / /'` ;;
+esac
+
+AC_ARG_ENABLE(as-accelerator-for,
+[AS_HELP_STRING([--enable-as-accelerator-for=ARG],
+		[build as offload target compiler.
+		Specify offload host triple by ARG])])
+
+AC_ARG_ENABLE(offload-targets,
+[AS_HELP_STRING([--enable-offload-targets=LIST],
+		[enable offloading to devices from comma-separated LIST of
+		TARGET[=DIR]. Use optional path to find offload target compiler
+		during the build])],
+[
+  if test x"$enable_offload_targets" = x; then
+    AC_MSG_ERROR([no offload targets specified])
+  fi
+], [enable_offload_targets=])
+
+# Handle --enable-gold, --enable-ld.
+# --disable-gold [--enable-ld]
+#     Build only ld.  Default option.
+# --enable-gold [--enable-ld]
+#     Build both gold and ld.  Install gold as "ld.gold", install ld
+#     as "ld.bfd" and "ld".
+# --enable-gold=default [--enable-ld]
+#     Build both gold and ld.  Install gold as "ld.gold" and "ld",
+#     install ld as "ld.bfd".
+# --enable-gold[=default] --disable-ld
+#     Build only gold, which is then installed as both "ld.gold" and "ld".
+# --enable-gold --enable-ld=default
+#     Build both gold (installed as "ld.gold") and ld (installed as "ld"
+#     and ld.bfd).
+#     In other words, ld is default
+# --enable-gold=default --enable-ld=default
+#     Error.
+
+default_ld=
+AC_ARG_ENABLE(gold,
+[AS_HELP_STRING([[--enable-gold[=ARG]]],
+		[build gold @<:@ARG={default,yes,no}@:>@])],
+ENABLE_GOLD=$enableval,
+ENABLE_GOLD=no)
+case "${ENABLE_GOLD}" in
+  yes|default)
+    # Check for ELF target.
+    is_elf=no
+    case "${target}" in
+      *-*-elf* | *-*-sysv4* | *-*-unixware* | *-*-eabi* | hppa*64*-*-hpux* \
+      | *-*-linux* | *-*-gnu* | frv-*-uclinux* | *-*-irix5* | *-*-irix6* \
+      | *-*-netbsd* | *-*-openbsd* | *-*-freebsd* | *-*-dragonfly* \
+      | *-*-solaris2* | *-*-nto* | *-*-nacl*)
+        case "${target}" in
+          *-*-linux*aout* | *-*-linux*oldld*)
+            ;;
+          *)
+            is_elf=yes
+            ;;
+        esac
+    esac
+
+    if test "$is_elf" = "yes"; then
+      # Check for target supported by gold.
+      case "${target}" in
+        i?86-*-* | x86_64-*-* | sparc*-*-* | powerpc*-*-* | arm*-*-* \
+        | aarch64*-*-* | tilegx*-*-*)
+	  configdirs="$configdirs gold"
+	  if test x${ENABLE_GOLD} = xdefault; then
+	    default_ld=gold
+	  fi
+	  ENABLE_GOLD=yes
+          ;;
+      esac
+    fi
+    ;;
+  no)
+    ;;
+  *)
+    AC_MSG_ERROR([invalid --enable-gold argument])
+    ;;
+esac
+
+AC_ARG_ENABLE(ld,
+[AS_HELP_STRING([[--enable-ld[=ARG]]],
+		[build ld @<:@ARG={default,yes,no}@:>@])],
+ENABLE_LD=$enableval,
+ENABLE_LD=yes)
+
+case "${ENABLE_LD}" in
+  default)
+    if test x${default_ld} != x; then
+      AC_MSG_ERROR([either gold or ld can be the default ld])
+    fi
+    ;;
+  yes)
+    ;;
+  no)
+    if test x${ENABLE_GOLD} != xyes; then
+      AC_MSG_WARN([neither ld nor gold are enabled])
+    fi
+    configdirs=`echo " ${configdirs} " | sed -e 's/ ld / /'`
+    ;;
+  *)
+    AC_MSG_ERROR([invalid --enable-ld argument])
+    ;;
+esac
+
+# PR gas/19109
+# Decide the default method for compressing debug sections.
+# Provide a configure time option to override our default.
+AC_ARG_ENABLE(compressed_debug_sections,
+[AS_HELP_STRING([--enable-compressed-debug-sections={all,gas,gold,ld,none}],
+		[Enable compressed debug sections for gas, gold or ld by
+		 default])],
+[
+  if test x"$enable_compressed_debug_sections" = xyes; then
+    AC_MSG_ERROR([no program with compressed debug sections specified])
+  fi
+], [enable_compressed_debug_sections=])
+
+# Configure extra directories which are host specific
+
+case "${host}" in
+  *-cygwin*)
+    configdirs="$configdirs libtermcap" ;;
+esac
+
+# A target can indicate whether a language isn't supported for some reason.
+# Only spaces may be used in this macro; not newlines or tabs.
+unsupported_languages=
+
+# Remove more programs from consideration, based on the host or 
+# target this usually means that a port of the program doesn't
+# exist yet.
+
+case "${host}" in
+  i[[3456789]]86-*-msdosdjgpp*)
+    noconfigdirs="$noconfigdirs tcl tk itcl"
+    ;;
+esac
+
+
+AC_ARG_ENABLE(libquadmath,
+AS_HELP_STRING([--disable-libquadmath],
+  [do not build libquadmath directory]),
+ENABLE_LIBQUADMATH=$enableval,
+ENABLE_LIBQUADMATH=yes)
+if test "${ENABLE_LIBQUADMATH}" = "no" ; then
+  noconfigdirs="$noconfigdirs target-libquadmath"
+fi
+
+
+AC_ARG_ENABLE(libquadmath-support,
+AS_HELP_STRING([--disable-libquadmath-support],
+  [disable libquadmath support for Fortran]),
+ENABLE_LIBQUADMATH_SUPPORT=$enableval,
+ENABLE_LIBQUADMATH_SUPPORT=yes)
+enable_libquadmath_support=
+if test "${ENABLE_LIBQUADMATH_SUPPORT}" = "no" ; then
+  enable_libquadmath_support=no
+fi
+
+
+AC_ARG_ENABLE(libada,
+[AS_HELP_STRING([--enable-libada], [build libada directory])],
+ENABLE_LIBADA=$enableval,
+ENABLE_LIBADA=yes)
+if test "${ENABLE_LIBADA}" != "yes" ; then
+  noconfigdirs="$noconfigdirs gnattools"
+fi
+
+AC_ARG_ENABLE(libssp,
+[AS_HELP_STRING([--enable-libssp], [build libssp directory])],
+ENABLE_LIBSSP=$enableval,
+ENABLE_LIBSSP=yes)
+
+AC_ARG_ENABLE(libstdcxx,
+AS_HELP_STRING([--disable-libstdcxx],
+  [do not build libstdc++-v3 directory]),
+ENABLE_LIBSTDCXX=$enableval,
+ENABLE_LIBSTDCXX=default)
+[if test "${ENABLE_LIBSTDCXX}" = "no" ; then
+  noconfigdirs="$noconfigdirs target-libstdc++-v3"
+fi]
+
+# If this is accelerator compiler and its target is intelmic we enable
+# target liboffloadmic by default.  If this is compiler with offloading
+# for intelmic we enable host liboffloadmic by default.  Otherwise
+# liboffloadmic is disabled by default.
+AC_ARG_ENABLE([liboffloadmic],
+AC_HELP_STRING([[--enable-liboffloadmic[=ARG]]],
+	       [build liboffloadmic @<:@ARG={no,host,target}@:>@]),
+[case "$enableval" in
+  no | host | target)
+    enable_liboffloadmic=$enableval ;;
+  *)
+    AC_MSG_ERROR([--enable-liboffloadmic=no/host/target]) ;;
+esac],
+[if test x"$enable_as_accelerator_for" != x; then
+  case "${target}" in
+    *-intelmic-* | *-intelmicemul-*)
+      enable_liboffloadmic=target
+      extra_liboffloadmic_configure_flags="--enable-liboffloadmic=target"
+      ;;
+    *)
+      enable_liboffloadmic=no
+      ;;
+  esac
+else
+  case "${enable_offload_targets}" in
+    *-intelmic-* | *-intelmicemul-*)
+      enable_liboffloadmic=host
+      extra_liboffloadmic_configure_flags="--enable-liboffloadmic=host"
+      ;;
+    *)
+      enable_liboffloadmic=no
+      ;;
+    esac
+fi])
+AC_SUBST(extra_liboffloadmic_configure_flags)
+
+# Save it here so that, even in case of --enable-libgcj, if the Java
+# front-end isn't enabled, we still get libgcj disabled.
+libgcj_saved=$libgcj
+case $enable_libgcj in
+yes)
+  # If we reset it here, it won't get added to noconfigdirs in the
+  # target-specific build rules, so it will be forcibly enabled
+  # (unless the Java language itself isn't enabled).
+  libgcj=
+  ;;
+no)
+  # Make sure we get it printed in the list of not supported target libs.
+  # Don't disable libffi, though, other languages use it.
+  noconfigdirs="$noconfigdirs `echo ${libgcj} | sed -e 's/target-libffi//'`"
+  # Clear libgcj_saved so that even if java is enabled libffi won't be
+  # built.
+  libgcj_saved=
+  ;;
+esac
+
+AC_ARG_ENABLE(static-libjava,
+[AS_HELP_STRING([[--enable-static-libjava[=ARG]]],
+		[build static libjava @<:@default=no@:>@])],
+ENABLE_STATIC_LIBJAVA=$enableval,
+ENABLE_STATIC_LIBJAVA=no)
+enable_static_libjava=
+if test "${ENABLE_STATIC_LIBJAVA}" = "yes" ; then
+  enable_static_libjava=yes
+fi
+
+if test x$enable_static_libjava != xyes ; then
+  EXTRA_CONFIGARGS_LIBJAVA=--disable-static
+fi
+AC_SUBST(EXTRA_CONFIGARGS_LIBJAVA)
+
+# Enable libgomp by default on hosted POSIX systems, and a few others.
+if test x$enable_libgomp = x ; then
+    case "${target}" in
+    *-*-linux* | *-*-gnu* | *-*-k*bsd*-gnu | *-*-kopensolaris*-gnu)
+	;;
+    *-*-netbsd* | *-*-freebsd* | *-*-openbsd* | *-*-dragonfly*)
+	;;
+    *-*-solaris2* | *-*-hpux11*)
+	;;
+    *-*-darwin* | *-*-aix*)
+	;;
+    nvptx*-*-*)
+	;;
+    *)
+	noconfigdirs="$noconfigdirs target-libgomp"
+	;;
+    esac
+fi
+
+# Disable libatomic on unsupported systems.
+if test -d ${srcdir}/libatomic; then
+    if test x$enable_libatomic = x; then
+	AC_MSG_CHECKING([for libatomic support])
+	if (srcdir=${srcdir}/libatomic; \
+		. ${srcdir}/configure.tgt; \
+		test -n "$UNSUPPORTED")
+	then
+	    AC_MSG_RESULT([no])
+	    noconfigdirs="$noconfigdirs target-libatomic"
+	else
+	    AC_MSG_RESULT([yes])
+	fi
+    fi
+fi
+
+# Disable libcilkrts on unsupported systems.
+if test -d ${srcdir}/libcilkrts; then
+    if test x$enable_libcilkrts = x; then
+	AC_MSG_CHECKING([for libcilkrts support])
+	if (srcdir=${srcdir}/libcilkrts; \
+		. ${srcdir}/configure.tgt; \
+		test -n "$UNSUPPORTED")
+	then
+	    AC_MSG_RESULT([no])
+	    noconfigdirs="$noconfigdirs target-libcilkrts"
+	else
+	    AC_MSG_RESULT([yes])
+	fi
+    fi
+fi
+
+# Disable liboffloadmic on unsupported systems.
+if test -d ${srcdir}/liboffloadmic; then
+    if test x$enable_liboffloadmic != xno; then
+	AC_MSG_CHECKING([for liboffloadmic support])
+	if (srcdir=${srcdir}/liboffloadmic; \
+		. ${srcdir}/configure.tgt; \
+		test -n "$UNSUPPORTED")
+	then
+	    AC_MSG_RESULT([no])
+	    noconfigdirs="$noconfigdirs target-liboffloadmic"
+	else
+	    AC_MSG_RESULT([yes])
+	fi
+    fi
+fi
+
+# Disable libitm on unsupported systems.
+if test -d ${srcdir}/libitm; then
+    if test x$enable_libitm = x; then
+	AC_MSG_CHECKING([for libitm support])
+	if (srcdir=${srcdir}/libitm; \
+		. ${srcdir}/configure.tgt; \
+		test -n "$UNSUPPORTED")
+	then
+	    AC_MSG_RESULT([no])
+	    noconfigdirs="$noconfigdirs target-libitm"
+	else
+	    AC_MSG_RESULT([yes])
+	fi
+    fi
+fi
+
+# Disable libsanitizer on unsupported systems.
+if test -d ${srcdir}/libsanitizer; then
+    if test x$enable_libsanitizer = x; then
+	AC_MSG_CHECKING([for libsanitizer support])
+	if (srcdir=${srcdir}/libsanitizer; \
+		. ${srcdir}/configure.tgt; \
+		test -n "$UNSUPPORTED")
+	then
+	    AC_MSG_RESULT([no])
+	    noconfigdirs="$noconfigdirs target-libsanitizer"
+	else
+	    AC_MSG_RESULT([yes])
+	fi
+    fi
+fi
+
+# Disable libvtv on unsupported systems.
+if test -d ${srcdir}/libvtv; then
+    if test x$enable_libvtv = x; then
+	AC_MSG_CHECKING([for libvtv support])
+	if (srcdir=${srcdir}/libvtv; \
+		. ${srcdir}/configure.tgt; \
+		test "$VTV_SUPPORTED" != "yes")
+	then
+	    AC_MSG_RESULT([no])
+	    noconfigdirs="$noconfigdirs target-libvtv"
+	else
+	    AC_MSG_RESULT([yes])
+	fi
+    fi
+fi
+
+
+# Enable libmpx on supported systems by request.
+if test -d ${srcdir}/libmpx; then
+    if test x$enable_libmpx = xyes; then
+       AC_MSG_CHECKING([for libmpx support])
+       if (srcdir=${srcdir}/libmpx; \
+               . ${srcdir}/configure.tgt; \
+               test "$LIBMPX_SUPPORTED" != "yes")
+       then
+           AC_MSG_RESULT([no])
+           noconfigdirs="$noconfigdirs target-libmpx"
+       else
+           AC_MSG_RESULT([yes])
+       fi
+    else
+       noconfigdirs="$noconfigdirs target-libmpx"
+    fi
+fi
+
+
+
+# Disable libquadmath for some systems.
+case "${target}" in
+  avr-*-*)
+    noconfigdirs="$noconfigdirs target-libquadmath"
+    ;;
+  # libquadmath is unused on AIX and libquadmath build process use of
+  # LD_LIBRARY_PATH can break AIX bootstrap.
+  powerpc-*-aix* | rs6000-*-aix*)
+    noconfigdirs="$noconfigdirs target-libquadmath"
+    ;;
+esac
+
+# Disable libssp for some systems.
+case "${target}" in
+  avr-*-*)
+    # No hosted I/O support.
+    noconfigdirs="$noconfigdirs target-libssp"
+    ;;
+  powerpc-*-aix* | rs6000-*-aix*)
+    noconfigdirs="$noconfigdirs target-libssp"
+    ;;
+  rl78-*-*)
+    # libssp uses a misaligned load to trigger a fault, but the RL78
+    # doesn't fault for those - instead, it gives a build-time error
+    # for explicit misaligned loads.
+    noconfigdirs="$noconfigdirs target-libssp"
+    ;;
+  visium-*-*)
+    # No hosted I/O support.
+    noconfigdirs="$noconfigdirs target-libssp"
+    ;;
+esac
+
+# Disable libstdc++-v3 for some systems.
+# Allow user to override this if they pass --enable-libstdc++-v3
+if test "${ENABLE_LIBSTDCXX}" = "default" ; then
+  case "${target}" in
+    *-*-vxworks*)
+      # VxWorks uses the Dinkumware C++ library.
+      noconfigdirs="$noconfigdirs target-libstdc++-v3"
+      ;;
+    arm*-wince-pe*)
+      # the C++ libraries don't build on top of CE's C libraries
+      noconfigdirs="$noconfigdirs target-libstdc++-v3"
+      ;;
+    avr-*-*)
+      noconfigdirs="$noconfigdirs target-libstdc++-v3"
+      ;;
+    ft32-*-*)
+      noconfigdirs="$noconfigdirs target-libstdc++-v3"
+      ;;
+  esac
+fi
+
+# Disable Fortran for some systems.
+case "${target}" in
+  mmix-*-*)
+    # See <http://gcc.gnu.org/ml/gcc-patches/2004-11/msg00572.html>.
+    unsupported_languages="$unsupported_languages fortran"
+    ;;
+esac
+
+# Disable Java if libffi is not supported.
+case "${target}" in
+  aarch64-*-*)
+    ;;
+  alpha*-*-*)
+    ;;
+  arm*-*-*)
+    ;;
+  cris-*-*)
+    ;;
+  frv-*-*)
+    ;;
+  hppa*-*-linux*)
+    ;;
+  hppa*-*-hpux*)
+    ;;
+  i?86-*-*)
+    ;;
+  ia64*-*-*)
+    ;;
+  m32r*-*-*)
+    ;;
+  m68k-*-*)
+    ;;
+  mips*-*-rtems*)
+    ;;
+  mips*-*-linux*)
+    ;;
+  powerpc*-*-linux*)
+    ;;
+  powerpc-*-darwin*)
+    ;;
+  powerpc-*-aix* | rs6000-*-aix*)
+    ;;
+  powerpc-*-freebsd*)
+    ;;
+  powerpc64-*-freebsd*)
+    ;;
+  powerpc*-*-rtems*)
+    ;;
+  s390-*-* | s390x-*-*)
+    ;;
+  sh-*-* | sh[[34]]*-*-*)
+    ;;
+  sh64-*-* | sh5*-*-*)
+    ;;
+  sparc*-*-*)
+    ;;
+  x86_64-*-*)
+    ;;
+  *-*-*)
+    unsupported_languages="$unsupported_languages java"
+    ;;
+esac
+
+# Disable Java, libgcj or related libraries for some systems.
+case "${target}" in
+  powerpc-*-darwin*)
+    ;;
+  i[[3456789]]86-*-darwin*)
+    ;;
+  x86_64-*-darwin[[912]]*)
+    ;;
+  *-*-darwin*)
+    noconfigdirs="$noconfigdirs ${libgcj}"
+    ;;
+  *-*-netware*)
+    noconfigdirs="$noconfigdirs ${libgcj}"
+    ;;
+  *-*-rtems*)
+    noconfigdirs="$noconfigdirs ${libgcj}"
+    ;;
+  *-*-tpf*)
+    noconfigdirs="$noconfigdirs ${libgcj}"
+    ;;
+  *-*-uclinux*)
+    noconfigdirs="$noconfigdirs ${libgcj}"
+    ;;
+  *-*-vxworks*)
+    noconfigdirs="$noconfigdirs ${libgcj}"
+    ;;
+  alpha*-*-*vms*)
+    noconfigdirs="$noconfigdirs ${libgcj}"
+    ;;
+  arm*-*-freebsd*)
+    noconfigdirs="$noconfigdirs ${libgcj}"
+    ;;
+  arm-wince-pe)
+    noconfigdirs="$noconfigdirs ${libgcj}"
+    ;;
+  arm*-*-symbianelf*)
+    noconfigdirs="$noconfigdirs ${libgcj}"
+    ;;
+  bfin-*-*)
+    noconfigdirs="$noconfigdirs target-boehm-gc"
+    ;;
+  cris-*-* | crisv32-*-*)
+    unsupported_languages="$unsupported_languages java"
+    case "${target}" in
+      *-*-linux*)
+	;;
+      *) # See PR46792 regarding target-libffi.
+	noconfigdirs="$noconfigdirs target-libffi target-boehm-gc";;
+    esac
+    ;;
+  hppa*64*-*-linux*)
+    # In this case, it's because the hppa64-linux target is for
+    # the kernel only at this point and has no libc, and thus no
+    # headers, crt*.o, etc., all of which are needed by these.
+    unsupported_languages="$unsupported_languages java"
+    ;;
+  hppa*64*-*-hpux*)
+    noconfigdirs="$noconfigdirs ${libgcj}"
+    ;;
+  hppa*-hp-hpux11*)
+    ;;
+  hppa*-*-hpux*)
+    # According to Alexandre Oliva <aoliva@redhat.com>, libjava won't
+    # build on HP-UX 10.20.
+    noconfigdirs="$noconfigdirs ${libgcj}"
+    ;;
+  ia64*-*-*vms*)
+    noconfigdirs="$noconfigdirs ${libgcj}"
+    ;;
+  i[[3456789]]86-w64-mingw*)
+    noconfigdirs="$noconfigdirs ${libgcj}"
+    ;;
+  i[[3456789]]86-*-mingw*)
+    noconfigdirs="$noconfigdirs ${libgcj}"
+    ;;
+  x86_64-*-mingw*)
+    noconfigdirs="$noconfigdirs ${libgcj}"
+    ;;
+  mmix-*-*)
+    noconfigdirs="$noconfigdirs target-libffi target-boehm-gc"
+    ;;
+  powerpc-*-aix*)
+    # copied from rs6000-*-* entry
+    noconfigdirs="$noconfigdirs ${libgcj}"
+    ;;
+  rs6000-*-aix*)
+    noconfigdirs="$noconfigdirs ${libgcj}"
+    ;;
+  ft32-*-*)
+    noconfigdirs="$noconfigdirs ${libgcj}"
+    ;;
+  *-*-lynxos*)
+    noconfigdirs="$noconfigdirs ${libgcj}"
+    ;;
+esac
+
+# Disable the go frontend on systems where it is known to not work. Please keep
+# this in sync with contrib/config-list.mk.
+case "${target}" in
+*-*-darwin* | *-*-cygwin* | *-*-mingw* | *-*-aix*)
+    unsupported_languages="$unsupported_languages go"
+    ;;
+esac
+
+# Disable libgo for some systems where it is known to not work.
+# For testing, you can easily override this with --enable-libgo.
+if test x$enable_libgo = x; then
+    case "${target}" in
+    *-*-darwin*)
+	# PR 46986
+	noconfigdirs="$noconfigdirs target-libgo"
+	;;
+    *-*-cygwin* | *-*-mingw*)
+	noconfigdirs="$noconfigdirs target-libgo"
+	;;
+    *-*-aix*)
+	noconfigdirs="$noconfigdirs target-libgo"
+	;;
+    esac
+fi
+
+# Default libgloss CPU subdirectory.
+libgloss_dir="$target_cpu"
+
+case "${target}" in
+  sh*-*-pe|mips*-*-pe|*arm-wince-pe)
+    libgloss_dir=wince
+    ;;
+  aarch64*-*-* )
+    libgloss_dir=aarch64
+    ;;
+  arm*-*-*)
+    libgloss_dir=arm
+    ;;
+  cris-*-* | crisv32-*-*)
+    libgloss_dir=cris
+    ;;
+  hppa*-*-*)
+    libgloss_dir=pa
+    ;;
+  i[[3456789]]86-*-*)
+    libgloss_dir=i386
+    ;;
+  m68hc11-*-*|m6811-*-*|m68hc12-*-*|m6812-*-*)
+    libgloss_dir=m68hc11
+    ;;
+  m68*-*-* | fido-*-*)
+    libgloss_dir=m68k
+    ;;
+  mips*-*-*)
+    libgloss_dir=mips
+    ;;
+  powerpc*-*-*)
+    libgloss_dir=rs6000
+    ;;
+  sparc*-*-*)
+    libgloss_dir=sparc
+    ;;
+esac
+
+# Disable newlib and libgloss for various target OSes.
+case "${target}" in
+  alpha*-dec-osf*)
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss"
+    ;;
+  i[[3456789]]86-*-linux*)
+    # This section makes it possible to build newlib natively on linux.
+    # If we are using a cross compiler then don't configure newlib.
+    if test x${is_cross_compiler} != xno ; then
+      noconfigdirs="$noconfigdirs target-newlib"
+    fi
+    noconfigdirs="$noconfigdirs target-libgloss"
+    # If we are not using a cross compiler, do configure newlib.
+    # Note however, that newlib will only be configured in this situation
+    # if the --with-newlib option has been given, because otherwise
+    # 'target-newlib' will appear in skipdirs.
+    ;;
+  i[[3456789]]86-*-rdos*)
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss"
+    ;;
+  sh*-*-pe|mips*-*-pe|arm-wince-pe)
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss"
+    ;;
+  sparc-*-sunos4*)
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss"
+    ;;
+  *-*-aix*)
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss"
+    ;;
+  *-*-beos*)
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss"
+    ;;
+  *-*-chorusos)
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss"
+    ;;
+  *-*-dragonfly*)
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss"
+    ;;
+  *-*-freebsd*)
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss"
+    ;;
+  *-*-linux* | *-*-gnu* | *-*-k*bsd*-gnu | *-*-kopensolaris*-gnu)
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss"
+    ;;
+  *-*-lynxos*)
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss"
+    ;; 
+  *-*-mingw*)
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss"
+    ;;
+  *-*-netbsd*)
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss"
+    ;;
+  *-*-netware*)
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss"
+    ;;
+  *-*-tpf*)
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss"
+    ;;
+  *-*-uclinux*)
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss"
+    ;;
+  *-*-vxworks*)
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss"
+    ;;
+esac
+
+case "${target}" in
+  *-*-chorusos)
+    ;;
+  powerpc-*-darwin*)
+    noconfigdirs="$noconfigdirs ld gas gdb gprof"
+    noconfigdirs="$noconfigdirs sim target-rda"
+    ;;
+  i[[3456789]]86-*-darwin*)
+    noconfigdirs="$noconfigdirs ld gprof"
+    noconfigdirs="$noconfigdirs sim target-rda"
+    ;;
+  x86_64-*-darwin[[912]]*)
+    noconfigdirs="$noconfigdirs ld gas gprof"
+    noconfigdirs="$noconfigdirs sim target-rda"
+    ;;
+  *-*-darwin*)
+    noconfigdirs="$noconfigdirs ld gas gdb gprof"
+    noconfigdirs="$noconfigdirs sim target-rda"
+    ;;
+  *-*-dragonfly*)
+    ;;
+  *-*-freebsd*)
+    if test "x$with_gmp" = x && test "x$with_gmp_dir" = x \
+	&& test -f /usr/local/include/gmp.h; then
+      with_gmp=/usr/local
+    fi
+    ;;
+  *-*-kaos*)
+    # Remove unsupported stuff on all kaOS configurations.
+    noconfigdirs="$noconfigdirs target-libgloss"
+    ;;
+  *-*-netbsd*)
+    ;;
+  *-*-netware*)
+    ;;
+  *-*-rtems*)
+    noconfigdirs="$noconfigdirs target-libgloss"
+    # this is not caught below because this stanza matches earlier
+    case $target in
+      or1k*-*-*) noconfigdirs="$noconfigdirs gdb" ;;
+    esac
+    ;;
+    # The tpf target doesn't support gdb yet.
+  *-*-tpf*)
+    noconfigdirs="$noconfigdirs gdb tcl tk libgui itcl"
+    ;;
+  *-*-uclinux*)
+    noconfigdirs="$noconfigdirs target-rda"
+    ;;
+  *-*-vxworks*)
+    ;;
+  alpha*-dec-osf*)
+    # ld works, but does not support shared libraries.
+    # gas doesn't generate exception information.
+    noconfigdirs="$noconfigdirs gas ld"
+    ;;
+  alpha*-*-*vms*)
+    noconfigdirs="$noconfigdirs gdb target-newlib target-libgloss"
+    ;;
+  alpha*-*-*)
+    # newlib is not 64 bit ready
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss"
+    ;;
+  sh*-*-pe|mips*-*-pe|*arm-wince-pe)
+    noconfigdirs="$noconfigdirs tcl tk itcl libgui sim"
+    ;;
+  arc-*-*|arceb-*-*)
+    noconfigdirs="$noconfigdirs target-libgloss"
+    ;;
+  arm-*-pe*)
+    noconfigdirs="$noconfigdirs target-libgloss"
+    ;;
+  arm-*-riscix*)
+    noconfigdirs="$noconfigdirs ld target-libgloss"
+    ;;
+  avr-*-rtems*)
+    ;;
+  avr-*-*)
+    if test x${with_avrlibc} != xno; then
+      noconfigdirs="$noconfigdirs target-newlib target-libgloss"
+    fi
+    ;;
+  c4x-*-* | tic4x-*-*)
+    noconfigdirs="$noconfigdirs target-libgloss"
+    ;;
+  tic54x-*-*)
+    noconfigdirs="$noconfigdirs target-libgloss gdb"
+    ;;
+  d10v-*-*)
+    noconfigdirs="$noconfigdirs target-libgloss"
+    ;;
+  d30v-*-*)
+    noconfigdirs="$noconfigdirs gdb"
+    ;;
+  fr30-*-elf*)
+    noconfigdirs="$noconfigdirs gdb"
+    ;;
+  ft32-*-*)
+    noconfigdirs="$noconfigdirs target-rda gprof"
+    ;;
+  moxie-*-*)
+    noconfigdirs="$noconfigdirs"
+    ;;
+  h8300*-*-*)
+    noconfigdirs="$noconfigdirs target-libgloss"
+    ;;
+  h8500-*-*)
+    noconfigdirs="$noconfigdirs target-libgloss"
+    ;;
+  hppa1.1-*-osf* | hppa1.1-*-bsd* )
+    ;;
+  hppa*64*-*-hpux*)
+    noconfigdirs="$noconfigdirs gdb"
+    ;;
+  hppa*-*-hpux11*)
+    noconfigdirs="$noconfigdirs gdb ld"
+    ;;
+  hppa*64*-*-linux*)
+    ;;
+  hppa*-*-linux*)
+    ;;
+  hppa*-*-*elf* | \
+  hppa*-*-lites* | \
+  hppa*-*-openbsd* | \
+  hppa*64*-*-*)
+    ;;
+  hppa*-*-pro*)
+    ;;
+  hppa*-*-*)
+    noconfigdirs="$noconfigdirs ld"
+    ;;
+  i960-*-*)
+    noconfigdirs="$noconfigdirs gdb"
+    ;;
+  ia64*-*-elf*)
+    # No gdb support yet.
+    noconfigdirs="$noconfigdirs readline libgui itcl gdb"
+    ;;
+  ia64*-**-hpux*)
+    # No ld support yet.
+    noconfigdirs="$noconfigdirs gdb libgui itcl ld"
+    ;;
+  ia64*-*-*vms*)
+    # No ld support yet.
+    noconfigdirs="$noconfigdirs libgui itcl ld"
+    ;;
+  i[[3456789]]86-w64-mingw*)
+    ;;
+  i[[3456789]]86-*-mingw*)
+    target_configdirs="$target_configdirs target-winsup"
+    ;;
+  *-*-cygwin*)
+    target_configdirs="$target_configdirs target-libtermcap target-winsup"
+    noconfigdirs="$noconfigdirs target-libgloss"
+    # always build newlib if winsup directory is present.
+    if test -d "$srcdir/winsup/cygwin"; then
+      skipdirs=`echo " ${skipdirs} " | sed -e 's/ target-newlib / /'`
+    elif test -d "$srcdir/newlib"; then
+      echo "Warning: winsup/cygwin is missing so newlib can't be built."
+    fi
+    ;;
+  i[[3456789]]86-*-pe)
+    noconfigdirs="$noconfigdirs target-libgloss"
+    ;;
+  i[[3456789]]86-*-sco3.2v5*)
+    # The linker does not yet know about weak symbols in COFF,
+    # and is not configured to handle mixed ELF and COFF.
+    noconfigdirs="$noconfigdirs ld target-libgloss"
+    ;;
+  i[[3456789]]86-*-sco*)
+    noconfigdirs="$noconfigdirs gprof target-libgloss"
+    ;;
+  i[[3456789]]86-*-solaris2* | x86_64-*-solaris2.1[[0-9]]*)
+    noconfigdirs="$noconfigdirs target-libgloss"
+    ;;
+  i[[3456789]]86-*-sysv4*)
+    noconfigdirs="$noconfigdirs target-libgloss"
+    ;;
+  i[[3456789]]86-*-beos*)
+    noconfigdirs="$noconfigdirs gdb"
+    ;;
+  i[[3456789]]86-*-rdos*)
+    noconfigdirs="$noconfigdirs gdb"
+    ;;
+  mmix-*-*)
+    noconfigdirs="$noconfigdirs gdb"
+    ;;
+  mt-*-*)
+    noconfigdirs="$noconfigdirs sim"
+    ;;
+  powerpc-*-aix*)
+    # copied from rs6000-*-* entry
+    noconfigdirs="$noconfigdirs gprof"
+    ;;
+  powerpc*-*-winnt* | powerpc*-*-pe*)
+    target_configdirs="$target_configdirs target-winsup"
+    noconfigdirs="$noconfigdirs gdb tcl tk target-libgloss itcl"
+    # always build newlib.
+    skipdirs=`echo " ${skipdirs} " | sed -e 's/ target-newlib / /'`
+    ;;
+    # This is temporary until we can link against shared libraries
+  powerpcle-*-solaris*)
+    noconfigdirs="$noconfigdirs gdb sim tcl tk itcl"
+    ;;
+  powerpc-*-beos*)
+    noconfigdirs="$noconfigdirs gdb"
+    ;;
+  rs6000-*-lynxos*)
+    noconfigdirs="$noconfigdirs gprof"
+    ;;
+  rs6000-*-aix*)
+    noconfigdirs="$noconfigdirs gprof"
+    ;;
+  rs6000-*-*)
+    noconfigdirs="$noconfigdirs gprof"
+    ;;
+  m68k-apollo-*)
+    noconfigdirs="$noconfigdirs ld binutils gprof target-libgloss"
+    ;;
+  microblaze*)
+    noconfigdirs="$noconfigdirs gprof"
+    ;;
+  mips*-sde-elf* | mips*-mti-elf* | mips*-img-elf*)
+    if test x$with_newlib = xyes; then
+      noconfigdirs="$noconfigdirs gprof"
+    fi
+    ;;
+  mips*-*-irix5*)
+    noconfigdirs="$noconfigdirs gprof target-libgloss"
+    ;;
+  mips*-*-irix6*)
+    noconfigdirs="$noconfigdirs gprof target-libgloss"
+    ;;
+  mips*-*-bsd*)
+    noconfigdirs="$noconfigdirs ld gas gprof target-libgloss"
+    ;;
+  mips*-*-linux*)
+    ;;
+  mips*-*-ultrix* | mips*-*-osf* | mips*-*-ecoff* | mips*-*-pe* \
+  | mips*-*-irix* | mips*-*-lnews* | mips*-*-riscos*)
+    noconfigdirs="$noconfigdirs ld gas gprof"
+    ;;
+  mips*-*-*)
+    noconfigdirs="$noconfigdirs gprof"
+    ;;
+  nds32*-*-*)
+    noconfigdirs="$noconfigdirs gdb"
+    ;;
+  nvptx*-*-*)
+    noconfigdirs="$noconfigdirs target-libssp target-libstdc++-v3 target-libobjc"
+    ;;
+  or1k*-*-*)
+    noconfigdirs="$noconfigdirs gdb"
+    ;;
+  sh-*-* | sh64-*-*)
+    case "${target}" in
+      sh*-*-elf)
+         ;;
+      *)
+         noconfigdirs="$noconfigdirs target-libgloss" ;;
+    esac
+    ;;
+  sparc-*-sunos4*)
+    if test x${is_cross_compiler} = xno ; then
+           use_gnu_ld=no
+    fi
+    ;;
+  tic6x-*-*)
+    noconfigdirs="$noconfigdirs sim"
+    ;;
+  tilepro*-*-* | tilegx*-*-*)
+    noconfigdirs="$noconfigdirs sim"
+    ;;
+  v810-*-*)
+    noconfigdirs="$noconfigdirs bfd binutils gas gdb ld opcodes target-libgloss"
+    ;;
+  vax-*-*)
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss"
+    ;;
+esac
+
+# If we aren't building newlib, then don't build libgloss, since libgloss
+# depends upon some newlib header files.
+case "${noconfigdirs}" in
+  *target-libgloss*) ;;
+  *target-newlib*) noconfigdirs="$noconfigdirs target-libgloss" ;;
+esac
+
+# Work in distributions that contain no compiler tools, like Autoconf.
+host_makefile_frag=/dev/null
+if test -d ${srcdir}/config ; then
+case "${host}" in
+  i[[3456789]]86-*-msdosdjgpp*)
+    host_makefile_frag="config/mh-djgpp"
+    ;;
+  *-cygwin*)
+    ACX_CHECK_CYGWIN_CAT_WORKS
+    host_makefile_frag="config/mh-cygwin"
+    ;;
+  *-mingw*)
+    host_makefile_frag="config/mh-mingw"
+    ;;
+  alpha*-linux*)
+    host_makefile_frag="config/mh-alpha-linux"
+    ;;
+  hppa*-hp-hpux10*)
+    host_makefile_frag="config/mh-pa-hpux10"
+    ;;
+  hppa*-hp-hpux*)
+    host_makefile_frag="config/mh-pa"
+    ;;
+  hppa*-*)	
+    host_makefile_frag="config/mh-pa"
+    ;;
+  *-*-darwin*)
+    host_makefile_frag="config/mh-darwin"
+    ;;
+  powerpc-*-aix*)
+    host_makefile_frag="config/mh-ppc-aix"
+    ;;
+  rs6000-*-aix*)
+    host_makefile_frag="config/mh-ppc-aix"
+    ;;
+esac
+fi
+
+if test "${build}" != "${host}" ; then
+  AR_FOR_BUILD=${AR_FOR_BUILD-ar}
+  AS_FOR_BUILD=${AS_FOR_BUILD-as}
+  CC_FOR_BUILD=${CC_FOR_BUILD-gcc}
+  CXX_FOR_BUILD=${CXX_FOR_BUILD-g++}
+  GCJ_FOR_BUILD=${GCJ_FOR_BUILD-gcj}
+  GFORTRAN_FOR_BUILD=${GFORTRAN_FOR_BUILD-gfortran}
+  GOC_FOR_BUILD=${GOC_FOR_BUILD-gccgo}
+  DLLTOOL_FOR_BUILD=${DLLTOOL_FOR_BUILD-dlltool}
+  LD_FOR_BUILD=${LD_FOR_BUILD-ld}
+  NM_FOR_BUILD=${NM_FOR_BUILD-nm}
+  RANLIB_FOR_BUILD=${RANLIB_FOR_BUILD-ranlib}
+  WINDRES_FOR_BUILD=${WINDRES_FOR_BUILD-windres}
+  WINDMC_FOR_BUILD=${WINDMC_FOR_BUILD-windmc}
+else
+  AR_FOR_BUILD="\$(AR)"
+  AS_FOR_BUILD="\$(AS)"
+  CC_FOR_BUILD="\$(CC)"
+  CXX_FOR_BUILD="\$(CXX)"
+  GCJ_FOR_BUILD="\$(GCJ)"
+  GFORTRAN_FOR_BUILD="\$(GFORTRAN)"
+  GOC_FOR_BUILD="\$(GOC)"
+  DLLTOOL_FOR_BUILD="\$(DLLTOOL)"
+  LD_FOR_BUILD="\$(LD)"
+  NM_FOR_BUILD="\$(NM)"
+  RANLIB_FOR_BUILD="\$(RANLIB)"
+  WINDRES_FOR_BUILD="\$(WINDRES)"
+  WINDMC_FOR_BUILD="\$(WINDMC)"
+fi
+
+AC_PROG_CC
+AC_PROG_CXX
+
+# We must set the default linker to the linker used by gcc for the correct
+# operation of libtool.  If LD is not defined and we are using gcc, try to
+# set the LD default to the ld used by gcc.
+if test -z "$LD"; then
+  if test "$GCC" = yes; then
+    case $build in
+    *-*-mingw*)
+      gcc_prog_ld=`$CC -print-prog-name=ld 2>&1 | tr -d '\015'` ;;
+    *)
+      gcc_prog_ld=`$CC -print-prog-name=ld 2>&1` ;;
+    esac
+    case $gcc_prog_ld in
+    # Accept absolute paths.
+    [[\\/]* | [A-Za-z]:[\\/]*)]
+      LD="$gcc_prog_ld" ;;
+    esac
+  fi
+fi
+
+# Check whether -static-libstdc++ -static-libgcc is supported.
+have_static_libs=no
+if test "$GCC" = yes; then
+  saved_LDFLAGS="$LDFLAGS"
+
+  LDFLAGS="$LDFLAGS -static-libstdc++ -static-libgcc"
+  AC_MSG_CHECKING([whether g++ accepts -static-libstdc++ -static-libgcc])
+  AC_LANG_PUSH(C++)
+  AC_LINK_IFELSE([
+#if (__GNUC__ < 4) || (__GNUC__ == 4 && __GNUC_MINOR__ < 5)
+#error -static-libstdc++ not implemented
+#endif
+int main() {}],
+    [AC_MSG_RESULT([yes]); have_static_libs=yes],
+    [AC_MSG_RESULT([no])])
+  AC_LANG_POP(C++)
+
+  LDFLAGS="$saved_LDFLAGS"
+fi
+
+ACX_PROG_GNAT
+ACX_PROG_CMP_IGNORE_INITIAL
+
+AC_ARG_ENABLE([bootstrap],
+[AS_HELP_STRING([--enable-bootstrap],
+		[enable bootstrapping @<:@yes if native build@:>@])],,
+enable_bootstrap=default)
+
+# Issue errors and warnings for invalid/strange bootstrap combinations.
+if test -r $srcdir/gcc/configure; then
+  have_compiler=yes
+else
+  have_compiler=no
+fi
+
+case "$have_compiler:$host:$target:$enable_bootstrap" in
+  *:*:*:no) ;;
+
+  # Default behavior.  Enable bootstrap if we have a compiler
+  # and we are in a native configuration.
+  yes:$build:$build:default)
+    enable_bootstrap=yes ;;
+
+  *:*:*:default)
+    enable_bootstrap=no ;;
+
+  # We have a compiler and we are in a native configuration, bootstrap is ok
+  yes:$build:$build:yes)
+    ;;
+
+  # Other configurations, but we have a compiler.  Assume the user knows
+  # what he's doing.
+  yes:*:*:yes)
+    AC_MSG_WARN([trying to bootstrap a cross compiler])
+    ;;
+
+  # No compiler: if they passed --enable-bootstrap explicitly, fail
+  no:*:*:yes)
+    AC_MSG_ERROR([cannot bootstrap without a compiler]) ;;
+
+  # Fail if wrong command line
+  *)
+    AC_MSG_ERROR([invalid option for --enable-bootstrap])
+    ;;
+esac
+
+# When bootstrapping with GCC, build stage 1 in C++98 mode to ensure that a
+# C++98 compiler can still start the bootstrap.
+if test "$enable_bootstrap:$GXX" = "yes:yes"; then
+  CXX="$CXX -std=gnu++98"
+fi
+
+# Used for setting $lt_cv_objdir
+_LT_CHECK_OBJDIR
+
+# Check for GMP, MPFR and MPC
+gmplibs="-lmpc -lmpfr -lgmp"
+gmpinc=
+have_gmp=no
+
+# Specify a location for mpc
+# check for this first so it ends up on the link line before mpfr.
+AC_ARG_WITH(mpc,
+[AS_HELP_STRING([--with-mpc=PATH],
+		[specify prefix directory for installed MPC package.
+		 Equivalent to --with-mpc-include=PATH/include
+		 plus --with-mpc-lib=PATH/lib])])
+AC_ARG_WITH(mpc-include,
+[AS_HELP_STRING([--with-mpc-include=PATH],
+		[specify directory for installed MPC include files])])
+AC_ARG_WITH(mpc-lib,
+[AS_HELP_STRING([--with-mpc-lib=PATH],
+		[specify directory for the installed MPC library])])
+
+if test "x$with_mpc" != x; then
+  gmplibs="-L$with_mpc/lib $gmplibs"
+  gmpinc="-I$with_mpc/include $gmpinc"
+fi
+if test "x$with_mpc_include" != x; then
+  gmpinc="-I$with_mpc_include $gmpinc"
+fi
+if test "x$with_mpc_lib" != x; then
+  gmplibs="-L$with_mpc_lib $gmplibs"
+fi
+if test "x$with_mpc$with_mpc_include$with_mpc_lib" = x && test -d ${srcdir}/mpc; then
+  gmplibs='-L$$r/$(HOST_SUBDIR)/mpc/src/'"$lt_cv_objdir $gmplibs"
+  gmpinc='-I$$s/mpc/src '"$gmpinc"
+  # Do not test the mpc version.  Assume that it is sufficient, since
+  # it is in the source tree, and the library has not been built yet
+  # but it would be included on the link line in the version check below
+  # hence making the test fail.
+  have_gmp=yes
+fi
+
+# Specify a location for mpfr
+# check for this first so it ends up on the link line before gmp.
+AC_ARG_WITH(mpfr-dir,
+[AS_HELP_STRING([--with-mpfr-dir=PATH], [this option has been REMOVED])],
+[AC_MSG_ERROR([The --with-mpfr-dir=PATH option has been removed.
+Use --with-mpfr=PATH or --with-mpfr-include=PATH plus --with-mpfr-lib=PATH])])
+
+AC_ARG_WITH(mpfr,
+[AS_HELP_STRING([--with-mpfr=PATH],
+		[specify prefix directory for installed MPFR package.
+		 Equivalent to --with-mpfr-include=PATH/include
+		 plus --with-mpfr-lib=PATH/lib])])
+AC_ARG_WITH(mpfr-include,
+[AS_HELP_STRING([--with-mpfr-include=PATH],
+		[specify directory for installed MPFR include files])])
+AC_ARG_WITH(mpfr-lib,
+[AS_HELP_STRING([--with-mpfr-lib=PATH],
+		[specify directory for the installed MPFR library])])
+
+if test "x$with_mpfr" != x; then
+  gmplibs="-L$with_mpfr/lib $gmplibs"
+  gmpinc="-I$with_mpfr/include $gmpinc"
+fi
+if test "x$with_mpfr_include" != x; then
+  gmpinc="-I$with_mpfr_include $gmpinc"
+fi
+if test "x$with_mpfr_lib" != x; then
+  gmplibs="-L$with_mpfr_lib $gmplibs"
+fi
+if test "x$with_mpfr$with_mpfr_include$with_mpfr_lib" = x && test -d ${srcdir}/mpfr; then
+  # MPFR v3.1.0 moved the sources into a src sub-directory.
+  if test -d ${srcdir}/mpfr/src; then
+    gmplibs='-L$$r/$(HOST_SUBDIR)/mpfr/src/'"$lt_cv_objdir $gmplibs"
+    gmpinc='-I$$r/$(HOST_SUBDIR)/mpfr/src -I$$s/mpfr/src '"$gmpinc"
+    extra_mpc_mpfr_configure_flags='--with-mpfr-include=$$s/mpfr/src --with-mpfr-lib=$$r/$(HOST_SUBDIR)/mpfr/src/'"$lt_cv_objdir"
+  else
+    gmplibs='-L$$r/$(HOST_SUBDIR)/mpfr/'"$lt_cv_objdir $gmplibs"
+    gmpinc='-I$$r/$(HOST_SUBDIR)/mpfr -I$$s/mpfr '"$gmpinc"
+    extra_mpc_mpfr_configure_flags='--with-mpfr-include=$$s/mpfr --with-mpfr-lib=$$r/$(HOST_SUBDIR)/mpfr/'"$lt_cv_objdir"
+  fi
+  # Do not test the mpfr version.  Assume that it is sufficient, since
+  # it is in the source tree, and the library has not been built yet
+  # but it would be included on the link line in the version check below
+  # hence making the test fail.
+  have_gmp=yes
+fi
+
+# Specify a location for gmp
+AC_ARG_WITH(gmp-dir,
+[AS_HELP_STRING([--with-gmp-dir=PATH], [this option has been REMOVED])],
+[AC_MSG_ERROR([The --with-gmp-dir=PATH option has been removed.
+Use --with-gmp=PATH or --with-gmp-include=PATH plus --with-gmp-lib=PATH])])
+
+AC_ARG_WITH(gmp,
+[AS_HELP_STRING([--with-gmp=PATH],
+		[specify prefix directory for the installed GMP package.
+		 Equivalent to --with-gmp-include=PATH/include
+		 plus --with-gmp-lib=PATH/lib])])
+AC_ARG_WITH(gmp-include,
+[AS_HELP_STRING([--with-gmp-include=PATH],
+		[specify directory for installed GMP include files])])
+AC_ARG_WITH(gmp-lib,
+[AS_HELP_STRING([--with-gmp-lib=PATH],
+		[specify directory for the installed GMP library])])
+
+
+if test "x$with_gmp" != x; then
+  gmplibs="-L$with_gmp/lib $gmplibs"
+  gmpinc="-I$with_gmp/include $gmpinc"
+fi
+if test "x$with_gmp_include" != x; then
+  gmpinc="-I$with_gmp_include $gmpinc"
+fi
+if test "x$with_gmp_lib" != x; then
+  gmplibs="-L$with_gmp_lib $gmplibs"
+fi
+if test "x$with_gmp$with_gmp_include$with_gmp_lib" = x && test -d ${srcdir}/gmp; then
+  gmplibs='-L$$r/$(HOST_SUBDIR)/gmp/'"$lt_cv_objdir $gmplibs"
+  gmpinc='-I$$r/$(HOST_SUBDIR)/gmp -I$$s/gmp '"$gmpinc"
+  extra_mpfr_configure_flags='--with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-gmp-lib=$$r/$(HOST_SUBDIR)/gmp/'"$lt_cv_objdir"
+  extra_mpc_gmp_configure_flags='--with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-gmp-lib=$$r/$(HOST_SUBDIR)/gmp/'"$lt_cv_objdir"
+  extra_isl_gmp_configure_flags='--with-gmp-builddir=$$r/$(HOST_SUBDIR)/gmp'
+  # Do not test the gmp version.  Assume that it is sufficient, since
+  # it is in the source tree, and the library has not been built yet
+  # but it would be included on the link line in the version check below
+  # hence making the test fail.
+  have_gmp=yes
+fi
+
+if test -d ${srcdir}/gcc && test "x$have_gmp" = xno; then
+  have_gmp=yes
+  saved_CFLAGS="$CFLAGS"
+  CFLAGS="$CFLAGS $gmpinc"
+  # Check for the recommended and required versions of GMP.
+  AC_MSG_CHECKING([for the correct version of gmp.h])
+  AC_TRY_COMPILE([#include "gmp.h"],[
+  #define GCC_GMP_VERSION_NUM(a,b,c) (((a) << 16L) | ((b) << 8) | (c))
+  #define GCC_GMP_VERSION GCC_GMP_VERSION_NUM(__GNU_MP_VERSION,__GNU_MP_VERSION_MINOR,__GNU_MP_VERSION_PATCHLEVEL)
+  #if GCC_GMP_VERSION < GCC_GMP_VERSION_NUM(4,2,3)
+  choke me
+  #endif
+  ], [AC_TRY_COMPILE([#include <gmp.h>],[
+  #define GCC_GMP_VERSION_NUM(a,b,c) (((a) << 16L) | ((b) << 8) | (c))
+  #define GCC_GMP_VERSION GCC_GMP_VERSION_NUM(__GNU_MP_VERSION,__GNU_MP_VERSION_MINOR,__GNU_MP_VERSION_PATCHLEVEL)
+  #if GCC_GMP_VERSION < GCC_GMP_VERSION_NUM(4,3,2)
+  choke me
+  #endif
+  ], [AC_MSG_RESULT([yes])], [AC_MSG_RESULT([buggy but acceptable])])],
+   [AC_MSG_RESULT([no]); have_gmp=no])
+
+  # If we have GMP, check the MPFR version.
+  if test x"$have_gmp" = xyes; then
+    # Check for the recommended and required versions of MPFR.
+    AC_MSG_CHECKING([for the correct version of mpfr.h])
+    AC_TRY_COMPILE([#include <gmp.h>
+    #include <mpfr.h>],[
+    #if MPFR_VERSION < MPFR_VERSION_NUM(2,4,0)
+    choke me
+    #endif
+    ], [AC_TRY_COMPILE([#include <gmp.h>
+    #include <mpfr.h>],[
+    #if MPFR_VERSION < MPFR_VERSION_NUM(2,4,2)
+    choke me
+    #endif
+    ], [AC_MSG_RESULT([yes])], [AC_MSG_RESULT([buggy but acceptable])])],
+     [AC_MSG_RESULT([no]); have_gmp=no])
+  fi
+
+  # Check for the MPC header version.
+  if test x"$have_gmp" = xyes ; then
+    # Check for the recommended and required versions of MPC.
+    AC_MSG_CHECKING([for the correct version of mpc.h])
+    AC_TRY_COMPILE([#include <mpc.h>],[
+    #if MPC_VERSION < MPC_VERSION_NUM(0,8,0)
+    choke me
+    #endif
+    ], [AC_TRY_COMPILE([#include <mpc.h>],[
+    #if MPC_VERSION < MPC_VERSION_NUM(0,8,1)
+    choke me
+    #endif
+    ], [AC_MSG_RESULT([yes])], [AC_MSG_RESULT([buggy but acceptable])])],
+     [AC_MSG_RESULT([no]); have_gmp=no])
+  fi
+
+  # Now check the MPFR library.
+  if test x"$have_gmp" = xyes; then
+    saved_LIBS="$LIBS"
+    LIBS="$LIBS $gmplibs"
+    AC_MSG_CHECKING([for the correct version of the gmp/mpfr/mpc libraries])
+    AC_TRY_LINK([#include <mpc.h>],[
+    mpfr_t n;
+    mpfr_t x;
+    mpc_t c;
+    int t;
+    mpfr_init (n);
+    mpfr_init (x);
+    mpfr_atan2 (n, n, x, GMP_RNDN);
+    mpfr_erfc (n, x, GMP_RNDN);
+    mpfr_subnormalize (x, t, GMP_RNDN);
+    mpfr_clear(n);
+    mpfr_clear(x);
+    mpc_init2 (c, 53);
+    mpc_set_ui_ui (c, 1, 1, MPC_RNDNN);
+    mpc_cosh (c, c, MPC_RNDNN);
+    mpc_pow (c, c, c, MPC_RNDNN);
+    mpc_acosh (c, c, MPC_RNDNN);
+    mpc_clear (c);
+    ], [AC_MSG_RESULT([yes])], [AC_MSG_RESULT([no]); have_gmp=no])
+    LIBS="$saved_LIBS"
+  fi
+
+  CFLAGS="$saved_CFLAGS"
+
+# The library versions listed in the error message below should match
+# the HARD-minimums enforced above.
+  if test x$have_gmp != xyes; then
+    AC_MSG_ERROR([Building GCC requires GMP 4.2+, MPFR 2.4.0+ and MPC 0.8.0+.
+Try the --with-gmp, --with-mpfr and/or --with-mpc options to specify
+their locations.  Source code for these libraries can be found at
+their respective hosting sites as well as at
+ftp://gcc.gnu.org/pub/gcc/infrastructure/.  See also
+http://gcc.gnu.org/install/prerequisites.html for additional info.  If
+you obtained GMP, MPFR and/or MPC from a vendor distribution package,
+make sure that you have installed both the libraries and the header
+files.  They may be located in separate packages.])
+  fi
+fi
+
+# Flags needed for both GMP, MPFR and/or MPC.
+AC_SUBST(gmplibs)
+AC_SUBST(gmpinc)
+AC_SUBST(extra_mpfr_configure_flags)
+AC_SUBST(extra_mpc_gmp_configure_flags)
+AC_SUBST(extra_mpc_mpfr_configure_flags)
+AC_SUBST(extra_isl_gmp_configure_flags)
+
+# Libraries to use for stage1 or when not bootstrapping.
+AC_ARG_WITH(stage1-libs,
+[AS_HELP_STRING([--with-stage1-libs=LIBS], [libraries for stage1])],
+[if test "$withval" = "no" -o "$withval" = "yes"; then
+   stage1_libs=
+ else
+   stage1_libs=$withval
+ fi],
+[stage1_libs=])
+AC_SUBST(stage1_libs)
+
+# Linker flags to use for stage1 or when not bootstrapping.
+AC_ARG_WITH(stage1-ldflags,
+[AS_HELP_STRING([--with-stage1-ldflags=FLAGS], [linker flags for stage1])],
+[if test "$withval" = "no" -o "$withval" = "yes"; then
+   stage1_ldflags=
+ else
+   stage1_ldflags=$withval
+ fi],
+[stage1_ldflags=
+ # In stage 1, default to linking libstdc++ and libgcc statically with GCC
+ # if supported.  But if the user explicitly specified the libraries to use,
+ # trust that they are doing what they want.
+ if test "$stage1_libs" = "" -a "$have_static_libs" = yes; then
+   stage1_ldflags="-static-libstdc++ -static-libgcc"
+ fi])
+AC_SUBST(stage1_ldflags)
+
+# Libraries to use for stage2 and later builds.
+AC_ARG_WITH(boot-libs,
+[AS_HELP_STRING([--with-boot-libs=LIBS], [libraries for stage2 and later])],
+[if test "$withval" = "no" -o "$withval" = "yes"; then
+   poststage1_libs=
+ else
+   poststage1_libs=$withval
+ fi],
+[poststage1_libs=])
+AC_SUBST(poststage1_libs)
+
+# Linker flags to use for stage2 and later builds.
+AC_ARG_WITH(boot-ldflags,
+[AS_HELP_STRING([--with-boot-ldflags=FLAGS],
+		[linker flags for stage2 and later])],
+[if test "$withval" = "no" -o "$withval" = "yes"; then
+   poststage1_ldflags=
+ else
+   poststage1_ldflags=$withval
+ fi],
+[poststage1_ldflags=
+ # In stages 2 and 3, default to linking libstdc++ and libgcc
+ # statically.  But if the user explicitly specified the libraries to
+ # use, trust that they are doing what they want.
+ if test "$poststage1_libs" = ""; then
+   poststage1_ldflags="-static-libstdc++ -static-libgcc"
+ fi])
+AC_SUBST(poststage1_ldflags)
+
+# GCC GRAPHITE dependency ISL.
+# Basic setup is inlined here, actual checks are in config/isl.m4
+
+AC_ARG_WITH(isl,
+  [AS_HELP_STRING(
+   [--with-isl=PATH],
+   [Specify prefix directory for the installed ISL package.
+    Equivalent to --with-isl-include=PATH/include
+    plus --with-isl-lib=PATH/lib])])
+
+# Treat --without-isl as a request to disable
+# GRAPHITE support and skip all following checks.
+if test "x$with_isl" != "xno"; then
+  # Check for ISL
+  dnl Provide configure switches and initialize islinc & isllibs
+  dnl with user input.
+  ISL_INIT_FLAGS
+  dnl The versions of ISL that work for Graphite
+  ISL_CHECK_VERSION()
+  dnl Only execute fail-action, if ISL has been requested.
+  ISL_IF_FAILED([
+    AC_MSG_ERROR([Unable to find a usable ISL.  See config.log for details.])])
+fi
+
+# If the ISL check failed, disable builds of in-tree variant of ISL
+if test "x$with_isl" = xno ||
+   test "x$gcc_cv_isl" = xno; then
+  noconfigdirs="$noconfigdirs isl"
+  islinc=
+fi
+
+AC_SUBST(isllibs)
+AC_SUBST(islinc)
+
+# Check for LTO support.
+AC_ARG_ENABLE(lto,
+[AS_HELP_STRING([--enable-lto], [enable link time optimization support])],
+enable_lto=$enableval,
+enable_lto=yes; default_enable_lto=yes)
+
+ACX_ELF_TARGET_IFELSE([# ELF platforms build the lto-plugin always.
+  build_lto_plugin=yes
+],[if test x"$default_enable_lto" = x"yes" ; then
+    case $target in
+      *-apple-darwin9* | *-cygwin* | *-mingw*) ;;
+      # On other non-ELF platforms, LTO has yet to be validated.
+      *) enable_lto=no ;;
+    esac
+  else
+  # Apart from ELF platforms, only Windows and Darwin support LTO so far.
+  # It would also be nice to check the binutils support, but we don't
+  # have gcc_GAS_CHECK_FEATURE available here.  For now, we'll just
+  # warn during gcc/ subconfigure; unless you're bootstrapping with
+  # -flto it won't be needed until after installation anyway.
+    case $target in
+      *-cygwin* | *-mingw* | *-apple-darwin*) ;;
+      *) if test x"$enable_lto" = x"yes"; then
+	AC_MSG_ERROR([LTO support is not enabled for this target.])
+        fi
+      ;;
+    esac
+  fi
+  # Among non-ELF, only Windows platforms support the lto-plugin so far.
+  # Build it unless LTO was explicitly disabled.
+  case $target in
+    *-cygwin* | *-mingw*) build_lto_plugin=$enable_lto ;;
+    *) ;;
+  esac
+])
+
+AC_ARG_ENABLE(linker-plugin-configure-flags,
+  [AS_HELP_STRING([[--enable-linker-plugin-configure-flags=FLAGS]],
+    [additional flags for configuring linker plugins @<:@none@:>@])],
+  extra_linker_plugin_configure_flags=$enableval,
+  extra_linker_plugin_configure_flags=)
+AC_SUBST(extra_linker_plugin_configure_flags)
+AC_ARG_ENABLE(linker-plugin-flags,
+  [AS_HELP_STRING([[--enable-linker-plugin-flags=FLAGS]],
+    [additional flags for configuring and building linker plugins @<:@none@:>@])],
+  extra_linker_plugin_flags=$enableval,
+  extra_linker_plugin_flags=)
+AC_SUBST(extra_linker_plugin_flags)
+
+
+# By default, C and C++ are the only stage 1 languages.
+stage1_languages=,c,
+
+# Target libraries that we bootstrap.
+bootstrap_target_libs=,target-libgcc,
+
+# Figure out what language subdirectories are present.
+# Look if the user specified --enable-languages="..."; if not, use
+# the environment variable $LANGUAGES if defined. $LANGUAGES might
+# go away some day.
+# NB:  embedded tabs in this IF block -- do not untabify
+if test -d ${srcdir}/gcc; then
+  if test x"${enable_languages+set}" != xset; then
+    if test x"${LANGUAGES+set}" = xset; then
+      enable_languages="${LANGUAGES}"
+        echo configure.ac: warning: setting LANGUAGES is deprecated, use --enable-languages instead 1>&2
+    else
+      enable_languages=all
+    fi
+  else
+    if test x"${enable_languages}" = x ||
+       test x"${enable_languages}" = xyes;
+       then
+      echo configure.ac: --enable-languages needs at least one language argument 1>&2
+      exit 1
+    fi
+  fi
+  enable_languages=`echo "${enable_languages}" | sed -e 's/[[ 	,]][[ 	,]]*/,/g' -e 's/,$//'`
+
+  # 'f95' is the old name for the 'fortran' language. We issue a warning
+  # and make the substitution.
+  case ,${enable_languages}, in
+    *,f95,*)
+      echo configure.ac: warning: 'f95' as language name is deprecated, use 'fortran' instead 1>&2
+      enable_languages=`echo "${enable_languages}" | sed -e 's/f95/fortran/g'`
+      ;;
+  esac
+
+  # If bootstrapping, C++ must be enabled.
+  case ",$enable_languages,:$enable_bootstrap" in
+    *,c++,*:*) ;;
+    *:yes)
+      if test -f ${srcdir}/gcc/cp/config-lang.in; then
+        enable_languages="${enable_languages},c++"
+      else
+        AC_MSG_ERROR([bootstrapping requires c++ sources])
+      fi
+      ;;
+  esac
+
+  # First scan to see if an enabled language requires some other language.
+  # We assume that a given config-lang.in will list all the language
+  # front ends it requires, even if some are required indirectly.
+  for lang_frag in ${srcdir}/gcc/*/config-lang.in .. ; do
+    case ${lang_frag} in
+      ..) ;;
+      # The odd quoting in the next line works around
+      # an apparent bug in bash 1.12 on linux.
+      ${srcdir}/gcc/[[*]]/config-lang.in) ;;
+      *)
+        # From the config-lang.in, get $language, $lang_requires, and
+        # $lang_requires_boot_languages.
+        language=
+        lang_requires=
+        lang_requires_boot_languages=
+        . ${lang_frag}
+        for other in ${lang_requires} ${lang_requires_boot_languages}; do
+          case ,${enable_languages}, in
+	    *,$other,*) ;;
+	    *,all,*) ;;
+	    *,$language,*)
+	      echo " \`$other' language required by \`$language'; enabling" 1>&2
+	      enable_languages="${enable_languages},${other}"
+	      ;;
+	  esac
+        done
+	for other in ${lang_requires_boot_languages} ; do
+	  if test "$other" != "c"; then
+	    case ,${enable_stage1_languages}, in
+	      *,$other,*) ;;
+	      *,all,*) ;;
+	      *)
+		case ,${enable_languages}, in
+		  *,$language,*)
+		    echo " '$other' language required by '$language' in stage 1; enabling" 1>&2
+		    enable_stage1_languages="$enable_stage1_languages,${other}"
+		    ;;
+		esac
+		;;
+	    esac
+          fi
+        done
+        ;;
+    esac
+  done
+
+  new_enable_languages=,c,
+
+  # If LTO is enabled, add the LTO front end.
+  if test "$enable_lto" = "yes" ; then
+    case ,${enable_languages}, in
+      *,lto,*) ;;
+      *) enable_languages="${enable_languages},lto" ;;
+    esac
+    if test "${build_lto_plugin}" = "yes" ; then
+      configdirs="$configdirs lto-plugin"
+    fi
+  fi
+
+  # If we're building an offloading compiler, add the LTO front end.
+  if test x"$enable_as_accelerator_for" != x ; then
+    case ,${enable_languages}, in
+      *,lto,*) ;;
+      *) enable_languages="${enable_languages},lto" ;;
+    esac
+  fi
+
+  missing_languages=`echo ",$enable_languages," | sed -e s/,all,/,/ -e s/,c,/,/ `
+  potential_languages=,c,
+
+  enabled_target_libs=
+  disabled_target_libs=
+
+  for lang_frag in ${srcdir}/gcc/*/config-lang.in .. ; do
+    case ${lang_frag} in
+      ..) ;;
+      # The odd quoting in the next line works around
+      # an apparent bug in bash 1.12 on linux.
+      ${srcdir}/gcc/[[*]]/config-lang.in) ;;
+      *)
+        # From the config-lang.in, get $language, $target_libs, 
+        # $lang_dirs, $boot_language, and $build_by_default
+        language=
+        target_libs=
+        lang_dirs=
+        subdir_requires=
+        boot_language=no
+        build_by_default=yes
+        . ${lang_frag}
+        if test x${language} = x; then
+          echo "${lang_frag} doesn't set \$language." 1>&2
+          exit 1
+        fi
+
+	if test "$language" = "c++"; then
+	  boot_language=yes
+	fi
+
+        add_this_lang=no
+        case ,${enable_languages}, in
+          *,${language},*)
+            # Language was explicitly selected; include it
+	    # unless it is C, which is enabled by default.
+	    if test "$language" != "c"; then
+	      add_this_lang=yes
+	    fi
+            ;;
+          *,all,*)
+            # 'all' was selected, select it if it is a default language
+	    if test "$language" != "c"; then
+	      add_this_lang=${build_by_default}
+	    fi
+            ;;
+        esac
+
+        # Disable languages that need other directories if these aren't available.
+	for i in $subdir_requires; do
+	  test -f "$srcdir/gcc/$i/config-lang.in" && continue
+	  case ,${enable_languages}, in
+            *,${language},*)
+              # Specifically requested language; tell them.
+              AC_MSG_ERROR([The gcc/$i directory contains parts of $language but is missing])
+              ;;
+            *)
+              # Silently disable.
+              add_this_lang=unsupported
+              ;;
+          esac
+	done
+
+        # Disable Ada if no preexisting GNAT is available.
+        case ,${enable_languages},:${language}:${have_gnat} in
+          *,${language},*:ada:no)
+            # Specifically requested language; tell them.
+            AC_MSG_ERROR([GNAT is required to build $language])
+            ;;
+          *:ada:no)
+            # Silently disable.
+            add_this_lang=unsupported
+            ;;
+        esac
+
+	# Disable a language that is unsupported by the target.
+	case " $unsupported_languages " in
+	  *" $language "*)
+	    add_this_lang=unsupported
+	    ;;
+	esac
+
+	case $add_this_lang in
+	  unsupported)
+            # Remove language-dependent dirs.
+	    disabled_target_libs="$disabled_target_libs $target_libs"
+	    noconfigdirs="$noconfigdirs $lang_dirs"
+	    ;;
+	  no)
+            # Remove language-dependent dirs; still show language as supported.
+	    disabled_target_libs="$disabled_target_libs $target_libs"
+	    noconfigdirs="$noconfigdirs $lang_dirs"
+            potential_languages="${potential_languages}${language},"
+	    ;;
+          yes)
+	    new_enable_languages="${new_enable_languages}${language},"
+            potential_languages="${potential_languages}${language},"
+	    missing_languages=`echo "$missing_languages" | sed "s/,$language,/,/"`
+	    enabled_target_libs="$enabled_target_libs $target_libs"
+	    case "${boot_language}:,$enable_stage1_languages," in
+	      yes:* | *:*,$language,* | *:*,yes, | *:*,all,)
+		# Add to (comma-separated) list of stage 1 languages.
+		case ",$stage1_languages," in
+		  *,$language,* | ,yes, | ,all,) ;;
+		  *) stage1_languages="${stage1_languages}${language}," ;;
+		esac
+		# We need to bootstrap any supporting libraries.
+		bootstrap_target_libs="${bootstrap_target_libs}${target_libs},"
+		;;
+	    esac
+	    ;;
+        esac
+        ;;
+    esac
+  done
+
+  # Add target libraries which are only needed for disabled languages
+  # to noconfigdirs.
+  if test -n "$disabled_target_libs"; then
+    for dir in $disabled_target_libs; do
+      case " $enabled_target_libs " in
+      *" ${dir} "*) ;;
+      *) noconfigdirs="$noconfigdirs $dir" ;;
+      esac
+    done
+  fi
+
+  AC_ARG_ENABLE(stage1-languages,
+  [AS_HELP_STRING([[--enable-stage1-languages[=all]]],
+		  [choose additional languages to build during
+		  stage1.  Mostly useful for compiler development])],
+  [case ,${enable_stage1_languages}, in
+    ,no,|,,)
+      # Set it to something that will have no effect in the loop below
+      enable_stage1_languages=c ;;
+    ,yes,)
+      enable_stage1_languages=`echo $new_enable_languages | \
+	sed -e "s/^,//" -e "s/,$//" ` ;;
+    *,all,*)
+      enable_stage1_languages=`echo ,$enable_stage1_languages, | \
+	sed -e "s/,all,/$new_enable_languages/" -e "s/^,//" -e "s/,$//" ` ;;
+  esac
+
+  # Add "good" languages from enable_stage1_languages to stage1_languages,
+  # while "bad" languages go in missing_languages.  Leave no duplicates.
+  for i in `echo $enable_stage1_languages | sed 's/,/ /g' `; do
+    case $potential_languages in
+      *,$i,*)
+        case $stage1_languages in
+          *,$i,*) ;;
+          *) stage1_languages="$stage1_languages$i," ;;
+        esac ;;
+      *)
+        case $missing_languages in
+          *,$i,*) ;;
+          *) missing_languages="$missing_languages$i," ;;
+        esac ;;
+     esac
+  done])
+
+  # Remove leading/trailing commas that were added for simplicity
+  potential_languages=`echo "$potential_languages" | sed -e "s/^,//" -e "s/,$//"`
+  missing_languages=`echo "$missing_languages" | sed -e "s/^,//" -e "s/,$//"`
+  stage1_languages=`echo "$stage1_languages" | sed -e "s/^,//" -e "s/,$//"`
+  new_enable_languages=`echo "$new_enable_languages" | sed -e "s/^,//" -e "s/,$//"`
+
+  if test "x$missing_languages" != x; then
+    AC_MSG_ERROR([
+The following requested languages could not be built: ${missing_languages}
+Supported languages are: ${potential_languages}])
+  fi
+  if test "x$new_enable_languages" != "x$enable_languages"; then
+    echo The following languages will be built: ${new_enable_languages}
+    enable_languages="$new_enable_languages"
+  fi
+
+  AC_SUBST(stage1_languages)
+  ac_configure_args=`echo " $ac_configure_args" | sed -e "s/ '--enable-languages=[[^ ]]*'//g" -e "s/$/ '--enable-languages="$enable_languages"'/" `
+fi
+
+# Handle --disable-<component> generically.
+for dir in $configdirs $build_configdirs $target_configdirs ; do
+  dirname=`echo $dir | sed -e s/target-//g -e s/build-//g -e s/-/_/g`
+  varname=`echo $dirname | sed -e s/+/_/g`
+  if eval test x\${enable_${varname}} "=" xno ; then
+    noconfigdirs="$noconfigdirs $dir"
+  fi
+done
+
+# Check for Boehm's garbage collector
+AC_ARG_ENABLE(objc-gc,
+[AS_HELP_STRING([--enable-objc-gc],
+		[enable use of Boehm's garbage collector with the
+		 GNU Objective-C runtime])],
+[case ,${enable_languages},:${enable_objc_gc}:${noconfigdirs} in
+  *,objc,*:*:yes:*target-boehm-gc*)
+    AC_MSG_ERROR([Boehm's garbage collector was requested yet not supported in this configuration])
+    ;;
+esac])
+
+# Make sure we only build Boehm's garbage collector if required.
+case ,${enable_languages},:${enable_objc_gc} in
+  *,objc,*:yes)
+    # Keep target-boehm-gc if requested for Objective-C.
+    ;;
+  *)
+    # Otherwise remove target-boehm-gc depending on target-libjava.
+    if echo " ${noconfigdirs} " | grep "target-libjava" >/dev/null 2>&1; then
+      noconfigdirs="$noconfigdirs target-boehm-gc"
+    fi
+    ;;
+esac
+
+# Disable libcilkrts, libitm, libsanitizer, libvtv, liboffloadmic if we're not building C++
+case ,${enable_languages}, in
+  *,c++,*)
+    # Disable libcilkrts, libitm, libsanitizer if we're not building libstdc++
+    case "${noconfigdirs}" in
+      *target-libstdc++-v3*)
+        noconfigdirs="$noconfigdirs target-libcilkrts target-libitm target-libsanitizer"
+        ;;
+      *) ;;
+    esac
+    ;;
+  *)
+    noconfigdirs="$noconfigdirs target-libcilkrts target-liboffloadmic target-libitm target-libsanitizer target-libvtv"
+    ;;
+esac
+
+# Remove the entries in $skipdirs and $noconfigdirs from $configdirs,
+# $build_configdirs and $target_configdirs.
+# If we have the source for $noconfigdirs entries, add them to $notsupp.
+
+notsupp=""
+for dir in . $skipdirs $noconfigdirs ; do
+  dirname=`echo $dir | sed -e s/target-//g -e s/build-//g`
+  if test $dir != .  && echo " ${configdirs} " | grep " ${dir} " >/dev/null 2>&1; then
+    configdirs=`echo " ${configdirs} " | sed -e "s/ ${dir} / /"`
+    if test -r $srcdir/$dirname/configure ; then
+      if echo " ${skipdirs} " | grep " ${dir} " >/dev/null 2>&1; then
+	true
+      else
+	notsupp="$notsupp $dir"
+      fi
+    fi
+  fi
+  if test $dir != .  && echo " ${build_configdirs} " | grep " ${dir} " >/dev/null 2>&1; then
+    build_configdirs=`echo " ${build_configdirs} " | sed -e "s/ ${dir} / /"`
+    if test -r $srcdir/$dirname/configure ; then
+      if echo " ${skipdirs} " | grep " ${dir} " >/dev/null 2>&1; then
+	true
+      else
+	notsupp="$notsupp $dir"
+      fi
+    fi
+  fi
+  if test $dir != . && echo " ${target_configdirs} " | grep " ${dir} " >/dev/null 2>&1; then
+    target_configdirs=`echo " ${target_configdirs} " | sed -e "s/ ${dir} / /"`
+    if test -r $srcdir/$dirname/configure ; then
+      if echo " ${skipdirs} " | grep " ${dir} " >/dev/null 2>&1; then
+	true
+      else
+	notsupp="$notsupp $dir"
+      fi
+    fi
+  fi
+done
+
+# Quietly strip out all directories which aren't configurable in this tree.
+# This relies on all configurable subdirectories being autoconfiscated, which
+# is now the case.
+build_configdirs_all="$build_configdirs"
+build_configdirs=
+for i in ${build_configdirs_all} ; do
+  j=`echo $i | sed -e s/build-//g` 
+  if test -f ${srcdir}/$j/configure ; then
+    build_configdirs="${build_configdirs} $i"
+  fi
+done
+
+configdirs_all="$configdirs"
+configdirs=
+for i in ${configdirs_all} ; do
+  if test -f ${srcdir}/$i/configure ; then
+    configdirs="${configdirs} $i"
+  fi
+done
+
+target_configdirs_all="$target_configdirs"
+target_configdirs=
+for i in ${target_configdirs_all} ; do
+  j=`echo $i | sed -e s/target-//g` 
+  if test -f ${srcdir}/$j/configure ; then
+    target_configdirs="${target_configdirs} $i"
+  fi
+done
+
+# Exclude target-zlib if target-libjava isn't built.
+case ${target_configdirs} in
+*target-libjava*)
+  ;;
+*)
+  target_configdirs="`echo ${target_configdirs} | sed -e 's/target-zlib//'`"
+  ;;
+esac
+
+# libiberty-linker-plugin is special: it doesn't have its own source directory,
+# so we have to add it after the preceding checks.
+if test x"$extra_linker_plugin_flags$extra_linker_plugin_configure_flags" != x
+then
+  case " $configdirs " in
+    *" libiberty "*)
+      # If we can build libiberty, we can also build libiberty-linker-plugin.
+      configdirs="$configdirs libiberty-linker-plugin"
+      extra_linker_plugin_configure_flags="$extra_linker_plugin_configure_flags \
+        --with-libiberty=../libiberty-linker-plugin";;
+    *)
+      AC_MSG_ERROR([libiberty missing]);;
+  esac
+fi
+
+# Sometimes we have special requirements for the host libiberty.
+extra_host_libiberty_configure_flags=
+extra_host_zlib_configure_flags=
+case " $configdirs " in
+  *" lto-plugin "* | *" libcc1 "*)
+    # When these are to be built as shared libraries, the same applies to
+    # libiberty.
+    extra_host_libiberty_configure_flags=--enable-shared
+    ;;
+  *" bfd "*)
+    # When bfd is to be built as a shared library, the same applies to
+    # zlib.
+    if test "$enable_shared" = "yes"; then
+      extra_host_zlib_configure_flags=--enable-host-shared
+    fi
+    ;;
+esac
+AC_SUBST(extra_host_libiberty_configure_flags)
+AC_SUBST(extra_host_zlib_configure_flags)
+
+# Produce a warning message for the subdirs we can't configure.
+# This isn't especially interesting in the Cygnus tree, but in the individual
+# FSF releases, it's important to let people know when their machine isn't
+# supported by the one or two programs in a package.
+
+if test -n "${notsupp}" && test -z "${norecursion}" ; then
+  # If $appdirs is non-empty, at least one of those directories must still
+  # be configured, or we error out.  (E.g., if the gas release supports a
+  # specified target in some subdirs but not the gas subdir, we shouldn't
+  # pretend that all is well.)
+  if test -n "$appdirs" ; then
+    for dir in $appdirs ; do
+      if test -r $dir/Makefile.in ; then
+	if echo " ${configdirs} " | grep " ${dir} " >/dev/null 2>&1; then
+	  appdirs=""
+	  break
+	fi
+	if echo " ${target_configdirs} " | grep " target-${dir} " >/dev/null 2>&1; then
+	  appdirs=""
+	  break
+	fi
+      fi
+    done
+    if test -n "$appdirs" ; then
+      echo "*** This configuration is not supported by this package." 1>&2
+      exit 1
+    fi
+  fi
+  # Okay, some application will build, or we don't care to check.  Still
+  # notify of subdirs not getting built.
+  echo "*** This configuration is not supported in the following subdirectories:" 1>&2
+  echo "    ${notsupp}" 1>&2
+  echo "    (Any other directories should still work fine.)" 1>&2
+fi
+
+case "$host" in
+  *msdosdjgpp*)
+    enable_gdbtk=no ;;
+esac
+
+# To find our prefix, in gcc_cv_tool_prefix.
+ACX_TOOL_DIRS
+
+copy_dirs=
+
+AC_ARG_WITH([build-sysroot], 
+  [AS_HELP_STRING([--with-build-sysroot=SYSROOT],
+		  [use sysroot as the system root during the build])],
+  [if test x"$withval" != x ; then
+     SYSROOT_CFLAGS_FOR_TARGET="--sysroot=$withval"
+   fi],
+  [SYSROOT_CFLAGS_FOR_TARGET=])
+AC_SUBST(SYSROOT_CFLAGS_FOR_TARGET)
+
+AC_ARG_WITH([debug-prefix-map],
+  [AS_HELP_STRING([--with-debug-prefix-map='A=B C=D ...'],
+		  [map A to B, C to D ... in debug information])],
+  [if test x"$withval" != x; then
+     DEBUG_PREFIX_CFLAGS_FOR_TARGET=
+     for debug_map in $withval; do
+       DEBUG_PREFIX_CFLAGS_FOR_TARGET="$DEBUG_PREFIX_CFLAGS_FOR_TARGET -fdebug-prefix-map=$debug_map"
+     done
+   fi],
+  [DEBUG_PREFIX_CFLAGS_FOR_TARGET=])
+AC_SUBST(DEBUG_PREFIX_CFLAGS_FOR_TARGET)
+
+# During gcc bootstrap, if we use some random cc for stage1 then CFLAGS
+# might be empty or "-g".  We don't require a C++ compiler, so CXXFLAGS
+# might also be empty (or "-g", if a non-GCC C++ compiler is in the path).
+# We want to ensure that TARGET libraries (which we know are built with
+# gcc) are built with "-O2 -g", so include those options when setting
+# CFLAGS_FOR_TARGET and CXXFLAGS_FOR_TARGET.
+if test "x$CFLAGS_FOR_TARGET" = x; then
+  if test "x${is_cross_compiler}" = xyes; then
+    CFLAGS_FOR_TARGET="-g -O2"
+  else
+    CFLAGS_FOR_TARGET=$CFLAGS
+    case " $CFLAGS " in
+      *" -O2 "*) ;;
+      *) CFLAGS_FOR_TARGET="-O2 $CFLAGS_FOR_TARGET" ;;
+    esac
+    case " $CFLAGS " in
+      *" -g "* | *" -g3 "*) ;;
+      *) CFLAGS_FOR_TARGET="-g $CFLAGS_FOR_TARGET" ;;
+    esac
+  fi
+fi
+AC_SUBST(CFLAGS_FOR_TARGET)
+
+if test "x$CXXFLAGS_FOR_TARGET" = x; then
+  if test "x${is_cross_compiler}" = xyes; then
+    CXXFLAGS_FOR_TARGET="-g -O2"
+  else
+    CXXFLAGS_FOR_TARGET=$CXXFLAGS
+    case " $CXXFLAGS " in
+      *" -O2 "*) ;;
+      *) CXXFLAGS_FOR_TARGET="-O2 $CXXFLAGS_FOR_TARGET" ;;
+    esac
+    case " $CXXFLAGS " in
+      *" -g "* | *" -g3 "*) ;;
+      *) CXXFLAGS_FOR_TARGET="-g $CXXFLAGS_FOR_TARGET" ;;
+    esac
+  fi
+fi
+AC_SUBST(CXXFLAGS_FOR_TARGET)
+
+AC_SUBST(LDFLAGS_FOR_TARGET)
+
+# Handle --with-headers=XXX.  If the value is not "yes", the contents of
+# the named directory are copied to $(tooldir)/sys-include.
+if test x"${with_headers}" != x && test x"${with_headers}" != xno ; then
+  if test x${is_cross_compiler} = xno ; then
+    echo 1>&2 '***' --with-headers is only supported when cross compiling
+    exit 1
+  fi
+  if test x"${with_headers}" != xyes ; then
+    x=${gcc_cv_tool_prefix}
+    copy_dirs="${copy_dirs} ${with_headers} $x/${target_noncanonical}/sys-include"
+  fi
+fi
+
+# Handle --with-libs=XXX.  If the value is not "yes", the contents of
+# the name directories are copied to $(tooldir)/lib.  Multiple directories
+# are permitted.
+if test x"${with_libs}" != x && test x"${with_libs}" != xno ; then
+  if test x${is_cross_compiler} = xno ; then
+    echo 1>&2 '***' --with-libs is only supported when cross compiling
+    exit 1
+  fi
+  if test x"${with_libs}" != xyes ; then
+    # Copy the libraries in reverse order, so that files in the first named
+    # library override files in subsequent libraries.
+    x=${gcc_cv_tool_prefix}
+    for l in ${with_libs}; do
+      copy_dirs="$l $x/${target_noncanonical}/lib ${copy_dirs}"
+    done
+  fi
+fi
+
+# Set with_gnu_as, with_gnu_ld, and with_system_zlib as appropriate.
+#
+# This is done by determining whether or not the appropriate directory
+# is available, and by checking whether or not specific configurations
+# have requested that this magic not happen.
+# 
+# The command line options always override the explicit settings in 
+# configure.ac, and the settings in configure.ac override this magic.
+#
+# If the default for a toolchain is to use GNU as and ld, and you don't 
+# want to do that, then you should use the --without-gnu-as and
+# --without-gnu-ld options for the configure script.  Similarly, if
+# the default is to use the included zlib and you don't want to do that,
+# you should use the --with-system-zlib option for the configure script.
+
+if test x${use_gnu_as} = x &&
+   echo " ${configdirs} " | grep " gas " > /dev/null 2>&1 ; then
+  with_gnu_as=yes
+  extra_host_args="$extra_host_args --with-gnu-as"
+fi
+
+if test x${use_gnu_ld} = x &&
+   echo " ${configdirs} " | egrep " (go)?ld " > /dev/null 2>&1 ; then
+  with_gnu_ld=yes
+  extra_host_args="$extra_host_args --with-gnu-ld"
+fi
+
+if test x${use_included_zlib} = x &&
+   echo " ${configdirs} " | grep " zlib " > /dev/null 2>&1 ; then
+  :
+else
+  with_system_zlib=yes
+  extra_host_args="$extra_host_args --with-system-zlib"
+fi
+
+# If using newlib, add --with-newlib to the extra_host_args so that gcc/configure
+# can detect this case.
+
+if test x${with_newlib} != xno && echo " ${target_configdirs} " | grep " target-newlib " > /dev/null 2>&1 ; then
+  with_newlib=yes
+  extra_host_args="$extra_host_args --with-newlib"
+fi
+
+# Handle ${copy_dirs}
+set fnord ${copy_dirs}
+shift
+while test $# != 0 ; do
+  if test -f $2/COPIED && test x"`cat $2/COPIED`" = x"$1" ; then
+    :
+  else
+    echo Copying $1 to $2
+
+    # Use the install script to create the directory and all required
+    # parent directories.
+    if test -d $2 ; then
+      :
+    else
+      echo >config.temp
+      ${srcdir}/install-sh -c -m 644 config.temp $2/COPIED
+    fi
+
+    # Copy the directory, assuming we have tar.
+    # FIXME: Should we use B in the second tar?  Not all systems support it.
+    (cd $1; tar -cf - .) | (cd $2; tar -xpf -)
+
+    # It is the responsibility of the user to correctly adjust all
+    # symlinks.  If somebody can figure out how to handle them correctly
+    # here, feel free to add the code.
+
+    echo $1 > $2/COPIED
+  fi
+  shift; shift
+done
+
+# Determine a target-dependent exec_prefix that the installed
+# gcc will search in.  Keep this list sorted by triplet, with
+# the *-*-osname triplets last.
+md_exec_prefix=
+case "${target}" in
+  i[[34567]]86-pc-msdosdjgpp*)
+    md_exec_prefix=/dev/env/DJDIR/bin
+    ;;
+  *-*-hpux* | \
+  *-*-nto-qnx* | \
+  *-*-solaris2*)
+    md_exec_prefix=/usr/ccs/bin
+    ;;
+esac
+
+extra_arflags_for_target=
+extra_nmflags_for_target=
+extra_ranlibflags_for_target=
+target_makefile_frag=/dev/null
+case "${target}" in
+  spu-*-*)
+    target_makefile_frag="config/mt-spu"
+    ;;
+  mips*-sde-elf* | mips*-mti-elf* | mips*-img-elf*)
+    target_makefile_frag="config/mt-sde"
+    ;;
+  mipsisa*-*-elfoabi*)
+    target_makefile_frag="config/mt-mips-elfoabi"
+    ;;
+  mips*-*-*linux* | mips*-*-gnu*)
+    target_makefile_frag="config/mt-mips-gnu"
+    ;;
+  nios2-*-elf*)
+    target_makefile_frag="config/mt-nios2-elf"
+    ;;
+  *-*-linux* | *-*-gnu* | *-*-k*bsd*-gnu | *-*-kopensolaris*-gnu)
+    target_makefile_frag="config/mt-gnu"
+    ;;
+  *-*-aix4.[[3456789]]* | *-*-aix[[56789]].*)
+    # nm and ar from AIX 4.3 and above require -X32_64 flag to all ar and nm 
+    # commands to handle both 32-bit and 64-bit objects.  These flags are
+    # harmless if we're using GNU nm or ar.
+    extra_arflags_for_target=" -X32_64"
+    extra_nmflags_for_target=" -B -X32_64"
+    ;;
+esac
+
+alphaieee_frag=/dev/null
+case $target in
+  alpha*-*-*)
+    # This just makes sure to use the -mieee option to build target libs.
+    # This should probably be set individually by each library.
+    alphaieee_frag="config/mt-alphaieee"
+    ;;
+esac
+
+# If --enable-target-optspace always use -Os instead of -O2 to build
+# the target libraries, similarly if it is not specified, use -Os
+# on selected platforms.
+ospace_frag=/dev/null
+case "${enable_target_optspace}:${target}" in
+  yes:*)
+    ospace_frag="config/mt-ospace"
+    ;;
+  :d30v-*)
+    ospace_frag="config/mt-d30v"
+    ;;
+  :m32r-* | :d10v-* | :fr30-* | :i?86*-*-elfiamcu)
+    ospace_frag="config/mt-ospace"
+    ;;
+  no:* | :*)
+    ;;
+  *)
+    echo "*** bad value \"${enable_target_optspace}\" for --enable-target-optspace flag; ignored" 1>&2
+    ;;
+esac
+
+# Some systems (e.g., one of the i386-aix systems the gas testers are
+# using) don't handle "\$" correctly, so don't use it here.
+tooldir='${exec_prefix}'/${target_noncanonical}
+build_tooldir=${tooldir}
+
+# Create a .gdbinit file which runs the one in srcdir
+# and tells GDB to look there for source files.
+
+if test -r ${srcdir}/.gdbinit ; then
+  case ${srcdir} in
+    .) ;;
+    *) cat > ./.gdbinit <<EOF
+# ${NO_EDIT}
+dir ${srcdir}
+dir .
+source ${srcdir}/.gdbinit
+EOF
+    ;;
+  esac
+fi
+
+# Make sure that the compiler is able to generate an executable.  If it
+# can't, we are probably in trouble.  We don't care whether we can run the
+# executable--we might be using a cross compiler--we only care whether it
+# can be created.  At this point the main configure script has set CC.
+we_are_ok=no
+echo "int main () { return 0; }" > conftest.c
+${CC} -o conftest ${CFLAGS} ${CPPFLAGS} ${LDFLAGS} conftest.c
+if test $? = 0 ; then
+  if test -s conftest || test -s conftest.exe ; then
+    we_are_ok=yes
+  fi
+fi 
+case $we_are_ok in
+  no)
+    echo 1>&2 "*** The command '${CC} -o conftest ${CFLAGS} ${CPPFLAGS} ${LDFLAGS} conftest.c' failed."
+    echo 1>&2 "*** You must set the environment variable CC to a working compiler."
+    rm -f conftest*
+    exit 1
+    ;;
+esac
+rm -f conftest*
+
+# Decide which environment variable is used to find dynamic libraries.
+case "${host}" in
+  *-*-hpux*) RPATH_ENVVAR=SHLIB_PATH ;;
+  *-*-darwin*) RPATH_ENVVAR=DYLD_LIBRARY_PATH ;;
+  *-*-mingw* | *-*-cygwin ) RPATH_ENVVAR=PATH ;;
+  *) RPATH_ENVVAR=LD_LIBRARY_PATH ;;
+esac
+
+# On systems where the dynamic library environment variable is PATH,
+# gcc/ will put dynamic libraries into a subdirectory to avoid adding
+# built executables to PATH.
+if test "$RPATH_ENVVAR" = PATH; then
+  GCC_SHLIB_SUBDIR=/shlib
+else
+  GCC_SHLIB_SUBDIR=
+fi
+
+# Adjust the toplevel makefile according to whether bootstrap was selected.
+case $enable_bootstrap in
+  yes)
+    bootstrap_suffix=bootstrap
+    BUILD_CONFIG=bootstrap-debug
+    ;;
+  no)
+    bootstrap_suffix=no-bootstrap
+    BUILD_CONFIG=
+    ;;
+esac
+
+AC_MSG_CHECKING(for default BUILD_CONFIG)
+
+AC_ARG_WITH([build-config],
+  [AS_HELP_STRING([--with-build-config='NAME NAME2...'],
+		  [use config/NAME.mk build configuration])],
+  [case $with_build_config in
+   yes) with_build_config= ;;
+   no) with_build_config= BUILD_CONFIG= ;;
+   esac])
+
+if test "x${with_build_config}" != x; then
+  BUILD_CONFIG=$with_build_config
+else
+  case $BUILD_CONFIG in
+  bootstrap-debug)
+    if echo "int f (void) { return 0; }" > conftest.c &&
+       ${CC} -c conftest.c &&
+       mv conftest.o conftest.o.g0 &&
+       ${CC} -c -g conftest.c &&
+       mv conftest.o conftest.o.g &&
+       ${srcdir}/contrib/compare-debug conftest.o.g0 conftest.o.g > /dev/null 2>&1; then
+      :
+    else
+      BUILD_CONFIG=
+    fi
+    rm -f conftest.c conftest.o conftest.o.g0 conftest.o.g
+    ;;
+  esac
+fi
+AC_MSG_RESULT($BUILD_CONFIG)
+AC_SUBST(BUILD_CONFIG)
+
+# Use same top-level configure hooks in libgcc/libstdc++/libvtv.
+AC_MSG_CHECKING([for --enable-vtable-verify])
+AC_ARG_ENABLE(vtable-verify,
+[AS_HELP_STRING([--enable-vtable-verify],
+		[Enable vtable verification feature])],
+[case "$enableval" in
+ yes) enable_vtable_verify=yes ;;
+ no)  enable_vtable_verify=no ;;
+ *)   enable_vtable_verify=no;;
+ esac],
+[enable_vtable_verify=no])
+AC_MSG_RESULT($enable_vtable_verify)
+
+# Record target_configdirs and the configure arguments for target and
+# build configuration in Makefile.
+target_configdirs=`echo "${target_configdirs}" | sed -e 's/target-//g'`
+build_configdirs=`echo "${build_configdirs}" | sed -e 's/build-//g'`
+bootstrap_fixincludes=no
+
+# If we are building libgomp, bootstrap it.
+if echo " ${target_configdirs} " | grep " libgomp " > /dev/null 2>&1 ; then
+  bootstrap_target_libs=${bootstrap_target_libs}target-libgomp,
+fi
+
+# If we are building libsanitizer and $BUILD_CONFIG contains bootstrap-asan
+# or bootstrap-ubsan, bootstrap it.
+if echo " ${target_configdirs} " | grep " libsanitizer " > /dev/null 2>&1; then
+  case "$BUILD_CONFIG" in
+    *bootstrap-asan* | *bootstrap-ubsan* )
+      bootstrap_target_libs=${bootstrap_target_libs}target-libsanitizer,
+      bootstrap_fixincludes=yes
+      ;;
+  esac
+fi
+
+# If we are building libvtv and --enable-vtable-verify, bootstrap it.
+if echo " ${target_configdirs} " | grep " libvtv " > /dev/null 2>&1 &&
+   test "$enable_vtable_verify" != no; then
+  bootstrap_target_libs=${bootstrap_target_libs}target-libvtv,
+fi
+
+# If we are building libmpx, bootstrap it.
+if echo " ${target_configdirs} " | grep " libmpx " > /dev/null 2>&1; then
+  bootstrap_target_libs=${bootstrap_target_libs}target-libmpx,
+fi
+
+# Determine whether gdb needs tk/tcl or not.
+# Use 'maybe' since enable_gdbtk might be true even if tk isn't available
+# and in that case we want gdb to be built without tk.  Ugh!
+# In fact I believe gdb is the *only* package directly dependent on tk,
+# so we should be able to put the 'maybe's in unconditionally and
+# leave out the maybe dependencies when enable_gdbtk is false.  I'm not
+# 100% sure that that's safe though.
+
+gdb_tk="maybe-all-tcl maybe-all-tk maybe-all-itcl maybe-all-libgui"
+case "$enable_gdbtk" in
+  no)
+    GDB_TK="" ;;
+  yes)
+    GDB_TK="${gdb_tk}" ;;
+  *)
+    # Only add the dependency on gdbtk when GDBtk is part of the gdb
+    # distro.  Eventually someone will fix this and move Insight, nee
+    # gdbtk to a separate directory.
+    if test -d ${srcdir}/gdb/gdbtk ; then
+      GDB_TK="${gdb_tk}"
+    else
+      GDB_TK=""
+    fi
+    ;;
+esac
+CONFIGURE_GDB_TK=`echo ${GDB_TK} | sed s/-all-/-configure-/g`
+INSTALL_GDB_TK=`echo ${GDB_TK} | sed s/-all-/-install-/g`
+
+# Strip out unwanted targets.
+
+# While at that, we remove Makefiles if we were started for recursive
+# configuration, so that the top-level Makefile reconfigures them,
+# like we used to do when configure itself was recursive.
+
+# Loop over modules.  We used to use the "$extrasub" feature from Autoconf
+# but now we're fixing up the Makefile ourselves with the additional
+# commands passed to AC_CONFIG_FILES.  Use separate variables
+# extrasub-{build,host,target} not because there is any reason to split
+# the substitutions up that way, but only to remain below the limit of
+# 99 commands in a script, for HP-UX sed.
+# Do not nest @if/@endif pairs, because configure will not warn you at all.
+
+case "$enable_bootstrap:$ENABLE_GOLD: $configdirs :,$stage1_languages," in
+  yes:yes:*\ gold\ *:*,c++,*) ;;
+  yes:yes:*\ gold\ *:*)
+    AC_MSG_ERROR([in a combined tree, bootstrapping with --enable-gold requires c++ in stage1_languages])
+    ;;
+esac
+
+extrasub_build=
+for module in ${build_configdirs} ; do
+  if test -z "${no_recursion}" \
+     && test -f ${build_subdir}/${module}/Makefile; then
+    echo 1>&2 "*** removing ${build_subdir}/${module}/Makefile to force reconfigure"
+    rm -f ${build_subdir}/${module}/Makefile
+  fi
+  extrasub_build="$extrasub_build
+/^@if build-$module\$/d
+/^@endif build-$module\$/d
+/^@if build-$module-$bootstrap_suffix\$/d
+/^@endif build-$module-$bootstrap_suffix\$/d"
+done
+extrasub_host=
+for module in ${configdirs} ; do
+  if test -z "${no_recursion}"; then
+    for file in stage*-${module}/Makefile prev-${module}/Makefile ${module}/Makefile; do
+      if test -f ${file}; then
+	echo 1>&2 "*** removing ${file} to force reconfigure"
+	rm -f ${file}
+      fi
+    done
+  fi
+  case ${module},${bootstrap_fixincludes} in
+    fixincludes,no) host_bootstrap_suffix=no-bootstrap ;;
+    *) host_bootstrap_suffix=$bootstrap_suffix ;;
+  esac
+  extrasub_host="$extrasub_host
+/^@if $module\$/d
+/^@endif $module\$/d
+/^@if $module-$host_bootstrap_suffix\$/d
+/^@endif $module-$host_bootstrap_suffix\$/d"
+done
+extrasub_target=
+for module in ${target_configdirs} ; do
+  if test -z "${no_recursion}" \
+     && test -f ${target_subdir}/${module}/Makefile; then
+    echo 1>&2 "*** removing ${target_subdir}/${module}/Makefile to force reconfigure"
+    rm -f ${target_subdir}/${module}/Makefile
+  fi
+
+  # We only bootstrap target libraries listed in bootstrap_target_libs.
+  case $bootstrap_target_libs in
+    *,target-$module,*) target_bootstrap_suffix=$bootstrap_suffix ;;
+    *) target_bootstrap_suffix=no-bootstrap ;;
+  esac
+
+  extrasub_target="$extrasub_target
+/^@if target-$module\$/d
+/^@endif target-$module\$/d
+/^@if target-$module-$target_bootstrap_suffix\$/d
+/^@endif target-$module-$target_bootstrap_suffix\$/d"
+done
+
+# Do the final fixup along with target modules.
+extrasub_target="$extrasub_target
+/^@if /,/^@endif /d"
+
+# Create the serialization dependencies.  This uses a temporary file.
+
+AC_ARG_ENABLE([serial-configure],
+[AS_HELP_STRING([[--enable-serial-[{host,target,build}-]configure]],
+		[force sequential configuration of
+		 sub-packages for the host, target or build
+		 machine, or all sub-packages])])
+
+case ${enable_serial_configure} in
+  yes)
+    enable_serial_build_configure=yes
+    enable_serial_host_configure=yes
+    enable_serial_target_configure=yes
+    ;;
+esac
+
+# These force 'configure's to be done one at a time, to avoid problems
+# with contention over a shared config.cache.
+rm -f serdep.tmp
+echo '# serdep.tmp' > serdep.tmp
+olditem=
+test "x${enable_serial_build_configure}" = xyes &&
+for item in ${build_configdirs} ; do
+  case ${olditem} in
+    "") ;;
+    *) echo "configure-build-${item}: configure-build-${olditem}" >> serdep.tmp ;;
+  esac
+  olditem=${item}
+done
+olditem=
+test "x${enable_serial_host_configure}" = xyes &&
+for item in ${configdirs} ; do
+  case ${olditem} in
+    "") ;;
+    *) echo "configure-${item}: configure-${olditem}" >> serdep.tmp ;;
+  esac
+  olditem=${item}
+done
+olditem=
+test "x${enable_serial_target_configure}" = xyes &&
+for item in ${target_configdirs} ; do
+  case ${olditem} in
+    "") ;;
+    *) echo "configure-target-${item}: configure-target-${olditem}" >> serdep.tmp ;;
+  esac
+  olditem=${item}
+done
+serialization_dependencies=serdep.tmp
+AC_SUBST_FILE(serialization_dependencies)
+
+# Base args.  Strip norecursion, cache-file, srcdir, host, build,
+# target, nonopt, and variable assignments.  These are the ones we
+# might not want to pass down to subconfigures.  The exception being
+# --cache-file=/dev/null, which is used to turn off the use of cache
+# files altogether, and which should be passed on to subconfigures.
+# Also strip program-prefix, program-suffix, and program-transform-name,
+# so that we can pass down a consistent program-transform-name.
+baseargs=
+tbaseargs=
+keep_next=no
+skip_next=no
+eval "set -- $ac_configure_args"
+for ac_arg
+do
+  if test X"$skip_next" = X"yes"; then
+    skip_next=no
+    continue
+  fi
+  if test X"$keep_next" = X"yes"; then
+    case $ac_arg in
+      *\'*)
+	ac_arg=`echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    baseargs="$baseargs '$ac_arg'"
+    tbaseargs="$tbaseargs '$ac_arg'"
+    keep_next=no
+    continue
+  fi
+
+  # Handle separated arguments.  Based on the logic generated by
+  # autoconf 2.59.
+  case $ac_arg in
+    *=* | --config-cache | -C | -disable-* | --disable-* \
+      | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
+      | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
+      | -with-* | --with-* | -without-* | --without-* | --x)
+      separate_arg=no
+      ;;
+    -*)
+      separate_arg=yes
+      ;;
+    *)
+      separate_arg=no
+      ;;
+  esac
+
+  skip_targ=no
+  case $ac_arg in
+changequote(,)
+  --with-* | --without-*)
+    libopt=`echo "$ac_arg" | sed -e 's,^--[^-_]*[-_],,' -e 's,=.*$,,'`
+
+    case $libopt in
+    *[-_]include)
+      lib=`echo "$libopt" | sed 's,[-_]include$,,'`
+      ;;
+    *[-_]lib)
+      lib=`echo "$libopt" | sed 's,[-_]lib$,,'`
+      ;;
+    *)
+      lib=$libopt
+      ;;
+    esac
+changequote([,])
+
+    case $lib in
+    mpc | mpfr | gmp | isl)
+      # If we're processing --with-$lib, --with-$lib-include or
+      # --with-$lib-lib, for one of the libs above, and target is
+      # different from host, don't pass the current argument to any
+      # target library's configure.
+      if test x$is_cross_compiler = xyes; then
+        skip_targ=yes
+      fi
+      ;;
+    esac
+    ;;
+  esac
+
+  case "$ac_arg" in
+    --cache-file=/dev/null | \
+    -cache-file=/dev/null )
+      # Handled here to avoid the test to skip args below.
+      baseargs="$baseargs '$ac_arg'"
+      tbaseargs="$tbaseargs '$ac_arg'"
+      # Assert: $separate_arg should always be no.
+      keep_next=$separate_arg
+      ;;
+    --no*)
+      continue
+      ;;
+    --c* | \
+    --sr* | \
+    --ho* | \
+    --bu* | \
+    --t* | \
+    --program-* | \
+    -cache_file* | \
+    -srcdir* | \
+    -host* | \
+    -build* | \
+    -target* | \
+    -program-prefix* | \
+    -program-suffix* | \
+    -program-transform-name* )
+      skip_next=$separate_arg
+      continue
+      ;;
+    -*)
+      # An option.  Add it.
+      case $ac_arg in
+	*\'*)
+	  ac_arg=`echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+      esac
+      baseargs="$baseargs '$ac_arg'"
+      if test X"$skip_targ" = Xno; then
+        tbaseargs="$tbaseargs '$ac_arg'"
+      fi
+      keep_next=$separate_arg
+      ;;
+    *)
+      # Either a variable assignment, or a nonopt (triplet).  Don't
+      # pass it down; let the Makefile handle this.
+      continue
+      ;;
+  esac
+done
+# Remove the initial space we just introduced and, as these will be
+# expanded by make, quote '$'.
+baseargs=`echo "x$baseargs" | sed -e 's/^x *//' -e 's,\\$,$$,g'`
+
+# Add in --program-transform-name, after --program-prefix and
+# --program-suffix have been applied to it.  Autoconf has already
+# doubled dollar signs and backslashes in program_transform_name; we want
+# the backslashes un-doubled, and then the entire thing wrapped in single
+# quotes, because this will be expanded first by make and then by the shell. 
+# Also, because we want to override the logic in subdir configure scripts to
+# choose program_transform_name, replace any s,x,x, with s,y,y,.
+sed -e "s,\\\\\\\\,\\\\,g; s,','\\\\'',g; s/s,x,x,/s,y,y,/" <<EOF_SED > conftestsed.out
+${program_transform_name}
+EOF_SED
+gcc_transform_name=`cat conftestsed.out`
+rm -f conftestsed.out
+baseargs="$baseargs --program-transform-name='${gcc_transform_name}'"
+tbaseargs="$tbaseargs --program-transform-name='${gcc_transform_name}'"
+if test "$silent" = yes; then
+  baseargs="$baseargs --silent"
+  tbaseargs="$tbaseargs --silent"
+fi
+baseargs="$baseargs --disable-option-checking"
+tbaseargs="$tbaseargs --disable-option-checking"
+
+# Record and document user additions to sub configure arguments.
+AC_ARG_VAR([build_configargs],
+	   [additional configure arguments for build directories])
+AC_ARG_VAR([host_configargs],
+	   [additional configure arguments for host directories])
+AC_ARG_VAR([target_configargs],
+	   [additional configure arguments for target directories])
+
+# For the build-side libraries, we just need to pretend we're native,
+# and not use the same cache file.  Multilibs are neither needed nor
+# desired.  We can't even use the same cache file for all build-side
+# libraries, as they're compiled differently; some with C, some with
+# C++ or with different feature-enabling options.
+build_configargs="$build_configargs --cache-file=./config.cache ${baseargs}"
+
+# For host modules, accept cache file option, or specification as blank.
+case "${cache_file}" in
+"") # empty
+  cache_file_option="" ;;
+/* | [[A-Za-z]]:[[\\/]]* ) # absolute path
+  cache_file_option="--cache-file=${cache_file}" ;;
+*) # relative path
+  cache_file_option="--cache-file=../${cache_file}" ;;
+esac
+
+# Host dirs don't like to share a cache file either, horribly enough.
+# This seems to be due to autoconf 2.5x stupidity.
+host_configargs="$host_configargs --cache-file=./config.cache ${extra_host_args} ${baseargs}"
+
+target_configargs="$target_configargs ${tbaseargs}"
+
+# Passing a --with-cross-host argument lets the target libraries know
+# whether they are being built with a cross-compiler or being built
+# native.  However, it would be better to use other mechanisms to make the
+# sorts of decisions they want to make on this basis.  Please consider
+# this option to be deprecated.  FIXME.
+if test x${is_cross_compiler} = xyes ; then
+  target_configargs="--with-cross-host=${host_noncanonical} ${target_configargs}"
+fi
+
+# Special user-friendly check for native x86_64-linux build, if
+# multilib is not explicitly enabled.
+case "$target:$have_compiler:$host:$target:$enable_multilib" in
+  x86_64-*linux*:yes:$build:$build:)
+    # Make sure we have a development environment that handles 32-bit
+    dev64=no
+    echo "int main () { return 0; }" > conftest.c
+    ${CC} -m32 -o conftest ${CFLAGS} ${CPPFLAGS} ${LDFLAGS} conftest.c
+    if test $? = 0 ; then
+      if test -s conftest || test -s conftest.exe ; then
+	dev64=yes
+      fi
+    fi 
+    rm -f conftest*
+    if test x${dev64} != xyes ; then
+      AC_MSG_ERROR([I suspect your system does not have 32-bit development libraries (libc and headers). If you have them, rerun configure with --enable-multilib. If you do not have them, and want to build a 64-bit-only compiler, rerun configure with --disable-multilib.])
+    fi
+    ;;
+esac
+
+# Default to --enable-multilib.
+if test x${enable_multilib} = x ; then
+  target_configargs="--enable-multilib ${target_configargs}"
+fi
+
+# Pass --with-newlib if appropriate.  Note that target_configdirs has
+# changed from the earlier setting of with_newlib.
+if test x${with_newlib} != xno && echo " ${target_configdirs} " | grep " newlib " > /dev/null 2>&1 && test -d ${srcdir}/newlib ; then
+  target_configargs="--with-newlib ${target_configargs}"
+fi
+
+# Different target subdirs use different values of certain variables
+# (notably CXX).  Worse, multilibs use *lots* of different values.
+# Worse yet, autoconf 2.5x makes some of these 'precious', meaning that
+# it doesn't automatically accept command-line overrides of them.
+# This means it's not safe for target subdirs to share a cache file,
+# which is disgusting, but there you have it.  Hopefully this can be
+# fixed in future.  It's still worthwhile to use a cache file for each
+# directory.  I think.
+
+# Pass the appropriate --build, --host, --target and --cache-file arguments.
+# We need to pass --target, as newer autoconf's requires consistency
+# for target_alias and gcc doesn't manage it consistently.
+target_configargs="--cache-file=./config.cache ${target_configargs}"
+
+FLAGS_FOR_TARGET=
+case " $target_configdirs " in
+ *" newlib "*)
+  case " $target_configargs " in
+  *" --with-newlib "*)
+   case "$target" in
+    *-cygwin*)
+      FLAGS_FOR_TARGET=$FLAGS_FOR_TARGET' -L$$r/$(TARGET_SUBDIR)/winsup/cygwin -isystem $$s/winsup/cygwin/include'
+      ;;
+   esac
+
+   # If we're not building GCC, don't discard standard headers.
+   if test -d ${srcdir}/gcc; then
+     FLAGS_FOR_TARGET=$FLAGS_FOR_TARGET' -nostdinc'
+
+     if test "${build}" != "${host}"; then
+       # On Canadian crosses, CC_FOR_TARGET will have already been set
+       # by `configure', so we won't have an opportunity to add -Bgcc/
+       # to it.  This is right: we don't want to search that directory
+       # for binaries, but we want the header files in there, so add
+       # them explicitly.
+       FLAGS_FOR_TARGET=$FLAGS_FOR_TARGET' -isystem $$r/$(HOST_SUBDIR)/gcc/include -isystem $$r/$(HOST_SUBDIR)/gcc/include-fixed'
+
+       # Someone might think of using the pre-installed headers on
+       # Canadian crosses, in case the installed compiler is not fully
+       # compatible with the compiler being built.  In this case, it
+       # would be better to flag an error than risking having
+       # incompatible object files being constructed.  We can't
+       # guarantee that an error will be flagged, but let's hope the
+       # compiler will do it, when presented with incompatible header
+       # files.
+     fi
+   fi
+
+   case "${target}-${is_cross_compiler}" in
+   i[[3456789]]86-*-linux*-no)
+      # Here host == target, so we don't need to build gcc,
+      # so we don't want to discard standard headers.
+      FLAGS_FOR_TARGET=`echo " $FLAGS_FOR_TARGET " | sed -e 's/ -nostdinc / /'`
+      ;;
+   *)
+      # If we're building newlib, use its generic headers last, but search
+      # for any libc-related directories first (so make it the last -B
+      # switch).
+      FLAGS_FOR_TARGET=$FLAGS_FOR_TARGET' -B$$r/$(TARGET_SUBDIR)/newlib/ -isystem $$r/$(TARGET_SUBDIR)/newlib/targ-include -isystem $$s/newlib/libc/include'
+
+      # If we're building libgloss, find the startup file, simulator library
+      # and linker script.
+      case " $target_configdirs " in
+	*" libgloss "*)
+	# Look for startup file, simulator library and maybe linker script.
+	FLAGS_FOR_TARGET=$FLAGS_FOR_TARGET' -B$$r/$(TARGET_SUBDIR)/libgloss/'"$libgloss_dir"
+	# Look for libnosys.a in case the target needs it.
+	FLAGS_FOR_TARGET=$FLAGS_FOR_TARGET' -L$$r/$(TARGET_SUBDIR)/libgloss/libnosys'
+	# Most targets have the linker script in the source directory.
+	FLAGS_FOR_TARGET=$FLAGS_FOR_TARGET' -L$$s/libgloss/'"$libgloss_dir"
+	;;
+      esac
+      ;;
+   esac
+   ;;
+  esac
+  ;;
+esac
+
+case "$target" in
+  x86_64-*mingw* | *-w64-mingw*)
+  # MinGW-w64 does not use newlib, nor does it use winsup. It may,
+  # however, use a symlink named 'mingw' in ${prefix} .
+    FLAGS_FOR_TARGET=$FLAGS_FOR_TARGET' -L${prefix}/${target}/lib -L${prefix}/mingw/lib -isystem ${prefix}/${target}/include -isystem ${prefix}/mingw/include'
+    ;;
+  *-mingw*)
+  # MinGW can't be handled as Cygwin above since it does not use newlib.
+    FLAGS_FOR_TARGET=$FLAGS_FOR_TARGET' -L$$r/$(TARGET_SUBDIR)/winsup/mingw -L$$r/$(TARGET_SUBDIR)/winsup/w32api/lib -isystem $$s/winsup/mingw/include -isystem $$s/winsup/w32api/include'
+    ;;
+esac
+
+# Allow the user to override the flags for
+# our build compiler if desired.
+if test x"${build}" = x"${host}" ; then
+  CFLAGS_FOR_BUILD=${CFLAGS_FOR_BUILD-${CFLAGS}}
+  CXXFLAGS_FOR_BUILD=${CXXFLAGS_FOR_BUILD-${CXXFLAGS}}
+  LDFLAGS_FOR_BUILD=${LDFLAGS_FOR_BUILD-${LDFLAGS}}
+fi
+
+# On Canadian crosses, we'll be searching the right directories for
+# the previously-installed cross compiler, so don't bother to add
+# flags for directories within the install tree of the compiler
+# being built; programs in there won't even run.
+if test "${build}" = "${host}" && test -d ${srcdir}/gcc; then
+  # Search for pre-installed headers if nothing else fits.
+  FLAGS_FOR_TARGET=$FLAGS_FOR_TARGET' -B$(build_tooldir)/bin/ -B$(build_tooldir)/lib/ -isystem $(build_tooldir)/include -isystem $(build_tooldir)/sys-include'
+fi
+
+if test "x${use_gnu_ld}" = x &&
+   echo " ${configdirs} " | grep " ld " > /dev/null ; then
+  # Arrange for us to find uninstalled linker scripts.
+  FLAGS_FOR_TARGET=$FLAGS_FOR_TARGET' -L$$r/$(HOST_SUBDIR)/ld'
+fi
+
+# Search for other target-specific linker scripts and such.
+case "${target}" in
+  mep*)
+    FLAGS_FOR_TARGET="$FLAGS_FOR_TARGET -mlibrary"
+    ;;
+esac
+
+# Makefile fragments.
+for frag in host_makefile_frag target_makefile_frag alphaieee_frag ospace_frag;
+do
+  eval fragval=\$$frag
+  if test $fragval != /dev/null; then
+    eval $frag=${srcdir}/$fragval
+  fi
+done
+AC_SUBST_FILE(host_makefile_frag)
+AC_SUBST_FILE(target_makefile_frag)
+AC_SUBST_FILE(alphaieee_frag)
+AC_SUBST_FILE(ospace_frag)
+
+# Miscellanea: directories, flags, etc.
+AC_SUBST(RPATH_ENVVAR)
+AC_SUBST(GCC_SHLIB_SUBDIR)
+AC_SUBST(tooldir)
+AC_SUBST(build_tooldir)
+AC_SUBST(CONFIGURE_GDB_TK)
+AC_SUBST(GDB_TK)
+AC_SUBST(INSTALL_GDB_TK)
+
+# Build module lists & subconfigure args.
+AC_SUBST(build_configargs)
+AC_SUBST(build_configdirs)
+
+# Host module lists & subconfigure args.
+AC_SUBST(host_configargs)
+AC_SUBST(configdirs)
+AC_SUBST(target_configdirs)
+
+# Target module lists & subconfigure args.
+AC_SUBST(target_configargs)
+
+
+# Build tools.
+AC_SUBST(AR_FOR_BUILD)
+AC_SUBST(AS_FOR_BUILD)
+AC_SUBST(CC_FOR_BUILD)
+AC_SUBST(CFLAGS_FOR_BUILD)
+AC_SUBST(CXXFLAGS_FOR_BUILD)
+AC_SUBST(CXX_FOR_BUILD)
+AC_SUBST(DLLTOOL_FOR_BUILD)
+AC_SUBST(GCJ_FOR_BUILD)
+AC_SUBST(GFORTRAN_FOR_BUILD)
+AC_SUBST(GOC_FOR_BUILD)
+AC_SUBST(LDFLAGS_FOR_BUILD)
+AC_SUBST(LD_FOR_BUILD)
+AC_SUBST(NM_FOR_BUILD)
+AC_SUBST(RANLIB_FOR_BUILD)
+AC_SUBST(WINDMC_FOR_BUILD)
+AC_SUBST(WINDRES_FOR_BUILD)
+
+# Generate default definitions for YACC, M4, LEX and other programs that run
+# on the build machine.  These are used if the Makefile can't locate these
+# programs in objdir.
+MISSING=`cd $ac_aux_dir && ${PWDCMD-pwd}`/missing
+
+AC_CHECK_PROGS([YACC], ['bison -y' byacc yacc], [$MISSING bison -y])
+case " $build_configdirs " in
+  *" bison "*) YACC='$$r/$(BUILD_SUBDIR)/bison/tests/bison -y' ;;
+esac
+
+AC_CHECK_PROGS([BISON], [bison], [$MISSING bison])
+case " $build_configdirs " in
+  *" bison "*) BISON='$$r/$(BUILD_SUBDIR)/bison/tests/bison' ;;
+esac
+
+AC_CHECK_PROGS([M4], [gm4 gnum4 m4], [$MISSING m4])
+case " $build_configdirs " in
+  *" m4 "*) M4='$$r/$(BUILD_SUBDIR)/m4/m4' ;;
+esac
+
+AC_CHECK_PROGS([LEX], [flex lex], [$MISSING flex])
+case " $build_configdirs " in
+  *" flex "*) LEX='$$r/$(BUILD_SUBDIR)/flex/flex' ;;
+  *" lex "*) LEX='$$r/$(BUILD_SUBDIR)/lex/lex' ;;
+esac
+
+AC_CHECK_PROGS([FLEX], [flex], [$MISSING flex])
+case " $build_configdirs " in
+  *" flex "*) FLEX='$$r/$(BUILD_SUBDIR)/flex/flex' ;;
+esac
+
+AC_CHECK_PROGS([MAKEINFO], makeinfo, [$MISSING makeinfo])
+case " $build_configdirs " in
+  *" texinfo "*) MAKEINFO='$$r/$(BUILD_SUBDIR)/texinfo/makeinfo/makeinfo' ;;
+  *)
+changequote(,)
+    # For an installed makeinfo, we require it to be from texinfo 4.7 or
+    # higher, else we use the "missing" dummy.
+    if ${MAKEINFO} --version \
+       | egrep 'texinfo[^0-9]*(4\.([7-9]|[1-9][0-9])|[5-9]|[1-9][0-9])' >/dev/null 2>&1; then
+      :
+    else
+      MAKEINFO="$MISSING makeinfo"
+    fi
+    ;;
+changequote([,])
+esac
+
+# FIXME: expect and dejagnu may become build tools?
+
+AC_CHECK_PROGS(EXPECT, expect, expect)
+case " $configdirs " in
+  *" expect "*)
+    test $host = $build && EXPECT='$$r/$(HOST_SUBDIR)/expect/expect'
+    ;;
+esac
+
+AC_CHECK_PROGS(RUNTEST, runtest, runtest)
+case " $configdirs " in
+  *" dejagnu "*)
+    test $host = $build && RUNTEST='$$s/$(HOST_SUBDIR)/dejagnu/runtest'
+    ;;
+esac
+
+
+# Host tools.
+NCN_STRICT_CHECK_TOOLS(AR, ar)
+NCN_STRICT_CHECK_TOOLS(AS, as)
+NCN_STRICT_CHECK_TOOLS(DLLTOOL, dlltool)
+NCN_STRICT_CHECK_TOOLS(LD, ld)
+NCN_STRICT_CHECK_TOOLS(LIPO, lipo)
+NCN_STRICT_CHECK_TOOLS(NM, nm)
+NCN_STRICT_CHECK_TOOLS(RANLIB, ranlib, true)
+NCN_STRICT_CHECK_TOOLS(STRIP, strip, true)
+NCN_STRICT_CHECK_TOOLS(WINDRES, windres)
+NCN_STRICT_CHECK_TOOLS(WINDMC, windmc)
+NCN_STRICT_CHECK_TOOLS(OBJCOPY, objcopy)
+NCN_STRICT_CHECK_TOOLS(OBJDUMP, objdump)
+NCN_STRICT_CHECK_TOOLS(READELF, readelf)
+AC_SUBST(CC)
+AC_SUBST(CXX)
+AC_SUBST(CFLAGS)
+AC_SUBST(CXXFLAGS)
+
+# Target tools.
+AC_ARG_WITH([build-time-tools], 
+  [AS_HELP_STRING([--with-build-time-tools=PATH],
+		  [use given path to find target tools during the build])],
+  [case x"$withval" in
+     x/*) ;;
+     *)
+       with_build_time_tools=
+       AC_MSG_WARN([argument to --with-build-time-tools must be an absolute path])
+       ;;
+   esac],
+  [with_build_time_tools=])
+
+NCN_STRICT_CHECK_TARGET_TOOLS(CC_FOR_TARGET, cc gcc)
+NCN_STRICT_CHECK_TARGET_TOOLS(CXX_FOR_TARGET, c++ g++ cxx gxx)
+NCN_STRICT_CHECK_TARGET_TOOLS(GCC_FOR_TARGET, gcc, ${CC_FOR_TARGET})
+NCN_STRICT_CHECK_TARGET_TOOLS(GCJ_FOR_TARGET, gcj)
+NCN_STRICT_CHECK_TARGET_TOOLS(GFORTRAN_FOR_TARGET, gfortran)
+NCN_STRICT_CHECK_TARGET_TOOLS(GOC_FOR_TARGET, gccgo)
+
+ACX_CHECK_INSTALLED_TARGET_TOOL(AR_FOR_TARGET, ar)
+ACX_CHECK_INSTALLED_TARGET_TOOL(AS_FOR_TARGET, as)
+ACX_CHECK_INSTALLED_TARGET_TOOL(DLLTOOL_FOR_TARGET, dlltool)
+ACX_CHECK_INSTALLED_TARGET_TOOL(LD_FOR_TARGET, ld)
+ACX_CHECK_INSTALLED_TARGET_TOOL(LIPO_FOR_TARGET, lipo)
+ACX_CHECK_INSTALLED_TARGET_TOOL(NM_FOR_TARGET, nm)
+ACX_CHECK_INSTALLED_TARGET_TOOL(OBJCOPY_FOR_TARGET, objcopy)
+ACX_CHECK_INSTALLED_TARGET_TOOL(OBJDUMP_FOR_TARGET, objdump)
+ACX_CHECK_INSTALLED_TARGET_TOOL(RANLIB_FOR_TARGET, ranlib)
+ACX_CHECK_INSTALLED_TARGET_TOOL(READELF_FOR_TARGET, readelf)
+ACX_CHECK_INSTALLED_TARGET_TOOL(STRIP_FOR_TARGET, strip)
+ACX_CHECK_INSTALLED_TARGET_TOOL(WINDRES_FOR_TARGET, windres)
+ACX_CHECK_INSTALLED_TARGET_TOOL(WINDMC_FOR_TARGET, windmc)
+
+RAW_CXX_FOR_TARGET="$CXX_FOR_TARGET"
+
+GCC_TARGET_TOOL(ar, AR_FOR_TARGET, AR, [binutils/ar])
+GCC_TARGET_TOOL(as, AS_FOR_TARGET, AS, [gas/as-new])
+GCC_TARGET_TOOL(cc, CC_FOR_TARGET, CC, [gcc/xgcc -B$$r/$(HOST_SUBDIR)/gcc/])
+dnl see comments for CXX_FOR_TARGET_FLAG_TO_PASS
+GCC_TARGET_TOOL(c++, CXX_FOR_TARGET, CXX,
+		[gcc/xg++ -B$$r/$(HOST_SUBDIR)/gcc/ -nostdinc++ `if test -f $$r/$(TARGET_SUBDIR)/libstdc++-v3/scripts/testsuite_flags; then $(SHELL) $$r/$(TARGET_SUBDIR)/libstdc++-v3/scripts/testsuite_flags --build-includes; else echo -funconfigured-libstdc++-v3 ; fi` -L$$r/$(TARGET_SUBDIR)/libstdc++-v3/src -L$$r/$(TARGET_SUBDIR)/libstdc++-v3/src/.libs -L$$r/$(TARGET_SUBDIR)/libstdc++-v3/libsupc++/.libs],
+		c++)
+GCC_TARGET_TOOL(c++ for libstdc++, RAW_CXX_FOR_TARGET, CXX,
+		[gcc/xgcc -shared-libgcc -B$$r/$(HOST_SUBDIR)/gcc -nostdinc++ -L$$r/$(TARGET_SUBDIR)/libstdc++-v3/src -L$$r/$(TARGET_SUBDIR)/libstdc++-v3/src/.libs -L$$r/$(TARGET_SUBDIR)/libstdc++-v3/libsupc++/.libs],
+		c++)
+GCC_TARGET_TOOL(dlltool, DLLTOOL_FOR_TARGET, DLLTOOL, [binutils/dlltool])
+GCC_TARGET_TOOL(gcc, GCC_FOR_TARGET, , [gcc/xgcc -B$$r/$(HOST_SUBDIR)/gcc/])
+GCC_TARGET_TOOL(gcj, GCJ_FOR_TARGET, GCJ,
+		[gcc/gcj -B$$r/$(HOST_SUBDIR)/gcc/], java)
+GCC_TARGET_TOOL(gfortran, GFORTRAN_FOR_TARGET, GFORTRAN,
+		[gcc/gfortran -B$$r/$(HOST_SUBDIR)/gcc/], fortran)
+GCC_TARGET_TOOL(gccgo, GOC_FOR_TARGET, GOC,
+		[gcc/gccgo -B$$r/$(HOST_SUBDIR)/gcc/], go)
+GCC_TARGET_TOOL(ld, LD_FOR_TARGET, LD, [ld/ld-new])
+GCC_TARGET_TOOL(lipo, LIPO_FOR_TARGET, LIPO)
+GCC_TARGET_TOOL(nm, NM_FOR_TARGET, NM, [binutils/nm-new])
+GCC_TARGET_TOOL(objcopy, OBJCOPY_FOR_TARGET, OBJCOPY, [binutils/objcopy])
+GCC_TARGET_TOOL(objdump, OBJDUMP_FOR_TARGET, OBJDUMP, [binutils/objdump])
+GCC_TARGET_TOOL(ranlib, RANLIB_FOR_TARGET, RANLIB, [binutils/ranlib])
+GCC_TARGET_TOOL(readelf, READELF_FOR_TARGET, READELF, [binutils/readelf])
+GCC_TARGET_TOOL(strip, STRIP_FOR_TARGET, STRIP, [binutils/strip-new])
+GCC_TARGET_TOOL(windres, WINDRES_FOR_TARGET, WINDRES, [binutils/windres])
+GCC_TARGET_TOOL(windmc, WINDMC_FOR_TARGET, WINDMC, [binutils/windmc])
+
+AC_SUBST(FLAGS_FOR_TARGET)
+AC_SUBST(RAW_CXX_FOR_TARGET)
+
+# Certain tools may need extra flags.
+AR_FOR_TARGET=${AR_FOR_TARGET}${extra_arflags_for_target}
+RANLIB_FOR_TARGET=${RANLIB_FOR_TARGET}${extra_ranlibflags_for_target}
+NM_FOR_TARGET=${NM_FOR_TARGET}${extra_nmflags_for_target}
+
+# When building target libraries, except in a Canadian cross, we use
+# the same toolchain as the compiler we just built.
+COMPILER_AS_FOR_TARGET='$(AS_FOR_TARGET)'
+COMPILER_LD_FOR_TARGET='$(LD_FOR_TARGET)'
+COMPILER_NM_FOR_TARGET='$(NM_FOR_TARGET)'
+if test $host = $build; then
+  case " $configdirs " in
+    *" gcc "*)
+      COMPILER_AS_FOR_TARGET='$$r/$(HOST_SUBDIR)/gcc/as'
+      COMPILER_LD_FOR_TARGET='$$r/$(HOST_SUBDIR)/gcc/collect-ld'
+      COMPILER_NM_FOR_TARGET='$$r/$(HOST_SUBDIR)/gcc/nm'${extra_nmflags_for_target}
+      ;;
+  esac
+fi
+
+AC_SUBST(COMPILER_AS_FOR_TARGET)
+AC_SUBST(COMPILER_LD_FOR_TARGET)
+AC_SUBST(COMPILER_NM_FOR_TARGET)
+
+AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])
+AC_ARG_ENABLE(maintainer-mode,
+[AS_HELP_STRING([--enable-maintainer-mode],
+		[enable make rules and dependencies not useful
+		 (and sometimes confusing) to the casual installer])],
+      USE_MAINTAINER_MODE=$enableval,
+      USE_MAINTAINER_MODE=no)
+AC_MSG_RESULT($USE_MAINTAINER_MODE)
+AC_SUBST(MAINTAINER_MODE_TRUE)
+AC_SUBST(MAINTAINER_MODE_FALSE)
+if test "$USE_MAINTAINER_MODE" = yes; then
+  MAINTAINER_MODE_TRUE=
+  MAINTAINER_MODE_FALSE='#'
+else
+  MAINTAINER_MODE_TRUE='#'
+  MAINTAINER_MODE_FALSE=
+fi	
+MAINT=$MAINTAINER_MODE_TRUE
+AC_SUBST(MAINT)dnl
+
+# ---------------------
+# GCC bootstrap support
+# ---------------------
+
+# Stage specific cflags for build.
+stage1_cflags="-g"
+case $build in
+  vax-*-*)
+    case ${GCC} in
+      yes) stage1_cflags="-g -Wa,-J" ;;
+      *) stage1_cflags="-g -J" ;;
+    esac ;;
+esac
+
+AC_SUBST(stage1_cflags)
+
+# Enable --enable-checking in stage1 of the compiler.
+AC_ARG_ENABLE(stage1-checking,
+[AS_HELP_STRING([[--enable-stage1-checking[=all]]],
+		[choose additional checking for stage1 of the compiler])],
+[stage1_checking=--enable-checking=${enable_stage1_checking}],
+[if test "x$enable_checking" = xno || test "x$enable_checking" = x; then
+  # For --disable-checking or implicit --enable-checking=release, avoid
+  # setting --enable-checking=gc in the default stage1 checking for LTO
+  # bootstraps.  See PR62077.
+  stage1_checking=--enable-checking=release,misc,gimple,rtlflag,tree,types
+  case $BUILD_CONFIG in
+    *lto*)
+      if test "x$enable_checking" = x && \
+	 test -d ${srcdir}/gcc && \
+	 test x"`cat ${srcdir}/gcc/DEV-PHASE`" = xexperimental; then
+	stage1_checking=--enable-checking=yes,types
+      fi;;
+    *) stage1_checking=--enable-checking=yes,types;;
+  esac
+else
+  stage1_checking=--enable-checking=$enable_checking,types
+fi])
+AC_SUBST(stage1_checking)
+
+# Enable -Werror in bootstrap stage2 and later.
+AC_ARG_ENABLE(werror,
+[AS_HELP_STRING([--enable-werror],
+		[enable -Werror in bootstrap stage2 and later])], [],
+[if test -d ${srcdir}/gcc && test x"`cat $srcdir/gcc/DEV-PHASE`" = xexperimental; then
+  enable_werror=yes
+else
+  enable_werror=no
+fi])
+case ${enable_werror} in
+  yes) stage2_werror_flag="--enable-werror-always" ;;
+  *) stage2_werror_flag="" ;;
+esac
+AC_SUBST(stage2_werror_flag)
+
+# Enable --enable-host-shared.
+AC_ARG_ENABLE(host-shared,
+[AS_HELP_STRING([--enable-host-shared],
+		[build host code as shared libraries])],
+[host_shared=$enableval], [host_shared=no])
+AC_SUBST(host_shared)
+
+# PR jit/64780: Require the user to explicitly specify
+# --enable-host-shared if the jit is enabled, hinting
+# that they might want to do a separate configure/build of
+# the jit, to avoid users from slowing down the rest of the
+# compiler by enabling the jit.
+if test ${host_shared} = "no" ; then
+  case "${enable_languages}" in
+    *jit*)
+      AC_MSG_ERROR([
+Enabling language "jit" requires --enable-host-shared.
+
+--enable-host-shared typically slows the rest of the compiler down by
+a few %, so you must explicitly enable it.
+
+If you want to build both the jit and the regular compiler, it is often
+best to do this via two separate configure/builds, in separate
+directories, to avoid imposing the performance cost of
+--enable-host-shared on the regular compiler.])
+      ;;
+    *)
+      ;;
+  esac
+fi
+
+# Specify what files to not compare during bootstrap.
+
+compare_exclusions="gcc/cc*-checksum\$(objext) | gcc/ada/*tools/*"
+case "$target" in
+  hppa*64*-*-hpux*) ;;
+  hppa*-*-hpux*) compare_exclusions="gcc/cc*-checksum\$(objext) | */libgcc/lib2funcs* | gcc/ada/*tools/*" ;;
+  powerpc*-ibm-aix*) compare_exclusions="gcc/cc*-checksum\$(objext) | gcc/ada/*tools/* | *libgomp*\$(objext)" ;;
+esac
+AC_SUBST(compare_exclusions)
+
+AC_CONFIG_FILES([Makefile],
+  [sed "$extrasub_build" Makefile |
+   sed "$extrasub_host" |
+   sed "$extrasub_target" > mf$$
+   mv -f mf$$ Makefile],
+  [extrasub_build="$extrasub_build"
+   extrasub_host="$extrasub_host"
+   extrasub_target="$extrasub_target"])
+AC_OUTPUT
diff -Naur binutils-2.26/gas/config/tc-arm.c binutils-2.26.0007/gas/config/tc-arm.c
--- binutils-2.26/gas/config/tc-arm.c	2016-01-25 09:51:06.000000000 +0100
+++ binutils-2.26.0007/gas/config/tc-arm.c	2016-03-10 17:02:24.287384333 +0100
@@ -138,7 +138,11 @@
 static int warn_on_deprecated = TRUE;
 
 /* Understand CodeComposer Studio assembly syntax.  */
+#ifdef TE_WINNT
+bfd_boolean codecomposer_syntax = TRUE;
+#else
 bfd_boolean codecomposer_syntax = FALSE;
+#endif
 
 /* Variables that we set while parsing command-line options.  Once all
    options have been read we re-process these values to set the real
@@ -886,7 +890,11 @@
 
 /* This array holds the chars that always start a comment.  If the
    pre-processor is disabled, these aren't very useful.	 */
+#ifdef TE_WINNT
+char arm_comment_chars[] = "@;";
+#else
 char arm_comment_chars[] = "@";
+#endif
 
 /* This array holds the chars that only start a comment at the beginning of
    a line.  If the line seems to have the form '# 123 filename'
@@ -897,7 +905,11 @@
 /* Also note that comments like this one will always work.  */
 const char line_comment_chars[] = "#";
 
+#ifdef TE_WINNT
+char arm_line_separator_chars[] = "\0\0";
+#else
 char arm_line_separator_chars[] = ";";
+#endif
 
 /* Chars that can be used to separate mant
    from exp in floating point numbers.	*/
@@ -3439,17 +3451,21 @@
   pool->symbol = NULL;
 }
 
-#ifdef OBJ_ELF
+#if defined(OBJ_ELF) || defined(TE_WINNT)
 /* Forward declarations for functions below, in the MD interface
    section.  */
 static void fix_new_arm (fragS *, int, short, expressionS *, int, int);
+#endif
+#ifdef OBJ_ELF
 static valueT create_unwind_entry (int);
 static void start_unwind_section (const segT, int);
 static void add_unwind_opcode (valueT, int);
 static void flush_pending_unwind (void);
+#endif
 
 /* Directives: Data.  */
 
+#if defined(OBJ_ELF) || defined(TE_WINNT)
 static void
 s_arm_elf_cons (int nbytes)
 {
@@ -3702,7 +3718,9 @@
 
   demand_empty_rest_of_line ();
 }
+#endif
 
+#ifdef OBJ_ELF
 /* Directives: AEABI stack-unwind tables.  */
 
 /* Parse an unwind_fnstart directive.  Simply records the current location.  */
@@ -4659,13 +4677,17 @@
   { "object_arch", s_arm_object_arch,	0 },
   { "fpu",	   s_arm_fpu,	  0 },
   { "arch_extension", s_arm_arch_extension, 0 },
-#ifdef OBJ_ELF
+#if defined(OBJ_ELF) || defined(TE_WINNT)
   { "word",	        s_arm_elf_cons, 4 },
   { "long",	        s_arm_elf_cons, 4 },
   { "inst.n",           s_arm_elf_inst, 2 },
   { "inst.w",           s_arm_elf_inst, 4 },
   { "inst",             s_arm_elf_inst, 0 },
   { "rel31",	        s_arm_rel31,	  0 },
+#else
+  { "word",    cons, 4},
+#endif
+#ifdef OBJ_ELF
   { "fnstart",		s_arm_unwind_fnstart,	0 },
   { "fnend",		s_arm_unwind_fnend,	0 },
   { "cantunwind",	s_arm_unwind_cantunwind, 0 },
@@ -4681,8 +4703,6 @@
   { "eabi_attribute",	s_arm_eabi_attribute,	0 },
   { "tlsdescseq",	s_arm_tls_descseq,      0 },
 #else
-  { "word",	   cons, 4},
-
   /* These are used for dwarf.  */
   {"2byte", cons, 2},
   {"4byte", cons, 4},
@@ -21747,7 +21767,7 @@
     case BFD_RELOC_ARM_PCREL_BRANCH:
     case BFD_RELOC_ARM_PCREL_JUMP:
     case BFD_RELOC_ARM_PLT32:
-#ifdef TE_WINCE
+#if defined(TE_WINCE) || defined(TE_WINNT)
       /* When handling fixups immediately, because we have already
 	 discovered the value of a symbol, or the address of the frag involved
 	 we must account for the offset by +8, as the OS loader will never see the reloc.
@@ -22926,7 +22946,7 @@
     case BFD_RELOC_32_SECREL:
 #endif
       if (fixP->fx_done || !seg->use_rela_p)
-#ifdef TE_WINCE
+#if defined(TE_WINCE) || defined (TE_WINNT)
 	/* For WinCE we only do this for pcrel fixups.  */
 	if (fixP->fx_done || fixP->fx_pcrel)
 #endif
diff -Naur binutils-2.26/gas/config/tc-arm.c.orig binutils-2.26.0007/gas/config/tc-arm.c.orig
--- binutils-2.26/gas/config/tc-arm.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.26.0007/gas/config/tc-arm.c.orig	2016-03-10 17:01:15.805554131 +0100
@@ -0,0 +1,25983 @@
+/* tc-arm.c -- Assemble for the ARM
+   Copyright (C) 1994-2015 Free Software Foundation, Inc.
+   Contributed by Richard Earnshaw (rwe@pegasus.esprit.ec.org)
+	Modified by David Taylor (dtaylor@armltd.co.uk)
+	Cirrus coprocessor mods by Aldy Hernandez (aldyh@redhat.com)
+	Cirrus coprocessor fixes by Petko Manolov (petkan@nucleusys.com)
+	Cirrus coprocessor fixes by Vladimir Ivanov (vladitx@nucleusys.com)
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#include "as.h"
+#include <limits.h>
+#include <stdarg.h>
+#define	 NO_RELOC 0
+#include "safe-ctype.h"
+#include "subsegs.h"
+#include "obstack.h"
+#include "libiberty.h"
+#include "opcode/arm.h"
+
+#ifdef OBJ_ELF
+#include "elf/arm.h"
+#include "dw2gencfi.h"
+#endif
+
+#include "dwarf2dbg.h"
+
+#ifdef OBJ_ELF
+/* Must be at least the size of the largest unwind opcode (currently two).  */
+#define ARM_OPCODE_CHUNK_SIZE 8
+
+/* This structure holds the unwinding state.  */
+
+static struct
+{
+  symbolS *	  proc_start;
+  symbolS *	  table_entry;
+  symbolS *	  personality_routine;
+  int		  personality_index;
+  /* The segment containing the function.  */
+  segT		  saved_seg;
+  subsegT	  saved_subseg;
+  /* Opcodes generated from this function.  */
+  unsigned char * opcodes;
+  int		  opcode_count;
+  int		  opcode_alloc;
+  /* The number of bytes pushed to the stack.  */
+  offsetT	  frame_size;
+  /* We don't add stack adjustment opcodes immediately so that we can merge
+     multiple adjustments.  We can also omit the final adjustment
+     when using a frame pointer.  */
+  offsetT	  pending_offset;
+  /* These two fields are set by both unwind_movsp and unwind_setfp.  They
+     hold the reg+offset to use when restoring sp from a frame pointer.	 */
+  offsetT	  fp_offset;
+  int		  fp_reg;
+  /* Nonzero if an unwind_setfp directive has been seen.  */
+  unsigned	  fp_used:1;
+  /* Nonzero if the last opcode restores sp from fp_reg.  */
+  unsigned	  sp_restored:1;
+} unwind;
+
+#endif /* OBJ_ELF */
+
+/* Results from operand parsing worker functions.  */
+
+typedef enum
+{
+  PARSE_OPERAND_SUCCESS,
+  PARSE_OPERAND_FAIL,
+  PARSE_OPERAND_FAIL_NO_BACKTRACK
+} parse_operand_result;
+
+enum arm_float_abi
+{
+  ARM_FLOAT_ABI_HARD,
+  ARM_FLOAT_ABI_SOFTFP,
+  ARM_FLOAT_ABI_SOFT
+};
+
+/* Types of processor to assemble for.	*/
+#ifndef CPU_DEFAULT
+/* The code that was here used to select a default CPU depending on compiler
+   pre-defines which were only present when doing native builds, thus
+   changing gas' default behaviour depending upon the build host.
+
+   If you have a target that requires a default CPU option then the you
+   should define CPU_DEFAULT here.  */
+#endif
+
+#ifndef FPU_DEFAULT
+# ifdef TE_LINUX
+#  define FPU_DEFAULT FPU_ARCH_FPA
+# elif defined (TE_NetBSD)
+#  ifdef OBJ_ELF
+#   define FPU_DEFAULT FPU_ARCH_VFP	/* Soft-float, but VFP order.  */
+#  else
+    /* Legacy a.out format.  */
+#   define FPU_DEFAULT FPU_ARCH_FPA	/* Soft-float, but FPA order.  */
+#  endif
+# elif defined (TE_VXWORKS)
+#  define FPU_DEFAULT FPU_ARCH_VFP	/* Soft-float, VFP order.  */
+# else
+   /* For backwards compatibility, default to FPA.  */
+#  define FPU_DEFAULT FPU_ARCH_FPA
+# endif
+#endif /* ifndef FPU_DEFAULT */
+
+#define streq(a, b)	      (strcmp (a, b) == 0)
+
+static arm_feature_set cpu_variant;
+static arm_feature_set arm_arch_used;
+static arm_feature_set thumb_arch_used;
+
+/* Flags stored in private area of BFD structure.  */
+static int uses_apcs_26	     = FALSE;
+static int atpcs	     = FALSE;
+static int support_interwork = FALSE;
+static int uses_apcs_float   = FALSE;
+static int pic_code	     = FALSE;
+static int fix_v4bx	     = FALSE;
+/* Warn on using deprecated features.  */
+static int warn_on_deprecated = TRUE;
+
+/* Understand CodeComposer Studio assembly syntax.  */
+bfd_boolean codecomposer_syntax = FALSE;
+
+/* Variables that we set while parsing command-line options.  Once all
+   options have been read we re-process these values to set the real
+   assembly flags.  */
+static const arm_feature_set *legacy_cpu = NULL;
+static const arm_feature_set *legacy_fpu = NULL;
+
+static const arm_feature_set *mcpu_cpu_opt = NULL;
+static const arm_feature_set *mcpu_fpu_opt = NULL;
+static const arm_feature_set *march_cpu_opt = NULL;
+static const arm_feature_set *march_fpu_opt = NULL;
+static const arm_feature_set *mfpu_opt = NULL;
+static const arm_feature_set *object_arch = NULL;
+
+/* Constants for known architecture features.  */
+static const arm_feature_set fpu_default = FPU_DEFAULT;
+static const arm_feature_set fpu_arch_vfp_v1 = FPU_ARCH_VFP_V1;
+static const arm_feature_set fpu_arch_vfp_v2 = FPU_ARCH_VFP_V2;
+static const arm_feature_set fpu_arch_vfp_v3 = FPU_ARCH_VFP_V3;
+static const arm_feature_set fpu_arch_neon_v1 = FPU_ARCH_NEON_V1;
+static const arm_feature_set fpu_arch_fpa = FPU_ARCH_FPA;
+static const arm_feature_set fpu_any_hard = FPU_ANY_HARD;
+static const arm_feature_set fpu_arch_maverick = FPU_ARCH_MAVERICK;
+static const arm_feature_set fpu_endian_pure = FPU_ARCH_ENDIAN_PURE;
+
+#ifdef CPU_DEFAULT
+static const arm_feature_set cpu_default = CPU_DEFAULT;
+#endif
+
+static const arm_feature_set arm_ext_v1 = ARM_FEATURE_CORE_LOW (ARM_EXT_V1);
+static const arm_feature_set arm_ext_v2 = ARM_FEATURE_CORE_LOW (ARM_EXT_V1);
+static const arm_feature_set arm_ext_v2s = ARM_FEATURE_CORE_LOW (ARM_EXT_V2S);
+static const arm_feature_set arm_ext_v3 = ARM_FEATURE_CORE_LOW (ARM_EXT_V3);
+static const arm_feature_set arm_ext_v3m = ARM_FEATURE_CORE_LOW (ARM_EXT_V3M);
+static const arm_feature_set arm_ext_v4 = ARM_FEATURE_CORE_LOW (ARM_EXT_V4);
+static const arm_feature_set arm_ext_v4t = ARM_FEATURE_CORE_LOW (ARM_EXT_V4T);
+static const arm_feature_set arm_ext_v5 = ARM_FEATURE_CORE_LOW (ARM_EXT_V5);
+static const arm_feature_set arm_ext_v4t_5 =
+  ARM_FEATURE_CORE_LOW (ARM_EXT_V4T | ARM_EXT_V5);
+static const arm_feature_set arm_ext_v5t = ARM_FEATURE_CORE_LOW (ARM_EXT_V5T);
+static const arm_feature_set arm_ext_v5e = ARM_FEATURE_CORE_LOW (ARM_EXT_V5E);
+static const arm_feature_set arm_ext_v5exp = ARM_FEATURE_CORE_LOW (ARM_EXT_V5ExP);
+static const arm_feature_set arm_ext_v5j = ARM_FEATURE_CORE_LOW (ARM_EXT_V5J);
+static const arm_feature_set arm_ext_v6 = ARM_FEATURE_CORE_LOW (ARM_EXT_V6);
+static const arm_feature_set arm_ext_v6k = ARM_FEATURE_CORE_LOW (ARM_EXT_V6K);
+static const arm_feature_set arm_ext_v6t2 = ARM_FEATURE_CORE_LOW (ARM_EXT_V6T2);
+static const arm_feature_set arm_ext_v6m = ARM_FEATURE_CORE_LOW (ARM_EXT_V6M);
+static const arm_feature_set arm_ext_v6_notm =
+  ARM_FEATURE_CORE_LOW (ARM_EXT_V6_NOTM);
+static const arm_feature_set arm_ext_v6_dsp =
+  ARM_FEATURE_CORE_LOW (ARM_EXT_V6_DSP);
+static const arm_feature_set arm_ext_barrier =
+  ARM_FEATURE_CORE_LOW (ARM_EXT_BARRIER);
+static const arm_feature_set arm_ext_msr =
+  ARM_FEATURE_CORE_LOW (ARM_EXT_THUMB_MSR);
+static const arm_feature_set arm_ext_div = ARM_FEATURE_CORE_LOW (ARM_EXT_DIV);
+static const arm_feature_set arm_ext_v7 = ARM_FEATURE_CORE_LOW (ARM_EXT_V7);
+static const arm_feature_set arm_ext_v7a = ARM_FEATURE_CORE_LOW (ARM_EXT_V7A);
+static const arm_feature_set arm_ext_v7r = ARM_FEATURE_CORE_LOW (ARM_EXT_V7R);
+static const arm_feature_set arm_ext_v7m = ARM_FEATURE_CORE_LOW (ARM_EXT_V7M);
+static const arm_feature_set arm_ext_v8 = ARM_FEATURE_CORE_LOW (ARM_EXT_V8);
+static const arm_feature_set arm_ext_m =
+  ARM_FEATURE_CORE_LOW (ARM_EXT_V6M | ARM_EXT_OS | ARM_EXT_V7M);
+static const arm_feature_set arm_ext_mp = ARM_FEATURE_CORE_LOW (ARM_EXT_MP);
+static const arm_feature_set arm_ext_sec = ARM_FEATURE_CORE_LOW (ARM_EXT_SEC);
+static const arm_feature_set arm_ext_os = ARM_FEATURE_CORE_LOW (ARM_EXT_OS);
+static const arm_feature_set arm_ext_adiv = ARM_FEATURE_CORE_LOW (ARM_EXT_ADIV);
+static const arm_feature_set arm_ext_virt = ARM_FEATURE_CORE_LOW (ARM_EXT_VIRT);
+static const arm_feature_set arm_ext_pan = ARM_FEATURE_CORE_HIGH (ARM_EXT2_PAN);
+
+static const arm_feature_set arm_arch_any = ARM_ANY;
+static const arm_feature_set arm_arch_full = ARM_FEATURE (-1, -1, -1);
+static const arm_feature_set arm_arch_t2 = ARM_ARCH_THUMB2;
+static const arm_feature_set arm_arch_none = ARM_ARCH_NONE;
+static const arm_feature_set arm_arch_v6m_only = ARM_ARCH_V6M_ONLY;
+
+static const arm_feature_set arm_cext_iwmmxt2 =
+  ARM_FEATURE_COPROC (ARM_CEXT_IWMMXT2);
+static const arm_feature_set arm_cext_iwmmxt =
+  ARM_FEATURE_COPROC (ARM_CEXT_IWMMXT);
+static const arm_feature_set arm_cext_xscale =
+  ARM_FEATURE_COPROC (ARM_CEXT_XSCALE);
+static const arm_feature_set arm_cext_maverick =
+  ARM_FEATURE_COPROC (ARM_CEXT_MAVERICK);
+static const arm_feature_set fpu_fpa_ext_v1 =
+  ARM_FEATURE_COPROC (FPU_FPA_EXT_V1);
+static const arm_feature_set fpu_fpa_ext_v2 =
+  ARM_FEATURE_COPROC (FPU_FPA_EXT_V2);
+static const arm_feature_set fpu_vfp_ext_v1xd =
+  ARM_FEATURE_COPROC (FPU_VFP_EXT_V1xD);
+static const arm_feature_set fpu_vfp_ext_v1 =
+  ARM_FEATURE_COPROC (FPU_VFP_EXT_V1);
+static const arm_feature_set fpu_vfp_ext_v2 =
+  ARM_FEATURE_COPROC (FPU_VFP_EXT_V2);
+static const arm_feature_set fpu_vfp_ext_v3xd =
+  ARM_FEATURE_COPROC (FPU_VFP_EXT_V3xD);
+static const arm_feature_set fpu_vfp_ext_v3 =
+  ARM_FEATURE_COPROC (FPU_VFP_EXT_V3);
+static const arm_feature_set fpu_vfp_ext_d32 =
+  ARM_FEATURE_COPROC (FPU_VFP_EXT_D32);
+static const arm_feature_set fpu_neon_ext_v1 =
+  ARM_FEATURE_COPROC (FPU_NEON_EXT_V1);
+static const arm_feature_set fpu_vfp_v3_or_neon_ext =
+  ARM_FEATURE_COPROC (FPU_NEON_EXT_V1 | FPU_VFP_EXT_V3);
+static const arm_feature_set fpu_vfp_fp16 =
+  ARM_FEATURE_COPROC (FPU_VFP_EXT_FP16);
+static const arm_feature_set fpu_neon_ext_fma =
+  ARM_FEATURE_COPROC (FPU_NEON_EXT_FMA);
+static const arm_feature_set fpu_vfp_ext_fma =
+  ARM_FEATURE_COPROC (FPU_VFP_EXT_FMA);
+static const arm_feature_set fpu_vfp_ext_armv8 =
+  ARM_FEATURE_COPROC (FPU_VFP_EXT_ARMV8);
+static const arm_feature_set fpu_vfp_ext_armv8xd =
+  ARM_FEATURE_COPROC (FPU_VFP_EXT_ARMV8xD);
+static const arm_feature_set fpu_neon_ext_armv8 =
+  ARM_FEATURE_COPROC (FPU_NEON_EXT_ARMV8);
+static const arm_feature_set fpu_crypto_ext_armv8 =
+  ARM_FEATURE_COPROC (FPU_CRYPTO_EXT_ARMV8);
+static const arm_feature_set crc_ext_armv8 =
+  ARM_FEATURE_COPROC (CRC_EXT_ARMV8);
+static const arm_feature_set fpu_neon_ext_v8_1 =
+  ARM_FEATURE_COPROC (FPU_NEON_EXT_ARMV8 | FPU_NEON_EXT_RDMA);
+
+static int mfloat_abi_opt = -1;
+/* Record user cpu selection for object attributes.  */
+static arm_feature_set selected_cpu = ARM_ARCH_NONE;
+/* Must be long enough to hold any of the names in arm_cpus.  */
+static char selected_cpu_name[20];
+
+extern FLONUM_TYPE generic_floating_point_number;
+
+/* Return if no cpu was selected on command-line.  */
+static bfd_boolean
+no_cpu_selected (void)
+{
+  return ARM_FEATURE_EQUAL (selected_cpu, arm_arch_none);
+}
+
+#ifdef OBJ_ELF
+# ifdef EABI_DEFAULT
+static int meabi_flags = EABI_DEFAULT;
+# else
+static int meabi_flags = EF_ARM_EABI_UNKNOWN;
+# endif
+
+static int attributes_set_explicitly[NUM_KNOWN_OBJ_ATTRIBUTES];
+
+bfd_boolean
+arm_is_eabi (void)
+{
+  return (EF_ARM_EABI_VERSION (meabi_flags) >= EF_ARM_EABI_VER4);
+}
+#endif
+
+#ifdef OBJ_ELF
+/* Pre-defined "_GLOBAL_OFFSET_TABLE_"	*/
+symbolS * GOT_symbol;
+#endif
+
+/* 0: assemble for ARM,
+   1: assemble for Thumb,
+   2: assemble for Thumb even though target CPU does not support thumb
+      instructions.  */
+static int thumb_mode = 0;
+/* A value distinct from the possible values for thumb_mode that we
+   can use to record whether thumb_mode has been copied into the
+   tc_frag_data field of a frag.  */
+#define MODE_RECORDED (1 << 4)
+
+/* Specifies the intrinsic IT insn behavior mode.  */
+enum implicit_it_mode
+{
+  IMPLICIT_IT_MODE_NEVER  = 0x00,
+  IMPLICIT_IT_MODE_ARM    = 0x01,
+  IMPLICIT_IT_MODE_THUMB  = 0x02,
+  IMPLICIT_IT_MODE_ALWAYS = (IMPLICIT_IT_MODE_ARM | IMPLICIT_IT_MODE_THUMB)
+};
+static int implicit_it_mode = IMPLICIT_IT_MODE_ARM;
+
+/* If unified_syntax is true, we are processing the new unified
+   ARM/Thumb syntax.  Important differences from the old ARM mode:
+
+     - Immediate operands do not require a # prefix.
+     - Conditional affixes always appear at the end of the
+       instruction.  (For backward compatibility, those instructions
+       that formerly had them in the middle, continue to accept them
+       there.)
+     - The IT instruction may appear, and if it does is validated
+       against subsequent conditional affixes.  It does not generate
+       machine code.
+
+   Important differences from the old Thumb mode:
+
+     - Immediate operands do not require a # prefix.
+     - Most of the V6T2 instructions are only available in unified mode.
+     - The .N and .W suffixes are recognized and honored (it is an error
+       if they cannot be honored).
+     - All instructions set the flags if and only if they have an 's' affix.
+     - Conditional affixes may be used.  They are validated against
+       preceding IT instructions.  Unlike ARM mode, you cannot use a
+       conditional affix except in the scope of an IT instruction.  */
+
+static bfd_boolean unified_syntax = FALSE;
+
+/* An immediate operand can start with #, and ld*, st*, pld operands
+   can contain [ and ].  We need to tell APP not to elide whitespace
+   before a [, which can appear as the first operand for pld.
+   Likewise, a { can appear as the first operand for push, pop, vld*, etc.  */
+const char arm_symbol_chars[] = "#[]{}";
+
+enum neon_el_type
+{
+  NT_invtype,
+  NT_untyped,
+  NT_integer,
+  NT_float,
+  NT_poly,
+  NT_signed,
+  NT_unsigned
+};
+
+struct neon_type_el
+{
+  enum neon_el_type type;
+  unsigned size;
+};
+
+#define NEON_MAX_TYPE_ELS 4
+
+struct neon_type
+{
+  struct neon_type_el el[NEON_MAX_TYPE_ELS];
+  unsigned elems;
+};
+
+enum it_instruction_type
+{
+   OUTSIDE_IT_INSN,
+   INSIDE_IT_INSN,
+   INSIDE_IT_LAST_INSN,
+   IF_INSIDE_IT_LAST_INSN, /* Either outside or inside;
+			      if inside, should be the last one.  */
+   NEUTRAL_IT_INSN,        /* This could be either inside or outside,
+			      i.e. BKPT and NOP.  */
+   IT_INSN                 /* The IT insn has been parsed.  */
+};
+
+/* The maximum number of operands we need.  */
+#define ARM_IT_MAX_OPERANDS 6
+
+struct arm_it
+{
+  const char *	error;
+  unsigned long instruction;
+  int		size;
+  int		size_req;
+  int		cond;
+  /* "uncond_value" is set to the value in place of the conditional field in
+     unconditional versions of the instruction, or -1 if nothing is
+     appropriate.  */
+  int		uncond_value;
+  struct neon_type vectype;
+  /* This does not indicate an actual NEON instruction, only that
+     the mnemonic accepts neon-style type suffixes.  */
+  int		is_neon;
+  /* Set to the opcode if the instruction needs relaxation.
+     Zero if the instruction is not relaxed.  */
+  unsigned long	relax;
+  struct
+  {
+    bfd_reloc_code_real_type type;
+    expressionS		     exp;
+    int			     pc_rel;
+  } reloc;
+
+  enum it_instruction_type it_insn_type;
+
+  struct
+  {
+    unsigned reg;
+    signed int imm;
+    struct neon_type_el vectype;
+    unsigned present	: 1;  /* Operand present.  */
+    unsigned isreg	: 1;  /* Operand was a register.  */
+    unsigned immisreg	: 1;  /* .imm field is a second register.  */
+    unsigned isscalar   : 1;  /* Operand is a (Neon) scalar.  */
+    unsigned immisalign : 1;  /* Immediate is an alignment specifier.  */
+    unsigned immisfloat : 1;  /* Immediate was parsed as a float.  */
+    /* Note: we abuse "regisimm" to mean "is Neon register" in VMOV
+       instructions. This allows us to disambiguate ARM <-> vector insns.  */
+    unsigned regisimm   : 1;  /* 64-bit immediate, reg forms high 32 bits.  */
+    unsigned isvec      : 1;  /* Is a single, double or quad VFP/Neon reg.  */
+    unsigned isquad     : 1;  /* Operand is Neon quad-precision register.  */
+    unsigned issingle   : 1;  /* Operand is VFP single-precision register.  */
+    unsigned hasreloc	: 1;  /* Operand has relocation suffix.  */
+    unsigned writeback	: 1;  /* Operand has trailing !  */
+    unsigned preind	: 1;  /* Preindexed address.  */
+    unsigned postind	: 1;  /* Postindexed address.  */
+    unsigned negative	: 1;  /* Index register was negated.  */
+    unsigned shifted	: 1;  /* Shift applied to operation.  */
+    unsigned shift_kind : 3;  /* Shift operation (enum shift_kind).  */
+  } operands[ARM_IT_MAX_OPERANDS];
+};
+
+static struct arm_it inst;
+
+#define NUM_FLOAT_VALS 8
+
+const char * fp_const[] =
+{
+  "0.0", "1.0", "2.0", "3.0", "4.0", "5.0", "0.5", "10.0", 0
+};
+
+/* Number of littlenums required to hold an extended precision number.	*/
+#define MAX_LITTLENUMS 6
+
+LITTLENUM_TYPE fp_values[NUM_FLOAT_VALS][MAX_LITTLENUMS];
+
+#define FAIL	(-1)
+#define SUCCESS (0)
+
+#define SUFF_S 1
+#define SUFF_D 2
+#define SUFF_E 3
+#define SUFF_P 4
+
+#define CP_T_X	 0x00008000
+#define CP_T_Y	 0x00400000
+
+#define CONDS_BIT	 0x00100000
+#define LOAD_BIT	 0x00100000
+
+#define DOUBLE_LOAD_FLAG 0x00000001
+
+struct asm_cond
+{
+  const char *	 template_name;
+  unsigned long  value;
+};
+
+#define COND_ALWAYS 0xE
+
+struct asm_psr
+{
+  const char *   template_name;
+  unsigned long  field;
+};
+
+struct asm_barrier_opt
+{
+  const char *    template_name;
+  unsigned long   value;
+  const arm_feature_set arch;
+};
+
+/* The bit that distinguishes CPSR and SPSR.  */
+#define SPSR_BIT   (1 << 22)
+
+/* The individual PSR flag bits.  */
+#define PSR_c	(1 << 16)
+#define PSR_x	(1 << 17)
+#define PSR_s	(1 << 18)
+#define PSR_f	(1 << 19)
+
+struct reloc_entry
+{
+  char *                    name;
+  bfd_reloc_code_real_type  reloc;
+};
+
+enum vfp_reg_pos
+{
+  VFP_REG_Sd, VFP_REG_Sm, VFP_REG_Sn,
+  VFP_REG_Dd, VFP_REG_Dm, VFP_REG_Dn
+};
+
+enum vfp_ldstm_type
+{
+  VFP_LDSTMIA, VFP_LDSTMDB, VFP_LDSTMIAX, VFP_LDSTMDBX
+};
+
+/* Bits for DEFINED field in neon_typed_alias.  */
+#define NTA_HASTYPE  1
+#define NTA_HASINDEX 2
+
+struct neon_typed_alias
+{
+  unsigned char        defined;
+  unsigned char        index;
+  struct neon_type_el  eltype;
+};
+
+/* ARM register categories.  This includes coprocessor numbers and various
+   architecture extensions' registers.	*/
+enum arm_reg_type
+{
+  REG_TYPE_RN,
+  REG_TYPE_CP,
+  REG_TYPE_CN,
+  REG_TYPE_FN,
+  REG_TYPE_VFS,
+  REG_TYPE_VFD,
+  REG_TYPE_NQ,
+  REG_TYPE_VFSD,
+  REG_TYPE_NDQ,
+  REG_TYPE_NSDQ,
+  REG_TYPE_VFC,
+  REG_TYPE_MVF,
+  REG_TYPE_MVD,
+  REG_TYPE_MVFX,
+  REG_TYPE_MVDX,
+  REG_TYPE_MVAX,
+  REG_TYPE_DSPSC,
+  REG_TYPE_MMXWR,
+  REG_TYPE_MMXWC,
+  REG_TYPE_MMXWCG,
+  REG_TYPE_XSCALE,
+  REG_TYPE_RNB
+};
+
+/* Structure for a hash table entry for a register.
+   If TYPE is REG_TYPE_VFD or REG_TYPE_NQ, the NEON field can point to extra
+   information which states whether a vector type or index is specified (for a
+   register alias created with .dn or .qn). Otherwise NEON should be NULL.  */
+struct reg_entry
+{
+  const char *               name;
+  unsigned int               number;
+  unsigned char              type;
+  unsigned char              builtin;
+  struct neon_typed_alias *  neon;
+};
+
+/* Diagnostics used when we don't get a register of the expected type.	*/
+const char * const reg_expected_msgs[] =
+{
+  N_("ARM register expected"),
+  N_("bad or missing co-processor number"),
+  N_("co-processor register expected"),
+  N_("FPA register expected"),
+  N_("VFP single precision register expected"),
+  N_("VFP/Neon double precision register expected"),
+  N_("Neon quad precision register expected"),
+  N_("VFP single or double precision register expected"),
+  N_("Neon double or quad precision register expected"),
+  N_("VFP single, double or Neon quad precision register expected"),
+  N_("VFP system register expected"),
+  N_("Maverick MVF register expected"),
+  N_("Maverick MVD register expected"),
+  N_("Maverick MVFX register expected"),
+  N_("Maverick MVDX register expected"),
+  N_("Maverick MVAX register expected"),
+  N_("Maverick DSPSC register expected"),
+  N_("iWMMXt data register expected"),
+  N_("iWMMXt control register expected"),
+  N_("iWMMXt scalar register expected"),
+  N_("XScale accumulator register expected"),
+};
+
+/* Some well known registers that we refer to directly elsewhere.  */
+#define REG_R12	12
+#define REG_SP	13
+#define REG_LR	14
+#define REG_PC	15
+
+/* ARM instructions take 4bytes in the object file, Thumb instructions
+   take 2:  */
+#define INSN_SIZE	4
+
+struct asm_opcode
+{
+  /* Basic string to match.  */
+  const char * template_name;
+
+  /* Parameters to instruction.	 */
+  unsigned int operands[8];
+
+  /* Conditional tag - see opcode_lookup.  */
+  unsigned int tag : 4;
+
+  /* Basic instruction code.  */
+  unsigned int avalue : 28;
+
+  /* Thumb-format instruction code.  */
+  unsigned int tvalue;
+
+  /* Which architecture variant provides this instruction.  */
+  const arm_feature_set * avariant;
+  const arm_feature_set * tvariant;
+
+  /* Function to call to encode instruction in ARM format.  */
+  void (* aencode) (void);
+
+  /* Function to call to encode instruction in Thumb format.  */
+  void (* tencode) (void);
+};
+
+/* Defines for various bits that we will want to toggle.  */
+#define INST_IMMEDIATE	0x02000000
+#define OFFSET_REG	0x02000000
+#define HWOFFSET_IMM	0x00400000
+#define SHIFT_BY_REG	0x00000010
+#define PRE_INDEX	0x01000000
+#define INDEX_UP	0x00800000
+#define WRITE_BACK	0x00200000
+#define LDM_TYPE_2_OR_3	0x00400000
+#define CPSI_MMOD	0x00020000
+
+#define LITERAL_MASK	0xf000f000
+#define OPCODE_MASK	0xfe1fffff
+#define V4_STR_BIT	0x00000020
+#define VLDR_VMOV_SAME	0x0040f000
+
+#define T2_SUBS_PC_LR	0xf3de8f00
+
+#define DATA_OP_SHIFT	21
+
+#define T2_OPCODE_MASK	0xfe1fffff
+#define T2_DATA_OP_SHIFT 21
+
+#define A_COND_MASK         0xf0000000
+#define A_PUSH_POP_OP_MASK  0x0fff0000
+
+/* Opcodes for pushing/poping registers to/from the stack.  */
+#define A1_OPCODE_PUSH    0x092d0000
+#define A2_OPCODE_PUSH    0x052d0004
+#define A2_OPCODE_POP     0x049d0004
+
+/* Codes to distinguish the arithmetic instructions.  */
+#define OPCODE_AND	0
+#define OPCODE_EOR	1
+#define OPCODE_SUB	2
+#define OPCODE_RSB	3
+#define OPCODE_ADD	4
+#define OPCODE_ADC	5
+#define OPCODE_SBC	6
+#define OPCODE_RSC	7
+#define OPCODE_TST	8
+#define OPCODE_TEQ	9
+#define OPCODE_CMP	10
+#define OPCODE_CMN	11
+#define OPCODE_ORR	12
+#define OPCODE_MOV	13
+#define OPCODE_BIC	14
+#define OPCODE_MVN	15
+
+#define T2_OPCODE_AND	0
+#define T2_OPCODE_BIC	1
+#define T2_OPCODE_ORR	2
+#define T2_OPCODE_ORN	3
+#define T2_OPCODE_EOR	4
+#define T2_OPCODE_ADD	8
+#define T2_OPCODE_ADC	10
+#define T2_OPCODE_SBC	11
+#define T2_OPCODE_SUB	13
+#define T2_OPCODE_RSB	14
+
+#define T_OPCODE_MUL 0x4340
+#define T_OPCODE_TST 0x4200
+#define T_OPCODE_CMN 0x42c0
+#define T_OPCODE_NEG 0x4240
+#define T_OPCODE_MVN 0x43c0
+
+#define T_OPCODE_ADD_R3	0x1800
+#define T_OPCODE_SUB_R3 0x1a00
+#define T_OPCODE_ADD_HI 0x4400
+#define T_OPCODE_ADD_ST 0xb000
+#define T_OPCODE_SUB_ST 0xb080
+#define T_OPCODE_ADD_SP 0xa800
+#define T_OPCODE_ADD_PC 0xa000
+#define T_OPCODE_ADD_I8 0x3000
+#define T_OPCODE_SUB_I8 0x3800
+#define T_OPCODE_ADD_I3 0x1c00
+#define T_OPCODE_SUB_I3 0x1e00
+
+#define T_OPCODE_ASR_R	0x4100
+#define T_OPCODE_LSL_R	0x4080
+#define T_OPCODE_LSR_R	0x40c0
+#define T_OPCODE_ROR_R	0x41c0
+#define T_OPCODE_ASR_I	0x1000
+#define T_OPCODE_LSL_I	0x0000
+#define T_OPCODE_LSR_I	0x0800
+
+#define T_OPCODE_MOV_I8	0x2000
+#define T_OPCODE_CMP_I8 0x2800
+#define T_OPCODE_CMP_LR 0x4280
+#define T_OPCODE_MOV_HR 0x4600
+#define T_OPCODE_CMP_HR 0x4500
+
+#define T_OPCODE_LDR_PC 0x4800
+#define T_OPCODE_LDR_SP 0x9800
+#define T_OPCODE_STR_SP 0x9000
+#define T_OPCODE_LDR_IW 0x6800
+#define T_OPCODE_STR_IW 0x6000
+#define T_OPCODE_LDR_IH 0x8800
+#define T_OPCODE_STR_IH 0x8000
+#define T_OPCODE_LDR_IB 0x7800
+#define T_OPCODE_STR_IB 0x7000
+#define T_OPCODE_LDR_RW 0x5800
+#define T_OPCODE_STR_RW 0x5000
+#define T_OPCODE_LDR_RH 0x5a00
+#define T_OPCODE_STR_RH 0x5200
+#define T_OPCODE_LDR_RB 0x5c00
+#define T_OPCODE_STR_RB 0x5400
+
+#define T_OPCODE_PUSH	0xb400
+#define T_OPCODE_POP	0xbc00
+
+#define T_OPCODE_BRANCH 0xe000
+
+#define THUMB_SIZE	2	/* Size of thumb instruction.  */
+#define THUMB_PP_PC_LR 0x0100
+#define THUMB_LOAD_BIT 0x0800
+#define THUMB2_LOAD_BIT 0x00100000
+
+#define BAD_ARGS	_("bad arguments to instruction")
+#define BAD_SP          _("r13 not allowed here")
+#define BAD_PC		_("r15 not allowed here")
+#define BAD_COND	_("instruction cannot be conditional")
+#define BAD_OVERLAP	_("registers may not be the same")
+#define BAD_HIREG	_("lo register required")
+#define BAD_THUMB32	_("instruction not supported in Thumb16 mode")
+#define BAD_ADDR_MODE   _("instruction does not accept this addressing mode");
+#define BAD_BRANCH	_("branch must be last instruction in IT block")
+#define BAD_NOT_IT	_("instruction not allowed in IT block")
+#define BAD_FPU		_("selected FPU does not support instruction")
+#define BAD_OUT_IT 	_("thumb conditional instruction should be in IT block")
+#define BAD_IT_COND	_("incorrect condition in IT block")
+#define BAD_IT_IT 	_("IT falling in the range of a previous IT block")
+#define MISSING_FNSTART	_("missing .fnstart before unwinding directive")
+#define BAD_PC_ADDRESSING \
+	_("cannot use register index with PC-relative addressing")
+#define BAD_PC_WRITEBACK \
+	_("cannot use writeback with PC-relative addressing")
+#define BAD_RANGE     _("branch out of range")
+#define UNPRED_REG(R)	_("using " R " results in unpredictable behaviour")
+
+static struct hash_control * arm_ops_hsh;
+static struct hash_control * arm_cond_hsh;
+static struct hash_control * arm_shift_hsh;
+static struct hash_control * arm_psr_hsh;
+static struct hash_control * arm_v7m_psr_hsh;
+static struct hash_control * arm_reg_hsh;
+static struct hash_control * arm_reloc_hsh;
+static struct hash_control * arm_barrier_opt_hsh;
+
+/* Stuff needed to resolve the label ambiguity
+   As:
+     ...
+     label:   <insn>
+   may differ from:
+     ...
+     label:
+	      <insn>  */
+
+symbolS *  last_label_seen;
+static int label_is_thumb_function_name = FALSE;
+
+/* Literal pool structure.  Held on a per-section
+   and per-sub-section basis.  */
+
+#define MAX_LITERAL_POOL_SIZE 1024
+typedef struct literal_pool
+{
+  expressionS	         literals [MAX_LITERAL_POOL_SIZE];
+  unsigned int	         next_free_entry;
+  unsigned int	         id;
+  symbolS *	         symbol;
+  segT		         section;
+  subsegT	         sub_section;
+#ifdef OBJ_ELF
+  struct dwarf2_line_info locs [MAX_LITERAL_POOL_SIZE];
+#endif
+  struct literal_pool *  next;
+  unsigned int		 alignment;
+} literal_pool;
+
+/* Pointer to a linked list of literal pools.  */
+literal_pool * list_of_pools = NULL;
+
+typedef enum asmfunc_states
+{
+  OUTSIDE_ASMFUNC,
+  WAITING_ASMFUNC_NAME,
+  WAITING_ENDASMFUNC
+} asmfunc_states;
+
+static asmfunc_states asmfunc_state = OUTSIDE_ASMFUNC;
+
+#ifdef OBJ_ELF
+#  define now_it seg_info (now_seg)->tc_segment_info_data.current_it
+#else
+static struct current_it now_it;
+#endif
+
+static inline int
+now_it_compatible (int cond)
+{
+  return (cond & ~1) == (now_it.cc & ~1);
+}
+
+static inline int
+conditional_insn (void)
+{
+  return inst.cond != COND_ALWAYS;
+}
+
+static int in_it_block (void);
+
+static int handle_it_state (void);
+
+static void force_automatic_it_block_close (void);
+
+static void it_fsm_post_encode (void);
+
+#define set_it_insn_type(type)			\
+  do						\
+    {						\
+      inst.it_insn_type = type;			\
+      if (handle_it_state () == FAIL)		\
+	return;					\
+    }						\
+  while (0)
+
+#define set_it_insn_type_nonvoid(type, failret) \
+  do						\
+    {                                           \
+      inst.it_insn_type = type;			\
+      if (handle_it_state () == FAIL)		\
+	return failret;				\
+    }						\
+  while(0)
+
+#define set_it_insn_type_last()				\
+  do							\
+    {							\
+      if (inst.cond == COND_ALWAYS)			\
+	set_it_insn_type (IF_INSIDE_IT_LAST_INSN);	\
+      else						\
+	set_it_insn_type (INSIDE_IT_LAST_INSN);		\
+    }							\
+  while (0)
+
+/* Pure syntax.	 */
+
+/* This array holds the chars that always start a comment.  If the
+   pre-processor is disabled, these aren't very useful.	 */
+char arm_comment_chars[] = "@";
+
+/* This array holds the chars that only start a comment at the beginning of
+   a line.  If the line seems to have the form '# 123 filename'
+   .line and .file directives will appear in the pre-processed output.	*/
+/* Note that input_file.c hand checks for '#' at the beginning of the
+   first line of the input file.  This is because the compiler outputs
+   #NO_APP at the beginning of its output.  */
+/* Also note that comments like this one will always work.  */
+const char line_comment_chars[] = "#";
+
+char arm_line_separator_chars[] = ";";
+
+/* Chars that can be used to separate mant
+   from exp in floating point numbers.	*/
+const char EXP_CHARS[] = "eE";
+
+/* Chars that mean this number is a floating point constant.  */
+/* As in 0f12.456  */
+/* or	 0d1.2345e12  */
+
+const char FLT_CHARS[] = "rRsSfFdDxXeEpP";
+
+/* Prefix characters that indicate the start of an immediate
+   value.  */
+#define is_immediate_prefix(C) ((C) == '#' || (C) == '$')
+
+/* Separator character handling.  */
+
+#define skip_whitespace(str)  do { if (*(str) == ' ') ++(str); } while (0)
+
+static inline int
+skip_past_char (char ** str, char c)
+{
+  /* PR gas/14987: Allow for whitespace before the expected character.  */
+  skip_whitespace (*str);
+
+  if (**str == c)
+    {
+      (*str)++;
+      return SUCCESS;
+    }
+  else
+    return FAIL;
+}
+
+#define skip_past_comma(str) skip_past_char (str, ',')
+
+/* Arithmetic expressions (possibly involving symbols).	 */
+
+/* Return TRUE if anything in the expression is a bignum.  */
+
+static int
+walk_no_bignums (symbolS * sp)
+{
+  if (symbol_get_value_expression (sp)->X_op == O_big)
+    return 1;
+
+  if (symbol_get_value_expression (sp)->X_add_symbol)
+    {
+      return (walk_no_bignums (symbol_get_value_expression (sp)->X_add_symbol)
+	      || (symbol_get_value_expression (sp)->X_op_symbol
+		  && walk_no_bignums (symbol_get_value_expression (sp)->X_op_symbol)));
+    }
+
+  return 0;
+}
+
+static int in_my_get_expression = 0;
+
+/* Third argument to my_get_expression.	 */
+#define GE_NO_PREFIX 0
+#define GE_IMM_PREFIX 1
+#define GE_OPT_PREFIX 2
+/* This is a bit of a hack. Use an optional prefix, and also allow big (64-bit)
+   immediates, as can be used in Neon VMVN and VMOV immediate instructions.  */
+#define GE_OPT_PREFIX_BIG 3
+
+static int
+my_get_expression (expressionS * ep, char ** str, int prefix_mode)
+{
+  char * save_in;
+  segT	 seg;
+
+  /* In unified syntax, all prefixes are optional.  */
+  if (unified_syntax)
+    prefix_mode = (prefix_mode == GE_OPT_PREFIX_BIG) ? prefix_mode
+		  : GE_OPT_PREFIX;
+
+  switch (prefix_mode)
+    {
+    case GE_NO_PREFIX: break;
+    case GE_IMM_PREFIX:
+      if (!is_immediate_prefix (**str))
+	{
+	  inst.error = _("immediate expression requires a # prefix");
+	  return FAIL;
+	}
+      (*str)++;
+      break;
+    case GE_OPT_PREFIX:
+    case GE_OPT_PREFIX_BIG:
+      if (is_immediate_prefix (**str))
+	(*str)++;
+      break;
+    default: abort ();
+    }
+
+  memset (ep, 0, sizeof (expressionS));
+
+  save_in = input_line_pointer;
+  input_line_pointer = *str;
+  in_my_get_expression = 1;
+  seg = expression (ep);
+  in_my_get_expression = 0;
+
+  if (ep->X_op == O_illegal || ep->X_op == O_absent)
+    {
+      /* We found a bad or missing expression in md_operand().  */
+      *str = input_line_pointer;
+      input_line_pointer = save_in;
+      if (inst.error == NULL)
+	inst.error = (ep->X_op == O_absent
+		      ? _("missing expression") :_("bad expression"));
+      return 1;
+    }
+
+#ifdef OBJ_AOUT
+  if (seg != absolute_section
+      && seg != text_section
+      && seg != data_section
+      && seg != bss_section
+      && seg != undefined_section)
+    {
+      inst.error = _("bad segment");
+      *str = input_line_pointer;
+      input_line_pointer = save_in;
+      return 1;
+    }
+#else
+  (void) seg;
+#endif
+
+  /* Get rid of any bignums now, so that we don't generate an error for which
+     we can't establish a line number later on.	 Big numbers are never valid
+     in instructions, which is where this routine is always called.  */
+  if (prefix_mode != GE_OPT_PREFIX_BIG
+      && (ep->X_op == O_big
+	  || (ep->X_add_symbol
+	      && (walk_no_bignums (ep->X_add_symbol)
+		  || (ep->X_op_symbol
+		      && walk_no_bignums (ep->X_op_symbol))))))
+    {
+      inst.error = _("invalid constant");
+      *str = input_line_pointer;
+      input_line_pointer = save_in;
+      return 1;
+    }
+
+  *str = input_line_pointer;
+  input_line_pointer = save_in;
+  return 0;
+}
+
+/* Turn a string in input_line_pointer into a floating point constant
+   of type TYPE, and store the appropriate bytes in *LITP.  The number
+   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
+   returned, or NULL on OK.
+
+   Note that fp constants aren't represent in the normal way on the ARM.
+   In big endian mode, things are as expected.	However, in little endian
+   mode fp constants are big-endian word-wise, and little-endian byte-wise
+   within the words.  For example, (double) 1.1 in big endian mode is
+   the byte sequence 3f f1 99 99 99 99 99 9a, and in little endian mode is
+   the byte sequence 99 99 f1 3f 9a 99 99 99.
+
+   ??? The format of 12 byte floats is uncertain according to gcc's arm.h.  */
+
+char *
+md_atof (int type, char * litP, int * sizeP)
+{
+  int prec;
+  LITTLENUM_TYPE words[MAX_LITTLENUMS];
+  char *t;
+  int i;
+
+  switch (type)
+    {
+    case 'f':
+    case 'F':
+    case 's':
+    case 'S':
+      prec = 2;
+      break;
+
+    case 'd':
+    case 'D':
+    case 'r':
+    case 'R':
+      prec = 4;
+      break;
+
+    case 'x':
+    case 'X':
+      prec = 5;
+      break;
+
+    case 'p':
+    case 'P':
+      prec = 5;
+      break;
+
+    default:
+      *sizeP = 0;
+      return _("Unrecognized or unsupported floating point constant");
+    }
+
+  t = atof_ieee (input_line_pointer, type, words);
+  if (t)
+    input_line_pointer = t;
+  *sizeP = prec * sizeof (LITTLENUM_TYPE);
+
+  if (target_big_endian)
+    {
+      for (i = 0; i < prec; i++)
+	{
+	  md_number_to_chars (litP, (valueT) words[i], sizeof (LITTLENUM_TYPE));
+	  litP += sizeof (LITTLENUM_TYPE);
+	}
+    }
+  else
+    {
+      if (ARM_CPU_HAS_FEATURE (cpu_variant, fpu_endian_pure))
+	for (i = prec - 1; i >= 0; i--)
+	  {
+	    md_number_to_chars (litP, (valueT) words[i], sizeof (LITTLENUM_TYPE));
+	    litP += sizeof (LITTLENUM_TYPE);
+	  }
+      else
+	/* For a 4 byte float the order of elements in `words' is 1 0.
+	   For an 8 byte float the order is 1 0 3 2.  */
+	for (i = 0; i < prec; i += 2)
+	  {
+	    md_number_to_chars (litP, (valueT) words[i + 1],
+				sizeof (LITTLENUM_TYPE));
+	    md_number_to_chars (litP + sizeof (LITTLENUM_TYPE),
+				(valueT) words[i], sizeof (LITTLENUM_TYPE));
+	    litP += 2 * sizeof (LITTLENUM_TYPE);
+	  }
+    }
+
+  return NULL;
+}
+
+/* We handle all bad expressions here, so that we can report the faulty
+   instruction in the error message.  */
+void
+md_operand (expressionS * exp)
+{
+  if (in_my_get_expression)
+    exp->X_op = O_illegal;
+}
+
+/* Immediate values.  */
+
+/* Generic immediate-value read function for use in directives.
+   Accepts anything that 'expression' can fold to a constant.
+   *val receives the number.  */
+#ifdef OBJ_ELF
+static int
+immediate_for_directive (int *val)
+{
+  expressionS exp;
+  exp.X_op = O_illegal;
+
+  if (is_immediate_prefix (*input_line_pointer))
+    {
+      input_line_pointer++;
+      expression (&exp);
+    }
+
+  if (exp.X_op != O_constant)
+    {
+      as_bad (_("expected #constant"));
+      ignore_rest_of_line ();
+      return FAIL;
+    }
+  *val = exp.X_add_number;
+  return SUCCESS;
+}
+#endif
+
+/* Register parsing.  */
+
+/* Generic register parser.  CCP points to what should be the
+   beginning of a register name.  If it is indeed a valid register
+   name, advance CCP over it and return the reg_entry structure;
+   otherwise return NULL.  Does not issue diagnostics.	*/
+
+static struct reg_entry *
+arm_reg_parse_multi (char **ccp)
+{
+  char *start = *ccp;
+  char *p;
+  struct reg_entry *reg;
+
+  skip_whitespace (start);
+
+#ifdef REGISTER_PREFIX
+  if (*start != REGISTER_PREFIX)
+    return NULL;
+  start++;
+#endif
+#ifdef OPTIONAL_REGISTER_PREFIX
+  if (*start == OPTIONAL_REGISTER_PREFIX)
+    start++;
+#endif
+
+  p = start;
+  if (!ISALPHA (*p) || !is_name_beginner (*p))
+    return NULL;
+
+  do
+    p++;
+  while (ISALPHA (*p) || ISDIGIT (*p) || *p == '_');
+
+  reg = (struct reg_entry *) hash_find_n (arm_reg_hsh, start, p - start);
+
+  if (!reg)
+    return NULL;
+
+  *ccp = p;
+  return reg;
+}
+
+static int
+arm_reg_alt_syntax (char **ccp, char *start, struct reg_entry *reg,
+		    enum arm_reg_type type)
+{
+  /* Alternative syntaxes are accepted for a few register classes.  */
+  switch (type)
+    {
+    case REG_TYPE_MVF:
+    case REG_TYPE_MVD:
+    case REG_TYPE_MVFX:
+    case REG_TYPE_MVDX:
+      /* Generic coprocessor register names are allowed for these.  */
+      if (reg && reg->type == REG_TYPE_CN)
+	return reg->number;
+      break;
+
+    case REG_TYPE_CP:
+      /* For backward compatibility, a bare number is valid here.  */
+      {
+	unsigned long processor = strtoul (start, ccp, 10);
+	if (*ccp != start && processor <= 15)
+	  return processor;
+      }
+
+    case REG_TYPE_MMXWC:
+      /* WC includes WCG.  ??? I'm not sure this is true for all
+	 instructions that take WC registers.  */
+      if (reg && reg->type == REG_TYPE_MMXWCG)
+	return reg->number;
+      break;
+
+    default:
+      break;
+    }
+
+  return FAIL;
+}
+
+/* As arm_reg_parse_multi, but the register must be of type TYPE, and the
+   return value is the register number or FAIL.  */
+
+static int
+arm_reg_parse (char **ccp, enum arm_reg_type type)
+{
+  char *start = *ccp;
+  struct reg_entry *reg = arm_reg_parse_multi (ccp);
+  int ret;
+
+  /* Do not allow a scalar (reg+index) to parse as a register.  */
+  if (reg && reg->neon && (reg->neon->defined & NTA_HASINDEX))
+    return FAIL;
+
+  if (reg && reg->type == type)
+    return reg->number;
+
+  if ((ret = arm_reg_alt_syntax (ccp, start, reg, type)) != FAIL)
+    return ret;
+
+  *ccp = start;
+  return FAIL;
+}
+
+/* Parse a Neon type specifier. *STR should point at the leading '.'
+   character. Does no verification at this stage that the type fits the opcode
+   properly. E.g.,
+
+     .i32.i32.s16
+     .s32.f32
+     .u16
+
+   Can all be legally parsed by this function.
+
+   Fills in neon_type struct pointer with parsed information, and updates STR
+   to point after the parsed type specifier. Returns SUCCESS if this was a legal
+   type, FAIL if not.  */
+
+static int
+parse_neon_type (struct neon_type *type, char **str)
+{
+  char *ptr = *str;
+
+  if (type)
+    type->elems = 0;
+
+  while (type->elems < NEON_MAX_TYPE_ELS)
+    {
+      enum neon_el_type thistype = NT_untyped;
+      unsigned thissize = -1u;
+
+      if (*ptr != '.')
+	break;
+
+      ptr++;
+
+      /* Just a size without an explicit type.  */
+      if (ISDIGIT (*ptr))
+	goto parsesize;
+
+      switch (TOLOWER (*ptr))
+	{
+	case 'i': thistype = NT_integer; break;
+	case 'f': thistype = NT_float; break;
+	case 'p': thistype = NT_poly; break;
+	case 's': thistype = NT_signed; break;
+	case 'u': thistype = NT_unsigned; break;
+	case 'd':
+	  thistype = NT_float;
+	  thissize = 64;
+	  ptr++;
+	  goto done;
+	default:
+	  as_bad (_("unexpected character `%c' in type specifier"), *ptr);
+	  return FAIL;
+	}
+
+      ptr++;
+
+      /* .f is an abbreviation for .f32.  */
+      if (thistype == NT_float && !ISDIGIT (*ptr))
+	thissize = 32;
+      else
+	{
+	parsesize:
+	  thissize = strtoul (ptr, &ptr, 10);
+
+	  if (thissize != 8 && thissize != 16 && thissize != 32
+	      && thissize != 64)
+	    {
+	      as_bad (_("bad size %d in type specifier"), thissize);
+	      return FAIL;
+	    }
+	}
+
+      done:
+      if (type)
+	{
+	  type->el[type->elems].type = thistype;
+	  type->el[type->elems].size = thissize;
+	  type->elems++;
+	}
+    }
+
+  /* Empty/missing type is not a successful parse.  */
+  if (type->elems == 0)
+    return FAIL;
+
+  *str = ptr;
+
+  return SUCCESS;
+}
+
+/* Errors may be set multiple times during parsing or bit encoding
+   (particularly in the Neon bits), but usually the earliest error which is set
+   will be the most meaningful. Avoid overwriting it with later (cascading)
+   errors by calling this function.  */
+
+static void
+first_error (const char *err)
+{
+  if (!inst.error)
+    inst.error = err;
+}
+
+/* Parse a single type, e.g. ".s32", leading period included.  */
+static int
+parse_neon_operand_type (struct neon_type_el *vectype, char **ccp)
+{
+  char *str = *ccp;
+  struct neon_type optype;
+
+  if (*str == '.')
+    {
+      if (parse_neon_type (&optype, &str) == SUCCESS)
+	{
+	  if (optype.elems == 1)
+	    *vectype = optype.el[0];
+	  else
+	    {
+	      first_error (_("only one type should be specified for operand"));
+	      return FAIL;
+	    }
+	}
+      else
+	{
+	  first_error (_("vector type expected"));
+	  return FAIL;
+	}
+    }
+  else
+    return FAIL;
+
+  *ccp = str;
+
+  return SUCCESS;
+}
+
+/* Special meanings for indices (which have a range of 0-7), which will fit into
+   a 4-bit integer.  */
+
+#define NEON_ALL_LANES		15
+#define NEON_INTERLEAVE_LANES	14
+
+/* Parse either a register or a scalar, with an optional type. Return the
+   register number, and optionally fill in the actual type of the register
+   when multiple alternatives were given (NEON_TYPE_NDQ) in *RTYPE, and
+   type/index information in *TYPEINFO.  */
+
+static int
+parse_typed_reg_or_scalar (char **ccp, enum arm_reg_type type,
+			   enum arm_reg_type *rtype,
+			   struct neon_typed_alias *typeinfo)
+{
+  char *str = *ccp;
+  struct reg_entry *reg = arm_reg_parse_multi (&str);
+  struct neon_typed_alias atype;
+  struct neon_type_el parsetype;
+
+  atype.defined = 0;
+  atype.index = -1;
+  atype.eltype.type = NT_invtype;
+  atype.eltype.size = -1;
+
+  /* Try alternate syntax for some types of register. Note these are mutually
+     exclusive with the Neon syntax extensions.  */
+  if (reg == NULL)
+    {
+      int altreg = arm_reg_alt_syntax (&str, *ccp, reg, type);
+      if (altreg != FAIL)
+	*ccp = str;
+      if (typeinfo)
+	*typeinfo = atype;
+      return altreg;
+    }
+
+  /* Undo polymorphism when a set of register types may be accepted.  */
+  if ((type == REG_TYPE_NDQ
+       && (reg->type == REG_TYPE_NQ || reg->type == REG_TYPE_VFD))
+      || (type == REG_TYPE_VFSD
+	  && (reg->type == REG_TYPE_VFS || reg->type == REG_TYPE_VFD))
+      || (type == REG_TYPE_NSDQ
+	  && (reg->type == REG_TYPE_VFS || reg->type == REG_TYPE_VFD
+	      || reg->type == REG_TYPE_NQ))
+      || (type == REG_TYPE_MMXWC
+	  && (reg->type == REG_TYPE_MMXWCG)))
+    type = (enum arm_reg_type) reg->type;
+
+  if (type != reg->type)
+    return FAIL;
+
+  if (reg->neon)
+    atype = *reg->neon;
+
+  if (parse_neon_operand_type (&parsetype, &str) == SUCCESS)
+    {
+      if ((atype.defined & NTA_HASTYPE) != 0)
+	{
+	  first_error (_("can't redefine type for operand"));
+	  return FAIL;
+	}
+      atype.defined |= NTA_HASTYPE;
+      atype.eltype = parsetype;
+    }
+
+  if (skip_past_char (&str, '[') == SUCCESS)
+    {
+      if (type != REG_TYPE_VFD)
+	{
+	  first_error (_("only D registers may be indexed"));
+	  return FAIL;
+	}
+
+      if ((atype.defined & NTA_HASINDEX) != 0)
+	{
+	  first_error (_("can't change index for operand"));
+	  return FAIL;
+	}
+
+      atype.defined |= NTA_HASINDEX;
+
+      if (skip_past_char (&str, ']') == SUCCESS)
+	atype.index = NEON_ALL_LANES;
+      else
+	{
+	  expressionS exp;
+
+	  my_get_expression (&exp, &str, GE_NO_PREFIX);
+
+	  if (exp.X_op != O_constant)
+	    {
+	      first_error (_("constant expression required"));
+	      return FAIL;
+	    }
+
+	  if (skip_past_char (&str, ']') == FAIL)
+	    return FAIL;
+
+	  atype.index = exp.X_add_number;
+	}
+    }
+
+  if (typeinfo)
+    *typeinfo = atype;
+
+  if (rtype)
+    *rtype = type;
+
+  *ccp = str;
+
+  return reg->number;
+}
+
+/* Like arm_reg_parse, but allow allow the following extra features:
+    - If RTYPE is non-zero, return the (possibly restricted) type of the
+      register (e.g. Neon double or quad reg when either has been requested).
+    - If this is a Neon vector type with additional type information, fill
+      in the struct pointed to by VECTYPE (if non-NULL).
+   This function will fault on encountering a scalar.  */
+
+static int
+arm_typed_reg_parse (char **ccp, enum arm_reg_type type,
+		     enum arm_reg_type *rtype, struct neon_type_el *vectype)
+{
+  struct neon_typed_alias atype;
+  char *str = *ccp;
+  int reg = parse_typed_reg_or_scalar (&str, type, rtype, &atype);
+
+  if (reg == FAIL)
+    return FAIL;
+
+  /* Do not allow regname(... to parse as a register.  */
+  if (*str == '(')
+    return FAIL;
+
+  /* Do not allow a scalar (reg+index) to parse as a register.  */
+  if ((atype.defined & NTA_HASINDEX) != 0)
+    {
+      first_error (_("register operand expected, but got scalar"));
+      return FAIL;
+    }
+
+  if (vectype)
+    *vectype = atype.eltype;
+
+  *ccp = str;
+
+  return reg;
+}
+
+#define NEON_SCALAR_REG(X)	((X) >> 4)
+#define NEON_SCALAR_INDEX(X)	((X) & 15)
+
+/* Parse a Neon scalar. Most of the time when we're parsing a scalar, we don't
+   have enough information to be able to do a good job bounds-checking. So, we
+   just do easy checks here, and do further checks later.  */
+
+static int
+parse_scalar (char **ccp, int elsize, struct neon_type_el *type)
+{
+  int reg;
+  char *str = *ccp;
+  struct neon_typed_alias atype;
+
+  reg = parse_typed_reg_or_scalar (&str, REG_TYPE_VFD, NULL, &atype);
+
+  if (reg == FAIL || (atype.defined & NTA_HASINDEX) == 0)
+    return FAIL;
+
+  if (atype.index == NEON_ALL_LANES)
+    {
+      first_error (_("scalar must have an index"));
+      return FAIL;
+    }
+  else if (atype.index >= 64 / elsize)
+    {
+      first_error (_("scalar index out of range"));
+      return FAIL;
+    }
+
+  if (type)
+    *type = atype.eltype;
+
+  *ccp = str;
+
+  return reg * 16 + atype.index;
+}
+
+/* Parse an ARM register list.  Returns the bitmask, or FAIL.  */
+
+static long
+parse_reg_list (char ** strp)
+{
+  char * str = * strp;
+  long	 range = 0;
+  int	 another_range;
+
+  /* We come back here if we get ranges concatenated by '+' or '|'.  */
+  do
+    {
+      skip_whitespace (str);
+
+      another_range = 0;
+
+      if (*str == '{')
+	{
+	  int in_range = 0;
+	  int cur_reg = -1;
+
+	  str++;
+	  do
+	    {
+	      int reg;
+
+	      if ((reg = arm_reg_parse (&str, REG_TYPE_RN)) == FAIL)
+		{
+		  first_error (_(reg_expected_msgs[REG_TYPE_RN]));
+		  return FAIL;
+		}
+
+	      if (in_range)
+		{
+		  int i;
+
+		  if (reg <= cur_reg)
+		    {
+		      first_error (_("bad range in register list"));
+		      return FAIL;
+		    }
+
+		  for (i = cur_reg + 1; i < reg; i++)
+		    {
+		      if (range & (1 << i))
+			as_tsktsk
+			  (_("Warning: duplicated register (r%d) in register list"),
+			   i);
+		      else
+			range |= 1 << i;
+		    }
+		  in_range = 0;
+		}
+
+	      if (range & (1 << reg))
+		as_tsktsk (_("Warning: duplicated register (r%d) in register list"),
+			   reg);
+	      else if (reg <= cur_reg)
+		as_tsktsk (_("Warning: register range not in ascending order"));
+
+	      range |= 1 << reg;
+	      cur_reg = reg;
+	    }
+	  while (skip_past_comma (&str) != FAIL
+		 || (in_range = 1, *str++ == '-'));
+	  str--;
+
+	  if (skip_past_char (&str, '}') == FAIL)
+	    {
+	      first_error (_("missing `}'"));
+	      return FAIL;
+	    }
+	}
+      else
+	{
+	  expressionS exp;
+
+	  if (my_get_expression (&exp, &str, GE_NO_PREFIX))
+	    return FAIL;
+
+	  if (exp.X_op == O_constant)
+	    {
+	      if (exp.X_add_number
+		  != (exp.X_add_number & 0x0000ffff))
+		{
+		  inst.error = _("invalid register mask");
+		  return FAIL;
+		}
+
+	      if ((range & exp.X_add_number) != 0)
+		{
+		  int regno = range & exp.X_add_number;
+
+		  regno &= -regno;
+		  regno = (1 << regno) - 1;
+		  as_tsktsk
+		    (_("Warning: duplicated register (r%d) in register list"),
+		     regno);
+		}
+
+	      range |= exp.X_add_number;
+	    }
+	  else
+	    {
+	      if (inst.reloc.type != 0)
+		{
+		  inst.error = _("expression too complex");
+		  return FAIL;
+		}
+
+	      memcpy (&inst.reloc.exp, &exp, sizeof (expressionS));
+	      inst.reloc.type = BFD_RELOC_ARM_MULTI;
+	      inst.reloc.pc_rel = 0;
+	    }
+	}
+
+      if (*str == '|' || *str == '+')
+	{
+	  str++;
+	  another_range = 1;
+	}
+    }
+  while (another_range);
+
+  *strp = str;
+  return range;
+}
+
+/* Types of registers in a list.  */
+
+enum reg_list_els
+{
+  REGLIST_VFP_S,
+  REGLIST_VFP_D,
+  REGLIST_NEON_D
+};
+
+/* Parse a VFP register list.  If the string is invalid return FAIL.
+   Otherwise return the number of registers, and set PBASE to the first
+   register.  Parses registers of type ETYPE.
+   If REGLIST_NEON_D is used, several syntax enhancements are enabled:
+     - Q registers can be used to specify pairs of D registers
+     - { } can be omitted from around a singleton register list
+	 FIXME: This is not implemented, as it would require backtracking in
+	 some cases, e.g.:
+	   vtbl.8 d3,d4,d5
+	 This could be done (the meaning isn't really ambiguous), but doesn't
+	 fit in well with the current parsing framework.
+     - 32 D registers may be used (also true for VFPv3).
+   FIXME: Types are ignored in these register lists, which is probably a
+   bug.  */
+
+static int
+parse_vfp_reg_list (char **ccp, unsigned int *pbase, enum reg_list_els etype)
+{
+  char *str = *ccp;
+  int base_reg;
+  int new_base;
+  enum arm_reg_type regtype = (enum arm_reg_type) 0;
+  int max_regs = 0;
+  int count = 0;
+  int warned = 0;
+  unsigned long mask = 0;
+  int i;
+
+  if (skip_past_char (&str, '{') == FAIL)
+    {
+      inst.error = _("expecting {");
+      return FAIL;
+    }
+
+  switch (etype)
+    {
+    case REGLIST_VFP_S:
+      regtype = REG_TYPE_VFS;
+      max_regs = 32;
+      break;
+
+    case REGLIST_VFP_D:
+      regtype = REG_TYPE_VFD;
+      break;
+
+    case REGLIST_NEON_D:
+      regtype = REG_TYPE_NDQ;
+      break;
+    }
+
+  if (etype != REGLIST_VFP_S)
+    {
+      /* VFPv3 allows 32 D registers, except for the VFPv3-D16 variant.  */
+      if (ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_d32))
+	{
+	  max_regs = 32;
+	  if (thumb_mode)
+	    ARM_MERGE_FEATURE_SETS (thumb_arch_used, thumb_arch_used,
+				    fpu_vfp_ext_d32);
+	  else
+	    ARM_MERGE_FEATURE_SETS (arm_arch_used, arm_arch_used,
+				    fpu_vfp_ext_d32);
+	}
+      else
+	max_regs = 16;
+    }
+
+  base_reg = max_regs;
+
+  do
+    {
+      int setmask = 1, addregs = 1;
+
+      new_base = arm_typed_reg_parse (&str, regtype, &regtype, NULL);
+
+      if (new_base == FAIL)
+	{
+	  first_error (_(reg_expected_msgs[regtype]));
+	  return FAIL;
+	}
+
+      if (new_base >= max_regs)
+	{
+	  first_error (_("register out of range in list"));
+	  return FAIL;
+	}
+
+      /* Note: a value of 2 * n is returned for the register Q<n>.  */
+      if (regtype == REG_TYPE_NQ)
+	{
+	  setmask = 3;
+	  addregs = 2;
+	}
+
+      if (new_base < base_reg)
+	base_reg = new_base;
+
+      if (mask & (setmask << new_base))
+	{
+	  first_error (_("invalid register list"));
+	  return FAIL;
+	}
+
+      if ((mask >> new_base) != 0 && ! warned)
+	{
+	  as_tsktsk (_("register list not in ascending order"));
+	  warned = 1;
+	}
+
+      mask |= setmask << new_base;
+      count += addregs;
+
+      if (*str == '-') /* We have the start of a range expression */
+	{
+	  int high_range;
+
+	  str++;
+
+	  if ((high_range = arm_typed_reg_parse (&str, regtype, NULL, NULL))
+	      == FAIL)
+	    {
+	      inst.error = gettext (reg_expected_msgs[regtype]);
+	      return FAIL;
+	    }
+
+	  if (high_range >= max_regs)
+	    {
+	      first_error (_("register out of range in list"));
+	      return FAIL;
+	    }
+
+	  if (regtype == REG_TYPE_NQ)
+	    high_range = high_range + 1;
+
+	  if (high_range <= new_base)
+	    {
+	      inst.error = _("register range not in ascending order");
+	      return FAIL;
+	    }
+
+	  for (new_base += addregs; new_base <= high_range; new_base += addregs)
+	    {
+	      if (mask & (setmask << new_base))
+		{
+		  inst.error = _("invalid register list");
+		  return FAIL;
+		}
+
+	      mask |= setmask << new_base;
+	      count += addregs;
+	    }
+	}
+    }
+  while (skip_past_comma (&str) != FAIL);
+
+  str++;
+
+  /* Sanity check -- should have raised a parse error above.  */
+  if (count == 0 || count > max_regs)
+    abort ();
+
+  *pbase = base_reg;
+
+  /* Final test -- the registers must be consecutive.  */
+  mask >>= base_reg;
+  for (i = 0; i < count; i++)
+    {
+      if ((mask & (1u << i)) == 0)
+	{
+	  inst.error = _("non-contiguous register range");
+	  return FAIL;
+	}
+    }
+
+  *ccp = str;
+
+  return count;
+}
+
+/* True if two alias types are the same.  */
+
+static bfd_boolean
+neon_alias_types_same (struct neon_typed_alias *a, struct neon_typed_alias *b)
+{
+  if (!a && !b)
+    return TRUE;
+
+  if (!a || !b)
+    return FALSE;
+
+  if (a->defined != b->defined)
+    return FALSE;
+
+  if ((a->defined & NTA_HASTYPE) != 0
+      && (a->eltype.type != b->eltype.type
+	  || a->eltype.size != b->eltype.size))
+    return FALSE;
+
+  if ((a->defined & NTA_HASINDEX) != 0
+      && (a->index != b->index))
+    return FALSE;
+
+  return TRUE;
+}
+
+/* Parse element/structure lists for Neon VLD<n> and VST<n> instructions.
+   The base register is put in *PBASE.
+   The lane (or one of the NEON_*_LANES constants) is placed in bits [3:0] of
+   the return value.
+   The register stride (minus one) is put in bit 4 of the return value.
+   Bits [6:5] encode the list length (minus one).
+   The type of the list elements is put in *ELTYPE, if non-NULL.  */
+
+#define NEON_LANE(X)		((X) & 0xf)
+#define NEON_REG_STRIDE(X)	((((X) >> 4) & 1) + 1)
+#define NEON_REGLIST_LENGTH(X)	((((X) >> 5) & 3) + 1)
+
+static int
+parse_neon_el_struct_list (char **str, unsigned *pbase,
+			   struct neon_type_el *eltype)
+{
+  char *ptr = *str;
+  int base_reg = -1;
+  int reg_incr = -1;
+  int count = 0;
+  int lane = -1;
+  int leading_brace = 0;
+  enum arm_reg_type rtype = REG_TYPE_NDQ;
+  const char *const incr_error = _("register stride must be 1 or 2");
+  const char *const type_error = _("mismatched element/structure types in list");
+  struct neon_typed_alias firsttype;
+
+  if (skip_past_char (&ptr, '{') == SUCCESS)
+    leading_brace = 1;
+
+  do
+    {
+      struct neon_typed_alias atype;
+      int getreg = parse_typed_reg_or_scalar (&ptr, rtype, &rtype, &atype);
+
+      if (getreg == FAIL)
+	{
+	  first_error (_(reg_expected_msgs[rtype]));
+	  return FAIL;
+	}
+
+      if (base_reg == -1)
+	{
+	  base_reg = getreg;
+	  if (rtype == REG_TYPE_NQ)
+	    {
+	      reg_incr = 1;
+	    }
+	  firsttype = atype;
+	}
+      else if (reg_incr == -1)
+	{
+	  reg_incr = getreg - base_reg;
+	  if (reg_incr < 1 || reg_incr > 2)
+	    {
+	      first_error (_(incr_error));
+	      return FAIL;
+	    }
+	}
+      else if (getreg != base_reg + reg_incr * count)
+	{
+	  first_error (_(incr_error));
+	  return FAIL;
+	}
+
+      if (! neon_alias_types_same (&atype, &firsttype))
+	{
+	  first_error (_(type_error));
+	  return FAIL;
+	}
+
+      /* Handle Dn-Dm or Qn-Qm syntax. Can only be used with non-indexed list
+	 modes.  */
+      if (ptr[0] == '-')
+	{
+	  struct neon_typed_alias htype;
+	  int hireg, dregs = (rtype == REG_TYPE_NQ) ? 2 : 1;
+	  if (lane == -1)
+	    lane = NEON_INTERLEAVE_LANES;
+	  else if (lane != NEON_INTERLEAVE_LANES)
+	    {
+	      first_error (_(type_error));
+	      return FAIL;
+	    }
+	  if (reg_incr == -1)
+	    reg_incr = 1;
+	  else if (reg_incr != 1)
+	    {
+	      first_error (_("don't use Rn-Rm syntax with non-unit stride"));
+	      return FAIL;
+	    }
+	  ptr++;
+	  hireg = parse_typed_reg_or_scalar (&ptr, rtype, NULL, &htype);
+	  if (hireg == FAIL)
+	    {
+	      first_error (_(reg_expected_msgs[rtype]));
+	      return FAIL;
+	    }
+	  if (! neon_alias_types_same (&htype, &firsttype))
+	    {
+	      first_error (_(type_error));
+	      return FAIL;
+	    }
+	  count += hireg + dregs - getreg;
+	  continue;
+	}
+
+      /* If we're using Q registers, we can't use [] or [n] syntax.  */
+      if (rtype == REG_TYPE_NQ)
+	{
+	  count += 2;
+	  continue;
+	}
+
+      if ((atype.defined & NTA_HASINDEX) != 0)
+	{
+	  if (lane == -1)
+	    lane = atype.index;
+	  else if (lane != atype.index)
+	    {
+	      first_error (_(type_error));
+	      return FAIL;
+	    }
+	}
+      else if (lane == -1)
+	lane = NEON_INTERLEAVE_LANES;
+      else if (lane != NEON_INTERLEAVE_LANES)
+	{
+	  first_error (_(type_error));
+	  return FAIL;
+	}
+      count++;
+    }
+  while ((count != 1 || leading_brace) && skip_past_comma (&ptr) != FAIL);
+
+  /* No lane set by [x]. We must be interleaving structures.  */
+  if (lane == -1)
+    lane = NEON_INTERLEAVE_LANES;
+
+  /* Sanity check.  */
+  if (lane == -1 || base_reg == -1 || count < 1 || count > 4
+      || (count > 1 && reg_incr == -1))
+    {
+      first_error (_("error parsing element/structure list"));
+      return FAIL;
+    }
+
+  if ((count > 1 || leading_brace) && skip_past_char (&ptr, '}') == FAIL)
+    {
+      first_error (_("expected }"));
+      return FAIL;
+    }
+
+  if (reg_incr == -1)
+    reg_incr = 1;
+
+  if (eltype)
+    *eltype = firsttype.eltype;
+
+  *pbase = base_reg;
+  *str = ptr;
+
+  return lane | ((reg_incr - 1) << 4) | ((count - 1) << 5);
+}
+
+/* Parse an explicit relocation suffix on an expression.  This is
+   either nothing, or a word in parentheses.  Note that if !OBJ_ELF,
+   arm_reloc_hsh contains no entries, so this function can only
+   succeed if there is no () after the word.  Returns -1 on error,
+   BFD_RELOC_UNUSED if there wasn't any suffix.	 */
+
+static int
+parse_reloc (char **str)
+{
+  struct reloc_entry *r;
+  char *p, *q;
+
+  if (**str != '(')
+    return BFD_RELOC_UNUSED;
+
+  p = *str + 1;
+  q = p;
+
+  while (*q && *q != ')' && *q != ',')
+    q++;
+  if (*q != ')')
+    return -1;
+
+  if ((r = (struct reloc_entry *)
+       hash_find_n (arm_reloc_hsh, p, q - p)) == NULL)
+    return -1;
+
+  *str = q + 1;
+  return r->reloc;
+}
+
+/* Directives: register aliases.  */
+
+static struct reg_entry *
+insert_reg_alias (char *str, unsigned number, int type)
+{
+  struct reg_entry *new_reg;
+  const char *name;
+
+  if ((new_reg = (struct reg_entry *) hash_find (arm_reg_hsh, str)) != 0)
+    {
+      if (new_reg->builtin)
+	as_warn (_("ignoring attempt to redefine built-in register '%s'"), str);
+
+      /* Only warn about a redefinition if it's not defined as the
+	 same register.	 */
+      else if (new_reg->number != number || new_reg->type != type)
+	as_warn (_("ignoring redefinition of register alias '%s'"), str);
+
+      return NULL;
+    }
+
+  name = xstrdup (str);
+  new_reg = (struct reg_entry *) xmalloc (sizeof (struct reg_entry));
+
+  new_reg->name = name;
+  new_reg->number = number;
+  new_reg->type = type;
+  new_reg->builtin = FALSE;
+  new_reg->neon = NULL;
+
+  if (hash_insert (arm_reg_hsh, name, (void *) new_reg))
+    abort ();
+
+  return new_reg;
+}
+
+static void
+insert_neon_reg_alias (char *str, int number, int type,
+		       struct neon_typed_alias *atype)
+{
+  struct reg_entry *reg = insert_reg_alias (str, number, type);
+
+  if (!reg)
+    {
+      first_error (_("attempt to redefine typed alias"));
+      return;
+    }
+
+  if (atype)
+    {
+      reg->neon = (struct neon_typed_alias *)
+	  xmalloc (sizeof (struct neon_typed_alias));
+      *reg->neon = *atype;
+    }
+}
+
+/* Look for the .req directive.	 This is of the form:
+
+	new_register_name .req existing_register_name
+
+   If we find one, or if it looks sufficiently like one that we want to
+   handle any error here, return TRUE.  Otherwise return FALSE.  */
+
+static bfd_boolean
+create_register_alias (char * newname, char *p)
+{
+  struct reg_entry *old;
+  char *oldname, *nbuf;
+  size_t nlen;
+
+  /* The input scrubber ensures that whitespace after the mnemonic is
+     collapsed to single spaces.  */
+  oldname = p;
+  if (strncmp (oldname, " .req ", 6) != 0)
+    return FALSE;
+
+  oldname += 6;
+  if (*oldname == '\0')
+    return FALSE;
+
+  old = (struct reg_entry *) hash_find (arm_reg_hsh, oldname);
+  if (!old)
+    {
+      as_warn (_("unknown register '%s' -- .req ignored"), oldname);
+      return TRUE;
+    }
+
+  /* If TC_CASE_SENSITIVE is defined, then newname already points to
+     the desired alias name, and p points to its end.  If not, then
+     the desired alias name is in the global original_case_string.  */
+#ifdef TC_CASE_SENSITIVE
+  nlen = p - newname;
+#else
+  newname = original_case_string;
+  nlen = strlen (newname);
+#endif
+
+  nbuf = (char *) alloca (nlen + 1);
+  memcpy (nbuf, newname, nlen);
+  nbuf[nlen] = '\0';
+
+  /* Create aliases under the new name as stated; an all-lowercase
+     version of the new name; and an all-uppercase version of the new
+     name.  */
+  if (insert_reg_alias (nbuf, old->number, old->type) != NULL)
+    {
+      for (p = nbuf; *p; p++)
+	*p = TOUPPER (*p);
+
+      if (strncmp (nbuf, newname, nlen))
+	{
+	  /* If this attempt to create an additional alias fails, do not bother
+	     trying to create the all-lower case alias.  We will fail and issue
+	     a second, duplicate error message.  This situation arises when the
+	     programmer does something like:
+	       foo .req r0
+	       Foo .req r1
+	     The second .req creates the "Foo" alias but then fails to create
+	     the artificial FOO alias because it has already been created by the
+	     first .req.  */
+	  if (insert_reg_alias (nbuf, old->number, old->type) == NULL)
+	    return TRUE;
+	}
+
+      for (p = nbuf; *p; p++)
+	*p = TOLOWER (*p);
+
+      if (strncmp (nbuf, newname, nlen))
+	insert_reg_alias (nbuf, old->number, old->type);
+    }
+
+  return TRUE;
+}
+
+/* Create a Neon typed/indexed register alias using directives, e.g.:
+     X .dn d5.s32[1]
+     Y .qn 6.s16
+     Z .dn d7
+     T .dn Z[0]
+   These typed registers can be used instead of the types specified after the
+   Neon mnemonic, so long as all operands given have types. Types can also be
+   specified directly, e.g.:
+     vadd d0.s32, d1.s32, d2.s32  */
+
+static bfd_boolean
+create_neon_reg_alias (char *newname, char *p)
+{
+  enum arm_reg_type basetype;
+  struct reg_entry *basereg;
+  struct reg_entry mybasereg;
+  struct neon_type ntype;
+  struct neon_typed_alias typeinfo;
+  char *namebuf, *nameend ATTRIBUTE_UNUSED;
+  int namelen;
+
+  typeinfo.defined = 0;
+  typeinfo.eltype.type = NT_invtype;
+  typeinfo.eltype.size = -1;
+  typeinfo.index = -1;
+
+  nameend = p;
+
+  if (strncmp (p, " .dn ", 5) == 0)
+    basetype = REG_TYPE_VFD;
+  else if (strncmp (p, " .qn ", 5) == 0)
+    basetype = REG_TYPE_NQ;
+  else
+    return FALSE;
+
+  p += 5;
+
+  if (*p == '\0')
+    return FALSE;
+
+  basereg = arm_reg_parse_multi (&p);
+
+  if (basereg && basereg->type != basetype)
+    {
+      as_bad (_("bad type for register"));
+      return FALSE;
+    }
+
+  if (basereg == NULL)
+    {
+      expressionS exp;
+      /* Try parsing as an integer.  */
+      my_get_expression (&exp, &p, GE_NO_PREFIX);
+      if (exp.X_op != O_constant)
+	{
+	  as_bad (_("expression must be constant"));
+	  return FALSE;
+	}
+      basereg = &mybasereg;
+      basereg->number = (basetype == REG_TYPE_NQ) ? exp.X_add_number * 2
+						  : exp.X_add_number;
+      basereg->neon = 0;
+    }
+
+  if (basereg->neon)
+    typeinfo = *basereg->neon;
+
+  if (parse_neon_type (&ntype, &p) == SUCCESS)
+    {
+      /* We got a type.  */
+      if (typeinfo.defined & NTA_HASTYPE)
+	{
+	  as_bad (_("can't redefine the type of a register alias"));
+	  return FALSE;
+	}
+
+      typeinfo.defined |= NTA_HASTYPE;
+      if (ntype.elems != 1)
+	{
+	  as_bad (_("you must specify a single type only"));
+	  return FALSE;
+	}
+      typeinfo.eltype = ntype.el[0];
+    }
+
+  if (skip_past_char (&p, '[') == SUCCESS)
+    {
+      expressionS exp;
+      /* We got a scalar index.  */
+
+      if (typeinfo.defined & NTA_HASINDEX)
+	{
+	  as_bad (_("can't redefine the index of a scalar alias"));
+	  return FALSE;
+	}
+
+      my_get_expression (&exp, &p, GE_NO_PREFIX);
+
+      if (exp.X_op != O_constant)
+	{
+	  as_bad (_("scalar index must be constant"));
+	  return FALSE;
+	}
+
+      typeinfo.defined |= NTA_HASINDEX;
+      typeinfo.index = exp.X_add_number;
+
+      if (skip_past_char (&p, ']') == FAIL)
+	{
+	  as_bad (_("expecting ]"));
+	  return FALSE;
+	}
+    }
+
+  /* If TC_CASE_SENSITIVE is defined, then newname already points to
+     the desired alias name, and p points to its end.  If not, then
+     the desired alias name is in the global original_case_string.  */
+#ifdef TC_CASE_SENSITIVE
+  namelen = nameend - newname;
+#else
+  newname = original_case_string;
+  namelen = strlen (newname);
+#endif
+
+  namebuf = (char *) alloca (namelen + 1);
+  strncpy (namebuf, newname, namelen);
+  namebuf[namelen] = '\0';
+
+  insert_neon_reg_alias (namebuf, basereg->number, basetype,
+			 typeinfo.defined != 0 ? &typeinfo : NULL);
+
+  /* Insert name in all uppercase.  */
+  for (p = namebuf; *p; p++)
+    *p = TOUPPER (*p);
+
+  if (strncmp (namebuf, newname, namelen))
+    insert_neon_reg_alias (namebuf, basereg->number, basetype,
+			   typeinfo.defined != 0 ? &typeinfo : NULL);
+
+  /* Insert name in all lowercase.  */
+  for (p = namebuf; *p; p++)
+    *p = TOLOWER (*p);
+
+  if (strncmp (namebuf, newname, namelen))
+    insert_neon_reg_alias (namebuf, basereg->number, basetype,
+			   typeinfo.defined != 0 ? &typeinfo : NULL);
+
+  return TRUE;
+}
+
+/* Should never be called, as .req goes between the alias and the
+   register name, not at the beginning of the line.  */
+
+static void
+s_req (int a ATTRIBUTE_UNUSED)
+{
+  as_bad (_("invalid syntax for .req directive"));
+}
+
+static void
+s_dn (int a ATTRIBUTE_UNUSED)
+{
+  as_bad (_("invalid syntax for .dn directive"));
+}
+
+static void
+s_qn (int a ATTRIBUTE_UNUSED)
+{
+  as_bad (_("invalid syntax for .qn directive"));
+}
+
+/* The .unreq directive deletes an alias which was previously defined
+   by .req.  For example:
+
+       my_alias .req r11
+       .unreq my_alias	  */
+
+static void
+s_unreq (int a ATTRIBUTE_UNUSED)
+{
+  char * name;
+  char saved_char;
+
+  name = input_line_pointer;
+
+  while (*input_line_pointer != 0
+	 && *input_line_pointer != ' '
+	 && *input_line_pointer != '\n')
+    ++input_line_pointer;
+
+  saved_char = *input_line_pointer;
+  *input_line_pointer = 0;
+
+  if (!*name)
+    as_bad (_("invalid syntax for .unreq directive"));
+  else
+    {
+      struct reg_entry *reg = (struct reg_entry *) hash_find (arm_reg_hsh,
+							      name);
+
+      if (!reg)
+	as_bad (_("unknown register alias '%s'"), name);
+      else if (reg->builtin)
+	as_warn (_("ignoring attempt to use .unreq on fixed register name: '%s'"),
+		 name);
+      else
+	{
+	  char * p;
+	  char * nbuf;
+
+	  hash_delete (arm_reg_hsh, name, FALSE);
+	  free ((char *) reg->name);
+	  if (reg->neon)
+	    free (reg->neon);
+	  free (reg);
+
+	  /* Also locate the all upper case and all lower case versions.
+	     Do not complain if we cannot find one or the other as it
+	     was probably deleted above.  */
+
+	  nbuf = strdup (name);
+	  for (p = nbuf; *p; p++)
+	    *p = TOUPPER (*p);
+	  reg = (struct reg_entry *) hash_find (arm_reg_hsh, nbuf);
+	  if (reg)
+	    {
+	      hash_delete (arm_reg_hsh, nbuf, FALSE);
+	      free ((char *) reg->name);
+	      if (reg->neon)
+		free (reg->neon);
+	      free (reg);
+	    }
+
+	  for (p = nbuf; *p; p++)
+	    *p = TOLOWER (*p);
+	  reg = (struct reg_entry *) hash_find (arm_reg_hsh, nbuf);
+	  if (reg)
+	    {
+	      hash_delete (arm_reg_hsh, nbuf, FALSE);
+	      free ((char *) reg->name);
+	      if (reg->neon)
+		free (reg->neon);
+	      free (reg);
+	    }
+
+	  free (nbuf);
+	}
+    }
+
+  *input_line_pointer = saved_char;
+  demand_empty_rest_of_line ();
+}
+
+/* Directives: Instruction set selection.  */
+
+#ifdef OBJ_ELF
+/* This code is to handle mapping symbols as defined in the ARM ELF spec.
+   (See "Mapping symbols", section 4.5.5, ARM AAELF version 1.0).
+   Note that previously, $a and $t has type STT_FUNC (BSF_OBJECT flag),
+   and $d has type STT_OBJECT (BSF_OBJECT flag). Now all three are untyped.  */
+
+/* Create a new mapping symbol for the transition to STATE.  */
+
+static void
+make_mapping_symbol (enum mstate state, valueT value, fragS *frag)
+{
+  symbolS * symbolP;
+  const char * symname;
+  int type;
+
+  switch (state)
+    {
+    case MAP_DATA:
+      symname = "$d";
+      type = BSF_NO_FLAGS;
+      break;
+    case MAP_ARM:
+      symname = "$a";
+      type = BSF_NO_FLAGS;
+      break;
+    case MAP_THUMB:
+      symname = "$t";
+      type = BSF_NO_FLAGS;
+      break;
+    default:
+      abort ();
+    }
+
+  symbolP = symbol_new (symname, now_seg, value, frag);
+  symbol_get_bfdsym (symbolP)->flags |= type | BSF_LOCAL;
+
+  switch (state)
+    {
+    case MAP_ARM:
+      THUMB_SET_FUNC (symbolP, 0);
+      ARM_SET_THUMB (symbolP, 0);
+      ARM_SET_INTERWORK (symbolP, support_interwork);
+      break;
+
+    case MAP_THUMB:
+      THUMB_SET_FUNC (symbolP, 1);
+      ARM_SET_THUMB (symbolP, 1);
+      ARM_SET_INTERWORK (symbolP, support_interwork);
+      break;
+
+    case MAP_DATA:
+    default:
+      break;
+    }
+
+  /* Save the mapping symbols for future reference.  Also check that
+     we do not place two mapping symbols at the same offset within a
+     frag.  We'll handle overlap between frags in
+     check_mapping_symbols.
+
+     If .fill or other data filling directive generates zero sized data,
+     the mapping symbol for the following code will have the same value
+     as the one generated for the data filling directive.  In this case,
+     we replace the old symbol with the new one at the same address.  */
+  if (value == 0)
+    {
+      if (frag->tc_frag_data.first_map != NULL)
+	{
+	  know (S_GET_VALUE (frag->tc_frag_data.first_map) == 0);
+	  symbol_remove (frag->tc_frag_data.first_map, &symbol_rootP, &symbol_lastP);
+	}
+      frag->tc_frag_data.first_map = symbolP;
+    }
+  if (frag->tc_frag_data.last_map != NULL)
+    {
+      know (S_GET_VALUE (frag->tc_frag_data.last_map) <= S_GET_VALUE (symbolP));
+      if (S_GET_VALUE (frag->tc_frag_data.last_map) == S_GET_VALUE (symbolP))
+	symbol_remove (frag->tc_frag_data.last_map, &symbol_rootP, &symbol_lastP);
+    }
+  frag->tc_frag_data.last_map = symbolP;
+}
+
+/* We must sometimes convert a region marked as code to data during
+   code alignment, if an odd number of bytes have to be padded.  The
+   code mapping symbol is pushed to an aligned address.  */
+
+static void
+insert_data_mapping_symbol (enum mstate state,
+			    valueT value, fragS *frag, offsetT bytes)
+{
+  /* If there was already a mapping symbol, remove it.  */
+  if (frag->tc_frag_data.last_map != NULL
+      && S_GET_VALUE (frag->tc_frag_data.last_map) == frag->fr_address + value)
+    {
+      symbolS *symp = frag->tc_frag_data.last_map;
+
+      if (value == 0)
+	{
+	  know (frag->tc_frag_data.first_map == symp);
+	  frag->tc_frag_data.first_map = NULL;
+	}
+      frag->tc_frag_data.last_map = NULL;
+      symbol_remove (symp, &symbol_rootP, &symbol_lastP);
+    }
+
+  make_mapping_symbol (MAP_DATA, value, frag);
+  make_mapping_symbol (state, value + bytes, frag);
+}
+
+static void mapping_state_2 (enum mstate state, int max_chars);
+
+/* Set the mapping state to STATE.  Only call this when about to
+   emit some STATE bytes to the file.  */
+
+#define TRANSITION(from, to) (mapstate == (from) && state == (to))
+void
+mapping_state (enum mstate state)
+{
+  enum mstate mapstate = seg_info (now_seg)->tc_segment_info_data.mapstate;
+
+  if (mapstate == state)
+    /* The mapping symbol has already been emitted.
+       There is nothing else to do.  */
+    return;
+
+  if (state == MAP_ARM || state == MAP_THUMB)
+    /*  PR gas/12931
+	All ARM instructions require 4-byte alignment.
+	(Almost) all Thumb instructions require 2-byte alignment.
+
+	When emitting instructions into any section, mark the section
+	appropriately.
+
+	Some Thumb instructions are alignment-sensitive modulo 4 bytes,
+	but themselves require 2-byte alignment; this applies to some
+	PC- relative forms.  However, these cases will invovle implicit
+	literal pool generation or an explicit .align >=2, both of
+	which will cause the section to me marked with sufficient
+	alignment.  Thus, we don't handle those cases here.  */
+    record_alignment (now_seg, state == MAP_ARM ? 2 : 1);
+
+  if (TRANSITION (MAP_UNDEFINED, MAP_DATA))
+    /* This case will be evaluated later.  */
+    return;
+
+  mapping_state_2 (state, 0);
+}
+
+/* Same as mapping_state, but MAX_CHARS bytes have already been
+   allocated.  Put the mapping symbol that far back.  */
+
+static void
+mapping_state_2 (enum mstate state, int max_chars)
+{
+  enum mstate mapstate = seg_info (now_seg)->tc_segment_info_data.mapstate;
+
+  if (!SEG_NORMAL (now_seg))
+    return;
+
+  if (mapstate == state)
+    /* The mapping symbol has already been emitted.
+       There is nothing else to do.  */
+    return;
+
+  if (TRANSITION (MAP_UNDEFINED, MAP_ARM)
+	  || TRANSITION (MAP_UNDEFINED, MAP_THUMB))
+    {
+      struct frag * const frag_first = seg_info (now_seg)->frchainP->frch_root;
+      const int add_symbol = (frag_now != frag_first) || (frag_now_fix () > 0);
+
+      if (add_symbol)
+	make_mapping_symbol (MAP_DATA, (valueT) 0, frag_first);
+    }
+
+  seg_info (now_seg)->tc_segment_info_data.mapstate = state;
+  make_mapping_symbol (state, (valueT) frag_now_fix () - max_chars, frag_now);
+}
+#undef TRANSITION
+#else
+#define mapping_state(x) ((void)0)
+#define mapping_state_2(x, y) ((void)0)
+#endif
+
+/* Find the real, Thumb encoded start of a Thumb function.  */
+
+#ifdef OBJ_COFF
+static symbolS *
+find_real_start (symbolS * symbolP)
+{
+  char *       real_start;
+  const char * name = S_GET_NAME (symbolP);
+  symbolS *    new_target;
+
+  /* This definition must agree with the one in gcc/config/arm/thumb.c.	 */
+#define STUB_NAME ".real_start_of"
+
+  if (name == NULL)
+    abort ();
+
+  /* The compiler may generate BL instructions to local labels because
+     it needs to perform a branch to a far away location. These labels
+     do not have a corresponding ".real_start_of" label.  We check
+     both for S_IS_LOCAL and for a leading dot, to give a way to bypass
+     the ".real_start_of" convention for nonlocal branches.  */
+  if (S_IS_LOCAL (symbolP) || name[0] == '.')
+    return symbolP;
+
+  real_start = ACONCAT ((STUB_NAME, name, NULL));
+  new_target = symbol_find (real_start);
+
+  if (new_target == NULL)
+    {
+      as_warn (_("Failed to find real start of function: %s\n"), name);
+      new_target = symbolP;
+    }
+
+  return new_target;
+}
+#endif
+
+static void
+opcode_select (int width)
+{
+  switch (width)
+    {
+    case 16:
+      if (! thumb_mode)
+	{
+	  if (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v4t))
+	    as_bad (_("selected processor does not support THUMB opcodes"));
+
+	  thumb_mode = 1;
+	  /* No need to force the alignment, since we will have been
+	     coming from ARM mode, which is word-aligned.  */
+	  record_alignment (now_seg, 1);
+	}
+      break;
+
+    case 32:
+      if (thumb_mode)
+	{
+	  if (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v1))
+	    as_bad (_("selected processor does not support ARM opcodes"));
+
+	  thumb_mode = 0;
+
+	  if (!need_pass_2)
+	    frag_align (2, 0, 0);
+
+	  record_alignment (now_seg, 1);
+	}
+      break;
+
+    default:
+      as_bad (_("invalid instruction size selected (%d)"), width);
+    }
+}
+
+static void
+s_arm (int ignore ATTRIBUTE_UNUSED)
+{
+  opcode_select (32);
+  demand_empty_rest_of_line ();
+}
+
+static void
+s_thumb (int ignore ATTRIBUTE_UNUSED)
+{
+  opcode_select (16);
+  demand_empty_rest_of_line ();
+}
+
+static void
+s_code (int unused ATTRIBUTE_UNUSED)
+{
+  int temp;
+
+  temp = get_absolute_expression ();
+  switch (temp)
+    {
+    case 16:
+    case 32:
+      opcode_select (temp);
+      break;
+
+    default:
+      as_bad (_("invalid operand to .code directive (%d) (expecting 16 or 32)"), temp);
+    }
+}
+
+static void
+s_force_thumb (int ignore ATTRIBUTE_UNUSED)
+{
+  /* If we are not already in thumb mode go into it, EVEN if
+     the target processor does not support thumb instructions.
+     This is used by gcc/config/arm/lib1funcs.asm for example
+     to compile interworking support functions even if the
+     target processor should not support interworking.	*/
+  if (! thumb_mode)
+    {
+      thumb_mode = 2;
+      record_alignment (now_seg, 1);
+    }
+
+  demand_empty_rest_of_line ();
+}
+
+static void
+s_thumb_func (int ignore ATTRIBUTE_UNUSED)
+{
+  s_thumb (0);
+
+  /* The following label is the name/address of the start of a Thumb function.
+     We need to know this for the interworking support.	 */
+  label_is_thumb_function_name = TRUE;
+}
+
+/* Perform a .set directive, but also mark the alias as
+   being a thumb function.  */
+
+static void
+s_thumb_set (int equiv)
+{
+  /* XXX the following is a duplicate of the code for s_set() in read.c
+     We cannot just call that code as we need to get at the symbol that
+     is created.  */
+  char *    name;
+  char	    delim;
+  char *    end_name;
+  symbolS * symbolP;
+
+  /* Especial apologies for the random logic:
+     This just grew, and could be parsed much more simply!
+     Dean - in haste.  */
+  delim	    = get_symbol_name (& name);
+  end_name  = input_line_pointer;
+  (void) restore_line_pointer (delim);
+
+  if (*input_line_pointer != ',')
+    {
+      *end_name = 0;
+      as_bad (_("expected comma after name \"%s\""), name);
+      *end_name = delim;
+      ignore_rest_of_line ();
+      return;
+    }
+
+  input_line_pointer++;
+  *end_name = 0;
+
+  if (name[0] == '.' && name[1] == '\0')
+    {
+      /* XXX - this should not happen to .thumb_set.  */
+      abort ();
+    }
+
+  if ((symbolP = symbol_find (name)) == NULL
+      && (symbolP = md_undefined_symbol (name)) == NULL)
+    {
+#ifndef NO_LISTING
+      /* When doing symbol listings, play games with dummy fragments living
+	 outside the normal fragment chain to record the file and line info
+	 for this symbol.  */
+      if (listing & LISTING_SYMBOLS)
+	{
+	  extern struct list_info_struct * listing_tail;
+	  fragS * dummy_frag = (fragS * ) xmalloc (sizeof (fragS));
+
+	  memset (dummy_frag, 0, sizeof (fragS));
+	  dummy_frag->fr_type = rs_fill;
+	  dummy_frag->line = listing_tail;
+	  symbolP = symbol_new (name, undefined_section, 0, dummy_frag);
+	  dummy_frag->fr_symbol = symbolP;
+	}
+      else
+#endif
+	symbolP = symbol_new (name, undefined_section, 0, &zero_address_frag);
+
+#ifdef OBJ_COFF
+      /* "set" symbols are local unless otherwise specified.  */
+      SF_SET_LOCAL (symbolP);
+#endif /* OBJ_COFF  */
+    }				/* Make a new symbol.  */
+
+  symbol_table_insert (symbolP);
+
+  * end_name = delim;
+
+  if (equiv
+      && S_IS_DEFINED (symbolP)
+      && S_GET_SEGMENT (symbolP) != reg_section)
+    as_bad (_("symbol `%s' already defined"), S_GET_NAME (symbolP));
+
+  pseudo_set (symbolP);
+
+  demand_empty_rest_of_line ();
+
+  /* XXX Now we come to the Thumb specific bit of code.	 */
+
+  THUMB_SET_FUNC (symbolP, 1);
+  ARM_SET_THUMB (symbolP, 1);
+#if defined OBJ_ELF || defined OBJ_COFF
+  ARM_SET_INTERWORK (symbolP, support_interwork);
+#endif
+}
+
+/* Directives: Mode selection.  */
+
+/* .syntax [unified|divided] - choose the new unified syntax
+   (same for Arm and Thumb encoding, modulo slight differences in what
+   can be represented) or the old divergent syntax for each mode.  */
+static void
+s_syntax (int unused ATTRIBUTE_UNUSED)
+{
+  char *name, delim;
+
+  delim = get_symbol_name (& name);
+
+  if (!strcasecmp (name, "unified"))
+    unified_syntax = TRUE;
+  else if (!strcasecmp (name, "divided"))
+    unified_syntax = FALSE;
+  else
+    {
+      as_bad (_("unrecognized syntax mode \"%s\""), name);
+      return;
+    }
+  (void) restore_line_pointer (delim);
+  demand_empty_rest_of_line ();
+}
+
+/* Directives: sectioning and alignment.  */
+
+static void
+s_bss (int ignore ATTRIBUTE_UNUSED)
+{
+  /* We don't support putting frags in the BSS segment, we fake it by
+     marking in_bss, then looking at s_skip for clues.	*/
+  subseg_set (bss_section, 0);
+  demand_empty_rest_of_line ();
+
+#ifdef md_elf_section_change_hook
+  md_elf_section_change_hook ();
+#endif
+}
+
+static void
+s_even (int ignore ATTRIBUTE_UNUSED)
+{
+  /* Never make frag if expect extra pass.  */
+  if (!need_pass_2)
+    frag_align (1, 0, 0);
+
+  record_alignment (now_seg, 1);
+
+  demand_empty_rest_of_line ();
+}
+
+/* Directives: CodeComposer Studio.  */
+
+/*  .ref  (for CodeComposer Studio syntax only).  */
+static void
+s_ccs_ref (int unused ATTRIBUTE_UNUSED)
+{
+  if (codecomposer_syntax)
+    ignore_rest_of_line ();
+  else
+    as_bad (_(".ref pseudo-op only available with -mccs flag."));
+}
+
+/*  If name is not NULL, then it is used for marking the beginning of a
+    function, wherease if it is NULL then it means the function end.  */
+static void
+asmfunc_debug (const char * name)
+{
+  static const char * last_name = NULL;
+
+  if (name != NULL)
+    {
+      gas_assert (last_name == NULL);
+      last_name = name;
+
+      if (debug_type == DEBUG_STABS)
+         stabs_generate_asm_func (name, name);
+    }
+  else
+    {
+      gas_assert (last_name != NULL);
+
+      if (debug_type == DEBUG_STABS)
+        stabs_generate_asm_endfunc (last_name, last_name);
+
+      last_name = NULL;
+    }
+}
+
+static void
+s_ccs_asmfunc (int unused ATTRIBUTE_UNUSED)
+{
+  if (codecomposer_syntax)
+    {
+      switch (asmfunc_state)
+	{
+	case OUTSIDE_ASMFUNC:
+	  asmfunc_state = WAITING_ASMFUNC_NAME;
+	  break;
+
+	case WAITING_ASMFUNC_NAME:
+	  as_bad (_(".asmfunc repeated."));
+	  break;
+
+	case WAITING_ENDASMFUNC:
+	  as_bad (_(".asmfunc without function."));
+	  break;
+	}
+      demand_empty_rest_of_line ();
+    }
+  else
+    as_bad (_(".asmfunc pseudo-op only available with -mccs flag."));
+}
+
+static void
+s_ccs_endasmfunc (int unused ATTRIBUTE_UNUSED)
+{
+  if (codecomposer_syntax)
+    {
+      switch (asmfunc_state)
+	{
+	case OUTSIDE_ASMFUNC:
+	  as_bad (_(".endasmfunc without a .asmfunc."));
+	  break;
+
+	case WAITING_ASMFUNC_NAME:
+	  as_bad (_(".endasmfunc without function."));
+	  break;
+
+	case WAITING_ENDASMFUNC:
+	  asmfunc_state = OUTSIDE_ASMFUNC;
+	  asmfunc_debug (NULL);
+	  break;
+	}
+      demand_empty_rest_of_line ();
+    }
+  else
+    as_bad (_(".endasmfunc pseudo-op only available with -mccs flag."));
+}
+
+static void
+s_ccs_def (int name)
+{
+  if (codecomposer_syntax)
+    s_globl (name);
+  else
+    as_bad (_(".def pseudo-op only available with -mccs flag."));
+}
+
+/* Directives: Literal pools.  */
+
+static literal_pool *
+find_literal_pool (void)
+{
+  literal_pool * pool;
+
+  for (pool = list_of_pools; pool != NULL; pool = pool->next)
+    {
+      if (pool->section == now_seg
+	  && pool->sub_section == now_subseg)
+	break;
+    }
+
+  return pool;
+}
+
+static literal_pool *
+find_or_make_literal_pool (void)
+{
+  /* Next literal pool ID number.  */
+  static unsigned int latest_pool_num = 1;
+  literal_pool *      pool;
+
+  pool = find_literal_pool ();
+
+  if (pool == NULL)
+    {
+      /* Create a new pool.  */
+      pool = (literal_pool *) xmalloc (sizeof (* pool));
+      if (! pool)
+	return NULL;
+
+      pool->next_free_entry = 0;
+      pool->section	    = now_seg;
+      pool->sub_section	    = now_subseg;
+      pool->next	    = list_of_pools;
+      pool->symbol	    = NULL;
+      pool->alignment	    = 2;
+
+      /* Add it to the list.  */
+      list_of_pools = pool;
+    }
+
+  /* New pools, and emptied pools, will have a NULL symbol.  */
+  if (pool->symbol == NULL)
+    {
+      pool->symbol = symbol_create (FAKE_LABEL_NAME, undefined_section,
+				    (valueT) 0, &zero_address_frag);
+      pool->id = latest_pool_num ++;
+    }
+
+  /* Done.  */
+  return pool;
+}
+
+/* Add the literal in the global 'inst'
+   structure to the relevant literal pool.  */
+
+static int
+add_to_lit_pool (unsigned int nbytes)
+{
+#define PADDING_SLOT 0x1
+#define LIT_ENTRY_SIZE_MASK 0xFF
+  literal_pool * pool;
+  unsigned int entry, pool_size = 0;
+  bfd_boolean padding_slot_p = FALSE;
+  unsigned imm1 = 0;
+  unsigned imm2 = 0;
+
+  if (nbytes == 8)
+    {
+      imm1 = inst.operands[1].imm;
+      imm2 = (inst.operands[1].regisimm ? inst.operands[1].reg
+	       : inst.reloc.exp.X_unsigned ? 0
+	       : ((bfd_int64_t) inst.operands[1].imm) >> 32);
+      if (target_big_endian)
+	{
+	  imm1 = imm2;
+	  imm2 = inst.operands[1].imm;
+	}
+    }
+
+  pool = find_or_make_literal_pool ();
+
+  /* Check if this literal value is already in the pool.  */
+  for (entry = 0; entry < pool->next_free_entry; entry ++)
+    {
+      if (nbytes == 4)
+	{
+	  if ((pool->literals[entry].X_op == inst.reloc.exp.X_op)
+	      && (inst.reloc.exp.X_op == O_constant)
+	      && (pool->literals[entry].X_add_number
+		  == inst.reloc.exp.X_add_number)
+	      && (pool->literals[entry].X_md == nbytes)
+	      && (pool->literals[entry].X_unsigned
+		  == inst.reloc.exp.X_unsigned))
+	    break;
+
+	  if ((pool->literals[entry].X_op == inst.reloc.exp.X_op)
+	      && (inst.reloc.exp.X_op == O_symbol)
+	      && (pool->literals[entry].X_add_number
+		  == inst.reloc.exp.X_add_number)
+	      && (pool->literals[entry].X_add_symbol
+		  == inst.reloc.exp.X_add_symbol)
+	      && (pool->literals[entry].X_op_symbol
+		  == inst.reloc.exp.X_op_symbol)
+	      && (pool->literals[entry].X_md == nbytes))
+	    break;
+	}
+      else if ((nbytes == 8)
+	       && !(pool_size & 0x7)
+	       && ((entry + 1) != pool->next_free_entry)
+	       && (pool->literals[entry].X_op == O_constant)
+	       && (pool->literals[entry].X_add_number == (offsetT) imm1)
+	       && (pool->literals[entry].X_unsigned
+		   == inst.reloc.exp.X_unsigned)
+	       && (pool->literals[entry + 1].X_op == O_constant)
+	       && (pool->literals[entry + 1].X_add_number == (offsetT) imm2)
+	       && (pool->literals[entry + 1].X_unsigned
+		   == inst.reloc.exp.X_unsigned))
+	break;
+
+      padding_slot_p = ((pool->literals[entry].X_md >> 8) == PADDING_SLOT);
+      if (padding_slot_p && (nbytes == 4))
+	break;
+
+      pool_size += 4;
+    }
+
+  /* Do we need to create a new entry?	*/
+  if (entry == pool->next_free_entry)
+    {
+      if (entry >= MAX_LITERAL_POOL_SIZE)
+	{
+	  inst.error = _("literal pool overflow");
+	  return FAIL;
+	}
+
+      if (nbytes == 8)
+	{
+	  /* For 8-byte entries, we align to an 8-byte boundary,
+	     and split it into two 4-byte entries, because on 32-bit
+	     host, 8-byte constants are treated as big num, thus
+	     saved in "generic_bignum" which will be overwritten
+	     by later assignments.
+
+	     We also need to make sure there is enough space for
+	     the split.
+
+	     We also check to make sure the literal operand is a
+	     constant number.  */
+	  if (!(inst.reloc.exp.X_op == O_constant
+	        || inst.reloc.exp.X_op == O_big))
+	    {
+	      inst.error = _("invalid type for literal pool");
+	      return FAIL;
+	    }
+	  else if (pool_size & 0x7)
+	    {
+	      if ((entry + 2) >= MAX_LITERAL_POOL_SIZE)
+		{
+		  inst.error = _("literal pool overflow");
+		  return FAIL;
+		}
+
+	      pool->literals[entry] = inst.reloc.exp;
+	      pool->literals[entry].X_add_number = 0;
+	      pool->literals[entry++].X_md = (PADDING_SLOT << 8) | 4;
+	      pool->next_free_entry += 1;
+	      pool_size += 4;
+	    }
+	  else if ((entry + 1) >= MAX_LITERAL_POOL_SIZE)
+	    {
+	      inst.error = _("literal pool overflow");
+	      return FAIL;
+	    }
+
+	  pool->literals[entry] = inst.reloc.exp;
+	  pool->literals[entry].X_op = O_constant;
+	  pool->literals[entry].X_add_number = imm1;
+	  pool->literals[entry].X_unsigned = inst.reloc.exp.X_unsigned;
+	  pool->literals[entry++].X_md = 4;
+	  pool->literals[entry] = inst.reloc.exp;
+	  pool->literals[entry].X_op = O_constant;
+	  pool->literals[entry].X_add_number = imm2;
+	  pool->literals[entry].X_unsigned = inst.reloc.exp.X_unsigned;
+	  pool->literals[entry].X_md = 4;
+	  pool->alignment = 3;
+	  pool->next_free_entry += 1;
+	}
+      else
+	{
+	  pool->literals[entry] = inst.reloc.exp;
+	  pool->literals[entry].X_md = 4;
+	}
+
+#ifdef OBJ_ELF
+      /* PR ld/12974: Record the location of the first source line to reference
+	 this entry in the literal pool.  If it turns out during linking that the
+	 symbol does not exist we will be able to give an accurate line number for
+	 the (first use of the) missing reference.  */
+      if (debug_type == DEBUG_DWARF2)
+	dwarf2_where (pool->locs + entry);
+#endif
+      pool->next_free_entry += 1;
+    }
+  else if (padding_slot_p)
+    {
+      pool->literals[entry] = inst.reloc.exp;
+      pool->literals[entry].X_md = nbytes;
+    }
+
+  inst.reloc.exp.X_op	      = O_symbol;
+  inst.reloc.exp.X_add_number = pool_size;
+  inst.reloc.exp.X_add_symbol = pool->symbol;
+
+  return SUCCESS;
+}
+
+bfd_boolean
+tc_start_label_without_colon (void)
+{
+  bfd_boolean ret = TRUE;
+
+  if (codecomposer_syntax && asmfunc_state == WAITING_ASMFUNC_NAME)
+    {
+      const char *label = input_line_pointer;
+
+      while (!is_end_of_line[(int) label[-1]])
+	--label;
+
+      if (*label == '.')
+	{
+	  as_bad (_("Invalid label '%s'"), label);
+	  ret = FALSE;
+	}
+
+      asmfunc_debug (label);
+
+      asmfunc_state = WAITING_ENDASMFUNC;
+    }
+
+  return ret;
+}
+
+/* Can't use symbol_new here, so have to create a symbol and then at
+   a later date assign it a value. Thats what these functions do.  */
+
+static void
+symbol_locate (symbolS *    symbolP,
+	       const char * name,	/* It is copied, the caller can modify.	 */
+	       segT	    segment,	/* Segment identifier (SEG_<something>).  */
+	       valueT	    valu,	/* Symbol value.  */
+	       fragS *	    frag)	/* Associated fragment.	 */
+{
+  size_t name_length;
+  char * preserved_copy_of_name;
+
+  name_length = strlen (name) + 1;   /* +1 for \0.  */
+  obstack_grow (&notes, name, name_length);
+  preserved_copy_of_name = (char *) obstack_finish (&notes);
+
+#ifdef tc_canonicalize_symbol_name
+  preserved_copy_of_name =
+    tc_canonicalize_symbol_name (preserved_copy_of_name);
+#endif
+
+  S_SET_NAME (symbolP, preserved_copy_of_name);
+
+  S_SET_SEGMENT (symbolP, segment);
+  S_SET_VALUE (symbolP, valu);
+  symbol_clear_list_pointers (symbolP);
+
+  symbol_set_frag (symbolP, frag);
+
+  /* Link to end of symbol chain.  */
+  {
+    extern int symbol_table_frozen;
+
+    if (symbol_table_frozen)
+      abort ();
+  }
+
+  symbol_append (symbolP, symbol_lastP, & symbol_rootP, & symbol_lastP);
+
+  obj_symbol_new_hook (symbolP);
+
+#ifdef tc_symbol_new_hook
+  tc_symbol_new_hook (symbolP);
+#endif
+
+#ifdef DEBUG_SYMS
+  verify_symbol_chain (symbol_rootP, symbol_lastP);
+#endif /* DEBUG_SYMS  */
+}
+
+static void
+s_ltorg (int ignored ATTRIBUTE_UNUSED)
+{
+  unsigned int entry;
+  literal_pool * pool;
+  char sym_name[20];
+
+  pool = find_literal_pool ();
+  if (pool == NULL
+      || pool->symbol == NULL
+      || pool->next_free_entry == 0)
+    return;
+
+  /* Align pool as you have word accesses.
+     Only make a frag if we have to.  */
+  if (!need_pass_2)
+    frag_align (pool->alignment, 0, 0);
+
+  record_alignment (now_seg, 2);
+
+#ifdef OBJ_ELF
+  seg_info (now_seg)->tc_segment_info_data.mapstate = MAP_DATA;
+  make_mapping_symbol (MAP_DATA, (valueT) frag_now_fix (), frag_now);
+#endif
+  sprintf (sym_name, "$$lit_\002%x", pool->id);
+
+  symbol_locate (pool->symbol, sym_name, now_seg,
+		 (valueT) frag_now_fix (), frag_now);
+  symbol_table_insert (pool->symbol);
+
+  ARM_SET_THUMB (pool->symbol, thumb_mode);
+
+#if defined OBJ_COFF || defined OBJ_ELF
+  ARM_SET_INTERWORK (pool->symbol, support_interwork);
+#endif
+
+  for (entry = 0; entry < pool->next_free_entry; entry ++)
+    {
+#ifdef OBJ_ELF
+      if (debug_type == DEBUG_DWARF2)
+	dwarf2_gen_line_info (frag_now_fix (), pool->locs + entry);
+#endif
+      /* First output the expression in the instruction to the pool.  */
+      emit_expr (&(pool->literals[entry]),
+		 pool->literals[entry].X_md & LIT_ENTRY_SIZE_MASK);
+    }
+
+  /* Mark the pool as empty.  */
+  pool->next_free_entry = 0;
+  pool->symbol = NULL;
+}
+
+#ifdef OBJ_ELF
+/* Forward declarations for functions below, in the MD interface
+   section.  */
+static void fix_new_arm (fragS *, int, short, expressionS *, int, int);
+static valueT create_unwind_entry (int);
+static void start_unwind_section (const segT, int);
+static void add_unwind_opcode (valueT, int);
+static void flush_pending_unwind (void);
+
+/* Directives: Data.  */
+
+static void
+s_arm_elf_cons (int nbytes)
+{
+  expressionS exp;
+
+#ifdef md_flush_pending_output
+  md_flush_pending_output ();
+#endif
+
+  if (is_it_end_of_statement ())
+    {
+      demand_empty_rest_of_line ();
+      return;
+    }
+
+#ifdef md_cons_align
+  md_cons_align (nbytes);
+#endif
+
+  mapping_state (MAP_DATA);
+  do
+    {
+      int reloc;
+      char *base = input_line_pointer;
+
+      expression (& exp);
+
+      if (exp.X_op != O_symbol)
+	emit_expr (&exp, (unsigned int) nbytes);
+      else
+	{
+	  char *before_reloc = input_line_pointer;
+	  reloc = parse_reloc (&input_line_pointer);
+	  if (reloc == -1)
+	    {
+	      as_bad (_("unrecognized relocation suffix"));
+	      ignore_rest_of_line ();
+	      return;
+	    }
+	  else if (reloc == BFD_RELOC_UNUSED)
+	    emit_expr (&exp, (unsigned int) nbytes);
+	  else
+	    {
+	      reloc_howto_type *howto = (reloc_howto_type *)
+		  bfd_reloc_type_lookup (stdoutput,
+					 (bfd_reloc_code_real_type) reloc);
+	      int size = bfd_get_reloc_size (howto);
+
+	      if (reloc == BFD_RELOC_ARM_PLT32)
+		{
+		  as_bad (_("(plt) is only valid on branch targets"));
+		  reloc = BFD_RELOC_UNUSED;
+		  size = 0;
+		}
+
+	      if (size > nbytes)
+		as_bad (_("%s relocations do not fit in %d bytes"),
+			howto->name, nbytes);
+	      else
+		{
+		  /* We've parsed an expression stopping at O_symbol.
+		     But there may be more expression left now that we
+		     have parsed the relocation marker.  Parse it again.
+		     XXX Surely there is a cleaner way to do this.  */
+		  char *p = input_line_pointer;
+		  int offset;
+		  char *save_buf = (char *) alloca (input_line_pointer - base);
+		  memcpy (save_buf, base, input_line_pointer - base);
+		  memmove (base + (input_line_pointer - before_reloc),
+			   base, before_reloc - base);
+
+		  input_line_pointer = base + (input_line_pointer-before_reloc);
+		  expression (&exp);
+		  memcpy (base, save_buf, p - base);
+
+		  offset = nbytes - size;
+		  p = frag_more (nbytes);
+		  memset (p, 0, nbytes);
+		  fix_new_exp (frag_now, p - frag_now->fr_literal + offset,
+			       size, &exp, 0, (enum bfd_reloc_code_real) reloc);
+		}
+	    }
+	}
+    }
+  while (*input_line_pointer++ == ',');
+
+  /* Put terminator back into stream.  */
+  input_line_pointer --;
+  demand_empty_rest_of_line ();
+}
+
+/* Emit an expression containing a 32-bit thumb instruction.
+   Implementation based on put_thumb32_insn.  */
+
+static void
+emit_thumb32_expr (expressionS * exp)
+{
+  expressionS exp_high = *exp;
+
+  exp_high.X_add_number = (unsigned long)exp_high.X_add_number >> 16;
+  emit_expr (& exp_high, (unsigned int) THUMB_SIZE);
+  exp->X_add_number &= 0xffff;
+  emit_expr (exp, (unsigned int) THUMB_SIZE);
+}
+
+/*  Guess the instruction size based on the opcode.  */
+
+static int
+thumb_insn_size (int opcode)
+{
+  if ((unsigned int) opcode < 0xe800u)
+    return 2;
+  else if ((unsigned int) opcode >= 0xe8000000u)
+    return 4;
+  else
+    return 0;
+}
+
+static bfd_boolean
+emit_insn (expressionS *exp, int nbytes)
+{
+  int size = 0;
+
+  if (exp->X_op == O_constant)
+    {
+      size = nbytes;
+
+      if (size == 0)
+	size = thumb_insn_size (exp->X_add_number);
+
+      if (size != 0)
+	{
+	  if (size == 2 && (unsigned int)exp->X_add_number > 0xffffu)
+	    {
+	      as_bad (_(".inst.n operand too big. "\
+			"Use .inst.w instead"));
+	      size = 0;
+	    }
+	  else
+	    {
+	      if (now_it.state == AUTOMATIC_IT_BLOCK)
+		set_it_insn_type_nonvoid (OUTSIDE_IT_INSN, 0);
+	      else
+		set_it_insn_type_nonvoid (NEUTRAL_IT_INSN, 0);
+
+	      if (thumb_mode && (size > THUMB_SIZE) && !target_big_endian)
+		emit_thumb32_expr (exp);
+	      else
+		emit_expr (exp, (unsigned int) size);
+
+	      it_fsm_post_encode ();
+	    }
+	}
+      else
+	as_bad (_("cannot determine Thumb instruction size. "	\
+		  "Use .inst.n/.inst.w instead"));
+    }
+  else
+    as_bad (_("constant expression required"));
+
+  return (size != 0);
+}
+
+/* Like s_arm_elf_cons but do not use md_cons_align and
+   set the mapping state to MAP_ARM/MAP_THUMB.  */
+
+static void
+s_arm_elf_inst (int nbytes)
+{
+  if (is_it_end_of_statement ())
+    {
+      demand_empty_rest_of_line ();
+      return;
+    }
+
+  /* Calling mapping_state () here will not change ARM/THUMB,
+     but will ensure not to be in DATA state.  */
+
+  if (thumb_mode)
+    mapping_state (MAP_THUMB);
+  else
+    {
+      if (nbytes != 0)
+	{
+	  as_bad (_("width suffixes are invalid in ARM mode"));
+	  ignore_rest_of_line ();
+	  return;
+	}
+
+      nbytes = 4;
+
+      mapping_state (MAP_ARM);
+    }
+
+  do
+    {
+      expressionS exp;
+
+      expression (& exp);
+
+      if (! emit_insn (& exp, nbytes))
+	{
+	  ignore_rest_of_line ();
+	  return;
+	}
+    }
+  while (*input_line_pointer++ == ',');
+
+  /* Put terminator back into stream.  */
+  input_line_pointer --;
+  demand_empty_rest_of_line ();
+}
+
+/* Parse a .rel31 directive.  */
+
+static void
+s_arm_rel31 (int ignored ATTRIBUTE_UNUSED)
+{
+  expressionS exp;
+  char *p;
+  valueT highbit;
+
+  highbit = 0;
+  if (*input_line_pointer == '1')
+    highbit = 0x80000000;
+  else if (*input_line_pointer != '0')
+    as_bad (_("expected 0 or 1"));
+
+  input_line_pointer++;
+  if (*input_line_pointer != ',')
+    as_bad (_("missing comma"));
+  input_line_pointer++;
+
+#ifdef md_flush_pending_output
+  md_flush_pending_output ();
+#endif
+
+#ifdef md_cons_align
+  md_cons_align (4);
+#endif
+
+  mapping_state (MAP_DATA);
+
+  expression (&exp);
+
+  p = frag_more (4);
+  md_number_to_chars (p, highbit, 4);
+  fix_new_arm (frag_now, p - frag_now->fr_literal, 4, &exp, 1,
+	       BFD_RELOC_ARM_PREL31);
+
+  demand_empty_rest_of_line ();
+}
+
+/* Directives: AEABI stack-unwind tables.  */
+
+/* Parse an unwind_fnstart directive.  Simply records the current location.  */
+
+static void
+s_arm_unwind_fnstart (int ignored ATTRIBUTE_UNUSED)
+{
+  demand_empty_rest_of_line ();
+  if (unwind.proc_start)
+    {
+      as_bad (_("duplicate .fnstart directive"));
+      return;
+    }
+
+  /* Mark the start of the function.  */
+  unwind.proc_start = expr_build_dot ();
+
+  /* Reset the rest of the unwind info.	 */
+  unwind.opcode_count = 0;
+  unwind.table_entry = NULL;
+  unwind.personality_routine = NULL;
+  unwind.personality_index = -1;
+  unwind.frame_size = 0;
+  unwind.fp_offset = 0;
+  unwind.fp_reg = REG_SP;
+  unwind.fp_used = 0;
+  unwind.sp_restored = 0;
+}
+
+
+/* Parse a handlerdata directive.  Creates the exception handling table entry
+   for the function.  */
+
+static void
+s_arm_unwind_handlerdata (int ignored ATTRIBUTE_UNUSED)
+{
+  demand_empty_rest_of_line ();
+  if (!unwind.proc_start)
+    as_bad (MISSING_FNSTART);
+
+  if (unwind.table_entry)
+    as_bad (_("duplicate .handlerdata directive"));
+
+  create_unwind_entry (1);
+}
+
+/* Parse an unwind_fnend directive.  Generates the index table entry.  */
+
+static void
+s_arm_unwind_fnend (int ignored ATTRIBUTE_UNUSED)
+{
+  long where;
+  char *ptr;
+  valueT val;
+  unsigned int marked_pr_dependency;
+
+  demand_empty_rest_of_line ();
+
+  if (!unwind.proc_start)
+    {
+      as_bad (_(".fnend directive without .fnstart"));
+      return;
+    }
+
+  /* Add eh table entry.  */
+  if (unwind.table_entry == NULL)
+    val = create_unwind_entry (0);
+  else
+    val = 0;
+
+  /* Add index table entry.  This is two words.	 */
+  start_unwind_section (unwind.saved_seg, 1);
+  frag_align (2, 0, 0);
+  record_alignment (now_seg, 2);
+
+  ptr = frag_more (8);
+  memset (ptr, 0, 8);
+  where = frag_now_fix () - 8;
+
+  /* Self relative offset of the function start.  */
+  fix_new (frag_now, where, 4, unwind.proc_start, 0, 1,
+	   BFD_RELOC_ARM_PREL31);
+
+  /* Indicate dependency on EHABI-defined personality routines to the
+     linker, if it hasn't been done already.  */
+  marked_pr_dependency
+    = seg_info (now_seg)->tc_segment_info_data.marked_pr_dependency;
+  if (unwind.personality_index >= 0 && unwind.personality_index < 3
+      && !(marked_pr_dependency & (1 << unwind.personality_index)))
+    {
+      static const char *const name[] =
+	{
+	  "__aeabi_unwind_cpp_pr0",
+	  "__aeabi_unwind_cpp_pr1",
+	  "__aeabi_unwind_cpp_pr2"
+	};
+      symbolS *pr = symbol_find_or_make (name[unwind.personality_index]);
+      fix_new (frag_now, where, 0, pr, 0, 1, BFD_RELOC_NONE);
+      seg_info (now_seg)->tc_segment_info_data.marked_pr_dependency
+	|= 1 << unwind.personality_index;
+    }
+
+  if (val)
+    /* Inline exception table entry.  */
+    md_number_to_chars (ptr + 4, val, 4);
+  else
+    /* Self relative offset of the table entry.	 */
+    fix_new (frag_now, where + 4, 4, unwind.table_entry, 0, 1,
+	     BFD_RELOC_ARM_PREL31);
+
+  /* Restore the original section.  */
+  subseg_set (unwind.saved_seg, unwind.saved_subseg);
+
+  unwind.proc_start = NULL;
+}
+
+
+/* Parse an unwind_cantunwind directive.  */
+
+static void
+s_arm_unwind_cantunwind (int ignored ATTRIBUTE_UNUSED)
+{
+  demand_empty_rest_of_line ();
+  if (!unwind.proc_start)
+    as_bad (MISSING_FNSTART);
+
+  if (unwind.personality_routine || unwind.personality_index != -1)
+    as_bad (_("personality routine specified for cantunwind frame"));
+
+  unwind.personality_index = -2;
+}
+
+
+/* Parse a personalityindex directive.	*/
+
+static void
+s_arm_unwind_personalityindex (int ignored ATTRIBUTE_UNUSED)
+{
+  expressionS exp;
+
+  if (!unwind.proc_start)
+    as_bad (MISSING_FNSTART);
+
+  if (unwind.personality_routine || unwind.personality_index != -1)
+    as_bad (_("duplicate .personalityindex directive"));
+
+  expression (&exp);
+
+  if (exp.X_op != O_constant
+      || exp.X_add_number < 0 || exp.X_add_number > 15)
+    {
+      as_bad (_("bad personality routine number"));
+      ignore_rest_of_line ();
+      return;
+    }
+
+  unwind.personality_index = exp.X_add_number;
+
+  demand_empty_rest_of_line ();
+}
+
+
+/* Parse a personality directive.  */
+
+static void
+s_arm_unwind_personality (int ignored ATTRIBUTE_UNUSED)
+{
+  char *name, *p, c;
+
+  if (!unwind.proc_start)
+    as_bad (MISSING_FNSTART);
+
+  if (unwind.personality_routine || unwind.personality_index != -1)
+    as_bad (_("duplicate .personality directive"));
+
+  c = get_symbol_name (& name);
+  p = input_line_pointer;
+  if (c == '"')
+    ++ input_line_pointer;
+  unwind.personality_routine = symbol_find_or_make (name);
+  *p = c;
+  demand_empty_rest_of_line ();
+}
+
+
+/* Parse a directive saving core registers.  */
+
+static void
+s_arm_unwind_save_core (void)
+{
+  valueT op;
+  long range;
+  int n;
+
+  range = parse_reg_list (&input_line_pointer);
+  if (range == FAIL)
+    {
+      as_bad (_("expected register list"));
+      ignore_rest_of_line ();
+      return;
+    }
+
+  demand_empty_rest_of_line ();
+
+  /* Turn .unwind_movsp ip followed by .unwind_save {..., ip, ...}
+     into .unwind_save {..., sp...}.  We aren't bothered about the value of
+     ip because it is clobbered by calls.  */
+  if (unwind.sp_restored && unwind.fp_reg == 12
+      && (range & 0x3000) == 0x1000)
+    {
+      unwind.opcode_count--;
+      unwind.sp_restored = 0;
+      range = (range | 0x2000) & ~0x1000;
+      unwind.pending_offset = 0;
+    }
+
+  /* Pop r4-r15.  */
+  if (range & 0xfff0)
+    {
+      /* See if we can use the short opcodes.  These pop a block of up to 8
+	 registers starting with r4, plus maybe r14.  */
+      for (n = 0; n < 8; n++)
+	{
+	  /* Break at the first non-saved register.	 */
+	  if ((range & (1 << (n + 4))) == 0)
+	    break;
+	}
+      /* See if there are any other bits set.  */
+      if (n == 0 || (range & (0xfff0 << n) & 0xbff0) != 0)
+	{
+	  /* Use the long form.  */
+	  op = 0x8000 | ((range >> 4) & 0xfff);
+	  add_unwind_opcode (op, 2);
+	}
+      else
+	{
+	  /* Use the short form.  */
+	  if (range & 0x4000)
+	    op = 0xa8; /* Pop r14.	*/
+	  else
+	    op = 0xa0; /* Do not pop r14.  */
+	  op |= (n - 1);
+	  add_unwind_opcode (op, 1);
+	}
+    }
+
+  /* Pop r0-r3.	 */
+  if (range & 0xf)
+    {
+      op = 0xb100 | (range & 0xf);
+      add_unwind_opcode (op, 2);
+    }
+
+  /* Record the number of bytes pushed.	 */
+  for (n = 0; n < 16; n++)
+    {
+      if (range & (1 << n))
+	unwind.frame_size += 4;
+    }
+}
+
+
+/* Parse a directive saving FPA registers.  */
+
+static void
+s_arm_unwind_save_fpa (int reg)
+{
+  expressionS exp;
+  int num_regs;
+  valueT op;
+
+  /* Get Number of registers to transfer.  */
+  if (skip_past_comma (&input_line_pointer) != FAIL)
+    expression (&exp);
+  else
+    exp.X_op = O_illegal;
+
+  if (exp.X_op != O_constant)
+    {
+      as_bad (_("expected , <constant>"));
+      ignore_rest_of_line ();
+      return;
+    }
+
+  num_regs = exp.X_add_number;
+
+  if (num_regs < 1 || num_regs > 4)
+    {
+      as_bad (_("number of registers must be in the range [1:4]"));
+      ignore_rest_of_line ();
+      return;
+    }
+
+  demand_empty_rest_of_line ();
+
+  if (reg == 4)
+    {
+      /* Short form.  */
+      op = 0xb4 | (num_regs - 1);
+      add_unwind_opcode (op, 1);
+    }
+  else
+    {
+      /* Long form.  */
+      op = 0xc800 | (reg << 4) | (num_regs - 1);
+      add_unwind_opcode (op, 2);
+    }
+  unwind.frame_size += num_regs * 12;
+}
+
+
+/* Parse a directive saving VFP registers for ARMv6 and above.  */
+
+static void
+s_arm_unwind_save_vfp_armv6 (void)
+{
+  int count;
+  unsigned int start;
+  valueT op;
+  int num_vfpv3_regs = 0;
+  int num_regs_below_16;
+
+  count = parse_vfp_reg_list (&input_line_pointer, &start, REGLIST_VFP_D);
+  if (count == FAIL)
+    {
+      as_bad (_("expected register list"));
+      ignore_rest_of_line ();
+      return;
+    }
+
+  demand_empty_rest_of_line ();
+
+  /* We always generate FSTMD/FLDMD-style unwinding opcodes (rather
+     than FSTMX/FLDMX-style ones).  */
+
+  /* Generate opcode for (VFPv3) registers numbered in the range 16 .. 31.  */
+  if (start >= 16)
+    num_vfpv3_regs = count;
+  else if (start + count > 16)
+    num_vfpv3_regs = start + count - 16;
+
+  if (num_vfpv3_regs > 0)
+    {
+      int start_offset = start > 16 ? start - 16 : 0;
+      op = 0xc800 | (start_offset << 4) | (num_vfpv3_regs - 1);
+      add_unwind_opcode (op, 2);
+    }
+
+  /* Generate opcode for registers numbered in the range 0 .. 15.  */
+  num_regs_below_16 = num_vfpv3_regs > 0 ? 16 - (int) start : count;
+  gas_assert (num_regs_below_16 + num_vfpv3_regs == count);
+  if (num_regs_below_16 > 0)
+    {
+      op = 0xc900 | (start << 4) | (num_regs_below_16 - 1);
+      add_unwind_opcode (op, 2);
+    }
+
+  unwind.frame_size += count * 8;
+}
+
+
+/* Parse a directive saving VFP registers for pre-ARMv6.  */
+
+static void
+s_arm_unwind_save_vfp (void)
+{
+  int count;
+  unsigned int reg;
+  valueT op;
+
+  count = parse_vfp_reg_list (&input_line_pointer, &reg, REGLIST_VFP_D);
+  if (count == FAIL)
+    {
+      as_bad (_("expected register list"));
+      ignore_rest_of_line ();
+      return;
+    }
+
+  demand_empty_rest_of_line ();
+
+  if (reg == 8)
+    {
+      /* Short form.  */
+      op = 0xb8 | (count - 1);
+      add_unwind_opcode (op, 1);
+    }
+  else
+    {
+      /* Long form.  */
+      op = 0xb300 | (reg << 4) | (count - 1);
+      add_unwind_opcode (op, 2);
+    }
+  unwind.frame_size += count * 8 + 4;
+}
+
+
+/* Parse a directive saving iWMMXt data registers.  */
+
+static void
+s_arm_unwind_save_mmxwr (void)
+{
+  int reg;
+  int hi_reg;
+  int i;
+  unsigned mask = 0;
+  valueT op;
+
+  if (*input_line_pointer == '{')
+    input_line_pointer++;
+
+  do
+    {
+      reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWR);
+
+      if (reg == FAIL)
+	{
+	  as_bad ("%s", _(reg_expected_msgs[REG_TYPE_MMXWR]));
+	  goto error;
+	}
+
+      if (mask >> reg)
+	as_tsktsk (_("register list not in ascending order"));
+      mask |= 1 << reg;
+
+      if (*input_line_pointer == '-')
+	{
+	  input_line_pointer++;
+	  hi_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWR);
+	  if (hi_reg == FAIL)
+	    {
+	      as_bad ("%s", _(reg_expected_msgs[REG_TYPE_MMXWR]));
+	      goto error;
+	    }
+	  else if (reg >= hi_reg)
+	    {
+	      as_bad (_("bad register range"));
+	      goto error;
+	    }
+	  for (; reg < hi_reg; reg++)
+	    mask |= 1 << reg;
+	}
+    }
+  while (skip_past_comma (&input_line_pointer) != FAIL);
+
+  skip_past_char (&input_line_pointer, '}');
+
+  demand_empty_rest_of_line ();
+
+  /* Generate any deferred opcodes because we're going to be looking at
+     the list.	*/
+  flush_pending_unwind ();
+
+  for (i = 0; i < 16; i++)
+    {
+      if (mask & (1 << i))
+	unwind.frame_size += 8;
+    }
+
+  /* Attempt to combine with a previous opcode.	 We do this because gcc
+     likes to output separate unwind directives for a single block of
+     registers.	 */
+  if (unwind.opcode_count > 0)
+    {
+      i = unwind.opcodes[unwind.opcode_count - 1];
+      if ((i & 0xf8) == 0xc0)
+	{
+	  i &= 7;
+	  /* Only merge if the blocks are contiguous.  */
+	  if (i < 6)
+	    {
+	      if ((mask & 0xfe00) == (1 << 9))
+		{
+		  mask |= ((1 << (i + 11)) - 1) & 0xfc00;
+		  unwind.opcode_count--;
+		}
+	    }
+	  else if (i == 6 && unwind.opcode_count >= 2)
+	    {
+	      i = unwind.opcodes[unwind.opcode_count - 2];
+	      reg = i >> 4;
+	      i &= 0xf;
+
+	      op = 0xffff << (reg - 1);
+	      if (reg > 0
+		  && ((mask & op) == (1u << (reg - 1))))
+		{
+		  op = (1 << (reg + i + 1)) - 1;
+		  op &= ~((1 << reg) - 1);
+		  mask |= op;
+		  unwind.opcode_count -= 2;
+		}
+	    }
+	}
+    }
+
+  hi_reg = 15;
+  /* We want to generate opcodes in the order the registers have been
+     saved, ie. descending order.  */
+  for (reg = 15; reg >= -1; reg--)
+    {
+      /* Save registers in blocks.  */
+      if (reg < 0
+	  || !(mask & (1 << reg)))
+	{
+	  /* We found an unsaved reg.  Generate opcodes to save the
+	     preceding block.	*/
+	  if (reg != hi_reg)
+	    {
+	      if (reg == 9)
+		{
+		  /* Short form.  */
+		  op = 0xc0 | (hi_reg - 10);
+		  add_unwind_opcode (op, 1);
+		}
+	      else
+		{
+		  /* Long form.	 */
+		  op = 0xc600 | ((reg + 1) << 4) | ((hi_reg - reg) - 1);
+		  add_unwind_opcode (op, 2);
+		}
+	    }
+	  hi_reg = reg - 1;
+	}
+    }
+
+  return;
+error:
+  ignore_rest_of_line ();
+}
+
+static void
+s_arm_unwind_save_mmxwcg (void)
+{
+  int reg;
+  int hi_reg;
+  unsigned mask = 0;
+  valueT op;
+
+  if (*input_line_pointer == '{')
+    input_line_pointer++;
+
+  skip_whitespace (input_line_pointer);
+
+  do
+    {
+      reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWCG);
+
+      if (reg == FAIL)
+	{
+	  as_bad ("%s", _(reg_expected_msgs[REG_TYPE_MMXWCG]));
+	  goto error;
+	}
+
+      reg -= 8;
+      if (mask >> reg)
+	as_tsktsk (_("register list not in ascending order"));
+      mask |= 1 << reg;
+
+      if (*input_line_pointer == '-')
+	{
+	  input_line_pointer++;
+	  hi_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWCG);
+	  if (hi_reg == FAIL)
+	    {
+	      as_bad ("%s", _(reg_expected_msgs[REG_TYPE_MMXWCG]));
+	      goto error;
+	    }
+	  else if (reg >= hi_reg)
+	    {
+	      as_bad (_("bad register range"));
+	      goto error;
+	    }
+	  for (; reg < hi_reg; reg++)
+	    mask |= 1 << reg;
+	}
+    }
+  while (skip_past_comma (&input_line_pointer) != FAIL);
+
+  skip_past_char (&input_line_pointer, '}');
+
+  demand_empty_rest_of_line ();
+
+  /* Generate any deferred opcodes because we're going to be looking at
+     the list.	*/
+  flush_pending_unwind ();
+
+  for (reg = 0; reg < 16; reg++)
+    {
+      if (mask & (1 << reg))
+	unwind.frame_size += 4;
+    }
+  op = 0xc700 | mask;
+  add_unwind_opcode (op, 2);
+  return;
+error:
+  ignore_rest_of_line ();
+}
+
+
+/* Parse an unwind_save directive.
+   If the argument is non-zero, this is a .vsave directive.  */
+
+static void
+s_arm_unwind_save (int arch_v6)
+{
+  char *peek;
+  struct reg_entry *reg;
+  bfd_boolean had_brace = FALSE;
+
+  if (!unwind.proc_start)
+    as_bad (MISSING_FNSTART);
+
+  /* Figure out what sort of save we have.  */
+  peek = input_line_pointer;
+
+  if (*peek == '{')
+    {
+      had_brace = TRUE;
+      peek++;
+    }
+
+  reg = arm_reg_parse_multi (&peek);
+
+  if (!reg)
+    {
+      as_bad (_("register expected"));
+      ignore_rest_of_line ();
+      return;
+    }
+
+  switch (reg->type)
+    {
+    case REG_TYPE_FN:
+      if (had_brace)
+	{
+	  as_bad (_("FPA .unwind_save does not take a register list"));
+	  ignore_rest_of_line ();
+	  return;
+	}
+      input_line_pointer = peek;
+      s_arm_unwind_save_fpa (reg->number);
+      return;
+
+    case REG_TYPE_RN:
+      s_arm_unwind_save_core ();
+      return;
+
+    case REG_TYPE_VFD:
+      if (arch_v6)
+	s_arm_unwind_save_vfp_armv6 ();
+      else
+	s_arm_unwind_save_vfp ();
+      return;
+
+    case REG_TYPE_MMXWR:
+      s_arm_unwind_save_mmxwr ();
+      return;
+
+    case REG_TYPE_MMXWCG:
+      s_arm_unwind_save_mmxwcg ();
+      return;
+
+    default:
+      as_bad (_(".unwind_save does not support this kind of register"));
+      ignore_rest_of_line ();
+    }
+}
+
+
+/* Parse an unwind_movsp directive.  */
+
+static void
+s_arm_unwind_movsp (int ignored ATTRIBUTE_UNUSED)
+{
+  int reg;
+  valueT op;
+  int offset;
+
+  if (!unwind.proc_start)
+    as_bad (MISSING_FNSTART);
+
+  reg = arm_reg_parse (&input_line_pointer, REG_TYPE_RN);
+  if (reg == FAIL)
+    {
+      as_bad ("%s", _(reg_expected_msgs[REG_TYPE_RN]));
+      ignore_rest_of_line ();
+      return;
+    }
+
+  /* Optional constant.	 */
+  if (skip_past_comma (&input_line_pointer) != FAIL)
+    {
+      if (immediate_for_directive (&offset) == FAIL)
+	return;
+    }
+  else
+    offset = 0;
+
+  demand_empty_rest_of_line ();
+
+  if (reg == REG_SP || reg == REG_PC)
+    {
+      as_bad (_("SP and PC not permitted in .unwind_movsp directive"));
+      return;
+    }
+
+  if (unwind.fp_reg != REG_SP)
+    as_bad (_("unexpected .unwind_movsp directive"));
+
+  /* Generate opcode to restore the value.  */
+  op = 0x90 | reg;
+  add_unwind_opcode (op, 1);
+
+  /* Record the information for later.	*/
+  unwind.fp_reg = reg;
+  unwind.fp_offset = unwind.frame_size - offset;
+  unwind.sp_restored = 1;
+}
+
+/* Parse an unwind_pad directive.  */
+
+static void
+s_arm_unwind_pad (int ignored ATTRIBUTE_UNUSED)
+{
+  int offset;
+
+  if (!unwind.proc_start)
+    as_bad (MISSING_FNSTART);
+
+  if (immediate_for_directive (&offset) == FAIL)
+    return;
+
+  if (offset & 3)
+    {
+      as_bad (_("stack increment must be multiple of 4"));
+      ignore_rest_of_line ();
+      return;
+    }
+
+  /* Don't generate any opcodes, just record the details for later.  */
+  unwind.frame_size += offset;
+  unwind.pending_offset += offset;
+
+  demand_empty_rest_of_line ();
+}
+
+/* Parse an unwind_setfp directive.  */
+
+static void
+s_arm_unwind_setfp (int ignored ATTRIBUTE_UNUSED)
+{
+  int sp_reg;
+  int fp_reg;
+  int offset;
+
+  if (!unwind.proc_start)
+    as_bad (MISSING_FNSTART);
+
+  fp_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_RN);
+  if (skip_past_comma (&input_line_pointer) == FAIL)
+    sp_reg = FAIL;
+  else
+    sp_reg = arm_reg_parse (&input_line_pointer, REG_TYPE_RN);
+
+  if (fp_reg == FAIL || sp_reg == FAIL)
+    {
+      as_bad (_("expected <reg>, <reg>"));
+      ignore_rest_of_line ();
+      return;
+    }
+
+  /* Optional constant.	 */
+  if (skip_past_comma (&input_line_pointer) != FAIL)
+    {
+      if (immediate_for_directive (&offset) == FAIL)
+	return;
+    }
+  else
+    offset = 0;
+
+  demand_empty_rest_of_line ();
+
+  if (sp_reg != REG_SP && sp_reg != unwind.fp_reg)
+    {
+      as_bad (_("register must be either sp or set by a previous"
+		"unwind_movsp directive"));
+      return;
+    }
+
+  /* Don't generate any opcodes, just record the information for later.	 */
+  unwind.fp_reg = fp_reg;
+  unwind.fp_used = 1;
+  if (sp_reg == REG_SP)
+    unwind.fp_offset = unwind.frame_size - offset;
+  else
+    unwind.fp_offset -= offset;
+}
+
+/* Parse an unwind_raw directive.  */
+
+static void
+s_arm_unwind_raw (int ignored ATTRIBUTE_UNUSED)
+{
+  expressionS exp;
+  /* This is an arbitrary limit.	 */
+  unsigned char op[16];
+  int count;
+
+  if (!unwind.proc_start)
+    as_bad (MISSING_FNSTART);
+
+  expression (&exp);
+  if (exp.X_op == O_constant
+      && skip_past_comma (&input_line_pointer) != FAIL)
+    {
+      unwind.frame_size += exp.X_add_number;
+      expression (&exp);
+    }
+  else
+    exp.X_op = O_illegal;
+
+  if (exp.X_op != O_constant)
+    {
+      as_bad (_("expected <offset>, <opcode>"));
+      ignore_rest_of_line ();
+      return;
+    }
+
+  count = 0;
+
+  /* Parse the opcode.	*/
+  for (;;)
+    {
+      if (count >= 16)
+	{
+	  as_bad (_("unwind opcode too long"));
+	  ignore_rest_of_line ();
+	}
+      if (exp.X_op != O_constant || exp.X_add_number & ~0xff)
+	{
+	  as_bad (_("invalid unwind opcode"));
+	  ignore_rest_of_line ();
+	  return;
+	}
+      op[count++] = exp.X_add_number;
+
+      /* Parse the next byte.  */
+      if (skip_past_comma (&input_line_pointer) == FAIL)
+	break;
+
+      expression (&exp);
+    }
+
+  /* Add the opcode bytes in reverse order.  */
+  while (count--)
+    add_unwind_opcode (op[count], 1);
+
+  demand_empty_rest_of_line ();
+}
+
+
+/* Parse a .eabi_attribute directive.  */
+
+static void
+s_arm_eabi_attribute (int ignored ATTRIBUTE_UNUSED)
+{
+  int tag = obj_elf_vendor_attribute (OBJ_ATTR_PROC);
+
+  if (tag < NUM_KNOWN_OBJ_ATTRIBUTES)
+    attributes_set_explicitly[tag] = 1;
+}
+
+/* Emit a tls fix for the symbol.  */
+
+static void
+s_arm_tls_descseq (int ignored ATTRIBUTE_UNUSED)
+{
+  char *p;
+  expressionS exp;
+#ifdef md_flush_pending_output
+  md_flush_pending_output ();
+#endif
+
+#ifdef md_cons_align
+  md_cons_align (4);
+#endif
+
+  /* Since we're just labelling the code, there's no need to define a
+     mapping symbol.  */
+  expression (&exp);
+  p = obstack_next_free (&frchain_now->frch_obstack);
+  fix_new_arm (frag_now, p - frag_now->fr_literal, 4, &exp, 0,
+	       thumb_mode ? BFD_RELOC_ARM_THM_TLS_DESCSEQ
+	       : BFD_RELOC_ARM_TLS_DESCSEQ);
+}
+#endif /* OBJ_ELF */
+
+static void s_arm_arch (int);
+static void s_arm_object_arch (int);
+static void s_arm_cpu (int);
+static void s_arm_fpu (int);
+static void s_arm_arch_extension (int);
+
+#ifdef TE_PE
+
+static void
+pe_directive_secrel (int dummy ATTRIBUTE_UNUSED)
+{
+  expressionS exp;
+
+  do
+    {
+      expression (&exp);
+      if (exp.X_op == O_symbol)
+	exp.X_op = O_secrel;
+
+      emit_expr (&exp, 4);
+    }
+  while (*input_line_pointer++ == ',');
+
+  input_line_pointer--;
+  demand_empty_rest_of_line ();
+}
+#endif /* TE_PE */
+
+/* This table describes all the machine specific pseudo-ops the assembler
+   has to support.  The fields are:
+     pseudo-op name without dot
+     function to call to execute this pseudo-op
+     Integer arg to pass to the function.  */
+
+const pseudo_typeS md_pseudo_table[] =
+{
+  /* Never called because '.req' does not start a line.	 */
+  { "req",	   s_req,	  0 },
+  /* Following two are likewise never called.  */
+  { "dn",	   s_dn,          0 },
+  { "qn",          s_qn,          0 },
+  { "unreq",	   s_unreq,	  0 },
+  { "bss",	   s_bss,	  0 },
+  { "align",	   s_align_ptwo,  2 },
+  { "arm",	   s_arm,	  0 },
+  { "thumb",	   s_thumb,	  0 },
+  { "code",	   s_code,	  0 },
+  { "force_thumb", s_force_thumb, 0 },
+  { "thumb_func",  s_thumb_func,  0 },
+  { "thumb_set",   s_thumb_set,	  0 },
+  { "even",	   s_even,	  0 },
+  { "ltorg",	   s_ltorg,	  0 },
+  { "pool",	   s_ltorg,	  0 },
+  { "syntax",	   s_syntax,	  0 },
+  { "cpu",	   s_arm_cpu,	  0 },
+  { "arch",	   s_arm_arch,	  0 },
+  { "object_arch", s_arm_object_arch,	0 },
+  { "fpu",	   s_arm_fpu,	  0 },
+  { "arch_extension", s_arm_arch_extension, 0 },
+#ifdef OBJ_ELF
+  { "word",	        s_arm_elf_cons, 4 },
+  { "long",	        s_arm_elf_cons, 4 },
+  { "inst.n",           s_arm_elf_inst, 2 },
+  { "inst.w",           s_arm_elf_inst, 4 },
+  { "inst",             s_arm_elf_inst, 0 },
+  { "rel31",	        s_arm_rel31,	  0 },
+  { "fnstart",		s_arm_unwind_fnstart,	0 },
+  { "fnend",		s_arm_unwind_fnend,	0 },
+  { "cantunwind",	s_arm_unwind_cantunwind, 0 },
+  { "personality",	s_arm_unwind_personality, 0 },
+  { "personalityindex",	s_arm_unwind_personalityindex, 0 },
+  { "handlerdata",	s_arm_unwind_handlerdata, 0 },
+  { "save",		s_arm_unwind_save,	0 },
+  { "vsave",		s_arm_unwind_save,	1 },
+  { "movsp",		s_arm_unwind_movsp,	0 },
+  { "pad",		s_arm_unwind_pad,	0 },
+  { "setfp",		s_arm_unwind_setfp,	0 },
+  { "unwind_raw",	s_arm_unwind_raw,	0 },
+  { "eabi_attribute",	s_arm_eabi_attribute,	0 },
+  { "tlsdescseq",	s_arm_tls_descseq,      0 },
+#else
+  { "word",	   cons, 4},
+
+  /* These are used for dwarf.  */
+  {"2byte", cons, 2},
+  {"4byte", cons, 4},
+  {"8byte", cons, 8},
+  /* These are used for dwarf2.  */
+  { "file", (void (*) (int)) dwarf2_directive_file, 0 },
+  { "loc",  dwarf2_directive_loc,  0 },
+  { "loc_mark_labels", dwarf2_directive_loc_mark_labels, 0 },
+#endif
+  { "extend",	   float_cons, 'x' },
+  { "ldouble",	   float_cons, 'x' },
+  { "packed",	   float_cons, 'p' },
+#ifdef TE_PE
+  {"secrel32", pe_directive_secrel, 0},
+#endif
+
+  /* These are for compatibility with CodeComposer Studio.  */
+  {"ref",          s_ccs_ref,        0},
+  {"def",          s_ccs_def,        0},
+  {"asmfunc",      s_ccs_asmfunc,    0},
+  {"endasmfunc",   s_ccs_endasmfunc, 0},
+
+  { 0, 0, 0 }
+};
+
+/* Parser functions used exclusively in instruction operands.  */
+
+/* Generic immediate-value read function for use in insn parsing.
+   STR points to the beginning of the immediate (the leading #);
+   VAL receives the value; if the value is outside [MIN, MAX]
+   issue an error.  PREFIX_OPT is true if the immediate prefix is
+   optional.  */
+
+static int
+parse_immediate (char **str, int *val, int min, int max,
+		 bfd_boolean prefix_opt)
+{
+  expressionS exp;
+  my_get_expression (&exp, str, prefix_opt ? GE_OPT_PREFIX : GE_IMM_PREFIX);
+  if (exp.X_op != O_constant)
+    {
+      inst.error = _("constant expression required");
+      return FAIL;
+    }
+
+  if (exp.X_add_number < min || exp.X_add_number > max)
+    {
+      inst.error = _("immediate value out of range");
+      return FAIL;
+    }
+
+  *val = exp.X_add_number;
+  return SUCCESS;
+}
+
+/* Less-generic immediate-value read function with the possibility of loading a
+   big (64-bit) immediate, as required by Neon VMOV, VMVN and logic immediate
+   instructions. Puts the result directly in inst.operands[i].  */
+
+static int
+parse_big_immediate (char **str, int i, expressionS *in_exp,
+		     bfd_boolean allow_symbol_p)
+{
+  expressionS exp;
+  expressionS *exp_p = in_exp ? in_exp : &exp;
+  char *ptr = *str;
+
+  my_get_expression (exp_p, &ptr, GE_OPT_PREFIX_BIG);
+
+  if (exp_p->X_op == O_constant)
+    {
+      inst.operands[i].imm = exp_p->X_add_number & 0xffffffff;
+      /* If we're on a 64-bit host, then a 64-bit number can be returned using
+	 O_constant.  We have to be careful not to break compilation for
+	 32-bit X_add_number, though.  */
+      if ((exp_p->X_add_number & ~(offsetT)(0xffffffffU)) != 0)
+	{
+	  /* X >> 32 is illegal if sizeof (exp_p->X_add_number) == 4.  */
+	  inst.operands[i].reg = (((exp_p->X_add_number >> 16) >> 16)
+				  & 0xffffffff);
+	  inst.operands[i].regisimm = 1;
+	}
+    }
+  else if (exp_p->X_op == O_big
+	   && LITTLENUM_NUMBER_OF_BITS * exp_p->X_add_number > 32)
+    {
+      unsigned parts = 32 / LITTLENUM_NUMBER_OF_BITS, j, idx = 0;
+
+      /* Bignums have their least significant bits in
+	 generic_bignum[0]. Make sure we put 32 bits in imm and
+	 32 bits in reg,  in a (hopefully) portable way.  */
+      gas_assert (parts != 0);
+
+      /* Make sure that the number is not too big.
+	 PR 11972: Bignums can now be sign-extended to the
+	 size of a .octa so check that the out of range bits
+	 are all zero or all one.  */
+      if (LITTLENUM_NUMBER_OF_BITS * exp_p->X_add_number > 64)
+	{
+	  LITTLENUM_TYPE m = -1;
+
+	  if (generic_bignum[parts * 2] != 0
+	      && generic_bignum[parts * 2] != m)
+	    return FAIL;
+
+	  for (j = parts * 2 + 1; j < (unsigned) exp_p->X_add_number; j++)
+	    if (generic_bignum[j] != generic_bignum[j-1])
+	      return FAIL;
+	}
+
+      inst.operands[i].imm = 0;
+      for (j = 0; j < parts; j++, idx++)
+	inst.operands[i].imm |= generic_bignum[idx]
+				<< (LITTLENUM_NUMBER_OF_BITS * j);
+      inst.operands[i].reg = 0;
+      for (j = 0; j < parts; j++, idx++)
+	inst.operands[i].reg |= generic_bignum[idx]
+				<< (LITTLENUM_NUMBER_OF_BITS * j);
+      inst.operands[i].regisimm = 1;
+    }
+  else if (!(exp_p->X_op == O_symbol && allow_symbol_p))
+    return FAIL;
+
+  *str = ptr;
+
+  return SUCCESS;
+}
+
+/* Returns the pseudo-register number of an FPA immediate constant,
+   or FAIL if there isn't a valid constant here.  */
+
+static int
+parse_fpa_immediate (char ** str)
+{
+  LITTLENUM_TYPE words[MAX_LITTLENUMS];
+  char *	 save_in;
+  expressionS	 exp;
+  int		 i;
+  int		 j;
+
+  /* First try and match exact strings, this is to guarantee
+     that some formats will work even for cross assembly.  */
+
+  for (i = 0; fp_const[i]; i++)
+    {
+      if (strncmp (*str, fp_const[i], strlen (fp_const[i])) == 0)
+	{
+	  char *start = *str;
+
+	  *str += strlen (fp_const[i]);
+	  if (is_end_of_line[(unsigned char) **str])
+	    return i + 8;
+	  *str = start;
+	}
+    }
+
+  /* Just because we didn't get a match doesn't mean that the constant
+     isn't valid, just that it is in a format that we don't
+     automatically recognize.  Try parsing it with the standard
+     expression routines.  */
+
+  memset (words, 0, MAX_LITTLENUMS * sizeof (LITTLENUM_TYPE));
+
+  /* Look for a raw floating point number.  */
+  if ((save_in = atof_ieee (*str, 'x', words)) != NULL
+      && is_end_of_line[(unsigned char) *save_in])
+    {
+      for (i = 0; i < NUM_FLOAT_VALS; i++)
+	{
+	  for (j = 0; j < MAX_LITTLENUMS; j++)
+	    {
+	      if (words[j] != fp_values[i][j])
+		break;
+	    }
+
+	  if (j == MAX_LITTLENUMS)
+	    {
+	      *str = save_in;
+	      return i + 8;
+	    }
+	}
+    }
+
+  /* Try and parse a more complex expression, this will probably fail
+     unless the code uses a floating point prefix (eg "0f").  */
+  save_in = input_line_pointer;
+  input_line_pointer = *str;
+  if (expression (&exp) == absolute_section
+      && exp.X_op == O_big
+      && exp.X_add_number < 0)
+    {
+      /* FIXME: 5 = X_PRECISION, should be #define'd where we can use it.
+	 Ditto for 15.	*/
+#define X_PRECISION 5
+#define E_PRECISION 15L
+      if (gen_to_words (words, X_PRECISION, E_PRECISION) == 0)
+	{
+	  for (i = 0; i < NUM_FLOAT_VALS; i++)
+	    {
+	      for (j = 0; j < MAX_LITTLENUMS; j++)
+		{
+		  if (words[j] != fp_values[i][j])
+		    break;
+		}
+
+	      if (j == MAX_LITTLENUMS)
+		{
+		  *str = input_line_pointer;
+		  input_line_pointer = save_in;
+		  return i + 8;
+		}
+	    }
+	}
+    }
+
+  *str = input_line_pointer;
+  input_line_pointer = save_in;
+  inst.error = _("invalid FPA immediate expression");
+  return FAIL;
+}
+
+/* Returns 1 if a number has "quarter-precision" float format
+   0baBbbbbbc defgh000 00000000 00000000.  */
+
+static int
+is_quarter_float (unsigned imm)
+{
+  int bs = (imm & 0x20000000) ? 0x3e000000 : 0x40000000;
+  return (imm & 0x7ffff) == 0 && ((imm & 0x7e000000) ^ bs) == 0;
+}
+
+
+/* Detect the presence of a floating point or integer zero constant,
+   i.e. #0.0 or #0.  */
+
+static bfd_boolean
+parse_ifimm_zero (char **in)
+{
+  int error_code;
+
+  if (!is_immediate_prefix (**in))
+    return FALSE;
+
+  ++*in;
+
+  /* Accept #0x0 as a synonym for #0.  */
+  if (strncmp (*in, "0x", 2) == 0)
+    {
+      int val;
+      if (parse_immediate (in, &val, 0, 0, TRUE) == FAIL)
+        return FALSE;
+      return TRUE;
+    }
+
+  error_code = atof_generic (in, ".", EXP_CHARS,
+                             &generic_floating_point_number);
+
+  if (!error_code
+      && generic_floating_point_number.sign == '+'
+      && (generic_floating_point_number.low
+          > generic_floating_point_number.leader))
+    return TRUE;
+
+  return FALSE;
+}
+
+/* Parse an 8-bit "quarter-precision" floating point number of the form:
+   0baBbbbbbc defgh000 00000000 00000000.
+   The zero and minus-zero cases need special handling, since they can't be
+   encoded in the "quarter-precision" float format, but can nonetheless be
+   loaded as integer constants.  */
+
+static unsigned
+parse_qfloat_immediate (char **ccp, int *immed)
+{
+  char *str = *ccp;
+  char *fpnum;
+  LITTLENUM_TYPE words[MAX_LITTLENUMS];
+  int found_fpchar = 0;
+
+  skip_past_char (&str, '#');
+
+  /* We must not accidentally parse an integer as a floating-point number. Make
+     sure that the value we parse is not an integer by checking for special
+     characters '.' or 'e'.
+     FIXME: This is a horrible hack, but doing better is tricky because type
+     information isn't in a very usable state at parse time.  */
+  fpnum = str;
+  skip_whitespace (fpnum);
+
+  if (strncmp (fpnum, "0x", 2) == 0)
+    return FAIL;
+  else
+    {
+      for (; *fpnum != '\0' && *fpnum != ' ' && *fpnum != '\n'; fpnum++)
+	if (*fpnum == '.' || *fpnum == 'e' || *fpnum == 'E')
+	  {
+	    found_fpchar = 1;
+	    break;
+	  }
+
+      if (!found_fpchar)
+	return FAIL;
+    }
+
+  if ((str = atof_ieee (str, 's', words)) != NULL)
+    {
+      unsigned fpword = 0;
+      int i;
+
+      /* Our FP word must be 32 bits (single-precision FP).  */
+      for (i = 0; i < 32 / LITTLENUM_NUMBER_OF_BITS; i++)
+	{
+	  fpword <<= LITTLENUM_NUMBER_OF_BITS;
+	  fpword |= words[i];
+	}
+
+      if (is_quarter_float (fpword) || (fpword & 0x7fffffff) == 0)
+	*immed = fpword;
+      else
+	return FAIL;
+
+      *ccp = str;
+
+      return SUCCESS;
+    }
+
+  return FAIL;
+}
+
+/* Shift operands.  */
+enum shift_kind
+{
+  SHIFT_LSL, SHIFT_LSR, SHIFT_ASR, SHIFT_ROR, SHIFT_RRX
+};
+
+struct asm_shift_name
+{
+  const char	  *name;
+  enum shift_kind  kind;
+};
+
+/* Third argument to parse_shift.  */
+enum parse_shift_mode
+{
+  NO_SHIFT_RESTRICT,		/* Any kind of shift is accepted.  */
+  SHIFT_IMMEDIATE,		/* Shift operand must be an immediate.	*/
+  SHIFT_LSL_OR_ASR_IMMEDIATE,	/* Shift must be LSL or ASR immediate.	*/
+  SHIFT_ASR_IMMEDIATE,		/* Shift must be ASR immediate.	 */
+  SHIFT_LSL_IMMEDIATE,		/* Shift must be LSL immediate.	 */
+};
+
+/* Parse a <shift> specifier on an ARM data processing instruction.
+   This has three forms:
+
+     (LSL|LSR|ASL|ASR|ROR) Rs
+     (LSL|LSR|ASL|ASR|ROR) #imm
+     RRX
+
+   Note that ASL is assimilated to LSL in the instruction encoding, and
+   RRX to ROR #0 (which cannot be written as such).  */
+
+static int
+parse_shift (char **str, int i, enum parse_shift_mode mode)
+{
+  const struct asm_shift_name *shift_name;
+  enum shift_kind shift;
+  char *s = *str;
+  char *p = s;
+  int reg;
+
+  for (p = *str; ISALPHA (*p); p++)
+    ;
+
+  if (p == *str)
+    {
+      inst.error = _("shift expression expected");
+      return FAIL;
+    }
+
+  shift_name = (const struct asm_shift_name *) hash_find_n (arm_shift_hsh, *str,
+							    p - *str);
+
+  if (shift_name == NULL)
+    {
+      inst.error = _("shift expression expected");
+      return FAIL;
+    }
+
+  shift = shift_name->kind;
+
+  switch (mode)
+    {
+    case NO_SHIFT_RESTRICT:
+    case SHIFT_IMMEDIATE:   break;
+
+    case SHIFT_LSL_OR_ASR_IMMEDIATE:
+      if (shift != SHIFT_LSL && shift != SHIFT_ASR)
+	{
+	  inst.error = _("'LSL' or 'ASR' required");
+	  return FAIL;
+	}
+      break;
+
+    case SHIFT_LSL_IMMEDIATE:
+      if (shift != SHIFT_LSL)
+	{
+	  inst.error = _("'LSL' required");
+	  return FAIL;
+	}
+      break;
+
+    case SHIFT_ASR_IMMEDIATE:
+      if (shift != SHIFT_ASR)
+	{
+	  inst.error = _("'ASR' required");
+	  return FAIL;
+	}
+      break;
+
+    default: abort ();
+    }
+
+  if (shift != SHIFT_RRX)
+    {
+      /* Whitespace can appear here if the next thing is a bare digit.	*/
+      skip_whitespace (p);
+
+      if (mode == NO_SHIFT_RESTRICT
+	  && (reg = arm_reg_parse (&p, REG_TYPE_RN)) != FAIL)
+	{
+	  inst.operands[i].imm = reg;
+	  inst.operands[i].immisreg = 1;
+	}
+      else if (my_get_expression (&inst.reloc.exp, &p, GE_IMM_PREFIX))
+	return FAIL;
+    }
+  inst.operands[i].shift_kind = shift;
+  inst.operands[i].shifted = 1;
+  *str = p;
+  return SUCCESS;
+}
+
+/* Parse a <shifter_operand> for an ARM data processing instruction:
+
+      #<immediate>
+      #<immediate>, <rotate>
+      <Rm>
+      <Rm>, <shift>
+
+   where <shift> is defined by parse_shift above, and <rotate> is a
+   multiple of 2 between 0 and 30.  Validation of immediate operands
+   is deferred to md_apply_fix.  */
+
+static int
+parse_shifter_operand (char **str, int i)
+{
+  int value;
+  expressionS exp;
+
+  if ((value = arm_reg_parse (str, REG_TYPE_RN)) != FAIL)
+    {
+      inst.operands[i].reg = value;
+      inst.operands[i].isreg = 1;
+
+      /* parse_shift will override this if appropriate */
+      inst.reloc.exp.X_op = O_constant;
+      inst.reloc.exp.X_add_number = 0;
+
+      if (skip_past_comma (str) == FAIL)
+	return SUCCESS;
+
+      /* Shift operation on register.  */
+      return parse_shift (str, i, NO_SHIFT_RESTRICT);
+    }
+
+  if (my_get_expression (&inst.reloc.exp, str, GE_IMM_PREFIX))
+    return FAIL;
+
+  if (skip_past_comma (str) == SUCCESS)
+    {
+      /* #x, y -- ie explicit rotation by Y.  */
+      if (my_get_expression (&exp, str, GE_NO_PREFIX))
+	return FAIL;
+
+      if (exp.X_op != O_constant || inst.reloc.exp.X_op != O_constant)
+	{
+	  inst.error = _("constant expression expected");
+	  return FAIL;
+	}
+
+      value = exp.X_add_number;
+      if (value < 0 || value > 30 || value % 2 != 0)
+	{
+	  inst.error = _("invalid rotation");
+	  return FAIL;
+	}
+      if (inst.reloc.exp.X_add_number < 0 || inst.reloc.exp.X_add_number > 255)
+	{
+	  inst.error = _("invalid constant");
+	  return FAIL;
+	}
+
+      /* Encode as specified.  */
+      inst.operands[i].imm = inst.reloc.exp.X_add_number | value << 7;
+      return SUCCESS;
+    }
+
+  inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;
+  inst.reloc.pc_rel = 0;
+  return SUCCESS;
+}
+
+/* Group relocation information.  Each entry in the table contains the
+   textual name of the relocation as may appear in assembler source
+   and must end with a colon.
+   Along with this textual name are the relocation codes to be used if
+   the corresponding instruction is an ALU instruction (ADD or SUB only),
+   an LDR, an LDRS, or an LDC.  */
+
+struct group_reloc_table_entry
+{
+  const char *name;
+  int alu_code;
+  int ldr_code;
+  int ldrs_code;
+  int ldc_code;
+};
+
+typedef enum
+{
+  /* Varieties of non-ALU group relocation.  */
+
+  GROUP_LDR,
+  GROUP_LDRS,
+  GROUP_LDC
+} group_reloc_type;
+
+static struct group_reloc_table_entry group_reloc_table[] =
+  { /* Program counter relative: */
+    { "pc_g0_nc",
+      BFD_RELOC_ARM_ALU_PC_G0_NC,	/* ALU */
+      0,				/* LDR */
+      0,				/* LDRS */
+      0 },				/* LDC */
+    { "pc_g0",
+      BFD_RELOC_ARM_ALU_PC_G0,		/* ALU */
+      BFD_RELOC_ARM_LDR_PC_G0,		/* LDR */
+      BFD_RELOC_ARM_LDRS_PC_G0,		/* LDRS */
+      BFD_RELOC_ARM_LDC_PC_G0 },	/* LDC */
+    { "pc_g1_nc",
+      BFD_RELOC_ARM_ALU_PC_G1_NC,	/* ALU */
+      0,				/* LDR */
+      0,				/* LDRS */
+      0 },				/* LDC */
+    { "pc_g1",
+      BFD_RELOC_ARM_ALU_PC_G1,		/* ALU */
+      BFD_RELOC_ARM_LDR_PC_G1, 		/* LDR */
+      BFD_RELOC_ARM_LDRS_PC_G1,		/* LDRS */
+      BFD_RELOC_ARM_LDC_PC_G1 },	/* LDC */
+    { "pc_g2",
+      BFD_RELOC_ARM_ALU_PC_G2,		/* ALU */
+      BFD_RELOC_ARM_LDR_PC_G2,		/* LDR */
+      BFD_RELOC_ARM_LDRS_PC_G2,		/* LDRS */
+      BFD_RELOC_ARM_LDC_PC_G2 },	/* LDC */
+    /* Section base relative */
+    { "sb_g0_nc",
+      BFD_RELOC_ARM_ALU_SB_G0_NC,	/* ALU */
+      0,				/* LDR */
+      0,				/* LDRS */
+      0 },				/* LDC */
+    { "sb_g0",
+      BFD_RELOC_ARM_ALU_SB_G0,		/* ALU */
+      BFD_RELOC_ARM_LDR_SB_G0,		/* LDR */
+      BFD_RELOC_ARM_LDRS_SB_G0,		/* LDRS */
+      BFD_RELOC_ARM_LDC_SB_G0 },	/* LDC */
+    { "sb_g1_nc",
+      BFD_RELOC_ARM_ALU_SB_G1_NC,	/* ALU */
+      0,				/* LDR */
+      0,				/* LDRS */
+      0 },				/* LDC */
+    { "sb_g1",
+      BFD_RELOC_ARM_ALU_SB_G1,		/* ALU */
+      BFD_RELOC_ARM_LDR_SB_G1, 		/* LDR */
+      BFD_RELOC_ARM_LDRS_SB_G1,		/* LDRS */
+      BFD_RELOC_ARM_LDC_SB_G1 },	/* LDC */
+    { "sb_g2",
+      BFD_RELOC_ARM_ALU_SB_G2,		/* ALU */
+      BFD_RELOC_ARM_LDR_SB_G2,		/* LDR */
+      BFD_RELOC_ARM_LDRS_SB_G2,		/* LDRS */
+      BFD_RELOC_ARM_LDC_SB_G2 }	};	/* LDC */
+
+/* Given the address of a pointer pointing to the textual name of a group
+   relocation as may appear in assembler source, attempt to find its details
+   in group_reloc_table.  The pointer will be updated to the character after
+   the trailing colon.  On failure, FAIL will be returned; SUCCESS
+   otherwise.  On success, *entry will be updated to point at the relevant
+   group_reloc_table entry. */
+
+static int
+find_group_reloc_table_entry (char **str, struct group_reloc_table_entry **out)
+{
+  unsigned int i;
+  for (i = 0; i < ARRAY_SIZE (group_reloc_table); i++)
+    {
+      int length = strlen (group_reloc_table[i].name);
+
+      if (strncasecmp (group_reloc_table[i].name, *str, length) == 0
+	  && (*str)[length] == ':')
+	{
+	  *out = &group_reloc_table[i];
+	  *str += (length + 1);
+	  return SUCCESS;
+	}
+    }
+
+  return FAIL;
+}
+
+/* Parse a <shifter_operand> for an ARM data processing instruction
+   (as for parse_shifter_operand) where group relocations are allowed:
+
+      #<immediate>
+      #<immediate>, <rotate>
+      #:<group_reloc>:<expression>
+      <Rm>
+      <Rm>, <shift>
+
+   where <group_reloc> is one of the strings defined in group_reloc_table.
+   The hashes are optional.
+
+   Everything else is as for parse_shifter_operand.  */
+
+static parse_operand_result
+parse_shifter_operand_group_reloc (char **str, int i)
+{
+  /* Determine if we have the sequence of characters #: or just :
+     coming next.  If we do, then we check for a group relocation.
+     If we don't, punt the whole lot to parse_shifter_operand.  */
+
+  if (((*str)[0] == '#' && (*str)[1] == ':')
+      || (*str)[0] == ':')
+    {
+      struct group_reloc_table_entry *entry;
+
+      if ((*str)[0] == '#')
+	(*str) += 2;
+      else
+	(*str)++;
+
+      /* Try to parse a group relocation.  Anything else is an error.  */
+      if (find_group_reloc_table_entry (str, &entry) == FAIL)
+	{
+	  inst.error = _("unknown group relocation");
+	  return PARSE_OPERAND_FAIL_NO_BACKTRACK;
+	}
+
+      /* We now have the group relocation table entry corresponding to
+	 the name in the assembler source.  Next, we parse the expression.  */
+      if (my_get_expression (&inst.reloc.exp, str, GE_NO_PREFIX))
+	return PARSE_OPERAND_FAIL_NO_BACKTRACK;
+
+      /* Record the relocation type (always the ALU variant here).  */
+      inst.reloc.type = (bfd_reloc_code_real_type) entry->alu_code;
+      gas_assert (inst.reloc.type != 0);
+
+      return PARSE_OPERAND_SUCCESS;
+    }
+  else
+    return parse_shifter_operand (str, i) == SUCCESS
+	   ? PARSE_OPERAND_SUCCESS : PARSE_OPERAND_FAIL;
+
+  /* Never reached.  */
+}
+
+/* Parse a Neon alignment expression.  Information is written to
+   inst.operands[i].  We assume the initial ':' has been skipped.
+
+   align	.imm = align << 8, .immisalign=1, .preind=0  */
+static parse_operand_result
+parse_neon_alignment (char **str, int i)
+{
+  char *p = *str;
+  expressionS exp;
+
+  my_get_expression (&exp, &p, GE_NO_PREFIX);
+
+  if (exp.X_op != O_constant)
+    {
+      inst.error = _("alignment must be constant");
+      return PARSE_OPERAND_FAIL;
+    }
+
+  inst.operands[i].imm = exp.X_add_number << 8;
+  inst.operands[i].immisalign = 1;
+  /* Alignments are not pre-indexes.  */
+  inst.operands[i].preind = 0;
+
+  *str = p;
+  return PARSE_OPERAND_SUCCESS;
+}
+
+/* Parse all forms of an ARM address expression.  Information is written
+   to inst.operands[i] and/or inst.reloc.
+
+   Preindexed addressing (.preind=1):
+
+   [Rn, #offset]       .reg=Rn .reloc.exp=offset
+   [Rn, +/-Rm]	       .reg=Rn .imm=Rm .immisreg=1 .negative=0/1
+   [Rn, +/-Rm, shift]  .reg=Rn .imm=Rm .immisreg=1 .negative=0/1
+		       .shift_kind=shift .reloc.exp=shift_imm
+
+   These three may have a trailing ! which causes .writeback to be set also.
+
+   Postindexed addressing (.postind=1, .writeback=1):
+
+   [Rn], #offset       .reg=Rn .reloc.exp=offset
+   [Rn], +/-Rm	       .reg=Rn .imm=Rm .immisreg=1 .negative=0/1
+   [Rn], +/-Rm, shift  .reg=Rn .imm=Rm .immisreg=1 .negative=0/1
+		       .shift_kind=shift .reloc.exp=shift_imm
+
+   Unindexed addressing (.preind=0, .postind=0):
+
+   [Rn], {option}      .reg=Rn .imm=option .immisreg=0
+
+   Other:
+
+   [Rn]{!}	       shorthand for [Rn,#0]{!}
+   =immediate	       .isreg=0 .reloc.exp=immediate
+   label	       .reg=PC .reloc.pc_rel=1 .reloc.exp=label
+
+  It is the caller's responsibility to check for addressing modes not
+  supported by the instruction, and to set inst.reloc.type.  */
+
+static parse_operand_result
+parse_address_main (char **str, int i, int group_relocations,
+		    group_reloc_type group_type)
+{
+  char *p = *str;
+  int reg;
+
+  if (skip_past_char (&p, '[') == FAIL)
+    {
+      if (skip_past_char (&p, '=') == FAIL)
+	{
+	  /* Bare address - translate to PC-relative offset.  */
+	  inst.reloc.pc_rel = 1;
+	  inst.operands[i].reg = REG_PC;
+	  inst.operands[i].isreg = 1;
+	  inst.operands[i].preind = 1;
+
+	  if (my_get_expression (&inst.reloc.exp, &p, GE_OPT_PREFIX_BIG))
+	    return PARSE_OPERAND_FAIL;
+	}
+      else if (parse_big_immediate (&p, i, &inst.reloc.exp,
+				    /*allow_symbol_p=*/TRUE))
+	return PARSE_OPERAND_FAIL;
+
+      *str = p;
+      return PARSE_OPERAND_SUCCESS;
+    }
+
+  /* PR gas/14887: Allow for whitespace after the opening bracket.  */
+  skip_whitespace (p);
+
+  if ((reg = arm_reg_parse (&p, REG_TYPE_RN)) == FAIL)
+    {
+      inst.error = _(reg_expected_msgs[REG_TYPE_RN]);
+      return PARSE_OPERAND_FAIL;
+    }
+  inst.operands[i].reg = reg;
+  inst.operands[i].isreg = 1;
+
+  if (skip_past_comma (&p) == SUCCESS)
+    {
+      inst.operands[i].preind = 1;
+
+      if (*p == '+') p++;
+      else if (*p == '-') p++, inst.operands[i].negative = 1;
+
+      if ((reg = arm_reg_parse (&p, REG_TYPE_RN)) != FAIL)
+	{
+	  inst.operands[i].imm = reg;
+	  inst.operands[i].immisreg = 1;
+
+	  if (skip_past_comma (&p) == SUCCESS)
+	    if (parse_shift (&p, i, SHIFT_IMMEDIATE) == FAIL)
+	      return PARSE_OPERAND_FAIL;
+	}
+      else if (skip_past_char (&p, ':') == SUCCESS)
+	{
+	  /* FIXME: '@' should be used here, but it's filtered out by generic
+	     code before we get to see it here. This may be subject to
+	     change.  */
+	  parse_operand_result result = parse_neon_alignment (&p, i);
+
+	  if (result != PARSE_OPERAND_SUCCESS)
+	    return result;
+	}
+      else
+	{
+	  if (inst.operands[i].negative)
+	    {
+	      inst.operands[i].negative = 0;
+	      p--;
+	    }
+
+	  if (group_relocations
+	      && ((*p == '#' && *(p + 1) == ':') || *p == ':'))
+	    {
+	      struct group_reloc_table_entry *entry;
+
+	      /* Skip over the #: or : sequence.  */
+	      if (*p == '#')
+		p += 2;
+	      else
+		p++;
+
+	      /* Try to parse a group relocation.  Anything else is an
+		 error.  */
+	      if (find_group_reloc_table_entry (&p, &entry) == FAIL)
+		{
+		  inst.error = _("unknown group relocation");
+		  return PARSE_OPERAND_FAIL_NO_BACKTRACK;
+		}
+
+	      /* We now have the group relocation table entry corresponding to
+		 the name in the assembler source.  Next, we parse the
+		 expression.  */
+	      if (my_get_expression (&inst.reloc.exp, &p, GE_NO_PREFIX))
+		return PARSE_OPERAND_FAIL_NO_BACKTRACK;
+
+	      /* Record the relocation type.  */
+	      switch (group_type)
+		{
+		  case GROUP_LDR:
+		    inst.reloc.type = (bfd_reloc_code_real_type) entry->ldr_code;
+		    break;
+
+		  case GROUP_LDRS:
+		    inst.reloc.type = (bfd_reloc_code_real_type) entry->ldrs_code;
+		    break;
+
+		  case GROUP_LDC:
+		    inst.reloc.type = (bfd_reloc_code_real_type) entry->ldc_code;
+		    break;
+
+		  default:
+		    gas_assert (0);
+		}
+
+	      if (inst.reloc.type == 0)
+		{
+		  inst.error = _("this group relocation is not allowed on this instruction");
+		  return PARSE_OPERAND_FAIL_NO_BACKTRACK;
+		}
+	    }
+	  else
+	    {
+	      char *q = p;
+	      if (my_get_expression (&inst.reloc.exp, &p, GE_IMM_PREFIX))
+		return PARSE_OPERAND_FAIL;
+	      /* If the offset is 0, find out if it's a +0 or -0.  */
+	      if (inst.reloc.exp.X_op == O_constant
+		  && inst.reloc.exp.X_add_number == 0)
+		{
+		  skip_whitespace (q);
+		  if (*q == '#')
+		    {
+		      q++;
+		      skip_whitespace (q);
+		    }
+		  if (*q == '-')
+		    inst.operands[i].negative = 1;
+		}
+	    }
+	}
+    }
+  else if (skip_past_char (&p, ':') == SUCCESS)
+    {
+      /* FIXME: '@' should be used here, but it's filtered out by generic code
+	 before we get to see it here. This may be subject to change.  */
+      parse_operand_result result = parse_neon_alignment (&p, i);
+
+      if (result != PARSE_OPERAND_SUCCESS)
+	return result;
+    }
+
+  if (skip_past_char (&p, ']') == FAIL)
+    {
+      inst.error = _("']' expected");
+      return PARSE_OPERAND_FAIL;
+    }
+
+  if (skip_past_char (&p, '!') == SUCCESS)
+    inst.operands[i].writeback = 1;
+
+  else if (skip_past_comma (&p) == SUCCESS)
+    {
+      if (skip_past_char (&p, '{') == SUCCESS)
+	{
+	  /* [Rn], {expr} - unindexed, with option */
+	  if (parse_immediate (&p, &inst.operands[i].imm,
+			       0, 255, TRUE) == FAIL)
+	    return PARSE_OPERAND_FAIL;
+
+	  if (skip_past_char (&p, '}') == FAIL)
+	    {
+	      inst.error = _("'}' expected at end of 'option' field");
+	      return PARSE_OPERAND_FAIL;
+	    }
+	  if (inst.operands[i].preind)
+	    {
+	      inst.error = _("cannot combine index with option");
+	      return PARSE_OPERAND_FAIL;
+	    }
+	  *str = p;
+	  return PARSE_OPERAND_SUCCESS;
+	}
+      else
+	{
+	  inst.operands[i].postind = 1;
+	  inst.operands[i].writeback = 1;
+
+	  if (inst.operands[i].preind)
+	    {
+	      inst.error = _("cannot combine pre- and post-indexing");
+	      return PARSE_OPERAND_FAIL;
+	    }
+
+	  if (*p == '+') p++;
+	  else if (*p == '-') p++, inst.operands[i].negative = 1;
+
+	  if ((reg = arm_reg_parse (&p, REG_TYPE_RN)) != FAIL)
+	    {
+	      /* We might be using the immediate for alignment already. If we
+		 are, OR the register number into the low-order bits.  */
+	      if (inst.operands[i].immisalign)
+		inst.operands[i].imm |= reg;
+	      else
+		inst.operands[i].imm = reg;
+	      inst.operands[i].immisreg = 1;
+
+	      if (skip_past_comma (&p) == SUCCESS)
+		if (parse_shift (&p, i, SHIFT_IMMEDIATE) == FAIL)
+		  return PARSE_OPERAND_FAIL;
+	    }
+	  else
+	    {
+	      char *q = p;
+	      if (inst.operands[i].negative)
+		{
+		  inst.operands[i].negative = 0;
+		  p--;
+		}
+	      if (my_get_expression (&inst.reloc.exp, &p, GE_IMM_PREFIX))
+		return PARSE_OPERAND_FAIL;
+	      /* If the offset is 0, find out if it's a +0 or -0.  */
+	      if (inst.reloc.exp.X_op == O_constant
+		  && inst.reloc.exp.X_add_number == 0)
+		{
+		  skip_whitespace (q);
+		  if (*q == '#')
+		    {
+		      q++;
+		      skip_whitespace (q);
+		    }
+		  if (*q == '-')
+		    inst.operands[i].negative = 1;
+		}
+	    }
+	}
+    }
+
+  /* If at this point neither .preind nor .postind is set, we have a
+     bare [Rn]{!}, which is shorthand for [Rn,#0]{!}.  */
+  if (inst.operands[i].preind == 0 && inst.operands[i].postind == 0)
+    {
+      inst.operands[i].preind = 1;
+      inst.reloc.exp.X_op = O_constant;
+      inst.reloc.exp.X_add_number = 0;
+    }
+  *str = p;
+  return PARSE_OPERAND_SUCCESS;
+}
+
+static int
+parse_address (char **str, int i)
+{
+  return parse_address_main (str, i, 0, GROUP_LDR) == PARSE_OPERAND_SUCCESS
+	 ? SUCCESS : FAIL;
+}
+
+static parse_operand_result
+parse_address_group_reloc (char **str, int i, group_reloc_type type)
+{
+  return parse_address_main (str, i, 1, type);
+}
+
+/* Parse an operand for a MOVW or MOVT instruction.  */
+static int
+parse_half (char **str)
+{
+  char * p;
+
+  p = *str;
+  skip_past_char (&p, '#');
+  if (strncasecmp (p, ":lower16:", 9) == 0)
+    inst.reloc.type = BFD_RELOC_ARM_MOVW;
+  else if (strncasecmp (p, ":upper16:", 9) == 0)
+    inst.reloc.type = BFD_RELOC_ARM_MOVT;
+
+  if (inst.reloc.type != BFD_RELOC_UNUSED)
+    {
+      p += 9;
+      skip_whitespace (p);
+    }
+
+  if (my_get_expression (&inst.reloc.exp, &p, GE_NO_PREFIX))
+    return FAIL;
+
+  if (inst.reloc.type == BFD_RELOC_UNUSED)
+    {
+      if (inst.reloc.exp.X_op != O_constant)
+	{
+	  inst.error = _("constant expression expected");
+	  return FAIL;
+	}
+      if (inst.reloc.exp.X_add_number < 0
+	  || inst.reloc.exp.X_add_number > 0xffff)
+	{
+	  inst.error = _("immediate value out of range");
+	  return FAIL;
+	}
+    }
+  *str = p;
+  return SUCCESS;
+}
+
+/* Miscellaneous. */
+
+/* Parse a PSR flag operand.  The value returned is FAIL on syntax error,
+   or a bitmask suitable to be or-ed into the ARM msr instruction.  */
+static int
+parse_psr (char **str, bfd_boolean lhs)
+{
+  char *p;
+  unsigned long psr_field;
+  const struct asm_psr *psr;
+  char *start;
+  bfd_boolean is_apsr = FALSE;
+  bfd_boolean m_profile = ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_m);
+
+  /* PR gas/12698:  If the user has specified -march=all then m_profile will
+     be TRUE, but we want to ignore it in this case as we are building for any
+     CPU type, including non-m variants.  */
+  if (ARM_FEATURE_CORE_EQUAL (selected_cpu, arm_arch_any))
+    m_profile = FALSE;
+
+  /* CPSR's and SPSR's can now be lowercase.  This is just a convenience
+     feature for ease of use and backwards compatibility.  */
+  p = *str;
+  if (strncasecmp (p, "SPSR", 4) == 0)
+    {
+      if (m_profile)
+	goto unsupported_psr;
+
+      psr_field = SPSR_BIT;
+    }
+  else if (strncasecmp (p, "CPSR", 4) == 0)
+    {
+      if (m_profile)
+	goto unsupported_psr;
+
+      psr_field = 0;
+    }
+  else if (strncasecmp (p, "APSR", 4) == 0)
+    {
+      /* APSR[_<bits>] can be used as a synonym for CPSR[_<flags>] on ARMv7-A
+	 and ARMv7-R architecture CPUs.  */
+      is_apsr = TRUE;
+      psr_field = 0;
+    }
+  else if (m_profile)
+    {
+      start = p;
+      do
+	p++;
+      while (ISALNUM (*p) || *p == '_');
+
+      if (strncasecmp (start, "iapsr", 5) == 0
+	  || strncasecmp (start, "eapsr", 5) == 0
+	  || strncasecmp (start, "xpsr", 4) == 0
+	  || strncasecmp (start, "psr", 3) == 0)
+	p = start + strcspn (start, "rR") + 1;
+
+      psr = (const struct asm_psr *) hash_find_n (arm_v7m_psr_hsh, start,
+						  p - start);
+
+      if (!psr)
+	return FAIL;
+
+      /* If APSR is being written, a bitfield may be specified.  Note that
+	 APSR itself is handled above.  */
+      if (psr->field <= 3)
+	{
+	  psr_field = psr->field;
+	  is_apsr = TRUE;
+	  goto check_suffix;
+	}
+
+      *str = p;
+      /* M-profile MSR instructions have the mask field set to "10", except
+	 *PSR variants which modify APSR, which may use a different mask (and
+	 have been handled already).  Do that by setting the PSR_f field
+	 here.  */
+      return psr->field | (lhs ? PSR_f : 0);
+    }
+  else
+    goto unsupported_psr;
+
+  p += 4;
+check_suffix:
+  if (*p == '_')
+    {
+      /* A suffix follows.  */
+      p++;
+      start = p;
+
+      do
+	p++;
+      while (ISALNUM (*p) || *p == '_');
+
+      if (is_apsr)
+	{
+	  /* APSR uses a notation for bits, rather than fields.  */
+	  unsigned int nzcvq_bits = 0;
+	  unsigned int g_bit = 0;
+	  char *bit;
+
+	  for (bit = start; bit != p; bit++)
+	    {
+	      switch (TOLOWER (*bit))
+		{
+		case 'n':
+		  nzcvq_bits |= (nzcvq_bits & 0x01) ? 0x20 : 0x01;
+		  break;
+
+		case 'z':
+		  nzcvq_bits |= (nzcvq_bits & 0x02) ? 0x20 : 0x02;
+		  break;
+
+		case 'c':
+		  nzcvq_bits |= (nzcvq_bits & 0x04) ? 0x20 : 0x04;
+		  break;
+
+		case 'v':
+		  nzcvq_bits |= (nzcvq_bits & 0x08) ? 0x20 : 0x08;
+		  break;
+
+		case 'q':
+		  nzcvq_bits |= (nzcvq_bits & 0x10) ? 0x20 : 0x10;
+		  break;
+
+		case 'g':
+		  g_bit |= (g_bit & 0x1) ? 0x2 : 0x1;
+		  break;
+
+		default:
+		  inst.error = _("unexpected bit specified after APSR");
+		  return FAIL;
+		}
+	    }
+
+	  if (nzcvq_bits == 0x1f)
+	    psr_field |= PSR_f;
+
+	  if (g_bit == 0x1)
+	    {
+	      if (!ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v6_dsp))
+		{
+		  inst.error = _("selected processor does not "
+				 "support DSP extension");
+		  return FAIL;
+		}
+
+	      psr_field |= PSR_s;
+	    }
+
+	  if ((nzcvq_bits & 0x20) != 0
+	      || (nzcvq_bits != 0x1f && nzcvq_bits != 0)
+	      || (g_bit & 0x2) != 0)
+	    {
+	      inst.error = _("bad bitmask specified after APSR");
+	      return FAIL;
+	    }
+	}
+      else
+	{
+	  psr = (const struct asm_psr *) hash_find_n (arm_psr_hsh, start,
+						      p - start);
+	  if (!psr)
+	    goto error;
+
+	  psr_field |= psr->field;
+	}
+    }
+  else
+    {
+      if (ISALNUM (*p))
+	goto error;    /* Garbage after "[CS]PSR".  */
+
+      /* Unadorned APSR is equivalent to APSR_nzcvq/CPSR_f (for writes).  This
+	 is deprecated, but allow it anyway.  */
+      if (is_apsr && lhs)
+	{
+	  psr_field |= PSR_f;
+	  as_tsktsk (_("writing to APSR without specifying a bitmask is "
+		       "deprecated"));
+	}
+      else if (!m_profile)
+	/* These bits are never right for M-profile devices: don't set them
+	   (only code paths which read/write APSR reach here).  */
+	psr_field |= (PSR_c | PSR_f);
+    }
+  *str = p;
+  return psr_field;
+
+ unsupported_psr:
+  inst.error = _("selected processor does not support requested special "
+		 "purpose register");
+  return FAIL;
+
+ error:
+  inst.error = _("flag for {c}psr instruction expected");
+  return FAIL;
+}
+
+/* Parse the flags argument to CPSI[ED].  Returns FAIL on error, or a
+   value suitable for splatting into the AIF field of the instruction.	*/
+
+static int
+parse_cps_flags (char **str)
+{
+  int val = 0;
+  int saw_a_flag = 0;
+  char *s = *str;
+
+  for (;;)
+    switch (*s++)
+      {
+      case '\0': case ',':
+	goto done;
+
+      case 'a': case 'A': saw_a_flag = 1; val |= 0x4; break;
+      case 'i': case 'I': saw_a_flag = 1; val |= 0x2; break;
+      case 'f': case 'F': saw_a_flag = 1; val |= 0x1; break;
+
+      default:
+	inst.error = _("unrecognized CPS flag");
+	return FAIL;
+      }
+
+ done:
+  if (saw_a_flag == 0)
+    {
+      inst.error = _("missing CPS flags");
+      return FAIL;
+    }
+
+  *str = s - 1;
+  return val;
+}
+
+/* Parse an endian specifier ("BE" or "LE", case insensitive);
+   returns 0 for big-endian, 1 for little-endian, FAIL for an error.  */
+
+static int
+parse_endian_specifier (char **str)
+{
+  int little_endian;
+  char *s = *str;
+
+  if (strncasecmp (s, "BE", 2))
+    little_endian = 0;
+  else if (strncasecmp (s, "LE", 2))
+    little_endian = 1;
+  else
+    {
+      inst.error = _("valid endian specifiers are be or le");
+      return FAIL;
+    }
+
+  if (ISALNUM (s[2]) || s[2] == '_')
+    {
+      inst.error = _("valid endian specifiers are be or le");
+      return FAIL;
+    }
+
+  *str = s + 2;
+  return little_endian;
+}
+
+/* Parse a rotation specifier: ROR #0, #8, #16, #24.  *val receives a
+   value suitable for poking into the rotate field of an sxt or sxta
+   instruction, or FAIL on error.  */
+
+static int
+parse_ror (char **str)
+{
+  int rot;
+  char *s = *str;
+
+  if (strncasecmp (s, "ROR", 3) == 0)
+    s += 3;
+  else
+    {
+      inst.error = _("missing rotation field after comma");
+      return FAIL;
+    }
+
+  if (parse_immediate (&s, &rot, 0, 24, FALSE) == FAIL)
+    return FAIL;
+
+  switch (rot)
+    {
+    case  0: *str = s; return 0x0;
+    case  8: *str = s; return 0x1;
+    case 16: *str = s; return 0x2;
+    case 24: *str = s; return 0x3;
+
+    default:
+      inst.error = _("rotation can only be 0, 8, 16, or 24");
+      return FAIL;
+    }
+}
+
+/* Parse a conditional code (from conds[] below).  The value returned is in the
+   range 0 .. 14, or FAIL.  */
+static int
+parse_cond (char **str)
+{
+  char *q;
+  const struct asm_cond *c;
+  int n;
+  /* Condition codes are always 2 characters, so matching up to
+     3 characters is sufficient.  */
+  char cond[3];
+
+  q = *str;
+  n = 0;
+  while (ISALPHA (*q) && n < 3)
+    {
+      cond[n] = TOLOWER (*q);
+      q++;
+      n++;
+    }
+
+  c = (const struct asm_cond *) hash_find_n (arm_cond_hsh, cond, n);
+  if (!c)
+    {
+      inst.error = _("condition required");
+      return FAIL;
+    }
+
+  *str = q;
+  return c->value;
+}
+
+/* If the given feature available in the selected CPU, mark it as used.
+   Returns TRUE iff feature is available.  */
+static bfd_boolean
+mark_feature_used (const arm_feature_set *feature)
+{
+  /* Ensure the option is valid on the current architecture.  */
+  if (!ARM_CPU_HAS_FEATURE (cpu_variant, *feature))
+    return FALSE;
+
+  /* Add the appropriate architecture feature for the barrier option used.
+     */
+  if (thumb_mode)
+    ARM_MERGE_FEATURE_SETS (thumb_arch_used, thumb_arch_used, *feature);
+  else
+    ARM_MERGE_FEATURE_SETS (arm_arch_used, arm_arch_used, *feature);
+
+  return TRUE;
+}
+
+/* Parse an option for a barrier instruction.  Returns the encoding for the
+   option, or FAIL.  */
+static int
+parse_barrier (char **str)
+{
+  char *p, *q;
+  const struct asm_barrier_opt *o;
+
+  p = q = *str;
+  while (ISALPHA (*q))
+    q++;
+
+  o = (const struct asm_barrier_opt *) hash_find_n (arm_barrier_opt_hsh, p,
+						    q - p);
+  if (!o)
+    return FAIL;
+
+  if (!mark_feature_used (&o->arch))
+    return FAIL;
+
+  *str = q;
+  return o->value;
+}
+
+/* Parse the operands of a table branch instruction.  Similar to a memory
+   operand.  */
+static int
+parse_tb (char **str)
+{
+  char * p = *str;
+  int reg;
+
+  if (skip_past_char (&p, '[') == FAIL)
+    {
+      inst.error = _("'[' expected");
+      return FAIL;
+    }
+
+  if ((reg = arm_reg_parse (&p, REG_TYPE_RN)) == FAIL)
+    {
+      inst.error = _(reg_expected_msgs[REG_TYPE_RN]);
+      return FAIL;
+    }
+  inst.operands[0].reg = reg;
+
+  if (skip_past_comma (&p) == FAIL)
+    {
+      inst.error = _("',' expected");
+      return FAIL;
+    }
+
+  if ((reg = arm_reg_parse (&p, REG_TYPE_RN)) == FAIL)
+    {
+      inst.error = _(reg_expected_msgs[REG_TYPE_RN]);
+      return FAIL;
+    }
+  inst.operands[0].imm = reg;
+
+  if (skip_past_comma (&p) == SUCCESS)
+    {
+      if (parse_shift (&p, 0, SHIFT_LSL_IMMEDIATE) == FAIL)
+	return FAIL;
+      if (inst.reloc.exp.X_add_number != 1)
+	{
+	  inst.error = _("invalid shift");
+	  return FAIL;
+	}
+      inst.operands[0].shifted = 1;
+    }
+
+  if (skip_past_char (&p, ']') == FAIL)
+    {
+      inst.error = _("']' expected");
+      return FAIL;
+    }
+  *str = p;
+  return SUCCESS;
+}
+
+/* Parse the operands of a Neon VMOV instruction. See do_neon_mov for more
+   information on the types the operands can take and how they are encoded.
+   Up to four operands may be read; this function handles setting the
+   ".present" field for each read operand itself.
+   Updates STR and WHICH_OPERAND if parsing is successful and returns SUCCESS,
+   else returns FAIL.  */
+
+static int
+parse_neon_mov (char **str, int *which_operand)
+{
+  int i = *which_operand, val;
+  enum arm_reg_type rtype;
+  char *ptr = *str;
+  struct neon_type_el optype;
+
+  if ((val = parse_scalar (&ptr, 8, &optype)) != FAIL)
+    {
+      /* Case 4: VMOV<c><q>.<size> <Dn[x]>, <Rd>.  */
+      inst.operands[i].reg = val;
+      inst.operands[i].isscalar = 1;
+      inst.operands[i].vectype = optype;
+      inst.operands[i++].present = 1;
+
+      if (skip_past_comma (&ptr) == FAIL)
+	goto wanted_comma;
+
+      if ((val = arm_reg_parse (&ptr, REG_TYPE_RN)) == FAIL)
+	goto wanted_arm;
+
+      inst.operands[i].reg = val;
+      inst.operands[i].isreg = 1;
+      inst.operands[i].present = 1;
+    }
+  else if ((val = arm_typed_reg_parse (&ptr, REG_TYPE_NSDQ, &rtype, &optype))
+	   != FAIL)
+    {
+      /* Cases 0, 1, 2, 3, 5 (D only).  */
+      if (skip_past_comma (&ptr) == FAIL)
+	goto wanted_comma;
+
+      inst.operands[i].reg = val;
+      inst.operands[i].isreg = 1;
+      inst.operands[i].isquad = (rtype == REG_TYPE_NQ);
+      inst.operands[i].issingle = (rtype == REG_TYPE_VFS);
+      inst.operands[i].isvec = 1;
+      inst.operands[i].vectype = optype;
+      inst.operands[i++].present = 1;
+
+      if ((val = arm_reg_parse (&ptr, REG_TYPE_RN)) != FAIL)
+	{
+	  /* Case 5: VMOV<c><q> <Dm>, <Rd>, <Rn>.
+	     Case 13: VMOV <Sd>, <Rm>  */
+	  inst.operands[i].reg = val;
+	  inst.operands[i].isreg = 1;
+	  inst.operands[i].present = 1;
+
+	  if (rtype == REG_TYPE_NQ)
+	    {
+	      first_error (_("can't use Neon quad register here"));
+	      return FAIL;
+	    }
+	  else if (rtype != REG_TYPE_VFS)
+	    {
+	      i++;
+	      if (skip_past_comma (&ptr) == FAIL)
+		goto wanted_comma;
+	      if ((val = arm_reg_parse (&ptr, REG_TYPE_RN)) == FAIL)
+		goto wanted_arm;
+	      inst.operands[i].reg = val;
+	      inst.operands[i].isreg = 1;
+	      inst.operands[i].present = 1;
+	    }
+	}
+      else if ((val = arm_typed_reg_parse (&ptr, REG_TYPE_NSDQ, &rtype,
+					   &optype)) != FAIL)
+	{
+	  /* Case 0: VMOV<c><q> <Qd>, <Qm>
+	     Case 1: VMOV<c><q> <Dd>, <Dm>
+	     Case 8: VMOV.F32 <Sd>, <Sm>
+	     Case 15: VMOV <Sd>, <Se>, <Rn>, <Rm>  */
+
+	  inst.operands[i].reg = val;
+	  inst.operands[i].isreg = 1;
+	  inst.operands[i].isquad = (rtype == REG_TYPE_NQ);
+	  inst.operands[i].issingle = (rtype == REG_TYPE_VFS);
+	  inst.operands[i].isvec = 1;
+	  inst.operands[i].vectype = optype;
+	  inst.operands[i].present = 1;
+
+	  if (skip_past_comma (&ptr) == SUCCESS)
+	    {
+	      /* Case 15.  */
+	      i++;
+
+	      if ((val = arm_reg_parse (&ptr, REG_TYPE_RN)) == FAIL)
+		goto wanted_arm;
+
+	      inst.operands[i].reg = val;
+	      inst.operands[i].isreg = 1;
+	      inst.operands[i++].present = 1;
+
+	      if (skip_past_comma (&ptr) == FAIL)
+		goto wanted_comma;
+
+	      if ((val = arm_reg_parse (&ptr, REG_TYPE_RN)) == FAIL)
+		goto wanted_arm;
+
+	      inst.operands[i].reg = val;
+	      inst.operands[i].isreg = 1;
+	      inst.operands[i].present = 1;
+	    }
+	}
+      else if (parse_qfloat_immediate (&ptr, &inst.operands[i].imm) == SUCCESS)
+	  /* Case 2: VMOV<c><q>.<dt> <Qd>, #<float-imm>
+	     Case 3: VMOV<c><q>.<dt> <Dd>, #<float-imm>
+	     Case 10: VMOV.F32 <Sd>, #<imm>
+	     Case 11: VMOV.F64 <Dd>, #<imm>  */
+	inst.operands[i].immisfloat = 1;
+      else if (parse_big_immediate (&ptr, i, NULL, /*allow_symbol_p=*/FALSE)
+	       == SUCCESS)
+	  /* Case 2: VMOV<c><q>.<dt> <Qd>, #<imm>
+	     Case 3: VMOV<c><q>.<dt> <Dd>, #<imm>  */
+	;
+      else
+	{
+	  first_error (_("expected <Rm> or <Dm> or <Qm> operand"));
+	  return FAIL;
+	}
+    }
+  else if ((val = arm_reg_parse (&ptr, REG_TYPE_RN)) != FAIL)
+    {
+      /* Cases 6, 7.  */
+      inst.operands[i].reg = val;
+      inst.operands[i].isreg = 1;
+      inst.operands[i++].present = 1;
+
+      if (skip_past_comma (&ptr) == FAIL)
+	goto wanted_comma;
+
+      if ((val = parse_scalar (&ptr, 8, &optype)) != FAIL)
+	{
+	  /* Case 6: VMOV<c><q>.<dt> <Rd>, <Dn[x]>  */
+	  inst.operands[i].reg = val;
+	  inst.operands[i].isscalar = 1;
+	  inst.operands[i].present = 1;
+	  inst.operands[i].vectype = optype;
+	}
+      else if ((val = arm_reg_parse (&ptr, REG_TYPE_RN)) != FAIL)
+	{
+	  /* Case 7: VMOV<c><q> <Rd>, <Rn>, <Dm>  */
+	  inst.operands[i].reg = val;
+	  inst.operands[i].isreg = 1;
+	  inst.operands[i++].present = 1;
+
+	  if (skip_past_comma (&ptr) == FAIL)
+	    goto wanted_comma;
+
+	  if ((val = arm_typed_reg_parse (&ptr, REG_TYPE_VFSD, &rtype, &optype))
+	      == FAIL)
+	    {
+	      first_error (_(reg_expected_msgs[REG_TYPE_VFSD]));
+	      return FAIL;
+	    }
+
+	  inst.operands[i].reg = val;
+	  inst.operands[i].isreg = 1;
+	  inst.operands[i].isvec = 1;
+	  inst.operands[i].issingle = (rtype == REG_TYPE_VFS);
+	  inst.operands[i].vectype = optype;
+	  inst.operands[i].present = 1;
+
+	  if (rtype == REG_TYPE_VFS)
+	    {
+	      /* Case 14.  */
+	      i++;
+	      if (skip_past_comma (&ptr) == FAIL)
+		goto wanted_comma;
+	      if ((val = arm_typed_reg_parse (&ptr, REG_TYPE_VFS, NULL,
+					      &optype)) == FAIL)
+		{
+		  first_error (_(reg_expected_msgs[REG_TYPE_VFS]));
+		  return FAIL;
+		}
+	      inst.operands[i].reg = val;
+	      inst.operands[i].isreg = 1;
+	      inst.operands[i].isvec = 1;
+	      inst.operands[i].issingle = 1;
+	      inst.operands[i].vectype = optype;
+	      inst.operands[i].present = 1;
+	    }
+	}
+      else if ((val = arm_typed_reg_parse (&ptr, REG_TYPE_VFS, NULL, &optype))
+	       != FAIL)
+	{
+	  /* Case 13.  */
+	  inst.operands[i].reg = val;
+	  inst.operands[i].isreg = 1;
+	  inst.operands[i].isvec = 1;
+	  inst.operands[i].issingle = 1;
+	  inst.operands[i].vectype = optype;
+	  inst.operands[i].present = 1;
+	}
+    }
+  else
+    {
+      first_error (_("parse error"));
+      return FAIL;
+    }
+
+  /* Successfully parsed the operands. Update args.  */
+  *which_operand = i;
+  *str = ptr;
+  return SUCCESS;
+
+ wanted_comma:
+  first_error (_("expected comma"));
+  return FAIL;
+
+ wanted_arm:
+  first_error (_(reg_expected_msgs[REG_TYPE_RN]));
+  return FAIL;
+}
+
+/* Use this macro when the operand constraints are different
+   for ARM and THUMB (e.g. ldrd).  */
+#define MIX_ARM_THUMB_OPERANDS(arm_operand, thumb_operand) \
+	((arm_operand) | ((thumb_operand) << 16))
+
+/* Matcher codes for parse_operands.  */
+enum operand_parse_code
+{
+  OP_stop,	/* end of line */
+
+  OP_RR,	/* ARM register */
+  OP_RRnpc,	/* ARM register, not r15 */
+  OP_RRnpcsp,	/* ARM register, neither r15 nor r13 (a.k.a. 'BadReg') */
+  OP_RRnpcb,	/* ARM register, not r15, in square brackets */
+  OP_RRnpctw,	/* ARM register, not r15 in Thumb-state or with writeback,
+		   optional trailing ! */
+  OP_RRw,	/* ARM register, not r15, optional trailing ! */
+  OP_RCP,	/* Coprocessor number */
+  OP_RCN,	/* Coprocessor register */
+  OP_RF,	/* FPA register */
+  OP_RVS,	/* VFP single precision register */
+  OP_RVD,	/* VFP double precision register (0..15) */
+  OP_RND,       /* Neon double precision register (0..31) */
+  OP_RNQ,	/* Neon quad precision register */
+  OP_RVSD,	/* VFP single or double precision register */
+  OP_RNDQ,      /* Neon double or quad precision register */
+  OP_RNSDQ,	/* Neon single, double or quad precision register */
+  OP_RNSC,      /* Neon scalar D[X] */
+  OP_RVC,	/* VFP control register */
+  OP_RMF,	/* Maverick F register */
+  OP_RMD,	/* Maverick D register */
+  OP_RMFX,	/* Maverick FX register */
+  OP_RMDX,	/* Maverick DX register */
+  OP_RMAX,	/* Maverick AX register */
+  OP_RMDS,	/* Maverick DSPSC register */
+  OP_RIWR,	/* iWMMXt wR register */
+  OP_RIWC,	/* iWMMXt wC register */
+  OP_RIWG,	/* iWMMXt wCG register */
+  OP_RXA,	/* XScale accumulator register */
+
+  OP_REGLST,	/* ARM register list */
+  OP_VRSLST,	/* VFP single-precision register list */
+  OP_VRDLST,	/* VFP double-precision register list */
+  OP_VRSDLST,   /* VFP single or double-precision register list (& quad) */
+  OP_NRDLST,    /* Neon double-precision register list (d0-d31, qN aliases) */
+  OP_NSTRLST,   /* Neon element/structure list */
+
+  OP_RNDQ_I0,   /* Neon D or Q reg, or immediate zero.  */
+  OP_RVSD_I0,	/* VFP S or D reg, or immediate zero.  */
+  OP_RSVD_FI0, /* VFP S or D reg, or floating point immediate zero.  */
+  OP_RR_RNSC,   /* ARM reg or Neon scalar.  */
+  OP_RNSDQ_RNSC, /* Vector S, D or Q reg, or Neon scalar.  */
+  OP_RNDQ_RNSC, /* Neon D or Q reg, or Neon scalar.  */
+  OP_RND_RNSC,  /* Neon D reg, or Neon scalar.  */
+  OP_VMOV,      /* Neon VMOV operands.  */
+  OP_RNDQ_Ibig,	/* Neon D or Q reg, or big immediate for logic and VMVN.  */
+  OP_RNDQ_I63b, /* Neon D or Q reg, or immediate for shift.  */
+  OP_RIWR_I32z, /* iWMMXt wR register, or immediate 0 .. 32 for iWMMXt2.  */
+
+  OP_I0,        /* immediate zero */
+  OP_I7,	/* immediate value 0 .. 7 */
+  OP_I15,	/*		   0 .. 15 */
+  OP_I16,	/*		   1 .. 16 */
+  OP_I16z,      /*                 0 .. 16 */
+  OP_I31,	/*		   0 .. 31 */
+  OP_I31w,	/*		   0 .. 31, optional trailing ! */
+  OP_I32,	/*		   1 .. 32 */
+  OP_I32z,	/*		   0 .. 32 */
+  OP_I63,	/*		   0 .. 63 */
+  OP_I63s,	/*		 -64 .. 63 */
+  OP_I64,	/*		   1 .. 64 */
+  OP_I64z,	/*		   0 .. 64 */
+  OP_I255,	/*		   0 .. 255 */
+
+  OP_I4b,	/* immediate, prefix optional, 1 .. 4 */
+  OP_I7b,	/*			       0 .. 7 */
+  OP_I15b,	/*			       0 .. 15 */
+  OP_I31b,	/*			       0 .. 31 */
+
+  OP_SH,	/* shifter operand */
+  OP_SHG,	/* shifter operand with possible group relocation */
+  OP_ADDR,	/* Memory address expression (any mode) */
+  OP_ADDRGLDR,	/* Mem addr expr (any mode) with possible LDR group reloc */
+  OP_ADDRGLDRS, /* Mem addr expr (any mode) with possible LDRS group reloc */
+  OP_ADDRGLDC,  /* Mem addr expr (any mode) with possible LDC group reloc */
+  OP_EXP,	/* arbitrary expression */
+  OP_EXPi,	/* same, with optional immediate prefix */
+  OP_EXPr,	/* same, with optional relocation suffix */
+  OP_HALF,	/* 0 .. 65535 or low/high reloc.  */
+
+  OP_CPSF,	/* CPS flags */
+  OP_ENDI,	/* Endianness specifier */
+  OP_wPSR,	/* CPSR/SPSR/APSR mask for msr (writing).  */
+  OP_rPSR,	/* CPSR/SPSR/APSR mask for msr (reading).  */
+  OP_COND,	/* conditional code */
+  OP_TB,	/* Table branch.  */
+
+  OP_APSR_RR,   /* ARM register or "APSR_nzcv".  */
+
+  OP_RRnpc_I0,	/* ARM register or literal 0 */
+  OP_RR_EXr,	/* ARM register or expression with opt. reloc suff. */
+  OP_RR_EXi,	/* ARM register or expression with imm prefix */
+  OP_RF_IF,	/* FPA register or immediate */
+  OP_RIWR_RIWC, /* iWMMXt R or C reg */
+  OP_RIWC_RIWG, /* iWMMXt wC or wCG reg */
+
+  /* Optional operands.	 */
+  OP_oI7b,	 /* immediate, prefix optional, 0 .. 7 */
+  OP_oI31b,	 /*				0 .. 31 */
+  OP_oI32b,      /*                             1 .. 32 */
+  OP_oI32z,      /*                             0 .. 32 */
+  OP_oIffffb,	 /*				0 .. 65535 */
+  OP_oI255c,	 /*	  curly-brace enclosed, 0 .. 255 */
+
+  OP_oRR,	 /* ARM register */
+  OP_oRRnpc,	 /* ARM register, not the PC */
+  OP_oRRnpcsp,	 /* ARM register, neither the PC nor the SP (a.k.a. BadReg) */
+  OP_oRRw,	 /* ARM register, not r15, optional trailing ! */
+  OP_oRND,       /* Optional Neon double precision register */
+  OP_oRNQ,       /* Optional Neon quad precision register */
+  OP_oRNDQ,      /* Optional Neon double or quad precision register */
+  OP_oRNSDQ,	 /* Optional single, double or quad precision vector register */
+  OP_oSHll,	 /* LSL immediate */
+  OP_oSHar,	 /* ASR immediate */
+  OP_oSHllar,	 /* LSL or ASR immediate */
+  OP_oROR,	 /* ROR 0/8/16/24 */
+  OP_oBARRIER_I15, /* Option argument for a barrier instruction.  */
+
+  /* Some pre-defined mixed (ARM/THUMB) operands.  */
+  OP_RR_npcsp		= MIX_ARM_THUMB_OPERANDS (OP_RR, OP_RRnpcsp),
+  OP_RRnpc_npcsp	= MIX_ARM_THUMB_OPERANDS (OP_RRnpc, OP_RRnpcsp),
+  OP_oRRnpc_npcsp	= MIX_ARM_THUMB_OPERANDS (OP_oRRnpc, OP_oRRnpcsp),
+
+  OP_FIRST_OPTIONAL = OP_oI7b
+};
+
+/* Generic instruction operand parser.	This does no encoding and no
+   semantic validation; it merely squirrels values away in the inst
+   structure.  Returns SUCCESS or FAIL depending on whether the
+   specified grammar matched.  */
+static int
+parse_operands (char *str, const unsigned int *pattern, bfd_boolean thumb)
+{
+  unsigned const int *upat = pattern;
+  char *backtrack_pos = 0;
+  const char *backtrack_error = 0;
+  int i, val = 0, backtrack_index = 0;
+  enum arm_reg_type rtype;
+  parse_operand_result result;
+  unsigned int op_parse_code;
+
+#define po_char_or_fail(chr)			\
+  do						\
+    {						\
+      if (skip_past_char (&str, chr) == FAIL)	\
+	goto bad_args;				\
+    }						\
+  while (0)
+
+#define po_reg_or_fail(regtype)					\
+  do								\
+    {								\
+      val = arm_typed_reg_parse (& str, regtype, & rtype,	\
+				 & inst.operands[i].vectype);	\
+      if (val == FAIL)						\
+	{							\
+	  first_error (_(reg_expected_msgs[regtype]));		\
+	  goto failure;						\
+	}							\
+      inst.operands[i].reg = val;				\
+      inst.operands[i].isreg = 1;				\
+      inst.operands[i].isquad = (rtype == REG_TYPE_NQ);		\
+      inst.operands[i].issingle = (rtype == REG_TYPE_VFS);	\
+      inst.operands[i].isvec = (rtype == REG_TYPE_VFS		\
+			     || rtype == REG_TYPE_VFD		\
+			     || rtype == REG_TYPE_NQ);		\
+    }								\
+  while (0)
+
+#define po_reg_or_goto(regtype, label)				\
+  do								\
+    {								\
+      val = arm_typed_reg_parse (& str, regtype, & rtype,	\
+				 & inst.operands[i].vectype);	\
+      if (val == FAIL)						\
+	goto label;						\
+								\
+      inst.operands[i].reg = val;				\
+      inst.operands[i].isreg = 1;				\
+      inst.operands[i].isquad = (rtype == REG_TYPE_NQ);		\
+      inst.operands[i].issingle = (rtype == REG_TYPE_VFS);	\
+      inst.operands[i].isvec = (rtype == REG_TYPE_VFS		\
+			     || rtype == REG_TYPE_VFD		\
+			     || rtype == REG_TYPE_NQ);		\
+    }								\
+  while (0)
+
+#define po_imm_or_fail(min, max, popt)				\
+  do								\
+    {								\
+      if (parse_immediate (&str, &val, min, max, popt) == FAIL)	\
+	goto failure;						\
+      inst.operands[i].imm = val;				\
+    }								\
+  while (0)
+
+#define po_scalar_or_goto(elsz, label)					\
+  do									\
+    {									\
+      val = parse_scalar (& str, elsz, & inst.operands[i].vectype);	\
+      if (val == FAIL)							\
+	goto label;							\
+      inst.operands[i].reg = val;					\
+      inst.operands[i].isscalar = 1;					\
+    }									\
+  while (0)
+
+#define po_misc_or_fail(expr)			\
+  do						\
+    {						\
+      if (expr)					\
+	goto failure;				\
+    }						\
+  while (0)
+
+#define po_misc_or_fail_no_backtrack(expr)		\
+  do							\
+    {							\
+      result = expr;					\
+      if (result == PARSE_OPERAND_FAIL_NO_BACKTRACK)	\
+	backtrack_pos = 0;				\
+      if (result != PARSE_OPERAND_SUCCESS)		\
+	goto failure;					\
+    }							\
+  while (0)
+
+#define po_barrier_or_imm(str)				   \
+  do							   \
+    {						 	   \
+      val = parse_barrier (&str);			   \
+      if (val == FAIL && ! ISALPHA (*str))		   \
+	goto immediate;					   \
+      if (val == FAIL					   \
+	  /* ISB can only take SY as an option.  */	   \
+	  || ((inst.instruction & 0xf0) == 0x60		   \
+	       && val != 0xf))				   \
+	{						   \
+	   inst.error = _("invalid barrier type");	   \
+	   backtrack_pos = 0;				   \
+	   goto failure;				   \
+	}						   \
+    }							   \
+  while (0)
+
+  skip_whitespace (str);
+
+  for (i = 0; upat[i] != OP_stop; i++)
+    {
+      op_parse_code = upat[i];
+      if (op_parse_code >= 1<<16)
+	op_parse_code = thumb ? (op_parse_code >> 16)
+				: (op_parse_code & ((1<<16)-1));
+
+      if (op_parse_code >= OP_FIRST_OPTIONAL)
+	{
+	  /* Remember where we are in case we need to backtrack.  */
+	  gas_assert (!backtrack_pos);
+	  backtrack_pos = str;
+	  backtrack_error = inst.error;
+	  backtrack_index = i;
+	}
+
+      if (i > 0 && (i > 1 || inst.operands[0].present))
+	po_char_or_fail (',');
+
+      switch (op_parse_code)
+	{
+	  /* Registers */
+	case OP_oRRnpc:
+	case OP_oRRnpcsp:
+	case OP_RRnpc:
+	case OP_RRnpcsp:
+	case OP_oRR:
+	case OP_RR:    po_reg_or_fail (REG_TYPE_RN);	  break;
+	case OP_RCP:   po_reg_or_fail (REG_TYPE_CP);	  break;
+	case OP_RCN:   po_reg_or_fail (REG_TYPE_CN);	  break;
+	case OP_RF:    po_reg_or_fail (REG_TYPE_FN);	  break;
+	case OP_RVS:   po_reg_or_fail (REG_TYPE_VFS);	  break;
+	case OP_RVD:   po_reg_or_fail (REG_TYPE_VFD);	  break;
+	case OP_oRND:
+	case OP_RND:   po_reg_or_fail (REG_TYPE_VFD);	  break;
+	case OP_RVC:
+	  po_reg_or_goto (REG_TYPE_VFC, coproc_reg);
+	  break;
+	  /* Also accept generic coprocessor regs for unknown registers.  */
+	  coproc_reg:
+	  po_reg_or_fail (REG_TYPE_CN);
+	  break;
+	case OP_RMF:   po_reg_or_fail (REG_TYPE_MVF);	  break;
+	case OP_RMD:   po_reg_or_fail (REG_TYPE_MVD);	  break;
+	case OP_RMFX:  po_reg_or_fail (REG_TYPE_MVFX);	  break;
+	case OP_RMDX:  po_reg_or_fail (REG_TYPE_MVDX);	  break;
+	case OP_RMAX:  po_reg_or_fail (REG_TYPE_MVAX);	  break;
+	case OP_RMDS:  po_reg_or_fail (REG_TYPE_DSPSC);	  break;
+	case OP_RIWR:  po_reg_or_fail (REG_TYPE_MMXWR);	  break;
+	case OP_RIWC:  po_reg_or_fail (REG_TYPE_MMXWC);	  break;
+	case OP_RIWG:  po_reg_or_fail (REG_TYPE_MMXWCG);  break;
+	case OP_RXA:   po_reg_or_fail (REG_TYPE_XSCALE);  break;
+	case OP_oRNQ:
+	case OP_RNQ:   po_reg_or_fail (REG_TYPE_NQ);      break;
+	case OP_oRNDQ:
+	case OP_RNDQ:  po_reg_or_fail (REG_TYPE_NDQ);     break;
+	case OP_RVSD:  po_reg_or_fail (REG_TYPE_VFSD);    break;
+	case OP_oRNSDQ:
+	case OP_RNSDQ: po_reg_or_fail (REG_TYPE_NSDQ);    break;
+
+	/* Neon scalar. Using an element size of 8 means that some invalid
+	   scalars are accepted here, so deal with those in later code.  */
+	case OP_RNSC:  po_scalar_or_goto (8, failure);    break;
+
+	case OP_RNDQ_I0:
+	  {
+	    po_reg_or_goto (REG_TYPE_NDQ, try_imm0);
+	    break;
+	    try_imm0:
+	    po_imm_or_fail (0, 0, TRUE);
+	  }
+	  break;
+
+	case OP_RVSD_I0:
+	  po_reg_or_goto (REG_TYPE_VFSD, try_imm0);
+	  break;
+
+	case OP_RSVD_FI0:
+	  {
+	    po_reg_or_goto (REG_TYPE_VFSD, try_ifimm0);
+	    break;
+	    try_ifimm0:
+	    if (parse_ifimm_zero (&str))
+	      inst.operands[i].imm = 0;
+	    else
+	    {
+	      inst.error
+	        = _("only floating point zero is allowed as immediate value");
+	      goto failure;
+	    }
+	  }
+	  break;
+
+	case OP_RR_RNSC:
+	  {
+	    po_scalar_or_goto (8, try_rr);
+	    break;
+	    try_rr:
+	    po_reg_or_fail (REG_TYPE_RN);
+	  }
+	  break;
+
+	case OP_RNSDQ_RNSC:
+	  {
+	    po_scalar_or_goto (8, try_nsdq);
+	    break;
+	    try_nsdq:
+	    po_reg_or_fail (REG_TYPE_NSDQ);
+	  }
+	  break;
+
+	case OP_RNDQ_RNSC:
+	  {
+	    po_scalar_or_goto (8, try_ndq);
+	    break;
+	    try_ndq:
+	    po_reg_or_fail (REG_TYPE_NDQ);
+	  }
+	  break;
+
+	case OP_RND_RNSC:
+	  {
+	    po_scalar_or_goto (8, try_vfd);
+	    break;
+	    try_vfd:
+	    po_reg_or_fail (REG_TYPE_VFD);
+	  }
+	  break;
+
+	case OP_VMOV:
+	  /* WARNING: parse_neon_mov can move the operand counter, i. If we're
+	     not careful then bad things might happen.  */
+	  po_misc_or_fail (parse_neon_mov (&str, &i) == FAIL);
+	  break;
+
+	case OP_RNDQ_Ibig:
+	  {
+	    po_reg_or_goto (REG_TYPE_NDQ, try_immbig);
+	    break;
+	    try_immbig:
+	    /* There's a possibility of getting a 64-bit immediate here, so
+	       we need special handling.  */
+	    if (parse_big_immediate (&str, i, NULL, /*allow_symbol_p=*/FALSE)
+		== FAIL)
+	      {
+		inst.error = _("immediate value is out of range");
+		goto failure;
+	      }
+	  }
+	  break;
+
+	case OP_RNDQ_I63b:
+	  {
+	    po_reg_or_goto (REG_TYPE_NDQ, try_shimm);
+	    break;
+	    try_shimm:
+	    po_imm_or_fail (0, 63, TRUE);
+	  }
+	  break;
+
+	case OP_RRnpcb:
+	  po_char_or_fail ('[');
+	  po_reg_or_fail  (REG_TYPE_RN);
+	  po_char_or_fail (']');
+	  break;
+
+	case OP_RRnpctw:
+	case OP_RRw:
+	case OP_oRRw:
+	  po_reg_or_fail (REG_TYPE_RN);
+	  if (skip_past_char (&str, '!') == SUCCESS)
+	    inst.operands[i].writeback = 1;
+	  break;
+
+	  /* Immediates */
+	case OP_I7:	 po_imm_or_fail (  0,	   7, FALSE);	break;
+	case OP_I15:	 po_imm_or_fail (  0,	  15, FALSE);	break;
+	case OP_I16:	 po_imm_or_fail (  1,	  16, FALSE);	break;
+	case OP_I16z:	 po_imm_or_fail (  0,     16, FALSE);   break;
+	case OP_I31:	 po_imm_or_fail (  0,	  31, FALSE);	break;
+	case OP_I32:	 po_imm_or_fail (  1,	  32, FALSE);	break;
+	case OP_I32z:	 po_imm_or_fail (  0,     32, FALSE);   break;
+	case OP_I63s:	 po_imm_or_fail (-64,	  63, FALSE);	break;
+	case OP_I63:	 po_imm_or_fail (  0,     63, FALSE);   break;
+	case OP_I64:	 po_imm_or_fail (  1,     64, FALSE);   break;
+	case OP_I64z:	 po_imm_or_fail (  0,     64, FALSE);   break;
+	case OP_I255:	 po_imm_or_fail (  0,	 255, FALSE);	break;
+
+	case OP_I4b:	 po_imm_or_fail (  1,	   4, TRUE);	break;
+	case OP_oI7b:
+	case OP_I7b:	 po_imm_or_fail (  0,	   7, TRUE);	break;
+	case OP_I15b:	 po_imm_or_fail (  0,	  15, TRUE);	break;
+	case OP_oI31b:
+	case OP_I31b:	 po_imm_or_fail (  0,	  31, TRUE);	break;
+	case OP_oI32b:   po_imm_or_fail (  1,     32, TRUE);    break;
+	case OP_oI32z:   po_imm_or_fail (  0,     32, TRUE);    break;
+	case OP_oIffffb: po_imm_or_fail (  0, 0xffff, TRUE);	break;
+
+	  /* Immediate variants */
+	case OP_oI255c:
+	  po_char_or_fail ('{');
+	  po_imm_or_fail (0, 255, TRUE);
+	  po_char_or_fail ('}');
+	  break;
+
+	case OP_I31w:
+	  /* The expression parser chokes on a trailing !, so we have
+	     to find it first and zap it.  */
+	  {
+	    char *s = str;
+	    while (*s && *s != ',')
+	      s++;
+	    if (s[-1] == '!')
+	      {
+		s[-1] = '\0';
+		inst.operands[i].writeback = 1;
+	      }
+	    po_imm_or_fail (0, 31, TRUE);
+	    if (str == s - 1)
+	      str = s;
+	  }
+	  break;
+
+	  /* Expressions */
+	case OP_EXPi:	EXPi:
+	  po_misc_or_fail (my_get_expression (&inst.reloc.exp, &str,
+					      GE_OPT_PREFIX));
+	  break;
+
+	case OP_EXP:
+	  po_misc_or_fail (my_get_expression (&inst.reloc.exp, &str,
+					      GE_NO_PREFIX));
+	  break;
+
+	case OP_EXPr:	EXPr:
+	  po_misc_or_fail (my_get_expression (&inst.reloc.exp, &str,
+					      GE_NO_PREFIX));
+	  if (inst.reloc.exp.X_op == O_symbol)
+	    {
+	      val = parse_reloc (&str);
+	      if (val == -1)
+		{
+		  inst.error = _("unrecognized relocation suffix");
+		  goto failure;
+		}
+	      else if (val != BFD_RELOC_UNUSED)
+		{
+		  inst.operands[i].imm = val;
+		  inst.operands[i].hasreloc = 1;
+		}
+	    }
+	  break;
+
+	  /* Operand for MOVW or MOVT.  */
+	case OP_HALF:
+	  po_misc_or_fail (parse_half (&str));
+	  break;
+
+	  /* Register or expression.  */
+	case OP_RR_EXr:	  po_reg_or_goto (REG_TYPE_RN, EXPr); break;
+	case OP_RR_EXi:	  po_reg_or_goto (REG_TYPE_RN, EXPi); break;
+
+	  /* Register or immediate.  */
+	case OP_RRnpc_I0: po_reg_or_goto (REG_TYPE_RN, I0);   break;
+	I0:		  po_imm_or_fail (0, 0, FALSE);	      break;
+
+	case OP_RF_IF:    po_reg_or_goto (REG_TYPE_FN, IF);   break;
+	IF:
+	  if (!is_immediate_prefix (*str))
+	    goto bad_args;
+	  str++;
+	  val = parse_fpa_immediate (&str);
+	  if (val == FAIL)
+	    goto failure;
+	  /* FPA immediates are encoded as registers 8-15.
+	     parse_fpa_immediate has already applied the offset.  */
+	  inst.operands[i].reg = val;
+	  inst.operands[i].isreg = 1;
+	  break;
+
+	case OP_RIWR_I32z: po_reg_or_goto (REG_TYPE_MMXWR, I32z); break;
+	I32z:		  po_imm_or_fail (0, 32, FALSE);	  break;
+
+	  /* Two kinds of register.  */
+	case OP_RIWR_RIWC:
+	  {
+	    struct reg_entry *rege = arm_reg_parse_multi (&str);
+	    if (!rege
+		|| (rege->type != REG_TYPE_MMXWR
+		    && rege->type != REG_TYPE_MMXWC
+		    && rege->type != REG_TYPE_MMXWCG))
+	      {
+		inst.error = _("iWMMXt data or control register expected");
+		goto failure;
+	      }
+	    inst.operands[i].reg = rege->number;
+	    inst.operands[i].isreg = (rege->type == REG_TYPE_MMXWR);
+	  }
+	  break;
+
+	case OP_RIWC_RIWG:
+	  {
+	    struct reg_entry *rege = arm_reg_parse_multi (&str);
+	    if (!rege
+		|| (rege->type != REG_TYPE_MMXWC
+		    && rege->type != REG_TYPE_MMXWCG))
+	      {
+		inst.error = _("iWMMXt control register expected");
+		goto failure;
+	      }
+	    inst.operands[i].reg = rege->number;
+	    inst.operands[i].isreg = 1;
+	  }
+	  break;
+
+	  /* Misc */
+	case OP_CPSF:	 val = parse_cps_flags (&str);		break;
+	case OP_ENDI:	 val = parse_endian_specifier (&str);	break;
+	case OP_oROR:	 val = parse_ror (&str);		break;
+	case OP_COND:	 val = parse_cond (&str);		break;
+	case OP_oBARRIER_I15:
+	  po_barrier_or_imm (str); break;
+	  immediate:
+	  if (parse_immediate (&str, &val, 0, 15, TRUE) == FAIL)
+	    goto failure;
+	  break;
+
+	case OP_wPSR:
+	case OP_rPSR:
+	  po_reg_or_goto (REG_TYPE_RNB, try_psr);
+	  if (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_virt))
+	    {
+	      inst.error = _("Banked registers are not available with this "
+			     "architecture.");
+	      goto failure;
+	    }
+	  break;
+	  try_psr:
+	  val = parse_psr (&str, op_parse_code == OP_wPSR);
+	  break;
+
+	case OP_APSR_RR:
+	  po_reg_or_goto (REG_TYPE_RN, try_apsr);
+	  break;
+	  try_apsr:
+	  /* Parse "APSR_nvzc" operand (for FMSTAT-equivalent MRS
+	     instruction).  */
+	  if (strncasecmp (str, "APSR_", 5) == 0)
+	    {
+	      unsigned found = 0;
+	      str += 5;
+	      while (found < 15)
+		switch (*str++)
+		  {
+		  case 'c': found = (found & 1) ? 16 : found | 1; break;
+		  case 'n': found = (found & 2) ? 16 : found | 2; break;
+		  case 'z': found = (found & 4) ? 16 : found | 4; break;
+		  case 'v': found = (found & 8) ? 16 : found | 8; break;
+		  default: found = 16;
+		  }
+	      if (found != 15)
+		goto failure;
+	      inst.operands[i].isvec = 1;
+	      /* APSR_nzcv is encoded in instructions as if it were the REG_PC.  */
+	      inst.operands[i].reg = REG_PC;
+	    }
+	  else
+	    goto failure;
+	  break;
+
+	case OP_TB:
+	  po_misc_or_fail (parse_tb (&str));
+	  break;
+
+	  /* Register lists.  */
+	case OP_REGLST:
+	  val = parse_reg_list (&str);
+	  if (*str == '^')
+	    {
+	      inst.operands[i].writeback = 1;
+	      str++;
+	    }
+	  break;
+
+	case OP_VRSLST:
+	  val = parse_vfp_reg_list (&str, &inst.operands[i].reg, REGLIST_VFP_S);
+	  break;
+
+	case OP_VRDLST:
+	  val = parse_vfp_reg_list (&str, &inst.operands[i].reg, REGLIST_VFP_D);
+	  break;
+
+	case OP_VRSDLST:
+	  /* Allow Q registers too.  */
+	  val = parse_vfp_reg_list (&str, &inst.operands[i].reg,
+				    REGLIST_NEON_D);
+	  if (val == FAIL)
+	    {
+	      inst.error = NULL;
+	      val = parse_vfp_reg_list (&str, &inst.operands[i].reg,
+					REGLIST_VFP_S);
+	      inst.operands[i].issingle = 1;
+	    }
+	  break;
+
+	case OP_NRDLST:
+	  val = parse_vfp_reg_list (&str, &inst.operands[i].reg,
+				    REGLIST_NEON_D);
+	  break;
+
+	case OP_NSTRLST:
+	  val = parse_neon_el_struct_list (&str, &inst.operands[i].reg,
+					   &inst.operands[i].vectype);
+	  break;
+
+	  /* Addressing modes */
+	case OP_ADDR:
+	  po_misc_or_fail (parse_address (&str, i));
+	  break;
+
+	case OP_ADDRGLDR:
+	  po_misc_or_fail_no_backtrack (
+	    parse_address_group_reloc (&str, i, GROUP_LDR));
+	  break;
+
+	case OP_ADDRGLDRS:
+	  po_misc_or_fail_no_backtrack (
+	    parse_address_group_reloc (&str, i, GROUP_LDRS));
+	  break;
+
+	case OP_ADDRGLDC:
+	  po_misc_or_fail_no_backtrack (
+	    parse_address_group_reloc (&str, i, GROUP_LDC));
+	  break;
+
+	case OP_SH:
+	  po_misc_or_fail (parse_shifter_operand (&str, i));
+	  break;
+
+	case OP_SHG:
+	  po_misc_or_fail_no_backtrack (
+	    parse_shifter_operand_group_reloc (&str, i));
+	  break;
+
+	case OP_oSHll:
+	  po_misc_or_fail (parse_shift (&str, i, SHIFT_LSL_IMMEDIATE));
+	  break;
+
+	case OP_oSHar:
+	  po_misc_or_fail (parse_shift (&str, i, SHIFT_ASR_IMMEDIATE));
+	  break;
+
+	case OP_oSHllar:
+	  po_misc_or_fail (parse_shift (&str, i, SHIFT_LSL_OR_ASR_IMMEDIATE));
+	  break;
+
+	default:
+	  as_fatal (_("unhandled operand code %d"), op_parse_code);
+	}
+
+      /* Various value-based sanity checks and shared operations.  We
+	 do not signal immediate failures for the register constraints;
+	 this allows a syntax error to take precedence.	 */
+      switch (op_parse_code)
+	{
+	case OP_oRRnpc:
+	case OP_RRnpc:
+	case OP_RRnpcb:
+	case OP_RRw:
+	case OP_oRRw:
+	case OP_RRnpc_I0:
+	  if (inst.operands[i].isreg && inst.operands[i].reg == REG_PC)
+	    inst.error = BAD_PC;
+	  break;
+
+	case OP_oRRnpcsp:
+	case OP_RRnpcsp:
+	  if (inst.operands[i].isreg)
+	    {
+	      if (inst.operands[i].reg == REG_PC)
+		inst.error = BAD_PC;
+	      else if (inst.operands[i].reg == REG_SP)
+		inst.error = BAD_SP;
+	    }
+	  break;
+
+	case OP_RRnpctw:
+	  if (inst.operands[i].isreg
+	      && inst.operands[i].reg == REG_PC
+	      && (inst.operands[i].writeback || thumb))
+	    inst.error = BAD_PC;
+	  break;
+
+	case OP_CPSF:
+	case OP_ENDI:
+	case OP_oROR:
+	case OP_wPSR:
+	case OP_rPSR:
+	case OP_COND:
+	case OP_oBARRIER_I15:
+	case OP_REGLST:
+	case OP_VRSLST:
+	case OP_VRDLST:
+	case OP_VRSDLST:
+	case OP_NRDLST:
+	case OP_NSTRLST:
+	  if (val == FAIL)
+	    goto failure;
+	  inst.operands[i].imm = val;
+	  break;
+
+	default:
+	  break;
+	}
+
+      /* If we get here, this operand was successfully parsed.	*/
+      inst.operands[i].present = 1;
+      continue;
+
+    bad_args:
+      inst.error = BAD_ARGS;
+
+    failure:
+      if (!backtrack_pos)
+	{
+	  /* The parse routine should already have set inst.error, but set a
+	     default here just in case.  */
+	  if (!inst.error)
+	    inst.error = _("syntax error");
+	  return FAIL;
+	}
+
+      /* Do not backtrack over a trailing optional argument that
+	 absorbed some text.  We will only fail again, with the
+	 'garbage following instruction' error message, which is
+	 probably less helpful than the current one.  */
+      if (backtrack_index == i && backtrack_pos != str
+	  && upat[i+1] == OP_stop)
+	{
+	  if (!inst.error)
+	    inst.error = _("syntax error");
+	  return FAIL;
+	}
+
+      /* Try again, skipping the optional argument at backtrack_pos.  */
+      str = backtrack_pos;
+      inst.error = backtrack_error;
+      inst.operands[backtrack_index].present = 0;
+      i = backtrack_index;
+      backtrack_pos = 0;
+    }
+
+  /* Check that we have parsed all the arguments.  */
+  if (*str != '\0' && !inst.error)
+    inst.error = _("garbage following instruction");
+
+  return inst.error ? FAIL : SUCCESS;
+}
+
+#undef po_char_or_fail
+#undef po_reg_or_fail
+#undef po_reg_or_goto
+#undef po_imm_or_fail
+#undef po_scalar_or_fail
+#undef po_barrier_or_imm
+
+/* Shorthand macro for instruction encoding functions issuing errors.  */
+#define constraint(expr, err)			\
+  do						\
+    {						\
+      if (expr)					\
+	{					\
+	  inst.error = err;			\
+	  return;				\
+	}					\
+    }						\
+  while (0)
+
+/* Reject "bad registers" for Thumb-2 instructions.  Many Thumb-2
+   instructions are unpredictable if these registers are used.  This
+   is the BadReg predicate in ARM's Thumb-2 documentation.  */
+#define reject_bad_reg(reg)				\
+  do							\
+   if (reg == REG_SP || reg == REG_PC)			\
+     {							\
+       inst.error = (reg == REG_SP) ? BAD_SP : BAD_PC;	\
+       return;						\
+     }							\
+  while (0)
+
+/* If REG is R13 (the stack pointer), warn that its use is
+   deprecated.  */
+#define warn_deprecated_sp(reg)			\
+  do						\
+    if (warn_on_deprecated && reg == REG_SP)	\
+       as_tsktsk (_("use of r13 is deprecated"));	\
+  while (0)
+
+/* Functions for operand encoding.  ARM, then Thumb.  */
+
+#define rotate_left(v, n) (v << (n & 31) | v >> ((32 - n) & 31))
+
+/* If VAL can be encoded in the immediate field of an ARM instruction,
+   return the encoded form.  Otherwise, return FAIL.  */
+
+static unsigned int
+encode_arm_immediate (unsigned int val)
+{
+  unsigned int a, i;
+
+  for (i = 0; i < 32; i += 2)
+    if ((a = rotate_left (val, i)) <= 0xff)
+      return a | (i << 7); /* 12-bit pack: [shift-cnt,const].  */
+
+  return FAIL;
+}
+
+/* If VAL can be encoded in the immediate field of a Thumb32 instruction,
+   return the encoded form.  Otherwise, return FAIL.  */
+static unsigned int
+encode_thumb32_immediate (unsigned int val)
+{
+  unsigned int a, i;
+
+  if (val <= 0xff)
+    return val;
+
+  for (i = 1; i <= 24; i++)
+    {
+      a = val >> i;
+      if ((val & ~(0xff << i)) == 0)
+	return ((val >> i) & 0x7f) | ((32 - i) << 7);
+    }
+
+  a = val & 0xff;
+  if (val == ((a << 16) | a))
+    return 0x100 | a;
+  if (val == ((a << 24) | (a << 16) | (a << 8) | a))
+    return 0x300 | a;
+
+  a = val & 0xff00;
+  if (val == ((a << 16) | a))
+    return 0x200 | (a >> 8);
+
+  return FAIL;
+}
+/* Encode a VFP SP or DP register number into inst.instruction.  */
+
+static void
+encode_arm_vfp_reg (int reg, enum vfp_reg_pos pos)
+{
+  if ((pos == VFP_REG_Dd || pos == VFP_REG_Dn || pos == VFP_REG_Dm)
+      && reg > 15)
+    {
+      if (ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_d32))
+	{
+	  if (thumb_mode)
+	    ARM_MERGE_FEATURE_SETS (thumb_arch_used, thumb_arch_used,
+				    fpu_vfp_ext_d32);
+	  else
+	    ARM_MERGE_FEATURE_SETS (arm_arch_used, arm_arch_used,
+				    fpu_vfp_ext_d32);
+	}
+      else
+	{
+	  first_error (_("D register out of range for selected VFP version"));
+	  return;
+	}
+    }
+
+  switch (pos)
+    {
+    case VFP_REG_Sd:
+      inst.instruction |= ((reg >> 1) << 12) | ((reg & 1) << 22);
+      break;
+
+    case VFP_REG_Sn:
+      inst.instruction |= ((reg >> 1) << 16) | ((reg & 1) << 7);
+      break;
+
+    case VFP_REG_Sm:
+      inst.instruction |= ((reg >> 1) << 0) | ((reg & 1) << 5);
+      break;
+
+    case VFP_REG_Dd:
+      inst.instruction |= ((reg & 15) << 12) | ((reg >> 4) << 22);
+      break;
+
+    case VFP_REG_Dn:
+      inst.instruction |= ((reg & 15) << 16) | ((reg >> 4) << 7);
+      break;
+
+    case VFP_REG_Dm:
+      inst.instruction |= (reg & 15) | ((reg >> 4) << 5);
+      break;
+
+    default:
+      abort ();
+    }
+}
+
+/* Encode a <shift> in an ARM-format instruction.  The immediate,
+   if any, is handled by md_apply_fix.	 */
+static void
+encode_arm_shift (int i)
+{
+  if (inst.operands[i].shift_kind == SHIFT_RRX)
+    inst.instruction |= SHIFT_ROR << 5;
+  else
+    {
+      inst.instruction |= inst.operands[i].shift_kind << 5;
+      if (inst.operands[i].immisreg)
+	{
+	  inst.instruction |= SHIFT_BY_REG;
+	  inst.instruction |= inst.operands[i].imm << 8;
+	}
+      else
+	inst.reloc.type = BFD_RELOC_ARM_SHIFT_IMM;
+    }
+}
+
+static void
+encode_arm_shifter_operand (int i)
+{
+  if (inst.operands[i].isreg)
+    {
+      inst.instruction |= inst.operands[i].reg;
+      encode_arm_shift (i);
+    }
+  else
+    {
+      inst.instruction |= INST_IMMEDIATE;
+      if (inst.reloc.type != BFD_RELOC_ARM_IMMEDIATE)
+	inst.instruction |= inst.operands[i].imm;
+    }
+}
+
+/* Subroutine of encode_arm_addr_mode_2 and encode_arm_addr_mode_3.  */
+static void
+encode_arm_addr_mode_common (int i, bfd_boolean is_t)
+{
+  /* PR 14260:
+     Generate an error if the operand is not a register.  */
+  constraint (!inst.operands[i].isreg,
+	      _("Instruction does not support =N addresses"));
+
+  inst.instruction |= inst.operands[i].reg << 16;
+
+  if (inst.operands[i].preind)
+    {
+      if (is_t)
+	{
+	  inst.error = _("instruction does not accept preindexed addressing");
+	  return;
+	}
+      inst.instruction |= PRE_INDEX;
+      if (inst.operands[i].writeback)
+	inst.instruction |= WRITE_BACK;
+
+    }
+  else if (inst.operands[i].postind)
+    {
+      gas_assert (inst.operands[i].writeback);
+      if (is_t)
+	inst.instruction |= WRITE_BACK;
+    }
+  else /* unindexed - only for coprocessor */
+    {
+      inst.error = _("instruction does not accept unindexed addressing");
+      return;
+    }
+
+  if (((inst.instruction & WRITE_BACK) || !(inst.instruction & PRE_INDEX))
+      && (((inst.instruction & 0x000f0000) >> 16)
+	  == ((inst.instruction & 0x0000f000) >> 12)))
+    as_warn ((inst.instruction & LOAD_BIT)
+	     ? _("destination register same as write-back base")
+	     : _("source register same as write-back base"));
+}
+
+/* inst.operands[i] was set up by parse_address.  Encode it into an
+   ARM-format mode 2 load or store instruction.	 If is_t is true,
+   reject forms that cannot be used with a T instruction (i.e. not
+   post-indexed).  */
+static void
+encode_arm_addr_mode_2 (int i, bfd_boolean is_t)
+{
+  const bfd_boolean is_pc = (inst.operands[i].reg == REG_PC);
+
+  encode_arm_addr_mode_common (i, is_t);
+
+  if (inst.operands[i].immisreg)
+    {
+      constraint ((inst.operands[i].imm == REG_PC
+		   || (is_pc && inst.operands[i].writeback)),
+		  BAD_PC_ADDRESSING);
+      inst.instruction |= INST_IMMEDIATE;  /* yes, this is backwards */
+      inst.instruction |= inst.operands[i].imm;
+      if (!inst.operands[i].negative)
+	inst.instruction |= INDEX_UP;
+      if (inst.operands[i].shifted)
+	{
+	  if (inst.operands[i].shift_kind == SHIFT_RRX)
+	    inst.instruction |= SHIFT_ROR << 5;
+	  else
+	    {
+	      inst.instruction |= inst.operands[i].shift_kind << 5;
+	      inst.reloc.type = BFD_RELOC_ARM_SHIFT_IMM;
+	    }
+	}
+    }
+  else /* immediate offset in inst.reloc */
+    {
+      if (is_pc && !inst.reloc.pc_rel)
+	{
+	  const bfd_boolean is_load = ((inst.instruction & LOAD_BIT) != 0);
+
+	  /* If is_t is TRUE, it's called from do_ldstt.  ldrt/strt
+	     cannot use PC in addressing.
+	     PC cannot be used in writeback addressing, either.  */
+	  constraint ((is_t || inst.operands[i].writeback),
+		      BAD_PC_ADDRESSING);
+
+	  /* Use of PC in str is deprecated for ARMv7.  */
+	  if (warn_on_deprecated
+	      && !is_load
+	      && ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v7))
+	    as_tsktsk (_("use of PC in this instruction is deprecated"));
+	}
+
+      if (inst.reloc.type == BFD_RELOC_UNUSED)
+	{
+	  /* Prefer + for zero encoded value.  */
+	  if (!inst.operands[i].negative)
+	    inst.instruction |= INDEX_UP;
+	  inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM;
+	}
+    }
+}
+
+/* inst.operands[i] was set up by parse_address.  Encode it into an
+   ARM-format mode 3 load or store instruction.	 Reject forms that
+   cannot be used with such instructions.  If is_t is true, reject
+   forms that cannot be used with a T instruction (i.e. not
+   post-indexed).  */
+static void
+encode_arm_addr_mode_3 (int i, bfd_boolean is_t)
+{
+  if (inst.operands[i].immisreg && inst.operands[i].shifted)
+    {
+      inst.error = _("instruction does not accept scaled register index");
+      return;
+    }
+
+  encode_arm_addr_mode_common (i, is_t);
+
+  if (inst.operands[i].immisreg)
+    {
+      constraint ((inst.operands[i].imm == REG_PC
+		   || (is_t && inst.operands[i].reg == REG_PC)),
+		  BAD_PC_ADDRESSING);
+      constraint (inst.operands[i].reg == REG_PC && inst.operands[i].writeback,
+		  BAD_PC_WRITEBACK);
+      inst.instruction |= inst.operands[i].imm;
+      if (!inst.operands[i].negative)
+	inst.instruction |= INDEX_UP;
+    }
+  else /* immediate offset in inst.reloc */
+    {
+      constraint ((inst.operands[i].reg == REG_PC && !inst.reloc.pc_rel
+		   && inst.operands[i].writeback),
+		  BAD_PC_WRITEBACK);
+      inst.instruction |= HWOFFSET_IMM;
+      if (inst.reloc.type == BFD_RELOC_UNUSED)
+	{
+	  /* Prefer + for zero encoded value.  */
+	  if (!inst.operands[i].negative)
+	    inst.instruction |= INDEX_UP;
+
+	  inst.reloc.type = BFD_RELOC_ARM_OFFSET_IMM8;
+	}
+    }
+}
+
+/* Write immediate bits [7:0] to the following locations:
+
+  |28/24|23     19|18 16|15                    4|3     0|
+  |  a  |x x x x x|b c d|x x x x x x x x x x x x|e f g h|
+
+  This function is used by VMOV/VMVN/VORR/VBIC.  */
+
+static void
+neon_write_immbits (unsigned immbits)
+{
+  inst.instruction |= immbits & 0xf;
+  inst.instruction |= ((immbits >> 4) & 0x7) << 16;
+  inst.instruction |= ((immbits >> 7) & 0x1) << (thumb_mode ? 28 : 24);
+}
+
+/* Invert low-order SIZE bits of XHI:XLO.  */
+
+static void
+neon_invert_size (unsigned *xlo, unsigned *xhi, int size)
+{
+  unsigned immlo = xlo ? *xlo : 0;
+  unsigned immhi = xhi ? *xhi : 0;
+
+  switch (size)
+    {
+    case 8:
+      immlo = (~immlo) & 0xff;
+      break;
+
+    case 16:
+      immlo = (~immlo) & 0xffff;
+      break;
+
+    case 64:
+      immhi = (~immhi) & 0xffffffff;
+      /* fall through.  */
+
+    case 32:
+      immlo = (~immlo) & 0xffffffff;
+      break;
+
+    default:
+      abort ();
+    }
+
+  if (xlo)
+    *xlo = immlo;
+
+  if (xhi)
+    *xhi = immhi;
+}
+
+/* True if IMM has form 0bAAAAAAAABBBBBBBBCCCCCCCCDDDDDDDD for bits
+   A, B, C, D.  */
+
+static int
+neon_bits_same_in_bytes (unsigned imm)
+{
+  return ((imm & 0x000000ff) == 0 || (imm & 0x000000ff) == 0x000000ff)
+	 && ((imm & 0x0000ff00) == 0 || (imm & 0x0000ff00) == 0x0000ff00)
+	 && ((imm & 0x00ff0000) == 0 || (imm & 0x00ff0000) == 0x00ff0000)
+	 && ((imm & 0xff000000) == 0 || (imm & 0xff000000) == 0xff000000);
+}
+
+/* For immediate of above form, return 0bABCD.  */
+
+static unsigned
+neon_squash_bits (unsigned imm)
+{
+  return (imm & 0x01) | ((imm & 0x0100) >> 7) | ((imm & 0x010000) >> 14)
+	 | ((imm & 0x01000000) >> 21);
+}
+
+/* Compress quarter-float representation to 0b...000 abcdefgh.  */
+
+static unsigned
+neon_qfloat_bits (unsigned imm)
+{
+  return ((imm >> 19) & 0x7f) | ((imm >> 24) & 0x80);
+}
+
+/* Returns CMODE. IMMBITS [7:0] is set to bits suitable for inserting into
+   the instruction. *OP is passed as the initial value of the op field, and
+   may be set to a different value depending on the constant (i.e.
+   "MOV I64, 0bAAAAAAAABBBB..." which uses OP = 1 despite being MOV not
+   MVN).  If the immediate looks like a repeated pattern then also
+   try smaller element sizes.  */
+
+static int
+neon_cmode_for_move_imm (unsigned immlo, unsigned immhi, int float_p,
+			 unsigned *immbits, int *op, int size,
+			 enum neon_el_type type)
+{
+  /* Only permit float immediates (including 0.0/-0.0) if the operand type is
+     float.  */
+  if (type == NT_float && !float_p)
+    return FAIL;
+
+  if (type == NT_float && is_quarter_float (immlo) && immhi == 0)
+    {
+      if (size != 32 || *op == 1)
+	return FAIL;
+      *immbits = neon_qfloat_bits (immlo);
+      return 0xf;
+    }
+
+  if (size == 64)
+    {
+      if (neon_bits_same_in_bytes (immhi)
+	  && neon_bits_same_in_bytes (immlo))
+	{
+	  if (*op == 1)
+	    return FAIL;
+	  *immbits = (neon_squash_bits (immhi) << 4)
+		     | neon_squash_bits (immlo);
+	  *op = 1;
+	  return 0xe;
+	}
+
+      if (immhi != immlo)
+	return FAIL;
+    }
+
+  if (size >= 32)
+    {
+      if (immlo == (immlo & 0x000000ff))
+	{
+	  *immbits = immlo;
+	  return 0x0;
+	}
+      else if (immlo == (immlo & 0x0000ff00))
+	{
+	  *immbits = immlo >> 8;
+	  return 0x2;
+	}
+      else if (immlo == (immlo & 0x00ff0000))
+	{
+	  *immbits = immlo >> 16;
+	  return 0x4;
+	}
+      else if (immlo == (immlo & 0xff000000))
+	{
+	  *immbits = immlo >> 24;
+	  return 0x6;
+	}
+      else if (immlo == ((immlo & 0x0000ff00) | 0x000000ff))
+	{
+	  *immbits = (immlo >> 8) & 0xff;
+	  return 0xc;
+	}
+      else if (immlo == ((immlo & 0x00ff0000) | 0x0000ffff))
+	{
+	  *immbits = (immlo >> 16) & 0xff;
+	  return 0xd;
+	}
+
+      if ((immlo & 0xffff) != (immlo >> 16))
+	return FAIL;
+      immlo &= 0xffff;
+    }
+
+  if (size >= 16)
+    {
+      if (immlo == (immlo & 0x000000ff))
+	{
+	  *immbits = immlo;
+	  return 0x8;
+	}
+      else if (immlo == (immlo & 0x0000ff00))
+	{
+	  *immbits = immlo >> 8;
+	  return 0xa;
+	}
+
+      if ((immlo & 0xff) != (immlo >> 8))
+	return FAIL;
+      immlo &= 0xff;
+    }
+
+  if (immlo == (immlo & 0x000000ff))
+    {
+      /* Don't allow MVN with 8-bit immediate.  */
+      if (*op == 1)
+	return FAIL;
+      *immbits = immlo;
+      return 0xe;
+    }
+
+  return FAIL;
+}
+
+#if defined BFD_HOST_64_BIT
+/* Returns TRUE if double precision value V may be cast
+   to single precision without loss of accuracy.  */
+
+static bfd_boolean
+is_double_a_single (bfd_int64_t v)
+{
+  int exp = (int)((v >> 52) & 0x7FF);
+  bfd_int64_t mantissa = (v & (bfd_int64_t)0xFFFFFFFFFFFFFULL);
+
+  return (exp == 0 || exp == 0x7FF
+	  || (exp >= 1023 - 126 && exp <= 1023 + 127))
+    && (mantissa & 0x1FFFFFFFl) == 0;
+}
+
+/* Returns a double precision value casted to single precision
+   (ignoring the least significant bits in exponent and mantissa).  */
+
+static int
+double_to_single (bfd_int64_t v)
+{
+  int sign = (int) ((v >> 63) & 1l);
+  int exp = (int) ((v >> 52) & 0x7FF);
+  bfd_int64_t mantissa = (v & (bfd_int64_t)0xFFFFFFFFFFFFFULL);
+
+  if (exp == 0x7FF)
+    exp = 0xFF;
+  else
+    {
+      exp = exp - 1023 + 127;
+      if (exp >= 0xFF)
+	{
+	  /* Infinity.  */
+	  exp = 0x7F;
+	  mantissa = 0;
+	}
+      else if (exp < 0)
+	{
+	  /* No denormalized numbers.  */
+	  exp = 0;
+	  mantissa = 0;
+	}
+    }
+  mantissa >>= 29;
+  return (sign << 31) | (exp << 23) | mantissa;
+}
+#endif /* BFD_HOST_64_BIT */
+
+enum lit_type
+{
+  CONST_THUMB,
+  CONST_ARM,
+  CONST_VEC
+};
+
+static void do_vfp_nsyn_opcode (const char *);
+
+/* inst.reloc.exp describes an "=expr" load pseudo-operation.
+   Determine whether it can be performed with a move instruction; if
+   it can, convert inst.instruction to that move instruction and
+   return TRUE; if it can't, convert inst.instruction to a literal-pool
+   load and return FALSE.  If this is not a valid thing to do in the
+   current context, set inst.error and return TRUE.
+
+   inst.operands[i] describes the destination register.	 */
+
+static bfd_boolean
+move_or_literal_pool (int i, enum lit_type t, bfd_boolean mode_3)
+{
+  unsigned long tbit;
+  bfd_boolean thumb_p = (t == CONST_THUMB);
+  bfd_boolean arm_p   = (t == CONST_ARM);
+
+  if (thumb_p)
+    tbit = (inst.instruction > 0xffff) ? THUMB2_LOAD_BIT : THUMB_LOAD_BIT;
+  else
+    tbit = LOAD_BIT;
+
+  if ((inst.instruction & tbit) == 0)
+    {
+      inst.error = _("invalid pseudo operation");
+      return TRUE;
+    }
+
+  if (inst.reloc.exp.X_op != O_constant
+      && inst.reloc.exp.X_op != O_symbol
+      && inst.reloc.exp.X_op != O_big)
+    {
+      inst.error = _("constant expression expected");
+      return TRUE;
+    }
+
+  if (inst.reloc.exp.X_op == O_constant
+      || inst.reloc.exp.X_op == O_big)
+    {
+#if defined BFD_HOST_64_BIT
+      bfd_int64_t v;
+#else
+      offsetT v;
+#endif
+      if (inst.reloc.exp.X_op == O_big)
+	{
+	  LITTLENUM_TYPE w[X_PRECISION];
+	  LITTLENUM_TYPE * l;
+
+	  if (inst.reloc.exp.X_add_number == -1)
+	    {
+	      gen_to_words (w, X_PRECISION, E_PRECISION);
+	      l = w;
+	      /* FIXME: Should we check words w[2..5] ?  */
+	    }
+	  else
+	    l = generic_bignum;
+
+#if defined BFD_HOST_64_BIT
+	  v =
+	    ((((((((bfd_int64_t) l[3] & LITTLENUM_MASK)
+		  << LITTLENUM_NUMBER_OF_BITS)
+		 | ((bfd_int64_t) l[2] & LITTLENUM_MASK))
+		<< LITTLENUM_NUMBER_OF_BITS)
+	       | ((bfd_int64_t) l[1] & LITTLENUM_MASK))
+	      << LITTLENUM_NUMBER_OF_BITS)
+	     | ((bfd_int64_t) l[0] & LITTLENUM_MASK));
+#else
+	  v = ((l[1] & LITTLENUM_MASK) << LITTLENUM_NUMBER_OF_BITS)
+	    |  (l[0] & LITTLENUM_MASK);
+#endif
+	}
+      else
+	v = inst.reloc.exp.X_add_number;
+
+      if (!inst.operands[i].issingle)
+	{
+	  if (thumb_p)
+	    {
+	      if ((v & ~0xFF) == 0)
+		{
+		  /* This can be done with a mov(1) instruction.  */
+		  inst.instruction = T_OPCODE_MOV_I8 | (inst.operands[i].reg << 8);
+		  inst.instruction |= v;
+		  return TRUE;
+		}
+
+	      if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_arch_t2))
+		{
+		  /* Check if on thumb2 it can be done with a mov.w or mvn.w
+		     instruction.  */
+		  unsigned int newimm;
+		  bfd_boolean isNegated;
+
+		  newimm = encode_thumb32_immediate (v);
+		  if (newimm != (unsigned int) FAIL)
+		    isNegated = FALSE;
+		  else
+		    {
+		      newimm = encode_thumb32_immediate (~v);
+		      if (newimm != (unsigned int) FAIL)
+			isNegated = TRUE;
+		    }
+
+		  if (newimm != (unsigned int) FAIL)
+		    {
+		      inst.instruction = (0xf04f0000
+					  | (inst.operands[i].reg << 8));
+		      inst.instruction |= (isNegated ? 0x200000 : 0);
+		      inst.instruction |= (newimm & 0x800) << 15;
+		      inst.instruction |= (newimm & 0x700) << 4;
+		      inst.instruction |= (newimm & 0x0ff);
+		      return TRUE;
+		    }
+		  else if ((v & ~0xFFFF) == 0)
+		    {
+		      /* The number can be loaded with a mov.w instruction.  */
+		      int imm = v & 0xFFFF;
+
+		      inst.instruction = 0xf2400000;  /* MOVW.  */
+		      inst.instruction |= (inst.operands[i].reg << 8);
+		      inst.instruction |= (imm & 0xf000) << 4;
+		      inst.instruction |= (imm & 0x0800) << 15;
+		      inst.instruction |= (imm & 0x0700) << 4;
+		      inst.instruction |= (imm & 0x00ff);
+		      return TRUE;
+		    }
+		}
+	    }
+	  else if (arm_p)
+	    {
+	      int value = encode_arm_immediate (v);
+
+	      if (value != FAIL)
+		{
+		  /* This can be done with a mov instruction.  */
+		  inst.instruction &= LITERAL_MASK;
+		  inst.instruction |= INST_IMMEDIATE | (OPCODE_MOV << DATA_OP_SHIFT);
+		  inst.instruction |= value & 0xfff;
+		  return TRUE;
+		}
+
+	      value = encode_arm_immediate (~ v);
+	      if (value != FAIL)
+		{
+		  /* This can be done with a mvn instruction.  */
+		  inst.instruction &= LITERAL_MASK;
+		  inst.instruction |= INST_IMMEDIATE | (OPCODE_MVN << DATA_OP_SHIFT);
+		  inst.instruction |= value & 0xfff;
+		  return TRUE;
+		}
+	    }
+	  else if (t == CONST_VEC)
+	    {
+	      int op = 0;
+	      unsigned immbits = 0;
+	      unsigned immlo = inst.operands[1].imm;
+	      unsigned immhi = inst.operands[1].regisimm
+		? inst.operands[1].reg
+		: inst.reloc.exp.X_unsigned
+		? 0
+		: ((bfd_int64_t)((int) immlo)) >> 32;
+	      int cmode = neon_cmode_for_move_imm (immlo, immhi, FALSE, &immbits,
+						   &op, 64, NT_invtype);
+
+	      if (cmode == FAIL)
+		{
+		  neon_invert_size (&immlo, &immhi, 64);
+		  op = !op;
+		  cmode = neon_cmode_for_move_imm (immlo, immhi, FALSE, &immbits,
+						   &op, 64, NT_invtype);
+		}
+
+	      if (cmode != FAIL)
+		{
+		  inst.instruction = (inst.instruction & VLDR_VMOV_SAME)
+		    | (1 << 23)
+		    | (cmode << 8)
+		    | (op << 5)
+		    | (1 << 4);
+
+		  /* Fill other bits in vmov encoding for both thumb and arm.  */
+		  if (thumb_mode)
+		    inst.instruction |= (0x7U << 29) | (0xF << 24);
+		  else
+		    inst.instruction |= (0xFU << 28) | (0x1 << 25);
+		  neon_write_immbits (immbits);
+		  return TRUE;
+		}
+	    }
+	}
+
+      if (t == CONST_VEC)
+	{
+	  /* Check if vldr Rx, =constant could be optimized to vmov Rx, #constant.  */
+	  if (inst.operands[i].issingle
+	      && is_quarter_float (inst.operands[1].imm)
+	      && ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v3xd))
+	    {
+	      inst.operands[1].imm =
+		neon_qfloat_bits (v);
+	      do_vfp_nsyn_opcode ("fconsts");
+	      return TRUE;
+	    }
+
+	  /* If our host does not support a 64-bit type then we cannot perform
+	     the following optimization.  This mean that there will be a
+	     discrepancy between the output produced by an assembler built for
+	     a 32-bit-only host and the output produced from a 64-bit host, but
+	     this cannot be helped.  */
+#if defined BFD_HOST_64_BIT
+	  else if (!inst.operands[1].issingle
+		   && ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v3))
+	    {
+	      if (is_double_a_single (v)
+		  && is_quarter_float (double_to_single (v)))
+		{
+		  inst.operands[1].imm =
+		    neon_qfloat_bits (double_to_single (v));
+		  do_vfp_nsyn_opcode ("fconstd");
+		  return TRUE;
+		}
+	    }
+#endif
+	}
+    }
+
+  if (add_to_lit_pool ((!inst.operands[i].isvec
+			|| inst.operands[i].issingle) ? 4 : 8) == FAIL)
+    return TRUE;
+
+  inst.operands[1].reg = REG_PC;
+  inst.operands[1].isreg = 1;
+  inst.operands[1].preind = 1;
+  inst.reloc.pc_rel = 1;
+  inst.reloc.type = (thumb_p
+		     ? BFD_RELOC_ARM_THUMB_OFFSET
+		     : (mode_3
+			? BFD_RELOC_ARM_HWLITERAL
+			: BFD_RELOC_ARM_LITERAL));
+  return FALSE;
+}
+
+/* inst.operands[i] was set up by parse_address.  Encode it into an
+   ARM-format instruction.  Reject all forms which cannot be encoded
+   into a coprocessor load/store instruction.  If wb_ok is false,
+   reject use of writeback; if unind_ok is false, reject use of
+   unindexed addressing.  If reloc_override is not 0, use it instead
+   of BFD_ARM_CP_OFF_IMM, unless the initial relocation is a group one
+   (in which case it is preserved).  */
+
+static int
+encode_arm_cp_address (int i, int wb_ok, int unind_ok, int reloc_override)
+{
+  if (!inst.operands[i].isreg)
+    {
+      /* PR 18256 */
+      if (! inst.operands[0].isvec)
+	{
+	  inst.error = _("invalid co-processor operand");
+	  return FAIL;
+	}
+      if (move_or_literal_pool (0, CONST_VEC, /*mode_3=*/FALSE))
+	return SUCCESS;
+    }
+
+  inst.instruction |= inst.operands[i].reg << 16;
+
+  gas_assert (!(inst.operands[i].preind && inst.operands[i].postind));
+
+  if (!inst.operands[i].preind && !inst.operands[i].postind) /* unindexed */
+    {
+      gas_assert (!inst.operands[i].writeback);
+      if (!unind_ok)
+	{
+	  inst.error = _("instruction does not support unindexed addressing");
+	  return FAIL;
+	}
+      inst.instruction |= inst.operands[i].imm;
+      inst.instruction |= INDEX_UP;
+      return SUCCESS;
+    }
+
+  if (inst.operands[i].preind)
+    inst.instruction |= PRE_INDEX;
+
+  if (inst.operands[i].writeback)
+    {
+      if (inst.operands[i].reg == REG_PC)
+	{
+	  inst.error = _("pc may not be used with write-back");
+	  return FAIL;
+	}
+      if (!wb_ok)
+	{
+	  inst.error = _("instruction does not support writeback");
+	  return FAIL;
+	}
+      inst.instruction |= WRITE_BACK;
+    }
+
+  if (reloc_override)
+    inst.reloc.type = (bfd_reloc_code_real_type) reloc_override;
+  else if ((inst.reloc.type < BFD_RELOC_ARM_ALU_PC_G0_NC
+	    || inst.reloc.type > BFD_RELOC_ARM_LDC_SB_G2)
+	   && inst.reloc.type != BFD_RELOC_ARM_LDR_PC_G0)
+    {
+      if (thumb_mode)
+	inst.reloc.type = BFD_RELOC_ARM_T32_CP_OFF_IMM;
+      else
+	inst.reloc.type = BFD_RELOC_ARM_CP_OFF_IMM;
+    }
+
+  /* Prefer + for zero encoded value.  */
+  if (!inst.operands[i].negative)
+    inst.instruction |= INDEX_UP;
+
+  return SUCCESS;
+}
+
+/* Functions for instruction encoding, sorted by sub-architecture.
+   First some generics; their names are taken from the conventional
+   bit positions for register arguments in ARM format instructions.  */
+
+static void
+do_noargs (void)
+{
+}
+
+static void
+do_rd (void)
+{
+  inst.instruction |= inst.operands[0].reg << 12;
+}
+
+static void
+do_rd_rm (void)
+{
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= inst.operands[1].reg;
+}
+
+static void
+do_rm_rn (void)
+{
+  inst.instruction |= inst.operands[0].reg;
+  inst.instruction |= inst.operands[1].reg << 16;
+}
+
+static void
+do_rd_rn (void)
+{
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= inst.operands[1].reg << 16;
+}
+
+static void
+do_rn_rd (void)
+{
+  inst.instruction |= inst.operands[0].reg << 16;
+  inst.instruction |= inst.operands[1].reg << 12;
+}
+
+static bfd_boolean
+check_obsolete (const arm_feature_set *feature, const char *msg)
+{
+  if (ARM_CPU_IS_ANY (cpu_variant))
+    {
+      as_tsktsk ("%s", msg);
+      return TRUE;
+    }
+  else if (ARM_CPU_HAS_FEATURE (cpu_variant, *feature))
+    {
+      as_bad ("%s", msg);
+      return TRUE;
+    }
+
+  return FALSE;
+}
+
+static void
+do_rd_rm_rn (void)
+{
+  unsigned Rn = inst.operands[2].reg;
+  /* Enforce restrictions on SWP instruction.  */
+  if ((inst.instruction & 0x0fbfffff) == 0x01000090)
+    {
+      constraint (Rn == inst.operands[0].reg || Rn == inst.operands[1].reg,
+		  _("Rn must not overlap other operands"));
+
+      /* SWP{b} is obsolete for ARMv8-A, and deprecated for ARMv6* and ARMv7.
+       */
+      if (!check_obsolete (&arm_ext_v8,
+			   _("swp{b} use is obsoleted for ARMv8 and later"))
+	  && warn_on_deprecated
+	  && ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v6))
+	as_tsktsk (_("swp{b} use is deprecated for ARMv6 and ARMv7"));
+    }
+
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= inst.operands[1].reg;
+  inst.instruction |= Rn << 16;
+}
+
+static void
+do_rd_rn_rm (void)
+{
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= inst.operands[1].reg << 16;
+  inst.instruction |= inst.operands[2].reg;
+}
+
+static void
+do_rm_rd_rn (void)
+{
+  constraint ((inst.operands[2].reg == REG_PC), BAD_PC);
+  constraint (((inst.reloc.exp.X_op != O_constant
+		&& inst.reloc.exp.X_op != O_illegal)
+	       || inst.reloc.exp.X_add_number != 0),
+	      BAD_ADDR_MODE);
+  inst.instruction |= inst.operands[0].reg;
+  inst.instruction |= inst.operands[1].reg << 12;
+  inst.instruction |= inst.operands[2].reg << 16;
+}
+
+static void
+do_imm0 (void)
+{
+  inst.instruction |= inst.operands[0].imm;
+}
+
+static void
+do_rd_cpaddr (void)
+{
+  inst.instruction |= inst.operands[0].reg << 12;
+  encode_arm_cp_address (1, TRUE, TRUE, 0);
+}
+
+/* ARM instructions, in alphabetical order by function name (except
+   that wrapper functions appear immediately after the function they
+   wrap).  */
+
+/* This is a pseudo-op of the form "adr rd, label" to be converted
+   into a relative address of the form "add rd, pc, #label-.-8".  */
+
+static void
+do_adr (void)
+{
+  inst.instruction |= (inst.operands[0].reg << 12);  /* Rd */
+
+  /* Frag hacking will turn this into a sub instruction if the offset turns
+     out to be negative.  */
+  inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;
+  inst.reloc.pc_rel = 1;
+  inst.reloc.exp.X_add_number -= 8;
+}
+
+/* This is a pseudo-op of the form "adrl rd, label" to be converted
+   into a relative address of the form:
+   add rd, pc, #low(label-.-8)"
+   add rd, rd, #high(label-.-8)"  */
+
+static void
+do_adrl (void)
+{
+  inst.instruction |= (inst.operands[0].reg << 12);  /* Rd */
+
+  /* Frag hacking will turn this into a sub instruction if the offset turns
+     out to be negative.  */
+  inst.reloc.type	       = BFD_RELOC_ARM_ADRL_IMMEDIATE;
+  inst.reloc.pc_rel	       = 1;
+  inst.size		       = INSN_SIZE * 2;
+  inst.reloc.exp.X_add_number -= 8;
+}
+
+static void
+do_arit (void)
+{
+  if (!inst.operands[1].present)
+    inst.operands[1].reg = inst.operands[0].reg;
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= inst.operands[1].reg << 16;
+  encode_arm_shifter_operand (2);
+}
+
+static void
+do_barrier (void)
+{
+  if (inst.operands[0].present)
+    inst.instruction |= inst.operands[0].imm;
+  else
+    inst.instruction |= 0xf;
+}
+
+static void
+do_bfc (void)
+{
+  unsigned int msb = inst.operands[1].imm + inst.operands[2].imm;
+  constraint (msb > 32, _("bit-field extends past end of register"));
+  /* The instruction encoding stores the LSB and MSB,
+     not the LSB and width.  */
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= inst.operands[1].imm << 7;
+  inst.instruction |= (msb - 1) << 16;
+}
+
+static void
+do_bfi (void)
+{
+  unsigned int msb;
+
+  /* #0 in second position is alternative syntax for bfc, which is
+     the same instruction but with REG_PC in the Rm field.  */
+  if (!inst.operands[1].isreg)
+    inst.operands[1].reg = REG_PC;
+
+  msb = inst.operands[2].imm + inst.operands[3].imm;
+  constraint (msb > 32, _("bit-field extends past end of register"));
+  /* The instruction encoding stores the LSB and MSB,
+     not the LSB and width.  */
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= inst.operands[1].reg;
+  inst.instruction |= inst.operands[2].imm << 7;
+  inst.instruction |= (msb - 1) << 16;
+}
+
+static void
+do_bfx (void)
+{
+  constraint (inst.operands[2].imm + inst.operands[3].imm > 32,
+	      _("bit-field extends past end of register"));
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= inst.operands[1].reg;
+  inst.instruction |= inst.operands[2].imm << 7;
+  inst.instruction |= (inst.operands[3].imm - 1) << 16;
+}
+
+/* ARM V5 breakpoint instruction (argument parse)
+     BKPT <16 bit unsigned immediate>
+     Instruction is not conditional.
+	The bit pattern given in insns[] has the COND_ALWAYS condition,
+	and it is an error if the caller tried to override that.  */
+
+static void
+do_bkpt (void)
+{
+  /* Top 12 of 16 bits to bits 19:8.  */
+  inst.instruction |= (inst.operands[0].imm & 0xfff0) << 4;
+
+  /* Bottom 4 of 16 bits to bits 3:0.  */
+  inst.instruction |= inst.operands[0].imm & 0xf;
+}
+
+static void
+encode_branch (int default_reloc)
+{
+  if (inst.operands[0].hasreloc)
+    {
+      constraint (inst.operands[0].imm != BFD_RELOC_ARM_PLT32
+		  && inst.operands[0].imm != BFD_RELOC_ARM_TLS_CALL,
+		  _("the only valid suffixes here are '(plt)' and '(tlscall)'"));
+      inst.reloc.type = inst.operands[0].imm == BFD_RELOC_ARM_PLT32
+	? BFD_RELOC_ARM_PLT32
+	: thumb_mode ? BFD_RELOC_ARM_THM_TLS_CALL : BFD_RELOC_ARM_TLS_CALL;
+    }
+  else
+    inst.reloc.type = (bfd_reloc_code_real_type) default_reloc;
+  inst.reloc.pc_rel = 1;
+}
+
+static void
+do_branch (void)
+{
+#ifdef OBJ_ELF
+  if (EF_ARM_EABI_VERSION (meabi_flags) >= EF_ARM_EABI_VER4)
+    encode_branch (BFD_RELOC_ARM_PCREL_JUMP);
+  else
+#endif
+    encode_branch (BFD_RELOC_ARM_PCREL_BRANCH);
+}
+
+static void
+do_bl (void)
+{
+#ifdef OBJ_ELF
+  if (EF_ARM_EABI_VERSION (meabi_flags) >= EF_ARM_EABI_VER4)
+    {
+      if (inst.cond == COND_ALWAYS)
+	encode_branch (BFD_RELOC_ARM_PCREL_CALL);
+      else
+	encode_branch (BFD_RELOC_ARM_PCREL_JUMP);
+    }
+  else
+#endif
+    encode_branch (BFD_RELOC_ARM_PCREL_BRANCH);
+}
+
+/* ARM V5 branch-link-exchange instruction (argument parse)
+     BLX <target_addr>		ie BLX(1)
+     BLX{<condition>} <Rm>	ie BLX(2)
+   Unfortunately, there are two different opcodes for this mnemonic.
+   So, the insns[].value is not used, and the code here zaps values
+	into inst.instruction.
+   Also, the <target_addr> can be 25 bits, hence has its own reloc.  */
+
+static void
+do_blx (void)
+{
+  if (inst.operands[0].isreg)
+    {
+      /* Arg is a register; the opcode provided by insns[] is correct.
+	 It is not illegal to do "blx pc", just useless.  */
+      if (inst.operands[0].reg == REG_PC)
+	as_tsktsk (_("use of r15 in blx in ARM mode is not really useful"));
+
+      inst.instruction |= inst.operands[0].reg;
+    }
+  else
+    {
+      /* Arg is an address; this instruction cannot be executed
+	 conditionally, and the opcode must be adjusted.
+	 We retain the BFD_RELOC_ARM_PCREL_BLX till the very end
+	 where we generate out a BFD_RELOC_ARM_PCREL_CALL instead.  */
+      constraint (inst.cond != COND_ALWAYS, BAD_COND);
+      inst.instruction = 0xfa000000;
+      encode_branch (BFD_RELOC_ARM_PCREL_BLX);
+    }
+}
+
+static void
+do_bx (void)
+{
+  bfd_boolean want_reloc;
+
+  if (inst.operands[0].reg == REG_PC)
+    as_tsktsk (_("use of r15 in bx in ARM mode is not really useful"));
+
+  inst.instruction |= inst.operands[0].reg;
+  /* Output R_ARM_V4BX relocations if is an EABI object that looks like
+     it is for ARMv4t or earlier.  */
+  want_reloc = !ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v5);
+  if (object_arch && !ARM_CPU_HAS_FEATURE (*object_arch, arm_ext_v5))
+      want_reloc = TRUE;
+
+#ifdef OBJ_ELF
+  if (EF_ARM_EABI_VERSION (meabi_flags) < EF_ARM_EABI_VER4)
+#endif
+    want_reloc = FALSE;
+
+  if (want_reloc)
+    inst.reloc.type = BFD_RELOC_ARM_V4BX;
+}
+
+
+/* ARM v5TEJ.  Jump to Jazelle code.  */
+
+static void
+do_bxj (void)
+{
+  if (inst.operands[0].reg == REG_PC)
+    as_tsktsk (_("use of r15 in bxj is not really useful"));
+
+  inst.instruction |= inst.operands[0].reg;
+}
+
+/* Co-processor data operation:
+      CDP{cond} <coproc>, <opcode_1>, <CRd>, <CRn>, <CRm>{, <opcode_2>}
+      CDP2	<coproc>, <opcode_1>, <CRd>, <CRn>, <CRm>{, <opcode_2>}	 */
+static void
+do_cdp (void)
+{
+  inst.instruction |= inst.operands[0].reg << 8;
+  inst.instruction |= inst.operands[1].imm << 20;
+  inst.instruction |= inst.operands[2].reg << 12;
+  inst.instruction |= inst.operands[3].reg << 16;
+  inst.instruction |= inst.operands[4].reg;
+  inst.instruction |= inst.operands[5].imm << 5;
+}
+
+static void
+do_cmp (void)
+{
+  inst.instruction |= inst.operands[0].reg << 16;
+  encode_arm_shifter_operand (1);
+}
+
+/* Transfer between coprocessor and ARM registers.
+   MRC{cond} <coproc>, <opcode_1>, <Rd>, <CRn>, <CRm>{, <opcode_2>}
+   MRC2
+   MCR{cond}
+   MCR2
+
+   No special properties.  */
+
+struct deprecated_coproc_regs_s
+{
+  unsigned cp;
+  int opc1;
+  unsigned crn;
+  unsigned crm;
+  int opc2;
+  arm_feature_set deprecated;
+  arm_feature_set obsoleted;
+  const char *dep_msg;
+  const char *obs_msg;
+};
+
+#define DEPR_ACCESS_V8 \
+  N_("This coprocessor register access is deprecated in ARMv8")
+
+/* Table of all deprecated coprocessor registers.  */
+static struct deprecated_coproc_regs_s deprecated_coproc_regs[] =
+{
+    {15, 0, 7, 10, 5,					/* CP15DMB.  */
+     ARM_FEATURE_CORE_LOW (ARM_EXT_V8), ARM_ARCH_NONE,
+     DEPR_ACCESS_V8, NULL},
+    {15, 0, 7, 10, 4,					/* CP15DSB.  */
+     ARM_FEATURE_CORE_LOW (ARM_EXT_V8), ARM_ARCH_NONE,
+     DEPR_ACCESS_V8, NULL},
+    {15, 0, 7,  5, 4,					/* CP15ISB.  */
+     ARM_FEATURE_CORE_LOW (ARM_EXT_V8), ARM_ARCH_NONE,
+     DEPR_ACCESS_V8, NULL},
+    {14, 6, 1,  0, 0,					/* TEEHBR.  */
+     ARM_FEATURE_CORE_LOW (ARM_EXT_V8), ARM_ARCH_NONE,
+     DEPR_ACCESS_V8, NULL},
+    {14, 6, 0,  0, 0,					/* TEECR.  */
+     ARM_FEATURE_CORE_LOW (ARM_EXT_V8), ARM_ARCH_NONE,
+     DEPR_ACCESS_V8, NULL},
+};
+
+#undef DEPR_ACCESS_V8
+
+static const size_t deprecated_coproc_reg_count =
+  sizeof (deprecated_coproc_regs) / sizeof (deprecated_coproc_regs[0]);
+
+static void
+do_co_reg (void)
+{
+  unsigned Rd;
+  size_t i;
+
+  Rd = inst.operands[2].reg;
+  if (thumb_mode)
+    {
+      if (inst.instruction == 0xee000010
+	  || inst.instruction == 0xfe000010)
+	/* MCR, MCR2  */
+	reject_bad_reg (Rd);
+      else
+	/* MRC, MRC2  */
+	constraint (Rd == REG_SP, BAD_SP);
+    }
+  else
+    {
+      /* MCR */
+      if (inst.instruction == 0xe000010)
+	constraint (Rd == REG_PC, BAD_PC);
+    }
+
+    for (i = 0; i < deprecated_coproc_reg_count; ++i)
+      {
+	const struct deprecated_coproc_regs_s *r =
+	  deprecated_coproc_regs + i;
+
+	if (inst.operands[0].reg == r->cp
+	    && inst.operands[1].imm == r->opc1
+	    && inst.operands[3].reg == r->crn
+	    && inst.operands[4].reg == r->crm
+	    && inst.operands[5].imm == r->opc2)
+	  {
+	    if (! ARM_CPU_IS_ANY (cpu_variant)
+		&& warn_on_deprecated
+		&& ARM_CPU_HAS_FEATURE (cpu_variant, r->deprecated))
+	      as_tsktsk ("%s", r->dep_msg);
+	  }
+      }
+
+  inst.instruction |= inst.operands[0].reg << 8;
+  inst.instruction |= inst.operands[1].imm << 21;
+  inst.instruction |= Rd << 12;
+  inst.instruction |= inst.operands[3].reg << 16;
+  inst.instruction |= inst.operands[4].reg;
+  inst.instruction |= inst.operands[5].imm << 5;
+}
+
+/* Transfer between coprocessor register and pair of ARM registers.
+   MCRR{cond} <coproc>, <opcode>, <Rd>, <Rn>, <CRm>.
+   MCRR2
+   MRRC{cond}
+   MRRC2
+
+   Two XScale instructions are special cases of these:
+
+     MAR{cond} acc0, <RdLo>, <RdHi> == MCRR{cond} p0, #0, <RdLo>, <RdHi>, c0
+     MRA{cond} acc0, <RdLo>, <RdHi> == MRRC{cond} p0, #0, <RdLo>, <RdHi>, c0
+
+   Result unpredictable if Rd or Rn is R15.  */
+
+static void
+do_co_reg2c (void)
+{
+  unsigned Rd, Rn;
+
+  Rd = inst.operands[2].reg;
+  Rn = inst.operands[3].reg;
+
+  if (thumb_mode)
+    {
+      reject_bad_reg (Rd);
+      reject_bad_reg (Rn);
+    }
+  else
+    {
+      constraint (Rd == REG_PC, BAD_PC);
+      constraint (Rn == REG_PC, BAD_PC);
+    }
+
+  inst.instruction |= inst.operands[0].reg << 8;
+  inst.instruction |= inst.operands[1].imm << 4;
+  inst.instruction |= Rd << 12;
+  inst.instruction |= Rn << 16;
+  inst.instruction |= inst.operands[4].reg;
+}
+
+static void
+do_cpsi (void)
+{
+  inst.instruction |= inst.operands[0].imm << 6;
+  if (inst.operands[1].present)
+    {
+      inst.instruction |= CPSI_MMOD;
+      inst.instruction |= inst.operands[1].imm;
+    }
+}
+
+static void
+do_dbg (void)
+{
+  inst.instruction |= inst.operands[0].imm;
+}
+
+static void
+do_div (void)
+{
+  unsigned Rd, Rn, Rm;
+
+  Rd = inst.operands[0].reg;
+  Rn = (inst.operands[1].present
+	? inst.operands[1].reg : Rd);
+  Rm = inst.operands[2].reg;
+
+  constraint ((Rd == REG_PC), BAD_PC);
+  constraint ((Rn == REG_PC), BAD_PC);
+  constraint ((Rm == REG_PC), BAD_PC);
+
+  inst.instruction |= Rd << 16;
+  inst.instruction |= Rn << 0;
+  inst.instruction |= Rm << 8;
+}
+
+static void
+do_it (void)
+{
+  /* There is no IT instruction in ARM mode.  We
+     process it to do the validation as if in
+     thumb mode, just in case the code gets
+     assembled for thumb using the unified syntax.  */
+
+  inst.size = 0;
+  if (unified_syntax)
+    {
+      set_it_insn_type (IT_INSN);
+      now_it.mask = (inst.instruction & 0xf) | 0x10;
+      now_it.cc = inst.operands[0].imm;
+    }
+}
+
+/* If there is only one register in the register list,
+   then return its register number.  Otherwise return -1.  */
+static int
+only_one_reg_in_list (int range)
+{
+  int i = ffs (range) - 1;
+  return (i > 15 || range != (1 << i)) ? -1 : i;
+}
+
+static void
+encode_ldmstm(int from_push_pop_mnem)
+{
+  int base_reg = inst.operands[0].reg;
+  int range = inst.operands[1].imm;
+  int one_reg;
+
+  inst.instruction |= base_reg << 16;
+  inst.instruction |= range;
+
+  if (inst.operands[1].writeback)
+    inst.instruction |= LDM_TYPE_2_OR_3;
+
+  if (inst.operands[0].writeback)
+    {
+      inst.instruction |= WRITE_BACK;
+      /* Check for unpredictable uses of writeback.  */
+      if (inst.instruction & LOAD_BIT)
+	{
+	  /* Not allowed in LDM type 2.	 */
+	  if ((inst.instruction & LDM_TYPE_2_OR_3)
+	      && ((range & (1 << REG_PC)) == 0))
+	    as_warn (_("writeback of base register is UNPREDICTABLE"));
+	  /* Only allowed if base reg not in list for other types.  */
+	  else if (range & (1 << base_reg))
+	    as_warn (_("writeback of base register when in register list is UNPREDICTABLE"));
+	}
+      else /* STM.  */
+	{
+	  /* Not allowed for type 2.  */
+	  if (inst.instruction & LDM_TYPE_2_OR_3)
+	    as_warn (_("writeback of base register is UNPREDICTABLE"));
+	  /* Only allowed if base reg not in list, or first in list.  */
+	  else if ((range & (1 << base_reg))
+		   && (range & ((1 << base_reg) - 1)))
+	    as_warn (_("if writeback register is in list, it must be the lowest reg in the list"));
+	}
+    }
+
+  /* If PUSH/POP has only one register, then use the A2 encoding.  */
+  one_reg = only_one_reg_in_list (range);
+  if (from_push_pop_mnem && one_reg >= 0)
+    {
+      int is_push = (inst.instruction & A_PUSH_POP_OP_MASK) == A1_OPCODE_PUSH;
+
+      inst.instruction &= A_COND_MASK;
+      inst.instruction |= is_push ? A2_OPCODE_PUSH : A2_OPCODE_POP;
+      inst.instruction |= one_reg << 12;
+    }
+}
+
+static void
+do_ldmstm (void)
+{
+  encode_ldmstm (/*from_push_pop_mnem=*/FALSE);
+}
+
+/* ARMv5TE load-consecutive (argument parse)
+   Mode is like LDRH.
+
+     LDRccD R, mode
+     STRccD R, mode.  */
+
+static void
+do_ldrd (void)
+{
+  constraint (inst.operands[0].reg % 2 != 0,
+	      _("first transfer register must be even"));
+  constraint (inst.operands[1].present
+	      && inst.operands[1].reg != inst.operands[0].reg + 1,
+	      _("can only transfer two consecutive registers"));
+  constraint (inst.operands[0].reg == REG_LR, _("r14 not allowed here"));
+  constraint (!inst.operands[2].isreg, _("'[' expected"));
+
+  if (!inst.operands[1].present)
+    inst.operands[1].reg = inst.operands[0].reg + 1;
+
+  /* encode_arm_addr_mode_3 will diagnose overlap between the base
+     register and the first register written; we have to diagnose
+     overlap between the base and the second register written here.  */
+
+  if (inst.operands[2].reg == inst.operands[1].reg
+      && (inst.operands[2].writeback || inst.operands[2].postind))
+    as_warn (_("base register written back, and overlaps "
+	       "second transfer register"));
+
+  if (!(inst.instruction & V4_STR_BIT))
+    {
+      /* For an index-register load, the index register must not overlap the
+	destination (even if not write-back).  */
+      if (inst.operands[2].immisreg
+	      && ((unsigned) inst.operands[2].imm == inst.operands[0].reg
+	      || (unsigned) inst.operands[2].imm == inst.operands[1].reg))
+	as_warn (_("index register overlaps transfer register"));
+    }
+  inst.instruction |= inst.operands[0].reg << 12;
+  encode_arm_addr_mode_3 (2, /*is_t=*/FALSE);
+}
+
+static void
+do_ldrex (void)
+{
+  constraint (!inst.operands[1].isreg || !inst.operands[1].preind
+	      || inst.operands[1].postind || inst.operands[1].writeback
+	      || inst.operands[1].immisreg || inst.operands[1].shifted
+	      || inst.operands[1].negative
+	      /* This can arise if the programmer has written
+		   strex rN, rM, foo
+		 or if they have mistakenly used a register name as the last
+		 operand,  eg:
+		   strex rN, rM, rX
+		 It is very difficult to distinguish between these two cases
+		 because "rX" might actually be a label. ie the register
+		 name has been occluded by a symbol of the same name. So we
+		 just generate a general 'bad addressing mode' type error
+		 message and leave it up to the programmer to discover the
+		 true cause and fix their mistake.  */
+	      || (inst.operands[1].reg == REG_PC),
+	      BAD_ADDR_MODE);
+
+  constraint (inst.reloc.exp.X_op != O_constant
+	      || inst.reloc.exp.X_add_number != 0,
+	      _("offset must be zero in ARM encoding"));
+
+  constraint ((inst.operands[1].reg == REG_PC), BAD_PC);
+
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= inst.operands[1].reg << 16;
+  inst.reloc.type = BFD_RELOC_UNUSED;
+}
+
+static void
+do_ldrexd (void)
+{
+  constraint (inst.operands[0].reg % 2 != 0,
+	      _("even register required"));
+  constraint (inst.operands[1].present
+	      && inst.operands[1].reg != inst.operands[0].reg + 1,
+	      _("can only load two consecutive registers"));
+  /* If op 1 were present and equal to PC, this function wouldn't
+     have been called in the first place.  */
+  constraint (inst.operands[0].reg == REG_LR, _("r14 not allowed here"));
+
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= inst.operands[2].reg << 16;
+}
+
+/* In both ARM and thumb state 'ldr pc, #imm'  with an immediate
+   which is not a multiple of four is UNPREDICTABLE.  */
+static void
+check_ldr_r15_aligned (void)
+{
+  constraint (!(inst.operands[1].immisreg)
+	      && (inst.operands[0].reg == REG_PC
+	      && inst.operands[1].reg == REG_PC
+	      && (inst.reloc.exp.X_add_number & 0x3)),
+	      _("ldr to register 15 must be 4-byte alligned"));
+}
+
+static void
+do_ldst (void)
+{
+  inst.instruction |= inst.operands[0].reg << 12;
+  if (!inst.operands[1].isreg)
+    if (move_or_literal_pool (0, CONST_ARM, /*mode_3=*/FALSE))
+      return;
+  encode_arm_addr_mode_2 (1, /*is_t=*/FALSE);
+  check_ldr_r15_aligned ();
+}
+
+static void
+do_ldstt (void)
+{
+  /* ldrt/strt always use post-indexed addressing.  Turn [Rn] into [Rn]! and
+     reject [Rn,...].  */
+  if (inst.operands[1].preind)
+    {
+      constraint (inst.reloc.exp.X_op != O_constant
+		  || inst.reloc.exp.X_add_number != 0,
+		  _("this instruction requires a post-indexed address"));
+
+      inst.operands[1].preind = 0;
+      inst.operands[1].postind = 1;
+      inst.operands[1].writeback = 1;
+    }
+  inst.instruction |= inst.operands[0].reg << 12;
+  encode_arm_addr_mode_2 (1, /*is_t=*/TRUE);
+}
+
+/* Halfword and signed-byte load/store operations.  */
+
+static void
+do_ldstv4 (void)
+{
+  constraint (inst.operands[0].reg == REG_PC, BAD_PC);
+  inst.instruction |= inst.operands[0].reg << 12;
+  if (!inst.operands[1].isreg)
+    if (move_or_literal_pool (0, CONST_ARM, /*mode_3=*/TRUE))
+      return;
+  encode_arm_addr_mode_3 (1, /*is_t=*/FALSE);
+}
+
+static void
+do_ldsttv4 (void)
+{
+  /* ldrt/strt always use post-indexed addressing.  Turn [Rn] into [Rn]! and
+     reject [Rn,...].  */
+  if (inst.operands[1].preind)
+    {
+      constraint (inst.reloc.exp.X_op != O_constant
+		  || inst.reloc.exp.X_add_number != 0,
+		  _("this instruction requires a post-indexed address"));
+
+      inst.operands[1].preind = 0;
+      inst.operands[1].postind = 1;
+      inst.operands[1].writeback = 1;
+    }
+  inst.instruction |= inst.operands[0].reg << 12;
+  encode_arm_addr_mode_3 (1, /*is_t=*/TRUE);
+}
+
+/* Co-processor register load/store.
+   Format: <LDC|STC>{cond}[L] CP#,CRd,<address>	 */
+static void
+do_lstc (void)
+{
+  inst.instruction |= inst.operands[0].reg << 8;
+  inst.instruction |= inst.operands[1].reg << 12;
+  encode_arm_cp_address (2, TRUE, TRUE, 0);
+}
+
+static void
+do_mlas (void)
+{
+  /* This restriction does not apply to mls (nor to mla in v6 or later).  */
+  if (inst.operands[0].reg == inst.operands[1].reg
+      && !ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v6)
+      && !(inst.instruction & 0x00400000))
+    as_tsktsk (_("Rd and Rm should be different in mla"));
+
+  inst.instruction |= inst.operands[0].reg << 16;
+  inst.instruction |= inst.operands[1].reg;
+  inst.instruction |= inst.operands[2].reg << 8;
+  inst.instruction |= inst.operands[3].reg << 12;
+}
+
+static void
+do_mov (void)
+{
+  inst.instruction |= inst.operands[0].reg << 12;
+  encode_arm_shifter_operand (1);
+}
+
+/* ARM V6T2 16-bit immediate register load: MOV[WT]{cond} Rd, #<imm16>.	 */
+static void
+do_mov16 (void)
+{
+  bfd_vma imm;
+  bfd_boolean top;
+
+  top = (inst.instruction & 0x00400000) != 0;
+  constraint (top && inst.reloc.type == BFD_RELOC_ARM_MOVW,
+	      _(":lower16: not allowed this instruction"));
+  constraint (!top && inst.reloc.type == BFD_RELOC_ARM_MOVT,
+	      _(":upper16: not allowed instruction"));
+  inst.instruction |= inst.operands[0].reg << 12;
+  if (inst.reloc.type == BFD_RELOC_UNUSED)
+    {
+      imm = inst.reloc.exp.X_add_number;
+      /* The value is in two pieces: 0:11, 16:19.  */
+      inst.instruction |= (imm & 0x00000fff);
+      inst.instruction |= (imm & 0x0000f000) << 4;
+    }
+}
+
+static int
+do_vfp_nsyn_mrs (void)
+{
+  if (inst.operands[0].isvec)
+    {
+      if (inst.operands[1].reg != 1)
+	first_error (_("operand 1 must be FPSCR"));
+      memset (&inst.operands[0], '\0', sizeof (inst.operands[0]));
+      memset (&inst.operands[1], '\0', sizeof (inst.operands[1]));
+      do_vfp_nsyn_opcode ("fmstat");
+    }
+  else if (inst.operands[1].isvec)
+    do_vfp_nsyn_opcode ("fmrx");
+  else
+    return FAIL;
+
+  return SUCCESS;
+}
+
+static int
+do_vfp_nsyn_msr (void)
+{
+  if (inst.operands[0].isvec)
+    do_vfp_nsyn_opcode ("fmxr");
+  else
+    return FAIL;
+
+  return SUCCESS;
+}
+
+static void
+do_vmrs (void)
+{
+  unsigned Rt = inst.operands[0].reg;
+
+  if (thumb_mode && Rt == REG_SP)
+    {
+      inst.error = BAD_SP;
+      return;
+    }
+
+  /* APSR_ sets isvec. All other refs to PC are illegal.  */
+  if (!inst.operands[0].isvec && Rt == REG_PC)
+    {
+      inst.error = BAD_PC;
+      return;
+    }
+
+  /* If we get through parsing the register name, we just insert the number
+     generated into the instruction without further validation.  */
+  inst.instruction |= (inst.operands[1].reg << 16);
+  inst.instruction |= (Rt << 12);
+}
+
+static void
+do_vmsr (void)
+{
+  unsigned Rt = inst.operands[1].reg;
+
+  if (thumb_mode)
+    reject_bad_reg (Rt);
+  else if (Rt == REG_PC)
+    {
+      inst.error = BAD_PC;
+      return;
+    }
+
+  /* If we get through parsing the register name, we just insert the number
+     generated into the instruction without further validation.  */
+  inst.instruction |= (inst.operands[0].reg << 16);
+  inst.instruction |= (Rt << 12);
+}
+
+static void
+do_mrs (void)
+{
+  unsigned br;
+
+  if (do_vfp_nsyn_mrs () == SUCCESS)
+    return;
+
+  constraint (inst.operands[0].reg == REG_PC, BAD_PC);
+  inst.instruction |= inst.operands[0].reg << 12;
+
+  if (inst.operands[1].isreg)
+    {
+      br = inst.operands[1].reg;
+      if (((br & 0x200) == 0) && ((br & 0xf0000) != 0xf000))
+	as_bad (_("bad register for mrs"));
+    }
+  else
+    {
+      /* mrs only accepts CPSR/SPSR/CPSR_all/SPSR_all.  */
+      constraint ((inst.operands[1].imm & (PSR_c|PSR_x|PSR_s|PSR_f))
+		  != (PSR_c|PSR_f),
+		  _("'APSR', 'CPSR' or 'SPSR' expected"));
+      br = (15<<16) | (inst.operands[1].imm & SPSR_BIT);
+    }
+
+  inst.instruction |= br;
+}
+
+/* Two possible forms:
+      "{C|S}PSR_<field>, Rm",
+      "{C|S}PSR_f, #expression".  */
+
+static void
+do_msr (void)
+{
+  if (do_vfp_nsyn_msr () == SUCCESS)
+    return;
+
+  inst.instruction |= inst.operands[0].imm;
+  if (inst.operands[1].isreg)
+    inst.instruction |= inst.operands[1].reg;
+  else
+    {
+      inst.instruction |= INST_IMMEDIATE;
+      inst.reloc.type = BFD_RELOC_ARM_IMMEDIATE;
+      inst.reloc.pc_rel = 0;
+    }
+}
+
+static void
+do_mul (void)
+{
+  constraint (inst.operands[2].reg == REG_PC, BAD_PC);
+
+  if (!inst.operands[2].present)
+    inst.operands[2].reg = inst.operands[0].reg;
+  inst.instruction |= inst.operands[0].reg << 16;
+  inst.instruction |= inst.operands[1].reg;
+  inst.instruction |= inst.operands[2].reg << 8;
+
+  if (inst.operands[0].reg == inst.operands[1].reg
+      && !ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v6))
+    as_tsktsk (_("Rd and Rm should be different in mul"));
+}
+
+/* Long Multiply Parser
+   UMULL RdLo, RdHi, Rm, Rs
+   SMULL RdLo, RdHi, Rm, Rs
+   UMLAL RdLo, RdHi, Rm, Rs
+   SMLAL RdLo, RdHi, Rm, Rs.  */
+
+static void
+do_mull (void)
+{
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= inst.operands[1].reg << 16;
+  inst.instruction |= inst.operands[2].reg;
+  inst.instruction |= inst.operands[3].reg << 8;
+
+  /* rdhi and rdlo must be different.  */
+  if (inst.operands[0].reg == inst.operands[1].reg)
+    as_tsktsk (_("rdhi and rdlo must be different"));
+
+  /* rdhi, rdlo and rm must all be different before armv6.  */
+  if ((inst.operands[0].reg == inst.operands[2].reg
+      || inst.operands[1].reg == inst.operands[2].reg)
+      && !ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v6))
+    as_tsktsk (_("rdhi, rdlo and rm must all be different"));
+}
+
+static void
+do_nop (void)
+{
+  if (inst.operands[0].present
+      || ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v6k))
+    {
+      /* Architectural NOP hints are CPSR sets with no bits selected.  */
+      inst.instruction &= 0xf0000000;
+      inst.instruction |= 0x0320f000;
+      if (inst.operands[0].present)
+	inst.instruction |= inst.operands[0].imm;
+    }
+}
+
+/* ARM V6 Pack Halfword Bottom Top instruction (argument parse).
+   PKHBT {<cond>} <Rd>, <Rn>, <Rm> {, LSL #<shift_imm>}
+   Condition defaults to COND_ALWAYS.
+   Error if Rd, Rn or Rm are R15.  */
+
+static void
+do_pkhbt (void)
+{
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= inst.operands[1].reg << 16;
+  inst.instruction |= inst.operands[2].reg;
+  if (inst.operands[3].present)
+    encode_arm_shift (3);
+}
+
+/* ARM V6 PKHTB (Argument Parse).  */
+
+static void
+do_pkhtb (void)
+{
+  if (!inst.operands[3].present)
+    {
+      /* If the shift specifier is omitted, turn the instruction
+	 into pkhbt rd, rm, rn. */
+      inst.instruction &= 0xfff00010;
+      inst.instruction |= inst.operands[0].reg << 12;
+      inst.instruction |= inst.operands[1].reg;
+      inst.instruction |= inst.operands[2].reg << 16;
+    }
+  else
+    {
+      inst.instruction |= inst.operands[0].reg << 12;
+      inst.instruction |= inst.operands[1].reg << 16;
+      inst.instruction |= inst.operands[2].reg;
+      encode_arm_shift (3);
+    }
+}
+
+/* ARMv5TE: Preload-Cache
+   MP Extensions: Preload for write
+
+    PLD(W) <addr_mode>
+
+  Syntactically, like LDR with B=1, W=0, L=1.  */
+
+static void
+do_pld (void)
+{
+  constraint (!inst.operands[0].isreg,
+	      _("'[' expected after PLD mnemonic"));
+  constraint (inst.operands[0].postind,
+	      _("post-indexed expression used in preload instruction"));
+  constraint (inst.operands[0].writeback,
+	      _("writeback used in preload instruction"));
+  constraint (!inst.operands[0].preind,
+	      _("unindexed addressing used in preload instruction"));
+  encode_arm_addr_mode_2 (0, /*is_t=*/FALSE);
+}
+
+/* ARMv7: PLI <addr_mode>  */
+static void
+do_pli (void)
+{
+  constraint (!inst.operands[0].isreg,
+	      _("'[' expected after PLI mnemonic"));
+  constraint (inst.operands[0].postind,
+	      _("post-indexed expression used in preload instruction"));
+  constraint (inst.operands[0].writeback,
+	      _("writeback used in preload instruction"));
+  constraint (!inst.operands[0].preind,
+	      _("unindexed addressing used in preload instruction"));
+  encode_arm_addr_mode_2 (0, /*is_t=*/FALSE);
+  inst.instruction &= ~PRE_INDEX;
+}
+
+static void
+do_push_pop (void)
+{
+  constraint (inst.operands[0].writeback,
+	      _("push/pop do not support {reglist}^"));
+  inst.operands[1] = inst.operands[0];
+  memset (&inst.operands[0], 0, sizeof inst.operands[0]);
+  inst.operands[0].isreg = 1;
+  inst.operands[0].writeback = 1;
+  inst.operands[0].reg = REG_SP;
+  encode_ldmstm (/*from_push_pop_mnem=*/TRUE);
+}
+
+/* ARM V6 RFE (Return from Exception) loads the PC and CPSR from the
+   word at the specified address and the following word
+   respectively.
+   Unconditionally executed.
+   Error if Rn is R15.	*/
+
+static void
+do_rfe (void)
+{
+  inst.instruction |= inst.operands[0].reg << 16;
+  if (inst.operands[0].writeback)
+    inst.instruction |= WRITE_BACK;
+}
+
+/* ARM V6 ssat (argument parse).  */
+
+static void
+do_ssat (void)
+{
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= (inst.operands[1].imm - 1) << 16;
+  inst.instruction |= inst.operands[2].reg;
+
+  if (inst.operands[3].present)
+    encode_arm_shift (3);
+}
+
+/* ARM V6 usat (argument parse).  */
+
+static void
+do_usat (void)
+{
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= inst.operands[1].imm << 16;
+  inst.instruction |= inst.operands[2].reg;
+
+  if (inst.operands[3].present)
+    encode_arm_shift (3);
+}
+
+/* ARM V6 ssat16 (argument parse).  */
+
+static void
+do_ssat16 (void)
+{
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= ((inst.operands[1].imm - 1) << 16);
+  inst.instruction |= inst.operands[2].reg;
+}
+
+static void
+do_usat16 (void)
+{
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= inst.operands[1].imm << 16;
+  inst.instruction |= inst.operands[2].reg;
+}
+
+/* ARM V6 SETEND (argument parse).  Sets the E bit in the CPSR while
+   preserving the other bits.
+
+   setend <endian_specifier>, where <endian_specifier> is either
+   BE or LE.  */
+
+static void
+do_setend (void)
+{
+  if (warn_on_deprecated
+      && ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v8))
+      as_tsktsk (_("setend use is deprecated for ARMv8"));
+
+  if (inst.operands[0].imm)
+    inst.instruction |= 0x200;
+}
+
+static void
+do_shift (void)
+{
+  unsigned int Rm = (inst.operands[1].present
+		     ? inst.operands[1].reg
+		     : inst.operands[0].reg);
+
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= Rm;
+  if (inst.operands[2].isreg)  /* Rd, {Rm,} Rs */
+    {
+      inst.instruction |= inst.operands[2].reg << 8;
+      inst.instruction |= SHIFT_BY_REG;
+      /* PR 12854: Error on extraneous shifts.  */
+      constraint (inst.operands[2].shifted,
+		  _("extraneous shift as part of operand to shift insn"));
+    }
+  else
+    inst.reloc.type = BFD_RELOC_ARM_SHIFT_IMM;
+}
+
+static void
+do_smc (void)
+{
+  inst.reloc.type = BFD_RELOC_ARM_SMC;
+  inst.reloc.pc_rel = 0;
+}
+
+static void
+do_hvc (void)
+{
+  inst.reloc.type = BFD_RELOC_ARM_HVC;
+  inst.reloc.pc_rel = 0;
+}
+
+static void
+do_swi (void)
+{
+  inst.reloc.type = BFD_RELOC_ARM_SWI;
+  inst.reloc.pc_rel = 0;
+}
+
+static void
+do_setpan (void)
+{
+  constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_pan),
+	      _("selected processor does not support SETPAN instruction"));
+
+  inst.instruction |= ((inst.operands[0].imm & 1) << 9);
+}
+
+static void
+do_t_setpan (void)
+{
+  constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_pan),
+	      _("selected processor does not support SETPAN instruction"));
+
+  inst.instruction |= (inst.operands[0].imm << 3);
+}
+
+/* ARM V5E (El Segundo) signed-multiply-accumulate (argument parse)
+   SMLAxy{cond} Rd,Rm,Rs,Rn
+   SMLAWy{cond} Rd,Rm,Rs,Rn
+   Error if any register is R15.  */
+
+static void
+do_smla (void)
+{
+  inst.instruction |= inst.operands[0].reg << 16;
+  inst.instruction |= inst.operands[1].reg;
+  inst.instruction |= inst.operands[2].reg << 8;
+  inst.instruction |= inst.operands[3].reg << 12;
+}
+
+/* ARM V5E (El Segundo) signed-multiply-accumulate-long (argument parse)
+   SMLALxy{cond} Rdlo,Rdhi,Rm,Rs
+   Error if any register is R15.
+   Warning if Rdlo == Rdhi.  */
+
+static void
+do_smlal (void)
+{
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= inst.operands[1].reg << 16;
+  inst.instruction |= inst.operands[2].reg;
+  inst.instruction |= inst.operands[3].reg << 8;
+
+  if (inst.operands[0].reg == inst.operands[1].reg)
+    as_tsktsk (_("rdhi and rdlo must be different"));
+}
+
+/* ARM V5E (El Segundo) signed-multiply (argument parse)
+   SMULxy{cond} Rd,Rm,Rs
+   Error if any register is R15.  */
+
+static void
+do_smul (void)
+{
+  inst.instruction |= inst.operands[0].reg << 16;
+  inst.instruction |= inst.operands[1].reg;
+  inst.instruction |= inst.operands[2].reg << 8;
+}
+
+/* ARM V6 srs (argument parse).  The variable fields in the encoding are
+   the same for both ARM and Thumb-2.  */
+
+static void
+do_srs (void)
+{
+  int reg;
+
+  if (inst.operands[0].present)
+    {
+      reg = inst.operands[0].reg;
+      constraint (reg != REG_SP, _("SRS base register must be r13"));
+    }
+  else
+    reg = REG_SP;
+
+  inst.instruction |= reg << 16;
+  inst.instruction |= inst.operands[1].imm;
+  if (inst.operands[0].writeback || inst.operands[1].writeback)
+    inst.instruction |= WRITE_BACK;
+}
+
+/* ARM V6 strex (argument parse).  */
+
+static void
+do_strex (void)
+{
+  constraint (!inst.operands[2].isreg || !inst.operands[2].preind
+	      || inst.operands[2].postind || inst.operands[2].writeback
+	      || inst.operands[2].immisreg || inst.operands[2].shifted
+	      || inst.operands[2].negative
+	      /* See comment in do_ldrex().  */
+	      || (inst.operands[2].reg == REG_PC),
+	      BAD_ADDR_MODE);
+
+  constraint (inst.operands[0].reg == inst.operands[1].reg
+	      || inst.operands[0].reg == inst.operands[2].reg, BAD_OVERLAP);
+
+  constraint (inst.reloc.exp.X_op != O_constant
+	      || inst.reloc.exp.X_add_number != 0,
+	      _("offset must be zero in ARM encoding"));
+
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= inst.operands[1].reg;
+  inst.instruction |= inst.operands[2].reg << 16;
+  inst.reloc.type = BFD_RELOC_UNUSED;
+}
+
+static void
+do_t_strexbh (void)
+{
+  constraint (!inst.operands[2].isreg || !inst.operands[2].preind
+	      || inst.operands[2].postind || inst.operands[2].writeback
+	      || inst.operands[2].immisreg || inst.operands[2].shifted
+	      || inst.operands[2].negative,
+	      BAD_ADDR_MODE);
+
+  constraint (inst.operands[0].reg == inst.operands[1].reg
+	      || inst.operands[0].reg == inst.operands[2].reg, BAD_OVERLAP);
+
+  do_rm_rd_rn ();
+}
+
+static void
+do_strexd (void)
+{
+  constraint (inst.operands[1].reg % 2 != 0,
+	      _("even register required"));
+  constraint (inst.operands[2].present
+	      && inst.operands[2].reg != inst.operands[1].reg + 1,
+	      _("can only store two consecutive registers"));
+  /* If op 2 were present and equal to PC, this function wouldn't
+     have been called in the first place.  */
+  constraint (inst.operands[1].reg == REG_LR, _("r14 not allowed here"));
+
+  constraint (inst.operands[0].reg == inst.operands[1].reg
+	      || inst.operands[0].reg == inst.operands[1].reg + 1
+	      || inst.operands[0].reg == inst.operands[3].reg,
+	      BAD_OVERLAP);
+
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= inst.operands[1].reg;
+  inst.instruction |= inst.operands[3].reg << 16;
+}
+
+/* ARM V8 STRL.  */
+static void
+do_stlex (void)
+{
+  constraint (inst.operands[0].reg == inst.operands[1].reg
+	      || inst.operands[0].reg == inst.operands[2].reg, BAD_OVERLAP);
+
+  do_rd_rm_rn ();
+}
+
+static void
+do_t_stlex (void)
+{
+  constraint (inst.operands[0].reg == inst.operands[1].reg
+	      || inst.operands[0].reg == inst.operands[2].reg, BAD_OVERLAP);
+
+  do_rm_rd_rn ();
+}
+
+/* ARM V6 SXTAH extracts a 16-bit value from a register, sign
+   extends it to 32-bits, and adds the result to a value in another
+   register.  You can specify a rotation by 0, 8, 16, or 24 bits
+   before extracting the 16-bit value.
+   SXTAH{<cond>} <Rd>, <Rn>, <Rm>{, <rotation>}
+   Condition defaults to COND_ALWAYS.
+   Error if any register uses R15.  */
+
+static void
+do_sxtah (void)
+{
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= inst.operands[1].reg << 16;
+  inst.instruction |= inst.operands[2].reg;
+  inst.instruction |= inst.operands[3].imm << 10;
+}
+
+/* ARM V6 SXTH.
+
+   SXTH {<cond>} <Rd>, <Rm>{, <rotation>}
+   Condition defaults to COND_ALWAYS.
+   Error if any register uses R15.  */
+
+static void
+do_sxth (void)
+{
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= inst.operands[1].reg;
+  inst.instruction |= inst.operands[2].imm << 10;
+}
+
+/* VFP instructions.  In a logical order: SP variant first, monad
+   before dyad, arithmetic then move then load/store.  */
+
+static void
+do_vfp_sp_monadic (void)
+{
+  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sd);
+  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Sm);
+}
+
+static void
+do_vfp_sp_dyadic (void)
+{
+  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sd);
+  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Sn);
+  encode_arm_vfp_reg (inst.operands[2].reg, VFP_REG_Sm);
+}
+
+static void
+do_vfp_sp_compare_z (void)
+{
+  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sd);
+}
+
+static void
+do_vfp_dp_sp_cvt (void)
+{
+  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dd);
+  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Sm);
+}
+
+static void
+do_vfp_sp_dp_cvt (void)
+{
+  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sd);
+  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Dm);
+}
+
+static void
+do_vfp_reg_from_sp (void)
+{
+  inst.instruction |= inst.operands[0].reg << 12;
+  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Sn);
+}
+
+static void
+do_vfp_reg2_from_sp2 (void)
+{
+  constraint (inst.operands[2].imm != 2,
+	      _("only two consecutive VFP SP registers allowed here"));
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= inst.operands[1].reg << 16;
+  encode_arm_vfp_reg (inst.operands[2].reg, VFP_REG_Sm);
+}
+
+static void
+do_vfp_sp_from_reg (void)
+{
+  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sn);
+  inst.instruction |= inst.operands[1].reg << 12;
+}
+
+static void
+do_vfp_sp2_from_reg2 (void)
+{
+  constraint (inst.operands[0].imm != 2,
+	      _("only two consecutive VFP SP registers allowed here"));
+  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sm);
+  inst.instruction |= inst.operands[1].reg << 12;
+  inst.instruction |= inst.operands[2].reg << 16;
+}
+
+static void
+do_vfp_sp_ldst (void)
+{
+  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sd);
+  encode_arm_cp_address (1, FALSE, TRUE, 0);
+}
+
+static void
+do_vfp_dp_ldst (void)
+{
+  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dd);
+  encode_arm_cp_address (1, FALSE, TRUE, 0);
+}
+
+
+static void
+vfp_sp_ldstm (enum vfp_ldstm_type ldstm_type)
+{
+  if (inst.operands[0].writeback)
+    inst.instruction |= WRITE_BACK;
+  else
+    constraint (ldstm_type != VFP_LDSTMIA,
+		_("this addressing mode requires base-register writeback"));
+  inst.instruction |= inst.operands[0].reg << 16;
+  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Sd);
+  inst.instruction |= inst.operands[1].imm;
+}
+
+static void
+vfp_dp_ldstm (enum vfp_ldstm_type ldstm_type)
+{
+  int count;
+
+  if (inst.operands[0].writeback)
+    inst.instruction |= WRITE_BACK;
+  else
+    constraint (ldstm_type != VFP_LDSTMIA && ldstm_type != VFP_LDSTMIAX,
+		_("this addressing mode requires base-register writeback"));
+
+  inst.instruction |= inst.operands[0].reg << 16;
+  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Dd);
+
+  count = inst.operands[1].imm << 1;
+  if (ldstm_type == VFP_LDSTMIAX || ldstm_type == VFP_LDSTMDBX)
+    count += 1;
+
+  inst.instruction |= count;
+}
+
+static void
+do_vfp_sp_ldstmia (void)
+{
+  vfp_sp_ldstm (VFP_LDSTMIA);
+}
+
+static void
+do_vfp_sp_ldstmdb (void)
+{
+  vfp_sp_ldstm (VFP_LDSTMDB);
+}
+
+static void
+do_vfp_dp_ldstmia (void)
+{
+  vfp_dp_ldstm (VFP_LDSTMIA);
+}
+
+static void
+do_vfp_dp_ldstmdb (void)
+{
+  vfp_dp_ldstm (VFP_LDSTMDB);
+}
+
+static void
+do_vfp_xp_ldstmia (void)
+{
+  vfp_dp_ldstm (VFP_LDSTMIAX);
+}
+
+static void
+do_vfp_xp_ldstmdb (void)
+{
+  vfp_dp_ldstm (VFP_LDSTMDBX);
+}
+
+static void
+do_vfp_dp_rd_rm (void)
+{
+  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dd);
+  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Dm);
+}
+
+static void
+do_vfp_dp_rn_rd (void)
+{
+  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dn);
+  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Dd);
+}
+
+static void
+do_vfp_dp_rd_rn (void)
+{
+  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dd);
+  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Dn);
+}
+
+static void
+do_vfp_dp_rd_rn_rm (void)
+{
+  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dd);
+  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Dn);
+  encode_arm_vfp_reg (inst.operands[2].reg, VFP_REG_Dm);
+}
+
+static void
+do_vfp_dp_rd (void)
+{
+  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dd);
+}
+
+static void
+do_vfp_dp_rm_rd_rn (void)
+{
+  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dm);
+  encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Dd);
+  encode_arm_vfp_reg (inst.operands[2].reg, VFP_REG_Dn);
+}
+
+/* VFPv3 instructions.  */
+static void
+do_vfp_sp_const (void)
+{
+  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sd);
+  inst.instruction |= (inst.operands[1].imm & 0xf0) << 12;
+  inst.instruction |= (inst.operands[1].imm & 0x0f);
+}
+
+static void
+do_vfp_dp_const (void)
+{
+  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dd);
+  inst.instruction |= (inst.operands[1].imm & 0xf0) << 12;
+  inst.instruction |= (inst.operands[1].imm & 0x0f);
+}
+
+static void
+vfp_conv (int srcsize)
+{
+  int immbits = srcsize - inst.operands[1].imm;
+
+  if (srcsize == 16 && !(immbits >= 0 && immbits <= srcsize))
+    {
+      /* If srcsize is 16, inst.operands[1].imm must be in the range 0-16.
+	 i.e. immbits must be in range 0 - 16.  */
+      inst.error = _("immediate value out of range, expected range [0, 16]");
+      return;
+    }
+  else if (srcsize == 32 && !(immbits >= 0 && immbits < srcsize))
+    {
+      /* If srcsize is 32, inst.operands[1].imm must be in the range 1-32.
+	 i.e. immbits must be in range 0 - 31.  */
+      inst.error = _("immediate value out of range, expected range [1, 32]");
+      return;
+    }
+
+  inst.instruction |= (immbits & 1) << 5;
+  inst.instruction |= (immbits >> 1);
+}
+
+static void
+do_vfp_sp_conv_16 (void)
+{
+  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sd);
+  vfp_conv (16);
+}
+
+static void
+do_vfp_dp_conv_16 (void)
+{
+  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dd);
+  vfp_conv (16);
+}
+
+static void
+do_vfp_sp_conv_32 (void)
+{
+  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sd);
+  vfp_conv (32);
+}
+
+static void
+do_vfp_dp_conv_32 (void)
+{
+  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dd);
+  vfp_conv (32);
+}
+
+/* FPA instructions.  Also in a logical order.	*/
+
+static void
+do_fpa_cmp (void)
+{
+  inst.instruction |= inst.operands[0].reg << 16;
+  inst.instruction |= inst.operands[1].reg;
+}
+
+static void
+do_fpa_ldmstm (void)
+{
+  inst.instruction |= inst.operands[0].reg << 12;
+  switch (inst.operands[1].imm)
+    {
+    case 1: inst.instruction |= CP_T_X;		 break;
+    case 2: inst.instruction |= CP_T_Y;		 break;
+    case 3: inst.instruction |= CP_T_Y | CP_T_X; break;
+    case 4:					 break;
+    default: abort ();
+    }
+
+  if (inst.instruction & (PRE_INDEX | INDEX_UP))
+    {
+      /* The instruction specified "ea" or "fd", so we can only accept
+	 [Rn]{!}.  The instruction does not really support stacking or
+	 unstacking, so we have to emulate these by setting appropriate
+	 bits and offsets.  */
+      constraint (inst.reloc.exp.X_op != O_constant
+		  || inst.reloc.exp.X_add_number != 0,
+		  _("this instruction does not support indexing"));
+
+      if ((inst.instruction & PRE_INDEX) || inst.operands[2].writeback)
+	inst.reloc.exp.X_add_number = 12 * inst.operands[1].imm;
+
+      if (!(inst.instruction & INDEX_UP))
+	inst.reloc.exp.X_add_number = -inst.reloc.exp.X_add_number;
+
+      if (!(inst.instruction & PRE_INDEX) && inst.operands[2].writeback)
+	{
+	  inst.operands[2].preind = 0;
+	  inst.operands[2].postind = 1;
+	}
+    }
+
+  encode_arm_cp_address (2, TRUE, TRUE, 0);
+}
+
+/* iWMMXt instructions: strictly in alphabetical order.	 */
+
+static void
+do_iwmmxt_tandorc (void)
+{
+  constraint (inst.operands[0].reg != REG_PC, _("only r15 allowed here"));
+}
+
+static void
+do_iwmmxt_textrc (void)
+{
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= inst.operands[1].imm;
+}
+
+static void
+do_iwmmxt_textrm (void)
+{
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= inst.operands[1].reg << 16;
+  inst.instruction |= inst.operands[2].imm;
+}
+
+static void
+do_iwmmxt_tinsr (void)
+{
+  inst.instruction |= inst.operands[0].reg << 16;
+  inst.instruction |= inst.operands[1].reg << 12;
+  inst.instruction |= inst.operands[2].imm;
+}
+
+static void
+do_iwmmxt_tmia (void)
+{
+  inst.instruction |= inst.operands[0].reg << 5;
+  inst.instruction |= inst.operands[1].reg;
+  inst.instruction |= inst.operands[2].reg << 12;
+}
+
+static void
+do_iwmmxt_waligni (void)
+{
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= inst.operands[1].reg << 16;
+  inst.instruction |= inst.operands[2].reg;
+  inst.instruction |= inst.operands[3].imm << 20;
+}
+
+static void
+do_iwmmxt_wmerge (void)
+{
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= inst.operands[1].reg << 16;
+  inst.instruction |= inst.operands[2].reg;
+  inst.instruction |= inst.operands[3].imm << 21;
+}
+
+static void
+do_iwmmxt_wmov (void)
+{
+  /* WMOV rD, rN is an alias for WOR rD, rN, rN.  */
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= inst.operands[1].reg << 16;
+  inst.instruction |= inst.operands[1].reg;
+}
+
+static void
+do_iwmmxt_wldstbh (void)
+{
+  int reloc;
+  inst.instruction |= inst.operands[0].reg << 12;
+  if (thumb_mode)
+    reloc = BFD_RELOC_ARM_T32_CP_OFF_IMM_S2;
+  else
+    reloc = BFD_RELOC_ARM_CP_OFF_IMM_S2;
+  encode_arm_cp_address (1, TRUE, FALSE, reloc);
+}
+
+static void
+do_iwmmxt_wldstw (void)
+{
+  /* RIWR_RIWC clears .isreg for a control register.  */
+  if (!inst.operands[0].isreg)
+    {
+      constraint (inst.cond != COND_ALWAYS, BAD_COND);
+      inst.instruction |= 0xf0000000;
+    }
+
+  inst.instruction |= inst.operands[0].reg << 12;
+  encode_arm_cp_address (1, TRUE, TRUE, 0);
+}
+
+static void
+do_iwmmxt_wldstd (void)
+{
+  inst.instruction |= inst.operands[0].reg << 12;
+  if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_cext_iwmmxt2)
+      && inst.operands[1].immisreg)
+    {
+      inst.instruction &= ~0x1a000ff;
+      inst.instruction |= (0xfU << 28);
+      if (inst.operands[1].preind)
+	inst.instruction |= PRE_INDEX;
+      if (!inst.operands[1].negative)
+	inst.instruction |= INDEX_UP;
+      if (inst.operands[1].writeback)
+	inst.instruction |= WRITE_BACK;
+      inst.instruction |= inst.operands[1].reg << 16;
+      inst.instruction |= inst.reloc.exp.X_add_number << 4;
+      inst.instruction |= inst.operands[1].imm;
+    }
+  else
+    encode_arm_cp_address (1, TRUE, FALSE, 0);
+}
+
+static void
+do_iwmmxt_wshufh (void)
+{
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= inst.operands[1].reg << 16;
+  inst.instruction |= ((inst.operands[2].imm & 0xf0) << 16);
+  inst.instruction |= (inst.operands[2].imm & 0x0f);
+}
+
+static void
+do_iwmmxt_wzero (void)
+{
+  /* WZERO reg is an alias for WANDN reg, reg, reg.  */
+  inst.instruction |= inst.operands[0].reg;
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= inst.operands[0].reg << 16;
+}
+
+static void
+do_iwmmxt_wrwrwr_or_imm5 (void)
+{
+  if (inst.operands[2].isreg)
+    do_rd_rn_rm ();
+  else {
+    constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_cext_iwmmxt2),
+		_("immediate operand requires iWMMXt2"));
+    do_rd_rn ();
+    if (inst.operands[2].imm == 0)
+      {
+	switch ((inst.instruction >> 20) & 0xf)
+	  {
+	  case 4:
+	  case 5:
+	  case 6:
+	  case 7:
+	    /* w...h wrd, wrn, #0 -> wrorh wrd, wrn, #16.  */
+	    inst.operands[2].imm = 16;
+	    inst.instruction = (inst.instruction & 0xff0fffff) | (0x7 << 20);
+	    break;
+	  case 8:
+	  case 9:
+	  case 10:
+	  case 11:
+	    /* w...w wrd, wrn, #0 -> wrorw wrd, wrn, #32.  */
+	    inst.operands[2].imm = 32;
+	    inst.instruction = (inst.instruction & 0xff0fffff) | (0xb << 20);
+	    break;
+	  case 12:
+	  case 13:
+	  case 14:
+	  case 15:
+	    {
+	      /* w...d wrd, wrn, #0 -> wor wrd, wrn, wrn.  */
+	      unsigned long wrn;
+	      wrn = (inst.instruction >> 16) & 0xf;
+	      inst.instruction &= 0xff0fff0f;
+	      inst.instruction |= wrn;
+	      /* Bail out here; the instruction is now assembled.  */
+	      return;
+	    }
+	  }
+      }
+    /* Map 32 -> 0, etc.  */
+    inst.operands[2].imm &= 0x1f;
+    inst.instruction |= (0xfU << 28) | ((inst.operands[2].imm & 0x10) << 4) | (inst.operands[2].imm & 0xf);
+  }
+}
+
+/* Cirrus Maverick instructions.  Simple 2-, 3-, and 4-register
+   operations first, then control, shift, and load/store.  */
+
+/* Insns like "foo X,Y,Z".  */
+
+static void
+do_mav_triple (void)
+{
+  inst.instruction |= inst.operands[0].reg << 16;
+  inst.instruction |= inst.operands[1].reg;
+  inst.instruction |= inst.operands[2].reg << 12;
+}
+
+/* Insns like "foo W,X,Y,Z".
+    where W=MVAX[0:3] and X,Y,Z=MVFX[0:15].  */
+
+static void
+do_mav_quad (void)
+{
+  inst.instruction |= inst.operands[0].reg << 5;
+  inst.instruction |= inst.operands[1].reg << 12;
+  inst.instruction |= inst.operands[2].reg << 16;
+  inst.instruction |= inst.operands[3].reg;
+}
+
+/* cfmvsc32<cond> DSPSC,MVDX[15:0].  */
+static void
+do_mav_dspsc (void)
+{
+  inst.instruction |= inst.operands[1].reg << 12;
+}
+
+/* Maverick shift immediate instructions.
+   cfsh32<cond> MVFX[15:0],MVFX[15:0],Shift[6:0].
+   cfsh64<cond> MVDX[15:0],MVDX[15:0],Shift[6:0].  */
+
+static void
+do_mav_shift (void)
+{
+  int imm = inst.operands[2].imm;
+
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= inst.operands[1].reg << 16;
+
+  /* Bits 0-3 of the insn should have bits 0-3 of the immediate.
+     Bits 5-7 of the insn should have bits 4-6 of the immediate.
+     Bit 4 should be 0.	 */
+  imm = (imm & 0xf) | ((imm & 0x70) << 1);
+
+  inst.instruction |= imm;
+}
+
+/* XScale instructions.	 Also sorted arithmetic before move.  */
+
+/* Xscale multiply-accumulate (argument parse)
+     MIAcc   acc0,Rm,Rs
+     MIAPHcc acc0,Rm,Rs
+     MIAxycc acc0,Rm,Rs.  */
+
+static void
+do_xsc_mia (void)
+{
+  inst.instruction |= inst.operands[1].reg;
+  inst.instruction |= inst.operands[2].reg << 12;
+}
+
+/* Xscale move-accumulator-register (argument parse)
+
+     MARcc   acc0,RdLo,RdHi.  */
+
+static void
+do_xsc_mar (void)
+{
+  inst.instruction |= inst.operands[1].reg << 12;
+  inst.instruction |= inst.operands[2].reg << 16;
+}
+
+/* Xscale move-register-accumulator (argument parse)
+
+     MRAcc   RdLo,RdHi,acc0.  */
+
+static void
+do_xsc_mra (void)
+{
+  constraint (inst.operands[0].reg == inst.operands[1].reg, BAD_OVERLAP);
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= inst.operands[1].reg << 16;
+}
+
+/* Encoding functions relevant only to Thumb.  */
+
+/* inst.operands[i] is a shifted-register operand; encode
+   it into inst.instruction in the format used by Thumb32.  */
+
+static void
+encode_thumb32_shifted_operand (int i)
+{
+  unsigned int value = inst.reloc.exp.X_add_number;
+  unsigned int shift = inst.operands[i].shift_kind;
+
+  constraint (inst.operands[i].immisreg,
+	      _("shift by register not allowed in thumb mode"));
+  inst.instruction |= inst.operands[i].reg;
+  if (shift == SHIFT_RRX)
+    inst.instruction |= SHIFT_ROR << 4;
+  else
+    {
+      constraint (inst.reloc.exp.X_op != O_constant,
+		  _("expression too complex"));
+
+      constraint (value > 32
+		  || (value == 32 && (shift == SHIFT_LSL
+				      || shift == SHIFT_ROR)),
+		  _("shift expression is too large"));
+
+      if (value == 0)
+	shift = SHIFT_LSL;
+      else if (value == 32)
+	value = 0;
+
+      inst.instruction |= shift << 4;
+      inst.instruction |= (value & 0x1c) << 10;
+      inst.instruction |= (value & 0x03) << 6;
+    }
+}
+
+
+/* inst.operands[i] was set up by parse_address.  Encode it into a
+   Thumb32 format load or store instruction.  Reject forms that cannot
+   be used with such instructions.  If is_t is true, reject forms that
+   cannot be used with a T instruction; if is_d is true, reject forms
+   that cannot be used with a D instruction.  If it is a store insn,
+   reject PC in Rn.  */
+
+static void
+encode_thumb32_addr_mode (int i, bfd_boolean is_t, bfd_boolean is_d)
+{
+  const bfd_boolean is_pc = (inst.operands[i].reg == REG_PC);
+
+  constraint (!inst.operands[i].isreg,
+	      _("Instruction does not support =N addresses"));
+
+  inst.instruction |= inst.operands[i].reg << 16;
+  if (inst.operands[i].immisreg)
+    {
+      constraint (is_pc, BAD_PC_ADDRESSING);
+      constraint (is_t || is_d, _("cannot use register index with this instruction"));
+      constraint (inst.operands[i].negative,
+		  _("Thumb does not support negative register indexing"));
+      constraint (inst.operands[i].postind,
+		  _("Thumb does not support register post-indexing"));
+      constraint (inst.operands[i].writeback,
+		  _("Thumb does not support register indexing with writeback"));
+      constraint (inst.operands[i].shifted && inst.operands[i].shift_kind != SHIFT_LSL,
+		  _("Thumb supports only LSL in shifted register indexing"));
+
+      inst.instruction |= inst.operands[i].imm;
+      if (inst.operands[i].shifted)
+	{
+	  constraint (inst.reloc.exp.X_op != O_constant,
+		      _("expression too complex"));
+	  constraint (inst.reloc.exp.X_add_number < 0
+		      || inst.reloc.exp.X_add_number > 3,
+		      _("shift out of range"));
+	  inst.instruction |= inst.reloc.exp.X_add_number << 4;
+	}
+      inst.reloc.type = BFD_RELOC_UNUSED;
+    }
+  else if (inst.operands[i].preind)
+    {
+      constraint (is_pc && inst.operands[i].writeback, BAD_PC_WRITEBACK);
+      constraint (is_t && inst.operands[i].writeback,
+		  _("cannot use writeback with this instruction"));
+      constraint (is_pc && ((inst.instruction & THUMB2_LOAD_BIT) == 0),
+		  BAD_PC_ADDRESSING);
+
+      if (is_d)
+	{
+	  inst.instruction |= 0x01000000;
+	  if (inst.operands[i].writeback)
+	    inst.instruction |= 0x00200000;
+	}
+      else
+	{
+	  inst.instruction |= 0x00000c00;
+	  if (inst.operands[i].writeback)
+	    inst.instruction |= 0x00000100;
+	}
+      inst.reloc.type = BFD_RELOC_ARM_T32_OFFSET_IMM;
+    }
+  else if (inst.operands[i].postind)
+    {
+      gas_assert (inst.operands[i].writeback);
+      constraint (is_pc, _("cannot use post-indexing with PC-relative addressing"));
+      constraint (is_t, _("cannot use post-indexing with this instruction"));
+
+      if (is_d)
+	inst.instruction |= 0x00200000;
+      else
+	inst.instruction |= 0x00000900;
+      inst.reloc.type = BFD_RELOC_ARM_T32_OFFSET_IMM;
+    }
+  else /* unindexed - only for coprocessor */
+    inst.error = _("instruction does not accept unindexed addressing");
+}
+
+/* Table of Thumb instructions which exist in both 16- and 32-bit
+   encodings (the latter only in post-V6T2 cores).  The index is the
+   value used in the insns table below.  When there is more than one
+   possible 16-bit encoding for the instruction, this table always
+   holds variant (1).
+   Also contains several pseudo-instructions used during relaxation.  */
+#define T16_32_TAB				\
+  X(_adc,   4140, eb400000),			\
+  X(_adcs,  4140, eb500000),			\
+  X(_add,   1c00, eb000000),			\
+  X(_adds,  1c00, eb100000),			\
+  X(_addi,  0000, f1000000),			\
+  X(_addis, 0000, f1100000),			\
+  X(_add_pc,000f, f20f0000),			\
+  X(_add_sp,000d, f10d0000),			\
+  X(_adr,   000f, f20f0000),			\
+  X(_and,   4000, ea000000),			\
+  X(_ands,  4000, ea100000),			\
+  X(_asr,   1000, fa40f000),			\
+  X(_asrs,  1000, fa50f000),			\
+  X(_b,     e000, f000b000),			\
+  X(_bcond, d000, f0008000),			\
+  X(_bic,   4380, ea200000),			\
+  X(_bics,  4380, ea300000),			\
+  X(_cmn,   42c0, eb100f00),			\
+  X(_cmp,   2800, ebb00f00),			\
+  X(_cpsie, b660, f3af8400),			\
+  X(_cpsid, b670, f3af8600),			\
+  X(_cpy,   4600, ea4f0000),			\
+  X(_dec_sp,80dd, f1ad0d00),			\
+  X(_eor,   4040, ea800000),			\
+  X(_eors,  4040, ea900000),			\
+  X(_inc_sp,00dd, f10d0d00),			\
+  X(_ldmia, c800, e8900000),			\
+  X(_ldr,   6800, f8500000),			\
+  X(_ldrb,  7800, f8100000),			\
+  X(_ldrh,  8800, f8300000),			\
+  X(_ldrsb, 5600, f9100000),			\
+  X(_ldrsh, 5e00, f9300000),			\
+  X(_ldr_pc,4800, f85f0000),			\
+  X(_ldr_pc2,4800, f85f0000),			\
+  X(_ldr_sp,9800, f85d0000),			\
+  X(_lsl,   0000, fa00f000),			\
+  X(_lsls,  0000, fa10f000),			\
+  X(_lsr,   0800, fa20f000),			\
+  X(_lsrs,  0800, fa30f000),			\
+  X(_mov,   2000, ea4f0000),			\
+  X(_movs,  2000, ea5f0000),			\
+  X(_mul,   4340, fb00f000),                     \
+  X(_muls,  4340, ffffffff), /* no 32b muls */	\
+  X(_mvn,   43c0, ea6f0000),			\
+  X(_mvns,  43c0, ea7f0000),			\
+  X(_neg,   4240, f1c00000), /* rsb #0 */	\
+  X(_negs,  4240, f1d00000), /* rsbs #0 */	\
+  X(_orr,   4300, ea400000),			\
+  X(_orrs,  4300, ea500000),			\
+  X(_pop,   bc00, e8bd0000), /* ldmia sp!,... */	\
+  X(_push,  b400, e92d0000), /* stmdb sp!,... */	\
+  X(_rev,   ba00, fa90f080),			\
+  X(_rev16, ba40, fa90f090),			\
+  X(_revsh, bac0, fa90f0b0),			\
+  X(_ror,   41c0, fa60f000),			\
+  X(_rors,  41c0, fa70f000),			\
+  X(_sbc,   4180, eb600000),			\
+  X(_sbcs,  4180, eb700000),			\
+  X(_stmia, c000, e8800000),			\
+  X(_str,   6000, f8400000),			\
+  X(_strb,  7000, f8000000),			\
+  X(_strh,  8000, f8200000),			\
+  X(_str_sp,9000, f84d0000),			\
+  X(_sub,   1e00, eba00000),			\
+  X(_subs,  1e00, ebb00000),			\
+  X(_subi,  8000, f1a00000),			\
+  X(_subis, 8000, f1b00000),			\
+  X(_sxtb,  b240, fa4ff080),			\
+  X(_sxth,  b200, fa0ff080),			\
+  X(_tst,   4200, ea100f00),			\
+  X(_uxtb,  b2c0, fa5ff080),			\
+  X(_uxth,  b280, fa1ff080),			\
+  X(_nop,   bf00, f3af8000),			\
+  X(_yield, bf10, f3af8001),			\
+  X(_wfe,   bf20, f3af8002),			\
+  X(_wfi,   bf30, f3af8003),			\
+  X(_sev,   bf40, f3af8004),                    \
+  X(_sevl,  bf50, f3af8005),			\
+  X(_udf,   de00, f7f0a000)
+
+/* To catch errors in encoding functions, the codes are all offset by
+   0xF800, putting them in one of the 32-bit prefix ranges, ergo undefined
+   as 16-bit instructions.  */
+#define X(a,b,c) T_MNEM##a
+enum t16_32_codes { T16_32_OFFSET = 0xF7FF, T16_32_TAB };
+#undef X
+
+#define X(a,b,c) 0x##b
+static const unsigned short thumb_op16[] = { T16_32_TAB };
+#define THUMB_OP16(n) (thumb_op16[(n) - (T16_32_OFFSET + 1)])
+#undef X
+
+#define X(a,b,c) 0x##c
+static const unsigned int thumb_op32[] = { T16_32_TAB };
+#define THUMB_OP32(n)        (thumb_op32[(n) - (T16_32_OFFSET + 1)])
+#define THUMB_SETS_FLAGS(n)  (THUMB_OP32 (n) & 0x00100000)
+#undef X
+#undef T16_32_TAB
+
+/* Thumb instruction encoders, in alphabetical order.  */
+
+/* ADDW or SUBW.  */
+
+static void
+do_t_add_sub_w (void)
+{
+  int Rd, Rn;
+
+  Rd = inst.operands[0].reg;
+  Rn = inst.operands[1].reg;
+
+  /* If Rn is REG_PC, this is ADR; if Rn is REG_SP, then this
+     is the SP-{plus,minus}-immediate form of the instruction.  */
+  if (Rn == REG_SP)
+    constraint (Rd == REG_PC, BAD_PC);
+  else
+    reject_bad_reg (Rd);
+
+  inst.instruction |= (Rn << 16) | (Rd << 8);
+  inst.reloc.type = BFD_RELOC_ARM_T32_IMM12;
+}
+
+/* Parse an add or subtract instruction.  We get here with inst.instruction
+   equalling any of THUMB_OPCODE_add, adds, sub, or subs.  */
+
+static void
+do_t_add_sub (void)
+{
+  int Rd, Rs, Rn;
+
+  Rd = inst.operands[0].reg;
+  Rs = (inst.operands[1].present
+	? inst.operands[1].reg    /* Rd, Rs, foo */
+	: inst.operands[0].reg);  /* Rd, foo -> Rd, Rd, foo */
+
+  if (Rd == REG_PC)
+    set_it_insn_type_last ();
+
+  if (unified_syntax)
+    {
+      bfd_boolean flags;
+      bfd_boolean narrow;
+      int opcode;
+
+      flags = (inst.instruction == T_MNEM_adds
+	       || inst.instruction == T_MNEM_subs);
+      if (flags)
+	narrow = !in_it_block ();
+      else
+	narrow = in_it_block ();
+      if (!inst.operands[2].isreg)
+	{
+	  int add;
+
+	  constraint (Rd == REG_SP && Rs != REG_SP, BAD_SP);
+
+	  add = (inst.instruction == T_MNEM_add
+		 || inst.instruction == T_MNEM_adds);
+	  opcode = 0;
+	  if (inst.size_req != 4)
+	    {
+	      /* Attempt to use a narrow opcode, with relaxation if
+		 appropriate.  */
+	      if (Rd == REG_SP && Rs == REG_SP && !flags)
+		opcode = add ? T_MNEM_inc_sp : T_MNEM_dec_sp;
+	      else if (Rd <= 7 && Rs == REG_SP && add && !flags)
+		opcode = T_MNEM_add_sp;
+	      else if (Rd <= 7 && Rs == REG_PC && add && !flags)
+		opcode = T_MNEM_add_pc;
+	      else if (Rd <= 7 && Rs <= 7 && narrow)
+		{
+		  if (flags)
+		    opcode = add ? T_MNEM_addis : T_MNEM_subis;
+		  else
+		    opcode = add ? T_MNEM_addi : T_MNEM_subi;
+		}
+	      if (opcode)
+		{
+		  inst.instruction = THUMB_OP16(opcode);
+		  inst.instruction |= (Rd << 4) | Rs;
+		  inst.reloc.type = BFD_RELOC_ARM_THUMB_ADD;
+		  if (inst.size_req != 2)
+		    inst.relax = opcode;
+		}
+	      else
+		constraint (inst.size_req == 2, BAD_HIREG);
+	    }
+	  if (inst.size_req == 4
+	      || (inst.size_req != 2 && !opcode))
+	    {
+	      if (Rd == REG_PC)
+		{
+		  constraint (add, BAD_PC);
+		  constraint (Rs != REG_LR || inst.instruction != T_MNEM_subs,
+			     _("only SUBS PC, LR, #const allowed"));
+		  constraint (inst.reloc.exp.X_op != O_constant,
+			      _("expression too complex"));
+		  constraint (inst.reloc.exp.X_add_number < 0
+			      || inst.reloc.exp.X_add_number > 0xff,
+			     _("immediate value out of range"));
+		  inst.instruction = T2_SUBS_PC_LR
+				     | inst.reloc.exp.X_add_number;
+		  inst.reloc.type = BFD_RELOC_UNUSED;
+		  return;
+		}
+	      else if (Rs == REG_PC)
+		{
+		  /* Always use addw/subw.  */
+		  inst.instruction = add ? 0xf20f0000 : 0xf2af0000;
+		  inst.reloc.type = BFD_RELOC_ARM_T32_IMM12;
+		}
+	      else
+		{
+		  inst.instruction = THUMB_OP32 (inst.instruction);
+		  inst.instruction = (inst.instruction & 0xe1ffffff)
+				     | 0x10000000;
+		  if (flags)
+		    inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
+		  else
+		    inst.reloc.type = BFD_RELOC_ARM_T32_ADD_IMM;
+		}
+	      inst.instruction |= Rd << 8;
+	      inst.instruction |= Rs << 16;
+	    }
+	}
+      else
+	{
+	  unsigned int value = inst.reloc.exp.X_add_number;
+	  unsigned int shift = inst.operands[2].shift_kind;
+
+	  Rn = inst.operands[2].reg;
+	  /* See if we can do this with a 16-bit instruction.  */
+	  if (!inst.operands[2].shifted && inst.size_req != 4)
+	    {
+	      if (Rd > 7 || Rs > 7 || Rn > 7)
+		narrow = FALSE;
+
+	      if (narrow)
+		{
+		  inst.instruction = ((inst.instruction == T_MNEM_adds
+				       || inst.instruction == T_MNEM_add)
+				      ? T_OPCODE_ADD_R3
+				      : T_OPCODE_SUB_R3);
+		  inst.instruction |= Rd | (Rs << 3) | (Rn << 6);
+		  return;
+		}
+
+	      if (inst.instruction == T_MNEM_add && (Rd == Rs || Rd == Rn))
+		{
+		  /* Thumb-1 cores (except v6-M) require at least one high
+		     register in a narrow non flag setting add.  */
+		  if (Rd > 7 || Rn > 7
+		      || ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v6t2)
+		      || ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_msr))
+		    {
+		      if (Rd == Rn)
+			{
+			  Rn = Rs;
+			  Rs = Rd;
+			}
+		      inst.instruction = T_OPCODE_ADD_HI;
+		      inst.instruction |= (Rd & 8) << 4;
+		      inst.instruction |= (Rd & 7);
+		      inst.instruction |= Rn << 3;
+		      return;
+		    }
+		}
+	    }
+
+	  constraint (Rd == REG_PC, BAD_PC);
+	  constraint (Rd == REG_SP && Rs != REG_SP, BAD_SP);
+	  constraint (Rs == REG_PC, BAD_PC);
+	  reject_bad_reg (Rn);
+
+	  /* If we get here, it can't be done in 16 bits.  */
+	  constraint (inst.operands[2].shifted && inst.operands[2].immisreg,
+		      _("shift must be constant"));
+	  inst.instruction = THUMB_OP32 (inst.instruction);
+	  inst.instruction |= Rd << 8;
+	  inst.instruction |= Rs << 16;
+	  constraint (Rd == REG_SP && Rs == REG_SP && value > 3,
+		      _("shift value over 3 not allowed in thumb mode"));
+	  constraint (Rd == REG_SP && Rs == REG_SP && shift != SHIFT_LSL,
+		      _("only LSL shift allowed in thumb mode"));
+	  encode_thumb32_shifted_operand (2);
+	}
+    }
+  else
+    {
+      constraint (inst.instruction == T_MNEM_adds
+		  || inst.instruction == T_MNEM_subs,
+		  BAD_THUMB32);
+
+      if (!inst.operands[2].isreg) /* Rd, Rs, #imm */
+	{
+	  constraint ((Rd > 7 && (Rd != REG_SP || Rs != REG_SP))
+		      || (Rs > 7 && Rs != REG_SP && Rs != REG_PC),
+		      BAD_HIREG);
+
+	  inst.instruction = (inst.instruction == T_MNEM_add
+			      ? 0x0000 : 0x8000);
+	  inst.instruction |= (Rd << 4) | Rs;
+	  inst.reloc.type = BFD_RELOC_ARM_THUMB_ADD;
+	  return;
+	}
+
+      Rn = inst.operands[2].reg;
+      constraint (inst.operands[2].shifted, _("unshifted register required"));
+
+      /* We now have Rd, Rs, and Rn set to registers.  */
+      if (Rd > 7 || Rs > 7 || Rn > 7)
+	{
+	  /* Can't do this for SUB.	 */
+	  constraint (inst.instruction == T_MNEM_sub, BAD_HIREG);
+	  inst.instruction = T_OPCODE_ADD_HI;
+	  inst.instruction |= (Rd & 8) << 4;
+	  inst.instruction |= (Rd & 7);
+	  if (Rs == Rd)
+	    inst.instruction |= Rn << 3;
+	  else if (Rn == Rd)
+	    inst.instruction |= Rs << 3;
+	  else
+	    constraint (1, _("dest must overlap one source register"));
+	}
+      else
+	{
+	  inst.instruction = (inst.instruction == T_MNEM_add
+			      ? T_OPCODE_ADD_R3 : T_OPCODE_SUB_R3);
+	  inst.instruction |= Rd | (Rs << 3) | (Rn << 6);
+	}
+    }
+}
+
+static void
+do_t_adr (void)
+{
+  unsigned Rd;
+
+  Rd = inst.operands[0].reg;
+  reject_bad_reg (Rd);
+
+  if (unified_syntax && inst.size_req == 0 && Rd <= 7)
+    {
+      /* Defer to section relaxation.  */
+      inst.relax = inst.instruction;
+      inst.instruction = THUMB_OP16 (inst.instruction);
+      inst.instruction |= Rd << 4;
+    }
+  else if (unified_syntax && inst.size_req != 2)
+    {
+      /* Generate a 32-bit opcode.  */
+      inst.instruction = THUMB_OP32 (inst.instruction);
+      inst.instruction |= Rd << 8;
+      inst.reloc.type = BFD_RELOC_ARM_T32_ADD_PC12;
+      inst.reloc.pc_rel = 1;
+    }
+  else
+    {
+      /* Generate a 16-bit opcode.  */
+      inst.instruction = THUMB_OP16 (inst.instruction);
+      inst.reloc.type = BFD_RELOC_ARM_THUMB_ADD;
+      inst.reloc.exp.X_add_number -= 4; /* PC relative adjust.  */
+      inst.reloc.pc_rel = 1;
+
+      inst.instruction |= Rd << 4;
+    }
+}
+
+/* Arithmetic instructions for which there is just one 16-bit
+   instruction encoding, and it allows only two low registers.
+   For maximal compatibility with ARM syntax, we allow three register
+   operands even when Thumb-32 instructions are not available, as long
+   as the first two are identical.  For instance, both "sbc r0,r1" and
+   "sbc r0,r0,r1" are allowed.  */
+static void
+do_t_arit3 (void)
+{
+  int Rd, Rs, Rn;
+
+  Rd = inst.operands[0].reg;
+  Rs = (inst.operands[1].present
+	? inst.operands[1].reg    /* Rd, Rs, foo */
+	: inst.operands[0].reg);  /* Rd, foo -> Rd, Rd, foo */
+  Rn = inst.operands[2].reg;
+
+  reject_bad_reg (Rd);
+  reject_bad_reg (Rs);
+  if (inst.operands[2].isreg)
+    reject_bad_reg (Rn);
+
+  if (unified_syntax)
+    {
+      if (!inst.operands[2].isreg)
+	{
+	  /* For an immediate, we always generate a 32-bit opcode;
+	     section relaxation will shrink it later if possible.  */
+	  inst.instruction = THUMB_OP32 (inst.instruction);
+	  inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
+	  inst.instruction |= Rd << 8;
+	  inst.instruction |= Rs << 16;
+	  inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
+	}
+      else
+	{
+	  bfd_boolean narrow;
+
+	  /* See if we can do this with a 16-bit instruction.  */
+	  if (THUMB_SETS_FLAGS (inst.instruction))
+	    narrow = !in_it_block ();
+	  else
+	    narrow = in_it_block ();
+
+	  if (Rd > 7 || Rn > 7 || Rs > 7)
+	    narrow = FALSE;
+	  if (inst.operands[2].shifted)
+	    narrow = FALSE;
+	  if (inst.size_req == 4)
+	    narrow = FALSE;
+
+	  if (narrow
+	      && Rd == Rs)
+	    {
+	      inst.instruction = THUMB_OP16 (inst.instruction);
+	      inst.instruction |= Rd;
+	      inst.instruction |= Rn << 3;
+	      return;
+	    }
+
+	  /* If we get here, it can't be done in 16 bits.  */
+	  constraint (inst.operands[2].shifted
+		      && inst.operands[2].immisreg,
+		      _("shift must be constant"));
+	  inst.instruction = THUMB_OP32 (inst.instruction);
+	  inst.instruction |= Rd << 8;
+	  inst.instruction |= Rs << 16;
+	  encode_thumb32_shifted_operand (2);
+	}
+    }
+  else
+    {
+      /* On its face this is a lie - the instruction does set the
+	 flags.  However, the only supported mnemonic in this mode
+	 says it doesn't.  */
+      constraint (THUMB_SETS_FLAGS (inst.instruction), BAD_THUMB32);
+
+      constraint (!inst.operands[2].isreg || inst.operands[2].shifted,
+		  _("unshifted register required"));
+      constraint (Rd > 7 || Rs > 7 || Rn > 7, BAD_HIREG);
+      constraint (Rd != Rs,
+		  _("dest and source1 must be the same register"));
+
+      inst.instruction = THUMB_OP16 (inst.instruction);
+      inst.instruction |= Rd;
+      inst.instruction |= Rn << 3;
+    }
+}
+
+/* Similarly, but for instructions where the arithmetic operation is
+   commutative, so we can allow either of them to be different from
+   the destination operand in a 16-bit instruction.  For instance, all
+   three of "adc r0,r1", "adc r0,r0,r1", and "adc r0,r1,r0" are
+   accepted.  */
+static void
+do_t_arit3c (void)
+{
+  int Rd, Rs, Rn;
+
+  Rd = inst.operands[0].reg;
+  Rs = (inst.operands[1].present
+	? inst.operands[1].reg    /* Rd, Rs, foo */
+	: inst.operands[0].reg);  /* Rd, foo -> Rd, Rd, foo */
+  Rn = inst.operands[2].reg;
+
+  reject_bad_reg (Rd);
+  reject_bad_reg (Rs);
+  if (inst.operands[2].isreg)
+    reject_bad_reg (Rn);
+
+  if (unified_syntax)
+    {
+      if (!inst.operands[2].isreg)
+	{
+	  /* For an immediate, we always generate a 32-bit opcode;
+	     section relaxation will shrink it later if possible.  */
+	  inst.instruction = THUMB_OP32 (inst.instruction);
+	  inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
+	  inst.instruction |= Rd << 8;
+	  inst.instruction |= Rs << 16;
+	  inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
+	}
+      else
+	{
+	  bfd_boolean narrow;
+
+	  /* See if we can do this with a 16-bit instruction.  */
+	  if (THUMB_SETS_FLAGS (inst.instruction))
+	    narrow = !in_it_block ();
+	  else
+	    narrow = in_it_block ();
+
+	  if (Rd > 7 || Rn > 7 || Rs > 7)
+	    narrow = FALSE;
+	  if (inst.operands[2].shifted)
+	    narrow = FALSE;
+	  if (inst.size_req == 4)
+	    narrow = FALSE;
+
+	  if (narrow)
+	    {
+	      if (Rd == Rs)
+		{
+		  inst.instruction = THUMB_OP16 (inst.instruction);
+		  inst.instruction |= Rd;
+		  inst.instruction |= Rn << 3;
+		  return;
+		}
+	      if (Rd == Rn)
+		{
+		  inst.instruction = THUMB_OP16 (inst.instruction);
+		  inst.instruction |= Rd;
+		  inst.instruction |= Rs << 3;
+		  return;
+		}
+	    }
+
+	  /* If we get here, it can't be done in 16 bits.  */
+	  constraint (inst.operands[2].shifted
+		      && inst.operands[2].immisreg,
+		      _("shift must be constant"));
+	  inst.instruction = THUMB_OP32 (inst.instruction);
+	  inst.instruction |= Rd << 8;
+	  inst.instruction |= Rs << 16;
+	  encode_thumb32_shifted_operand (2);
+	}
+    }
+  else
+    {
+      /* On its face this is a lie - the instruction does set the
+	 flags.  However, the only supported mnemonic in this mode
+	 says it doesn't.  */
+      constraint (THUMB_SETS_FLAGS (inst.instruction), BAD_THUMB32);
+
+      constraint (!inst.operands[2].isreg || inst.operands[2].shifted,
+		  _("unshifted register required"));
+      constraint (Rd > 7 || Rs > 7 || Rn > 7, BAD_HIREG);
+
+      inst.instruction = THUMB_OP16 (inst.instruction);
+      inst.instruction |= Rd;
+
+      if (Rd == Rs)
+	inst.instruction |= Rn << 3;
+      else if (Rd == Rn)
+	inst.instruction |= Rs << 3;
+      else
+	constraint (1, _("dest must overlap one source register"));
+    }
+}
+
+static void
+do_t_bfc (void)
+{
+  unsigned Rd;
+  unsigned int msb = inst.operands[1].imm + inst.operands[2].imm;
+  constraint (msb > 32, _("bit-field extends past end of register"));
+  /* The instruction encoding stores the LSB and MSB,
+     not the LSB and width.  */
+  Rd = inst.operands[0].reg;
+  reject_bad_reg (Rd);
+  inst.instruction |= Rd << 8;
+  inst.instruction |= (inst.operands[1].imm & 0x1c) << 10;
+  inst.instruction |= (inst.operands[1].imm & 0x03) << 6;
+  inst.instruction |= msb - 1;
+}
+
+static void
+do_t_bfi (void)
+{
+  int Rd, Rn;
+  unsigned int msb;
+
+  Rd = inst.operands[0].reg;
+  reject_bad_reg (Rd);
+
+  /* #0 in second position is alternative syntax for bfc, which is
+     the same instruction but with REG_PC in the Rm field.  */
+  if (!inst.operands[1].isreg)
+    Rn = REG_PC;
+  else
+    {
+      Rn = inst.operands[1].reg;
+      reject_bad_reg (Rn);
+    }
+
+  msb = inst.operands[2].imm + inst.operands[3].imm;
+  constraint (msb > 32, _("bit-field extends past end of register"));
+  /* The instruction encoding stores the LSB and MSB,
+     not the LSB and width.  */
+  inst.instruction |= Rd << 8;
+  inst.instruction |= Rn << 16;
+  inst.instruction |= (inst.operands[2].imm & 0x1c) << 10;
+  inst.instruction |= (inst.operands[2].imm & 0x03) << 6;
+  inst.instruction |= msb - 1;
+}
+
+static void
+do_t_bfx (void)
+{
+  unsigned Rd, Rn;
+
+  Rd = inst.operands[0].reg;
+  Rn = inst.operands[1].reg;
+
+  reject_bad_reg (Rd);
+  reject_bad_reg (Rn);
+
+  constraint (inst.operands[2].imm + inst.operands[3].imm > 32,
+	      _("bit-field extends past end of register"));
+  inst.instruction |= Rd << 8;
+  inst.instruction |= Rn << 16;
+  inst.instruction |= (inst.operands[2].imm & 0x1c) << 10;
+  inst.instruction |= (inst.operands[2].imm & 0x03) << 6;
+  inst.instruction |= inst.operands[3].imm - 1;
+}
+
+/* ARM V5 Thumb BLX (argument parse)
+	BLX <target_addr>	which is BLX(1)
+	BLX <Rm>		which is BLX(2)
+   Unfortunately, there are two different opcodes for this mnemonic.
+   So, the insns[].value is not used, and the code here zaps values
+	into inst.instruction.
+
+   ??? How to take advantage of the additional two bits of displacement
+   available in Thumb32 mode?  Need new relocation?  */
+
+static void
+do_t_blx (void)
+{
+  set_it_insn_type_last ();
+
+  if (inst.operands[0].isreg)
+    {
+      constraint (inst.operands[0].reg == REG_PC, BAD_PC);
+      /* We have a register, so this is BLX(2).  */
+      inst.instruction |= inst.operands[0].reg << 3;
+    }
+  else
+    {
+      /* No register.  This must be BLX(1).  */
+      inst.instruction = 0xf000e800;
+      encode_branch (BFD_RELOC_THUMB_PCREL_BLX);
+    }
+}
+
+static void
+do_t_branch (void)
+{
+  int opcode;
+  int cond;
+  int reloc;
+
+  cond = inst.cond;
+  set_it_insn_type (IF_INSIDE_IT_LAST_INSN);
+
+  if (in_it_block ())
+    {
+      /* Conditional branches inside IT blocks are encoded as unconditional
+	 branches.  */
+      cond = COND_ALWAYS;
+    }
+  else
+    cond = inst.cond;
+
+  if (cond != COND_ALWAYS)
+    opcode = T_MNEM_bcond;
+  else
+    opcode = inst.instruction;
+
+  if (unified_syntax
+      && (inst.size_req == 4
+	  || (inst.size_req != 2
+	      && (inst.operands[0].hasreloc
+		  || inst.reloc.exp.X_op == O_constant))))
+    {
+      inst.instruction = THUMB_OP32(opcode);
+      if (cond == COND_ALWAYS)
+	reloc = BFD_RELOC_THUMB_PCREL_BRANCH25;
+      else
+	{
+	  gas_assert (cond != 0xF);
+	  inst.instruction |= cond << 22;
+	  reloc = BFD_RELOC_THUMB_PCREL_BRANCH20;
+	}
+    }
+  else
+    {
+      inst.instruction = THUMB_OP16(opcode);
+      if (cond == COND_ALWAYS)
+	reloc = BFD_RELOC_THUMB_PCREL_BRANCH12;
+      else
+	{
+	  inst.instruction |= cond << 8;
+	  reloc = BFD_RELOC_THUMB_PCREL_BRANCH9;
+	}
+      /* Allow section relaxation.  */
+      if (unified_syntax && inst.size_req != 2)
+	inst.relax = opcode;
+    }
+  inst.reloc.type = reloc;
+  inst.reloc.pc_rel = 1;
+}
+
+/* Actually do the work for Thumb state bkpt and hlt.  The only difference
+   between the two is the maximum immediate allowed - which is passed in
+   RANGE.  */
+static void
+do_t_bkpt_hlt1 (int range)
+{
+  constraint (inst.cond != COND_ALWAYS,
+	      _("instruction is always unconditional"));
+  if (inst.operands[0].present)
+    {
+      constraint (inst.operands[0].imm > range,
+		  _("immediate value out of range"));
+      inst.instruction |= inst.operands[0].imm;
+    }
+
+  set_it_insn_type (NEUTRAL_IT_INSN);
+}
+
+static void
+do_t_hlt (void)
+{
+  do_t_bkpt_hlt1 (63);
+}
+
+static void
+do_t_bkpt (void)
+{
+  do_t_bkpt_hlt1 (255);
+}
+
+static void
+do_t_branch23 (void)
+{
+  set_it_insn_type_last ();
+  encode_branch (BFD_RELOC_THUMB_PCREL_BRANCH23);
+
+  /* md_apply_fix blows up with 'bl foo(PLT)' where foo is defined in
+     this file.  We used to simply ignore the PLT reloc type here --
+     the branch encoding is now needed to deal with TLSCALL relocs.
+     So if we see a PLT reloc now, put it back to how it used to be to
+     keep the preexisting behaviour.  */
+  if (inst.reloc.type == BFD_RELOC_ARM_PLT32)
+    inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH23;
+
+#if defined(OBJ_COFF)
+  /* If the destination of the branch is a defined symbol which does not have
+     the THUMB_FUNC attribute, then we must be calling a function which has
+     the (interfacearm) attribute.  We look for the Thumb entry point to that
+     function and change the branch to refer to that function instead.	*/
+  if (	 inst.reloc.exp.X_op == O_symbol
+      && inst.reloc.exp.X_add_symbol != NULL
+      && S_IS_DEFINED (inst.reloc.exp.X_add_symbol)
+      && ! THUMB_IS_FUNC (inst.reloc.exp.X_add_symbol))
+    inst.reloc.exp.X_add_symbol =
+      find_real_start (inst.reloc.exp.X_add_symbol);
+#endif
+}
+
+static void
+do_t_bx (void)
+{
+  set_it_insn_type_last ();
+  inst.instruction |= inst.operands[0].reg << 3;
+  /* ??? FIXME: Should add a hacky reloc here if reg is REG_PC.	 The reloc
+     should cause the alignment to be checked once it is known.	 This is
+     because BX PC only works if the instruction is word aligned.  */
+}
+
+static void
+do_t_bxj (void)
+{
+  int Rm;
+
+  set_it_insn_type_last ();
+  Rm = inst.operands[0].reg;
+  reject_bad_reg (Rm);
+  inst.instruction |= Rm << 16;
+}
+
+static void
+do_t_clz (void)
+{
+  unsigned Rd;
+  unsigned Rm;
+
+  Rd = inst.operands[0].reg;
+  Rm = inst.operands[1].reg;
+
+  reject_bad_reg (Rd);
+  reject_bad_reg (Rm);
+
+  inst.instruction |= Rd << 8;
+  inst.instruction |= Rm << 16;
+  inst.instruction |= Rm;
+}
+
+static void
+do_t_cps (void)
+{
+  set_it_insn_type (OUTSIDE_IT_INSN);
+  inst.instruction |= inst.operands[0].imm;
+}
+
+static void
+do_t_cpsi (void)
+{
+  set_it_insn_type (OUTSIDE_IT_INSN);
+  if (unified_syntax
+      && (inst.operands[1].present || inst.size_req == 4)
+      && ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v6_notm))
+    {
+      unsigned int imod = (inst.instruction & 0x0030) >> 4;
+      inst.instruction = 0xf3af8000;
+      inst.instruction |= imod << 9;
+      inst.instruction |= inst.operands[0].imm << 5;
+      if (inst.operands[1].present)
+	inst.instruction |= 0x100 | inst.operands[1].imm;
+    }
+  else
+    {
+      constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v1)
+		  && (inst.operands[0].imm & 4),
+		  _("selected processor does not support 'A' form "
+		    "of this instruction"));
+      constraint (inst.operands[1].present || inst.size_req == 4,
+		  _("Thumb does not support the 2-argument "
+		    "form of this instruction"));
+      inst.instruction |= inst.operands[0].imm;
+    }
+}
+
+/* THUMB CPY instruction (argument parse).  */
+
+static void
+do_t_cpy (void)
+{
+  if (inst.size_req == 4)
+    {
+      inst.instruction = THUMB_OP32 (T_MNEM_mov);
+      inst.instruction |= inst.operands[0].reg << 8;
+      inst.instruction |= inst.operands[1].reg;
+    }
+  else
+    {
+      inst.instruction |= (inst.operands[0].reg & 0x8) << 4;
+      inst.instruction |= (inst.operands[0].reg & 0x7);
+      inst.instruction |= inst.operands[1].reg << 3;
+    }
+}
+
+static void
+do_t_cbz (void)
+{
+  set_it_insn_type (OUTSIDE_IT_INSN);
+  constraint (inst.operands[0].reg > 7, BAD_HIREG);
+  inst.instruction |= inst.operands[0].reg;
+  inst.reloc.pc_rel = 1;
+  inst.reloc.type = BFD_RELOC_THUMB_PCREL_BRANCH7;
+}
+
+static void
+do_t_dbg (void)
+{
+  inst.instruction |= inst.operands[0].imm;
+}
+
+static void
+do_t_div (void)
+{
+  unsigned Rd, Rn, Rm;
+
+  Rd = inst.operands[0].reg;
+  Rn = (inst.operands[1].present
+	? inst.operands[1].reg : Rd);
+  Rm = inst.operands[2].reg;
+
+  reject_bad_reg (Rd);
+  reject_bad_reg (Rn);
+  reject_bad_reg (Rm);
+
+  inst.instruction |= Rd << 8;
+  inst.instruction |= Rn << 16;
+  inst.instruction |= Rm;
+}
+
+static void
+do_t_hint (void)
+{
+  if (unified_syntax && inst.size_req == 4)
+    inst.instruction = THUMB_OP32 (inst.instruction);
+  else
+    inst.instruction = THUMB_OP16 (inst.instruction);
+}
+
+static void
+do_t_it (void)
+{
+  unsigned int cond = inst.operands[0].imm;
+
+  set_it_insn_type (IT_INSN);
+  now_it.mask = (inst.instruction & 0xf) | 0x10;
+  now_it.cc = cond;
+  now_it.warn_deprecated = FALSE;
+
+  /* If the condition is a negative condition, invert the mask.  */
+  if ((cond & 0x1) == 0x0)
+    {
+      unsigned int mask = inst.instruction & 0x000f;
+
+      if ((mask & 0x7) == 0)
+	{
+	  /* No conversion needed.  */
+	  now_it.block_length = 1;
+	}
+      else if ((mask & 0x3) == 0)
+	{
+	  mask ^= 0x8;
+	  now_it.block_length = 2;
+	}
+      else if ((mask & 0x1) == 0)
+	{
+	  mask ^= 0xC;
+	  now_it.block_length = 3;
+	}
+      else
+	{
+	  mask ^= 0xE;
+	  now_it.block_length = 4;
+	}
+
+      inst.instruction &= 0xfff0;
+      inst.instruction |= mask;
+    }
+
+  inst.instruction |= cond << 4;
+}
+
+/* Helper function used for both push/pop and ldm/stm.  */
+static void
+encode_thumb2_ldmstm (int base, unsigned mask, bfd_boolean writeback)
+{
+  bfd_boolean load;
+
+  load = (inst.instruction & (1 << 20)) != 0;
+
+  if (mask & (1 << 13))
+    inst.error =  _("SP not allowed in register list");
+
+  if ((mask & (1 << base)) != 0
+      && writeback)
+    inst.error = _("having the base register in the register list when "
+		   "using write back is UNPREDICTABLE");
+
+  if (load)
+    {
+      if (mask & (1 << 15))
+	{
+	  if (mask & (1 << 14))
+	    inst.error = _("LR and PC should not both be in register list");
+	  else
+	    set_it_insn_type_last ();
+	}
+    }
+  else
+    {
+      if (mask & (1 << 15))
+	inst.error = _("PC not allowed in register list");
+    }
+
+  if ((mask & (mask - 1)) == 0)
+    {
+      /* Single register transfers implemented as str/ldr.  */
+      if (writeback)
+	{
+	  if (inst.instruction & (1 << 23))
+	    inst.instruction = 0x00000b04; /* ia! -> [base], #4 */
+	  else
+	    inst.instruction = 0x00000d04; /* db! -> [base, #-4]! */
+	}
+      else
+	{
+	  if (inst.instruction & (1 << 23))
+	    inst.instruction = 0x00800000; /* ia -> [base] */
+	  else
+	    inst.instruction = 0x00000c04; /* db -> [base, #-4] */
+	}
+
+      inst.instruction |= 0xf8400000;
+      if (load)
+	inst.instruction |= 0x00100000;
+
+      mask = ffs (mask) - 1;
+      mask <<= 12;
+    }
+  else if (writeback)
+    inst.instruction |= WRITE_BACK;
+
+  inst.instruction |= mask;
+  inst.instruction |= base << 16;
+}
+
+static void
+do_t_ldmstm (void)
+{
+  /* This really doesn't seem worth it.  */
+  constraint (inst.reloc.type != BFD_RELOC_UNUSED,
+	      _("expression too complex"));
+  constraint (inst.operands[1].writeback,
+	      _("Thumb load/store multiple does not support {reglist}^"));
+
+  if (unified_syntax)
+    {
+      bfd_boolean narrow;
+      unsigned mask;
+
+      narrow = FALSE;
+      /* See if we can use a 16-bit instruction.  */
+      if (inst.instruction < 0xffff /* not ldmdb/stmdb */
+	  && inst.size_req != 4
+	  && !(inst.operands[1].imm & ~0xff))
+	{
+	  mask = 1 << inst.operands[0].reg;
+
+	  if (inst.operands[0].reg <= 7)
+	    {
+	      if (inst.instruction == T_MNEM_stmia
+		  ? inst.operands[0].writeback
+		  : (inst.operands[0].writeback
+		     == !(inst.operands[1].imm & mask)))
+		{
+		  if (inst.instruction == T_MNEM_stmia
+		      && (inst.operands[1].imm & mask)
+		      && (inst.operands[1].imm & (mask - 1)))
+		    as_warn (_("value stored for r%d is UNKNOWN"),
+			     inst.operands[0].reg);
+
+		  inst.instruction = THUMB_OP16 (inst.instruction);
+		  inst.instruction |= inst.operands[0].reg << 8;
+		  inst.instruction |= inst.operands[1].imm;
+		  narrow = TRUE;
+		}
+	      else if ((inst.operands[1].imm & (inst.operands[1].imm-1)) == 0)
+		{
+		  /* This means 1 register in reg list one of 3 situations:
+		     1. Instruction is stmia, but without writeback.
+		     2. lmdia without writeback, but with Rn not in
+			reglist.
+		     3. ldmia with writeback, but with Rn in reglist.
+		     Case 3 is UNPREDICTABLE behaviour, so we handle
+		     case 1 and 2 which can be converted into a 16-bit
+		     str or ldr. The SP cases are handled below.  */
+		  unsigned long opcode;
+		  /* First, record an error for Case 3.  */
+		  if (inst.operands[1].imm & mask
+		      && inst.operands[0].writeback)
+		    inst.error =
+			_("having the base register in the register list when "
+			  "using write back is UNPREDICTABLE");
+
+		  opcode = (inst.instruction == T_MNEM_stmia ? T_MNEM_str
+							     : T_MNEM_ldr);
+		  inst.instruction = THUMB_OP16 (opcode);
+		  inst.instruction |= inst.operands[0].reg << 3;
+		  inst.instruction |= (ffs (inst.operands[1].imm)-1);
+		  narrow = TRUE;
+		}
+	    }
+	  else if (inst.operands[0] .reg == REG_SP)
+	    {
+	      if (inst.operands[0].writeback)
+		{
+		  inst.instruction =
+			THUMB_OP16 (inst.instruction == T_MNEM_stmia
+				    ? T_MNEM_push : T_MNEM_pop);
+		  inst.instruction |= inst.operands[1].imm;
+		  narrow = TRUE;
+		}
+	      else if ((inst.operands[1].imm & (inst.operands[1].imm-1)) == 0)
+		{
+		  inst.instruction =
+			THUMB_OP16 (inst.instruction == T_MNEM_stmia
+				    ? T_MNEM_str_sp : T_MNEM_ldr_sp);
+		  inst.instruction |= ((ffs (inst.operands[1].imm)-1) << 8);
+		  narrow = TRUE;
+		}
+	    }
+	}
+
+      if (!narrow)
+	{
+	  if (inst.instruction < 0xffff)
+	    inst.instruction = THUMB_OP32 (inst.instruction);
+
+	  encode_thumb2_ldmstm (inst.operands[0].reg, inst.operands[1].imm,
+				inst.operands[0].writeback);
+	}
+    }
+  else
+    {
+      constraint (inst.operands[0].reg > 7
+		  || (inst.operands[1].imm & ~0xff), BAD_HIREG);
+      constraint (inst.instruction != T_MNEM_ldmia
+		  && inst.instruction != T_MNEM_stmia,
+		  _("Thumb-2 instruction only valid in unified syntax"));
+      if (inst.instruction == T_MNEM_stmia)
+	{
+	  if (!inst.operands[0].writeback)
+	    as_warn (_("this instruction will write back the base register"));
+	  if ((inst.operands[1].imm & (1 << inst.operands[0].reg))
+	      && (inst.operands[1].imm & ((1 << inst.operands[0].reg) - 1)))
+	    as_warn (_("value stored for r%d is UNKNOWN"),
+		     inst.operands[0].reg);
+	}
+      else
+	{
+	  if (!inst.operands[0].writeback
+	      && !(inst.operands[1].imm & (1 << inst.operands[0].reg)))
+	    as_warn (_("this instruction will write back the base register"));
+	  else if (inst.operands[0].writeback
+		   && (inst.operands[1].imm & (1 << inst.operands[0].reg)))
+	    as_warn (_("this instruction will not write back the base register"));
+	}
+
+      inst.instruction = THUMB_OP16 (inst.instruction);
+      inst.instruction |= inst.operands[0].reg << 8;
+      inst.instruction |= inst.operands[1].imm;
+    }
+}
+
+static void
+do_t_ldrex (void)
+{
+  constraint (!inst.operands[1].isreg || !inst.operands[1].preind
+	      || inst.operands[1].postind || inst.operands[1].writeback
+	      || inst.operands[1].immisreg || inst.operands[1].shifted
+	      || inst.operands[1].negative,
+	      BAD_ADDR_MODE);
+
+  constraint ((inst.operands[1].reg == REG_PC), BAD_PC);
+
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= inst.operands[1].reg << 16;
+  inst.reloc.type = BFD_RELOC_ARM_T32_OFFSET_U8;
+}
+
+static void
+do_t_ldrexd (void)
+{
+  if (!inst.operands[1].present)
+    {
+      constraint (inst.operands[0].reg == REG_LR,
+		  _("r14 not allowed as first register "
+		    "when second register is omitted"));
+      inst.operands[1].reg = inst.operands[0].reg + 1;
+    }
+  constraint (inst.operands[0].reg == inst.operands[1].reg,
+	      BAD_OVERLAP);
+
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= inst.operands[1].reg << 8;
+  inst.instruction |= inst.operands[2].reg << 16;
+}
+
+static void
+do_t_ldst (void)
+{
+  unsigned long opcode;
+  int Rn;
+
+  if (inst.operands[0].isreg
+      && !inst.operands[0].preind
+      && inst.operands[0].reg == REG_PC)
+    set_it_insn_type_last ();
+
+  opcode = inst.instruction;
+  if (unified_syntax)
+    {
+      if (!inst.operands[1].isreg)
+	{
+	  if (opcode <= 0xffff)
+	    inst.instruction = THUMB_OP32 (opcode);
+	  if (move_or_literal_pool (0, CONST_THUMB, /*mode_3=*/FALSE))
+	    return;
+	}
+      if (inst.operands[1].isreg
+	  && !inst.operands[1].writeback
+	  && !inst.operands[1].shifted && !inst.operands[1].postind
+	  && !inst.operands[1].negative && inst.operands[0].reg <= 7
+	  && opcode <= 0xffff
+	  && inst.size_req != 4)
+	{
+	  /* Insn may have a 16-bit form.  */
+	  Rn = inst.operands[1].reg;
+	  if (inst.operands[1].immisreg)
+	    {
+	      inst.instruction = THUMB_OP16 (opcode);
+	      /* [Rn, Rik] */
+	      if (Rn <= 7 && inst.operands[1].imm <= 7)
+		goto op16;
+	      else if (opcode != T_MNEM_ldr && opcode != T_MNEM_str)
+		reject_bad_reg (inst.operands[1].imm);
+	    }
+	  else if ((Rn <= 7 && opcode != T_MNEM_ldrsh
+		    && opcode != T_MNEM_ldrsb)
+		   || ((Rn == REG_PC || Rn == REG_SP) && opcode == T_MNEM_ldr)
+		   || (Rn == REG_SP && opcode == T_MNEM_str))
+	    {
+	      /* [Rn, #const] */
+	      if (Rn > 7)
+		{
+		  if (Rn == REG_PC)
+		    {
+		      if (inst.reloc.pc_rel)
+			opcode = T_MNEM_ldr_pc2;
+		      else
+			opcode = T_MNEM_ldr_pc;
+		    }
+		  else
+		    {
+		      if (opcode == T_MNEM_ldr)
+			opcode = T_MNEM_ldr_sp;
+		      else
+			opcode = T_MNEM_str_sp;
+		    }
+		  inst.instruction = inst.operands[0].reg << 8;
+		}
+	      else
+		{
+		  inst.instruction = inst.operands[0].reg;
+		  inst.instruction |= inst.operands[1].reg << 3;
+		}
+	      inst.instruction |= THUMB_OP16 (opcode);
+	      if (inst.size_req == 2)
+		inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;
+	      else
+		inst.relax = opcode;
+	      return;
+	    }
+	}
+      /* Definitely a 32-bit variant.  */
+
+      /* Warning for Erratum 752419.  */
+      if (opcode == T_MNEM_ldr
+	  && inst.operands[0].reg == REG_SP
+	  && inst.operands[1].writeback == 1
+	  && !inst.operands[1].immisreg)
+	{
+	  if (no_cpu_selected ()
+	      || (ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v7)
+		  && !ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v7a)
+		  && !ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v7r)))
+	    as_warn (_("This instruction may be unpredictable "
+		       "if executed on M-profile cores "
+		       "with interrupts enabled."));
+	}
+
+      /* Do some validations regarding addressing modes.  */
+      if (inst.operands[1].immisreg)
+	reject_bad_reg (inst.operands[1].imm);
+
+      constraint (inst.operands[1].writeback == 1
+		  && inst.operands[0].reg == inst.operands[1].reg,
+		  BAD_OVERLAP);
+
+      inst.instruction = THUMB_OP32 (opcode);
+      inst.instruction |= inst.operands[0].reg << 12;
+      encode_thumb32_addr_mode (1, /*is_t=*/FALSE, /*is_d=*/FALSE);
+      check_ldr_r15_aligned ();
+      return;
+    }
+
+  constraint (inst.operands[0].reg > 7, BAD_HIREG);
+
+  if (inst.instruction == T_MNEM_ldrsh || inst.instruction == T_MNEM_ldrsb)
+    {
+      /* Only [Rn,Rm] is acceptable.  */
+      constraint (inst.operands[1].reg > 7 || inst.operands[1].imm > 7, BAD_HIREG);
+      constraint (!inst.operands[1].isreg || !inst.operands[1].immisreg
+		  || inst.operands[1].postind || inst.operands[1].shifted
+		  || inst.operands[1].negative,
+		  _("Thumb does not support this addressing mode"));
+      inst.instruction = THUMB_OP16 (inst.instruction);
+      goto op16;
+    }
+
+  inst.instruction = THUMB_OP16 (inst.instruction);
+  if (!inst.operands[1].isreg)
+    if (move_or_literal_pool (0, CONST_THUMB, /*mode_3=*/FALSE))
+      return;
+
+  constraint (!inst.operands[1].preind
+	      || inst.operands[1].shifted
+	      || inst.operands[1].writeback,
+	      _("Thumb does not support this addressing mode"));
+  if (inst.operands[1].reg == REG_PC || inst.operands[1].reg == REG_SP)
+    {
+      constraint (inst.instruction & 0x0600,
+		  _("byte or halfword not valid for base register"));
+      constraint (inst.operands[1].reg == REG_PC
+		  && !(inst.instruction & THUMB_LOAD_BIT),
+		  _("r15 based store not allowed"));
+      constraint (inst.operands[1].immisreg,
+		  _("invalid base register for register offset"));
+
+      if (inst.operands[1].reg == REG_PC)
+	inst.instruction = T_OPCODE_LDR_PC;
+      else if (inst.instruction & THUMB_LOAD_BIT)
+	inst.instruction = T_OPCODE_LDR_SP;
+      else
+	inst.instruction = T_OPCODE_STR_SP;
+
+      inst.instruction |= inst.operands[0].reg << 8;
+      inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;
+      return;
+    }
+
+  constraint (inst.operands[1].reg > 7, BAD_HIREG);
+  if (!inst.operands[1].immisreg)
+    {
+      /* Immediate offset.  */
+      inst.instruction |= inst.operands[0].reg;
+      inst.instruction |= inst.operands[1].reg << 3;
+      inst.reloc.type = BFD_RELOC_ARM_THUMB_OFFSET;
+      return;
+    }
+
+  /* Register offset.  */
+  constraint (inst.operands[1].imm > 7, BAD_HIREG);
+  constraint (inst.operands[1].negative,
+	      _("Thumb does not support this addressing mode"));
+
+ op16:
+  switch (inst.instruction)
+    {
+    case T_OPCODE_STR_IW: inst.instruction = T_OPCODE_STR_RW; break;
+    case T_OPCODE_STR_IH: inst.instruction = T_OPCODE_STR_RH; break;
+    case T_OPCODE_STR_IB: inst.instruction = T_OPCODE_STR_RB; break;
+    case T_OPCODE_LDR_IW: inst.instruction = T_OPCODE_LDR_RW; break;
+    case T_OPCODE_LDR_IH: inst.instruction = T_OPCODE_LDR_RH; break;
+    case T_OPCODE_LDR_IB: inst.instruction = T_OPCODE_LDR_RB; break;
+    case 0x5600 /* ldrsb */:
+    case 0x5e00 /* ldrsh */: break;
+    default: abort ();
+    }
+
+  inst.instruction |= inst.operands[0].reg;
+  inst.instruction |= inst.operands[1].reg << 3;
+  inst.instruction |= inst.operands[1].imm << 6;
+}
+
+static void
+do_t_ldstd (void)
+{
+  if (!inst.operands[1].present)
+    {
+      inst.operands[1].reg = inst.operands[0].reg + 1;
+      constraint (inst.operands[0].reg == REG_LR,
+		  _("r14 not allowed here"));
+      constraint (inst.operands[0].reg == REG_R12,
+		  _("r12 not allowed here"));
+    }
+
+  if (inst.operands[2].writeback
+      && (inst.operands[0].reg == inst.operands[2].reg
+      || inst.operands[1].reg == inst.operands[2].reg))
+    as_warn (_("base register written back, and overlaps "
+	       "one of transfer registers"));
+
+  inst.instruction |= inst.operands[0].reg << 12;
+  inst.instruction |= inst.operands[1].reg << 8;
+  encode_thumb32_addr_mode (2, /*is_t=*/FALSE, /*is_d=*/TRUE);
+}
+
+static void
+do_t_ldstt (void)
+{
+  inst.instruction |= inst.operands[0].reg << 12;
+  encode_thumb32_addr_mode (1, /*is_t=*/TRUE, /*is_d=*/FALSE);
+}
+
+static void
+do_t_mla (void)
+{
+  unsigned Rd, Rn, Rm, Ra;
+
+  Rd = inst.operands[0].reg;
+  Rn = inst.operands[1].reg;
+  Rm = inst.operands[2].reg;
+  Ra = inst.operands[3].reg;
+
+  reject_bad_reg (Rd);
+  reject_bad_reg (Rn);
+  reject_bad_reg (Rm);
+  reject_bad_reg (Ra);
+
+  inst.instruction |= Rd << 8;
+  inst.instruction |= Rn << 16;
+  inst.instruction |= Rm;
+  inst.instruction |= Ra << 12;
+}
+
+static void
+do_t_mlal (void)
+{
+  unsigned RdLo, RdHi, Rn, Rm;
+
+  RdLo = inst.operands[0].reg;
+  RdHi = inst.operands[1].reg;
+  Rn = inst.operands[2].reg;
+  Rm = inst.operands[3].reg;
+
+  reject_bad_reg (RdLo);
+  reject_bad_reg (RdHi);
+  reject_bad_reg (Rn);
+  reject_bad_reg (Rm);
+
+  inst.instruction |= RdLo << 12;
+  inst.instruction |= RdHi << 8;
+  inst.instruction |= Rn << 16;
+  inst.instruction |= Rm;
+}
+
+static void
+do_t_mov_cmp (void)
+{
+  unsigned Rn, Rm;
+
+  Rn = inst.operands[0].reg;
+  Rm = inst.operands[1].reg;
+
+  if (Rn == REG_PC)
+    set_it_insn_type_last ();
+
+  if (unified_syntax)
+    {
+      int r0off = (inst.instruction == T_MNEM_mov
+		   || inst.instruction == T_MNEM_movs) ? 8 : 16;
+      unsigned long opcode;
+      bfd_boolean narrow;
+      bfd_boolean low_regs;
+
+      low_regs = (Rn <= 7 && Rm <= 7);
+      opcode = inst.instruction;
+      if (in_it_block ())
+	narrow = opcode != T_MNEM_movs;
+      else
+	narrow = opcode != T_MNEM_movs || low_regs;
+      if (inst.size_req == 4
+	  || inst.operands[1].shifted)
+	narrow = FALSE;
+
+      /* MOVS PC, LR is encoded as SUBS PC, LR, #0.  */
+      if (opcode == T_MNEM_movs && inst.operands[1].isreg
+	  && !inst.operands[1].shifted
+	  && Rn == REG_PC
+	  && Rm == REG_LR)
+	{
+	  inst.instruction = T2_SUBS_PC_LR;
+	  return;
+	}
+
+      if (opcode == T_MNEM_cmp)
+	{
+	  constraint (Rn == REG_PC, BAD_PC);
+	  if (narrow)
+	    {
+	      /* In the Thumb-2 ISA, use of R13 as Rm is deprecated,
+		 but valid.  */
+	      warn_deprecated_sp (Rm);
+	      /* R15 was documented as a valid choice for Rm in ARMv6,
+		 but as UNPREDICTABLE in ARMv7.  ARM's proprietary
+		 tools reject R15, so we do too.  */
+	      constraint (Rm == REG_PC, BAD_PC);
+	    }
+	  else
+	    reject_bad_reg (Rm);
+	}
+      else if (opcode == T_MNEM_mov
+	       || opcode == T_MNEM_movs)
+	{
+	  if (inst.operands[1].isreg)
+	    {
+	      if (opcode == T_MNEM_movs)
+		{
+		  reject_bad_reg (Rn);
+		  reject_bad_reg (Rm);
+		}
+	      else if (narrow)
+		{
+		  /* This is mov.n.  */
+		  if ((Rn == REG_SP || Rn == REG_PC)
+		      && (Rm == REG_SP || Rm == REG_PC))
+		    {
+		      as_tsktsk (_("Use of r%u as a source register is "
+				 "deprecated when r%u is the destination "
+				 "register."), Rm, Rn);
+		    }
+		}
+	      else
+		{
+		  /* This is mov.w.  */
+		  constraint (Rn == REG_PC, BAD_PC);
+		  constraint (Rm == REG_PC, BAD_PC);
+		  constraint (Rn == REG_SP && Rm == REG_SP, BAD_SP);
+		}
+	    }
+	  else
+	    reject_bad_reg (Rn);
+	}
+
+      if (!inst.operands[1].isreg)
+	{
+	  /* Immediate operand.  */
+	  if (!in_it_block () && opcode == T_MNEM_mov)
+	    narrow = 0;
+	  if (low_regs && narrow)
+	    {
+	      inst.instruction = THUMB_OP16 (opcode);
+	      inst.instruction |= Rn << 8;
+	      if (inst.size_req == 2)
+		inst.reloc.type = BFD_RELOC_ARM_THUMB_IMM;
+	      else
+		inst.relax = opcode;
+	    }
+	  else
+	    {
+	      inst.instruction = THUMB_OP32 (inst.instruction);
+	      inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
+	      inst.instruction |= Rn << r0off;
+	      inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
+	    }
+	}
+      else if (inst.operands[1].shifted && inst.operands[1].immisreg
+	       && (inst.instruction == T_MNEM_mov
+		   || inst.instruction == T_MNEM_movs))
+	{
+	  /* Register shifts are encoded as separate shift instructions.  */
+	  bfd_boolean flags = (inst.instruction == T_MNEM_movs);
+
+	  if (in_it_block ())
+	    narrow = !flags;
+	  else
+	    narrow = flags;
+
+	  if (inst.size_req == 4)
+	    narrow = FALSE;
+
+	  if (!low_regs || inst.operands[1].imm > 7)
+	    narrow = FALSE;
+
+	  if (Rn != Rm)
+	    narrow = FALSE;
+
+	  switch (inst.operands[1].shift_kind)
+	    {
+	    case SHIFT_LSL:
+	      opcode = narrow ? T_OPCODE_LSL_R : THUMB_OP32 (T_MNEM_lsl);
+	      break;
+	    case SHIFT_ASR:
+	      opcode = narrow ? T_OPCODE_ASR_R : THUMB_OP32 (T_MNEM_asr);
+	      break;
+	    case SHIFT_LSR:
+	      opcode = narrow ? T_OPCODE_LSR_R : THUMB_OP32 (T_MNEM_lsr);
+	      break;
+	    case SHIFT_ROR:
+	      opcode = narrow ? T_OPCODE_ROR_R : THUMB_OP32 (T_MNEM_ror);
+	      break;
+	    default:
+	      abort ();
+	    }
+
+	  inst.instruction = opcode;
+	  if (narrow)
+	    {
+	      inst.instruction |= Rn;
+	      inst.instruction |= inst.operands[1].imm << 3;
+	    }
+	  else
+	    {
+	      if (flags)
+		inst.instruction |= CONDS_BIT;
+
+	      inst.instruction |= Rn << 8;
+	      inst.instruction |= Rm << 16;
+	      inst.instruction |= inst.operands[1].imm;
+	    }
+	}
+      else if (!narrow)
+	{
+	  /* Some mov with immediate shift have narrow variants.
+	     Register shifts are handled above.  */
+	  if (low_regs && inst.operands[1].shifted
+	      && (inst.instruction == T_MNEM_mov
+		  || inst.instruction == T_MNEM_movs))
+	    {
+	      if (in_it_block ())
+		narrow = (inst.instruction == T_MNEM_mov);
+	      else
+		narrow = (inst.instruction == T_MNEM_movs);
+	    }
+
+	  if (narrow)
+	    {
+	      switch (inst.operands[1].shift_kind)
+		{
+		case SHIFT_LSL: inst.instruction = T_OPCODE_LSL_I; break;
+		case SHIFT_LSR: inst.instruction = T_OPCODE_LSR_I; break;
+		case SHIFT_ASR: inst.instruction = T_OPCODE_ASR_I; break;
+		default: narrow = FALSE; break;
+		}
+	    }
+
+	  if (narrow)
+	    {
+	      inst.instruction |= Rn;
+	      inst.instruction |= Rm << 3;
+	      inst.reloc.type = BFD_RELOC_ARM_THUMB_SHIFT;
+	    }
+	  else
+	    {
+	      inst.instruction = THUMB_OP32 (inst.instruction);
+	      inst.instruction |= Rn << r0off;
+	      encode_thumb32_shifted_operand (1);
+	    }
+	}
+      else
+	switch (inst.instruction)
+	  {
+	  case T_MNEM_mov:
+	    /* In v4t or v5t a move of two lowregs produces unpredictable
+	       results. Don't allow this.  */
+	    if (low_regs)
+	      {
+		constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v6),
+			    "MOV Rd, Rs with two low registers is not "
+			    "permitted on this architecture");
+		ARM_MERGE_FEATURE_SETS (thumb_arch_used, thumb_arch_used,
+					arm_ext_v6);
+	      }
+
+	    inst.instruction = T_OPCODE_MOV_HR;
+	    inst.instruction |= (Rn & 0x8) << 4;
+	    inst.instruction |= (Rn & 0x7);
+	    inst.instruction |= Rm << 3;
+	    break;
+
+	  case T_MNEM_movs:
+	    /* We know we have low registers at this point.
+	       Generate LSLS Rd, Rs, #0.  */
+	    inst.instruction = T_OPCODE_LSL_I;
+	    inst.instruction |= Rn;
+	    inst.instruction |= Rm << 3;
+	    break;
+
+	  case T_MNEM_cmp:
+	    if (low_regs)
+	      {
+		inst.instruction = T_OPCODE_CMP_LR;
+		inst.instruction |= Rn;
+		inst.instruction |= Rm << 3;
+	      }
+	    else
+	      {
+		inst.instruction = T_OPCODE_CMP_HR;
+		inst.instruction |= (Rn & 0x8) << 4;
+		inst.instruction |= (Rn & 0x7);
+		inst.instruction |= Rm << 3;
+	      }
+	    break;
+	  }
+      return;
+    }
+
+  inst.instruction = THUMB_OP16 (inst.instruction);
+
+  /* PR 10443: Do not silently ignore shifted operands.  */
+  constraint (inst.operands[1].shifted,
+	      _("shifts in CMP/MOV instructions are only supported in unified syntax"));
+
+  if (inst.operands[1].isreg)
+    {
+      if (Rn < 8 && Rm < 8)
+	{
+	  /* A move of two lowregs is encoded as ADD Rd, Rs, #0
+	     since a MOV instruction produces unpredictable results.  */
+	  if (inst.instruction == T_OPCODE_MOV_I8)
+	    inst.instruction = T_OPCODE_ADD_I3;
+	  else
+	    inst.instruction = T_OPCODE_CMP_LR;
+
+	  inst.instruction |= Rn;
+	  inst.instruction |= Rm << 3;
+	}
+      else
+	{
+	  if (inst.instruction == T_OPCODE_MOV_I8)
+	    inst.instruction = T_OPCODE_MOV_HR;
+	  else
+	    inst.instruction = T_OPCODE_CMP_HR;
+	  do_t_cpy ();
+	}
+    }
+  else
+    {
+      constraint (Rn > 7,
+		  _("only lo regs allowed with immediate"));
+      inst.instruction |= Rn << 8;
+      inst.reloc.type = BFD_RELOC_ARM_THUMB_IMM;
+    }
+}
+
+static void
+do_t_mov16 (void)
+{
+  unsigned Rd;
+  bfd_vma imm;
+  bfd_boolean top;
+
+  top = (inst.instruction & 0x00800000) != 0;
+  if (inst.reloc.type == BFD_RELOC_ARM_MOVW)
+    {
+      constraint (top, _(":lower16: not allowed this instruction"));
+      inst.reloc.type = BFD_RELOC_ARM_THUMB_MOVW;
+    }
+  else if (inst.reloc.type == BFD_RELOC_ARM_MOVT)
+    {
+      constraint (!top, _(":upper16: not allowed this instruction"));
+      inst.reloc.type = BFD_RELOC_ARM_THUMB_MOVT;
+    }
+
+  Rd = inst.operands[0].reg;
+  reject_bad_reg (Rd);
+
+  inst.instruction |= Rd << 8;
+  if (inst.reloc.type == BFD_RELOC_UNUSED)
+    {
+      imm = inst.reloc.exp.X_add_number;
+      inst.instruction |= (imm & 0xf000) << 4;
+      inst.instruction |= (imm & 0x0800) << 15;
+      inst.instruction |= (imm & 0x0700) << 4;
+      inst.instruction |= (imm & 0x00ff);
+    }
+}
+
+static void
+do_t_mvn_tst (void)
+{
+  unsigned Rn, Rm;
+
+  Rn = inst.operands[0].reg;
+  Rm = inst.operands[1].reg;
+
+  if (inst.instruction == T_MNEM_cmp
+      || inst.instruction == T_MNEM_cmn)
+    constraint (Rn == REG_PC, BAD_PC);
+  else
+    reject_bad_reg (Rn);
+  reject_bad_reg (Rm);
+
+  if (unified_syntax)
+    {
+      int r0off = (inst.instruction == T_MNEM_mvn
+		   || inst.instruction == T_MNEM_mvns) ? 8 : 16;
+      bfd_boolean narrow;
+
+      if (inst.size_req == 4
+	  || inst.instruction > 0xffff
+	  || inst.operands[1].shifted
+	  || Rn > 7 || Rm > 7)
+	narrow = FALSE;
+      else if (inst.instruction == T_MNEM_cmn
+	       || inst.instruction == T_MNEM_tst)
+	narrow = TRUE;
+      else if (THUMB_SETS_FLAGS (inst.instruction))
+	narrow = !in_it_block ();
+      else
+	narrow = in_it_block ();
+
+      if (!inst.operands[1].isreg)
+	{
+	  /* For an immediate, we always generate a 32-bit opcode;
+	     section relaxation will shrink it later if possible.  */
+	  if (inst.instruction < 0xffff)
+	    inst.instruction = THUMB_OP32 (inst.instruction);
+	  inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
+	  inst.instruction |= Rn << r0off;
+	  inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
+	}
+      else
+	{
+	  /* See if we can do this with a 16-bit instruction.  */
+	  if (narrow)
+	    {
+	      inst.instruction = THUMB_OP16 (inst.instruction);
+	      inst.instruction |= Rn;
+	      inst.instruction |= Rm << 3;
+	    }
+	  else
+	    {
+	      constraint (inst.operands[1].shifted
+			  && inst.operands[1].immisreg,
+			  _("shift must be constant"));
+	      if (inst.instruction < 0xffff)
+		inst.instruction = THUMB_OP32 (inst.instruction);
+	      inst.instruction |= Rn << r0off;
+	      encode_thumb32_shifted_operand (1);
+	    }
+	}
+    }
+  else
+    {
+      constraint (inst.instruction > 0xffff
+		  || inst.instruction == T_MNEM_mvns, BAD_THUMB32);
+      constraint (!inst.operands[1].isreg || inst.operands[1].shifted,
+		  _("unshifted register required"));
+      constraint (Rn > 7 || Rm > 7,
+		  BAD_HIREG);
+
+      inst.instruction = THUMB_OP16 (inst.instruction);
+      inst.instruction |= Rn;
+      inst.instruction |= Rm << 3;
+    }
+}
+
+static void
+do_t_mrs (void)
+{
+  unsigned Rd;
+
+  if (do_vfp_nsyn_mrs () == SUCCESS)
+    return;
+
+  Rd = inst.operands[0].reg;
+  reject_bad_reg (Rd);
+  inst.instruction |= Rd << 8;
+
+  if (inst.operands[1].isreg)
+    {
+      unsigned br = inst.operands[1].reg;
+      if (((br & 0x200) == 0) && ((br & 0xf000) != 0xf000))
+	as_bad (_("bad register for mrs"));
+
+      inst.instruction |= br & (0xf << 16);
+      inst.instruction |= (br & 0x300) >> 4;
+      inst.instruction |= (br & SPSR_BIT) >> 2;
+    }
+  else
+    {
+      int flags = inst.operands[1].imm & (PSR_c|PSR_x|PSR_s|PSR_f|SPSR_BIT);
+
+      if (ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_m))
+	{
+	  /* PR gas/12698:  The constraint is only applied for m_profile.
+	     If the user has specified -march=all, we want to ignore it as
+	     we are building for any CPU type, including non-m variants.  */
+	  bfd_boolean m_profile =
+	    !ARM_FEATURE_CORE_EQUAL (selected_cpu, arm_arch_any);
+	  constraint ((flags != 0) && m_profile, _("selected processor does "
+						   "not support requested special purpose register"));
+	}
+      else
+	/* mrs only accepts APSR/CPSR/SPSR/CPSR_all/SPSR_all (for non-M profile
+	   devices).  */
+	constraint ((flags & ~SPSR_BIT) != (PSR_c|PSR_f),
+		    _("'APSR', 'CPSR' or 'SPSR' expected"));
+
+      inst.instruction |= (flags & SPSR_BIT) >> 2;
+      inst.instruction |= inst.operands[1].imm & 0xff;
+      inst.instruction |= 0xf0000;
+    }
+}
+
+static void
+do_t_msr (void)
+{
+  int flags;
+  unsigned Rn;
+
+  if (do_vfp_nsyn_msr () == SUCCESS)
+    return;
+
+  constraint (!inst.operands[1].isreg,
+	      _("Thumb encoding does not support an immediate here"));
+
+  if (inst.operands[0].isreg)
+    flags = (int)(inst.operands[0].reg);
+  else
+    flags = inst.operands[0].imm;
+
+  if (ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_m))
+    {
+      int bits = inst.operands[0].imm & (PSR_c|PSR_x|PSR_s|PSR_f|SPSR_BIT);
+
+      /* PR gas/12698:  The constraint is only applied for m_profile.
+	 If the user has specified -march=all, we want to ignore it as
+	 we are building for any CPU type, including non-m variants.  */
+      bfd_boolean m_profile =
+	!ARM_FEATURE_CORE_EQUAL (selected_cpu, arm_arch_any);
+      constraint (((ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v6_dsp)
+	   && (bits & ~(PSR_s | PSR_f)) != 0)
+	  || (!ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v6_dsp)
+	      && bits != PSR_f)) && m_profile,
+	  _("selected processor does not support requested special "
+	    "purpose register"));
+    }
+  else
+     constraint ((flags & 0xff) != 0, _("selected processor does not support "
+		 "requested special purpose register"));
+
+  Rn = inst.operands[1].reg;
+  reject_bad_reg (Rn);
+
+  inst.instruction |= (flags & SPSR_BIT) >> 2;
+  inst.instruction |= (flags & 0xf0000) >> 8;
+  inst.instruction |= (flags & 0x300) >> 4;
+  inst.instruction |= (flags & 0xff);
+  inst.instruction |= Rn << 16;
+}
+
+static void
+do_t_mul (void)
+{
+  bfd_boolean narrow;
+  unsigned Rd, Rn, Rm;
+
+  if (!inst.operands[2].present)
+    inst.operands[2].reg = inst.operands[0].reg;
+
+  Rd = inst.operands[0].reg;
+  Rn = inst.operands[1].reg;
+  Rm = inst.operands[2].reg;
+
+  if (unified_syntax)
+    {
+      if (inst.size_req == 4
+	  || (Rd != Rn
+	      && Rd != Rm)
+	  || Rn > 7
+	  || Rm > 7)
+	narrow = FALSE;
+      else if (inst.instruction == T_MNEM_muls)
+	narrow = !in_it_block ();
+      else
+	narrow = in_it_block ();
+    }
+  else
+    {
+      constraint (inst.instruction == T_MNEM_muls, BAD_THUMB32);
+      constraint (Rn > 7 || Rm > 7,
+		  BAD_HIREG);
+      narrow = TRUE;
+    }
+
+  if (narrow)
+    {
+      /* 16-bit MULS/Conditional MUL.  */
+      inst.instruction = THUMB_OP16 (inst.instruction);
+      inst.instruction |= Rd;
+
+      if (Rd == Rn)
+	inst.instruction |= Rm << 3;
+      else if (Rd == Rm)
+	inst.instruction |= Rn << 3;
+      else
+	constraint (1, _("dest must overlap one source register"));
+    }
+  else
+    {
+      constraint (inst.instruction != T_MNEM_mul,
+		  _("Thumb-2 MUL must not set flags"));
+      /* 32-bit MUL.  */
+      inst.instruction = THUMB_OP32 (inst.instruction);
+      inst.instruction |= Rd << 8;
+      inst.instruction |= Rn << 16;
+      inst.instruction |= Rm << 0;
+
+      reject_bad_reg (Rd);
+      reject_bad_reg (Rn);
+      reject_bad_reg (Rm);
+    }
+}
+
+static void
+do_t_mull (void)
+{
+  unsigned RdLo, RdHi, Rn, Rm;
+
+  RdLo = inst.operands[0].reg;
+  RdHi = inst.operands[1].reg;
+  Rn = inst.operands[2].reg;
+  Rm = inst.operands[3].reg;
+
+  reject_bad_reg (RdLo);
+  reject_bad_reg (RdHi);
+  reject_bad_reg (Rn);
+  reject_bad_reg (Rm);
+
+  inst.instruction |= RdLo << 12;
+  inst.instruction |= RdHi << 8;
+  inst.instruction |= Rn << 16;
+  inst.instruction |= Rm;
+
+ if (RdLo == RdHi)
+    as_tsktsk (_("rdhi and rdlo must be different"));
+}
+
+static void
+do_t_nop (void)
+{
+  set_it_insn_type (NEUTRAL_IT_INSN);
+
+  if (unified_syntax)
+    {
+      if (inst.size_req == 4 || inst.operands[0].imm > 15)
+	{
+	  inst.instruction = THUMB_OP32 (inst.instruction);
+	  inst.instruction |= inst.operands[0].imm;
+	}
+      else
+	{
+	  /* PR9722: Check for Thumb2 availability before
+	     generating a thumb2 nop instruction.  */
+	  if (ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v6t2))
+	    {
+	      inst.instruction = THUMB_OP16 (inst.instruction);
+	      inst.instruction |= inst.operands[0].imm << 4;
+	    }
+	  else
+	    inst.instruction = 0x46c0;
+	}
+    }
+  else
+    {
+      constraint (inst.operands[0].present,
+		  _("Thumb does not support NOP with hints"));
+      inst.instruction = 0x46c0;
+    }
+}
+
+static void
+do_t_neg (void)
+{
+  if (unified_syntax)
+    {
+      bfd_boolean narrow;
+
+      if (THUMB_SETS_FLAGS (inst.instruction))
+	narrow = !in_it_block ();
+      else
+	narrow = in_it_block ();
+      if (inst.operands[0].reg > 7 || inst.operands[1].reg > 7)
+	narrow = FALSE;
+      if (inst.size_req == 4)
+	narrow = FALSE;
+
+      if (!narrow)
+	{
+	  inst.instruction = THUMB_OP32 (inst.instruction);
+	  inst.instruction |= inst.operands[0].reg << 8;
+	  inst.instruction |= inst.operands[1].reg << 16;
+	}
+      else
+	{
+	  inst.instruction = THUMB_OP16 (inst.instruction);
+	  inst.instruction |= inst.operands[0].reg;
+	  inst.instruction |= inst.operands[1].reg << 3;
+	}
+    }
+  else
+    {
+      constraint (inst.operands[0].reg > 7 || inst.operands[1].reg > 7,
+		  BAD_HIREG);
+      constraint (THUMB_SETS_FLAGS (inst.instruction), BAD_THUMB32);
+
+      inst.instruction = THUMB_OP16 (inst.instruction);
+      inst.instruction |= inst.operands[0].reg;
+      inst.instruction |= inst.operands[1].reg << 3;
+    }
+}
+
+static void
+do_t_orn (void)
+{
+  unsigned Rd, Rn;
+
+  Rd = inst.operands[0].reg;
+  Rn = inst.operands[1].present ? inst.operands[1].reg : Rd;
+
+  reject_bad_reg (Rd);
+  /* Rn == REG_SP is unpredictable; Rn == REG_PC is MVN.  */
+  reject_bad_reg (Rn);
+
+  inst.instruction |= Rd << 8;
+  inst.instruction |= Rn << 16;
+
+  if (!inst.operands[2].isreg)
+    {
+      inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
+      inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
+    }
+  else
+    {
+      unsigned Rm;
+
+      Rm = inst.operands[2].reg;
+      reject_bad_reg (Rm);
+
+      constraint (inst.operands[2].shifted
+		  && inst.operands[2].immisreg,
+		  _("shift must be constant"));
+      encode_thumb32_shifted_operand (2);
+    }
+}
+
+static void
+do_t_pkhbt (void)
+{
+  unsigned Rd, Rn, Rm;
+
+  Rd = inst.operands[0].reg;
+  Rn = inst.operands[1].reg;
+  Rm = inst.operands[2].reg;
+
+  reject_bad_reg (Rd);
+  reject_bad_reg (Rn);
+  reject_bad_reg (Rm);
+
+  inst.instruction |= Rd << 8;
+  inst.instruction |= Rn << 16;
+  inst.instruction |= Rm;
+  if (inst.operands[3].present)
+    {
+      unsigned int val = inst.reloc.exp.X_add_number;
+      constraint (inst.reloc.exp.X_op != O_constant,
+		  _("expression too complex"));
+      inst.instruction |= (val & 0x1c) << 10;
+      inst.instruction |= (val & 0x03) << 6;
+    }
+}
+
+static void
+do_t_pkhtb (void)
+{
+  if (!inst.operands[3].present)
+    {
+      unsigned Rtmp;
+
+      inst.instruction &= ~0x00000020;
+
+      /* PR 10168.  Swap the Rm and Rn registers.  */
+      Rtmp = inst.operands[1].reg;
+      inst.operands[1].reg = inst.operands[2].reg;
+      inst.operands[2].reg = Rtmp;
+    }
+  do_t_pkhbt ();
+}
+
+static void
+do_t_pld (void)
+{
+  if (inst.operands[0].immisreg)
+    reject_bad_reg (inst.operands[0].imm);
+
+  encode_thumb32_addr_mode (0, /*is_t=*/FALSE, /*is_d=*/FALSE);
+}
+
+static void
+do_t_push_pop (void)
+{
+  unsigned mask;
+
+  constraint (inst.operands[0].writeback,
+	      _("push/pop do not support {reglist}^"));
+  constraint (inst.reloc.type != BFD_RELOC_UNUSED,
+	      _("expression too complex"));
+
+  mask = inst.operands[0].imm;
+  if (inst.size_req != 4 && (mask & ~0xff) == 0)
+    inst.instruction = THUMB_OP16 (inst.instruction) | mask;
+  else if (inst.size_req != 4
+	   && (mask & ~0xff) == (1 << (inst.instruction == T_MNEM_push
+				       ? REG_LR : REG_PC)))
+    {
+      inst.instruction = THUMB_OP16 (inst.instruction);
+      inst.instruction |= THUMB_PP_PC_LR;
+      inst.instruction |= mask & 0xff;
+    }
+  else if (unified_syntax)
+    {
+      inst.instruction = THUMB_OP32 (inst.instruction);
+      encode_thumb2_ldmstm (13, mask, TRUE);
+    }
+  else
+    {
+      inst.error = _("invalid register list to push/pop instruction");
+      return;
+    }
+}
+
+static void
+do_t_rbit (void)
+{
+  unsigned Rd, Rm;
+
+  Rd = inst.operands[0].reg;
+  Rm = inst.operands[1].reg;
+
+  reject_bad_reg (Rd);
+  reject_bad_reg (Rm);
+
+  inst.instruction |= Rd << 8;
+  inst.instruction |= Rm << 16;
+  inst.instruction |= Rm;
+}
+
+static void
+do_t_rev (void)
+{
+  unsigned Rd, Rm;
+
+  Rd = inst.operands[0].reg;
+  Rm = inst.operands[1].reg;
+
+  reject_bad_reg (Rd);
+  reject_bad_reg (Rm);
+
+  if (Rd <= 7 && Rm <= 7
+      && inst.size_req != 4)
+    {
+      inst.instruction = THUMB_OP16 (inst.instruction);
+      inst.instruction |= Rd;
+      inst.instruction |= Rm << 3;
+    }
+  else if (unified_syntax)
+    {
+      inst.instruction = THUMB_OP32 (inst.instruction);
+      inst.instruction |= Rd << 8;
+      inst.instruction |= Rm << 16;
+      inst.instruction |= Rm;
+    }
+  else
+    inst.error = BAD_HIREG;
+}
+
+static void
+do_t_rrx (void)
+{
+  unsigned Rd, Rm;
+
+  Rd = inst.operands[0].reg;
+  Rm = inst.operands[1].reg;
+
+  reject_bad_reg (Rd);
+  reject_bad_reg (Rm);
+
+  inst.instruction |= Rd << 8;
+  inst.instruction |= Rm;
+}
+
+static void
+do_t_rsb (void)
+{
+  unsigned Rd, Rs;
+
+  Rd = inst.operands[0].reg;
+  Rs = (inst.operands[1].present
+	? inst.operands[1].reg    /* Rd, Rs, foo */
+	: inst.operands[0].reg);  /* Rd, foo -> Rd, Rd, foo */
+
+  reject_bad_reg (Rd);
+  reject_bad_reg (Rs);
+  if (inst.operands[2].isreg)
+    reject_bad_reg (inst.operands[2].reg);
+
+  inst.instruction |= Rd << 8;
+  inst.instruction |= Rs << 16;
+  if (!inst.operands[2].isreg)
+    {
+      bfd_boolean narrow;
+
+      if ((inst.instruction & 0x00100000) != 0)
+	narrow = !in_it_block ();
+      else
+	narrow = in_it_block ();
+
+      if (Rd > 7 || Rs > 7)
+	narrow = FALSE;
+
+      if (inst.size_req == 4 || !unified_syntax)
+	narrow = FALSE;
+
+      if (inst.reloc.exp.X_op != O_constant
+	  || inst.reloc.exp.X_add_number != 0)
+	narrow = FALSE;
+
+      /* Turn rsb #0 into 16-bit neg.  We should probably do this via
+	 relaxation, but it doesn't seem worth the hassle.  */
+      if (narrow)
+	{
+	  inst.reloc.type = BFD_RELOC_UNUSED;
+	  inst.instruction = THUMB_OP16 (T_MNEM_negs);
+	  inst.instruction |= Rs << 3;
+	  inst.instruction |= Rd;
+	}
+      else
+	{
+	  inst.instruction = (inst.instruction & 0xe1ffffff) | 0x10000000;
+	  inst.reloc.type = BFD_RELOC_ARM_T32_IMMEDIATE;
+	}
+    }
+  else
+    encode_thumb32_shifted_operand (2);
+}
+
+static void
+do_t_setend (void)
+{
+  if (warn_on_deprecated
+      && ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v8))
+      as_tsktsk (_("setend use is deprecated for ARMv8"));
+
+  set_it_insn_type (OUTSIDE_IT_INSN);
+  if (inst.operands[0].imm)
+    inst.instruction |= 0x8;
+}
+
+static void
+do_t_shift (void)
+{
+  if (!inst.operands[1].present)
+    inst.operands[1].reg = inst.operands[0].reg;
+
+  if (unified_syntax)
+    {
+      bfd_boolean narrow;
+      int shift_kind;
+
+      switch (inst.instruction)
+	{
+	case T_MNEM_asr:
+	case T_MNEM_asrs: shift_kind = SHIFT_ASR; break;
+	case T_MNEM_lsl:
+	case T_MNEM_lsls: shift_kind = SHIFT_LSL; break;
+	case T_MNEM_lsr:
+	case T_MNEM_lsrs: shift_kind = SHIFT_LSR; break;
+	case T_MNEM_ror:
+	case T_MNEM_rors: shift_kind = SHIFT_ROR; break;
+	default: abort ();
+	}
+
+      if (THUMB_SETS_FLAGS (inst.instruction))
+	narrow = !in_it_block ();
+      else
+	narrow = in_it_block ();
+      if (inst.operands[0].reg > 7 || inst.operands[1].reg > 7)
+	narrow = FALSE;
+      if (!inst.operands[2].isreg && shift_kind == SHIFT_ROR)
+	narrow = FALSE;
+      if (inst.operands[2].isreg
+	  && (inst.operands[1].reg != inst.operands[0].reg
+	      || inst.operands[2].reg > 7))
+	narrow = FALSE;
+      if (inst.size_req == 4)
+	narrow = FALSE;
+
+      reject_bad_reg (inst.operands[0].reg);
+      reject_bad_reg (inst.operands[1].reg);
+
+      if (!narrow)
+	{
+	  if (inst.operands[2].isreg)
+	    {
+	      reject_bad_reg (inst.operands[2].reg);
+	      inst.instruction = THUMB_OP32 (inst.instruction);
+	      inst.instruction |= inst.operands[0].reg << 8;
+	      inst.instruction |= inst.operands[1].reg << 16;
+	      inst.instruction |= inst.operands[2].reg;
+
+	      /* PR 12854: Error on extraneous shifts.  */
+	      constraint (inst.operands[2].shifted,
+			  _("extraneous shift as part of operand to shift insn"));
+	    }
+	  else
+	    {
+	      inst.operands[1].shifted = 1;
+	      inst.operands[1].shift_kind = shift_kind;
+	      inst.instruction = THUMB_OP32 (THUMB_SETS_FLAGS (inst.instruction)
+					     ? T_MNEM_movs : T_MNEM_mov);
+	      inst.instruction |= inst.operands[0].reg << 8;
+	      encode_thumb32_shifted_operand (1);
+	      /* Prevent the incorrect generation of an ARM_IMMEDIATE fixup.  */
+	      inst.reloc.type = BFD_RELOC_UNUSED;
+	    }
+	}
+      else
+	{
+	  if (inst.operands[2].isreg)
+	    {
+	      switch (shift_kind)
+		{
+		case SHIFT_ASR: inst.instruction = T_OPCODE_ASR_R; break;
+		case SHIFT_LSL: inst.instruction = T_OPCODE_LSL_R; break;
+		case SHIFT_LSR: inst.instruction = T_OPCODE_LSR_R; break;
+		case SHIFT_ROR: inst.instruction = T_OPCODE_ROR_R; break;
+		default: abort ();
+		}
+
+	      inst.instruction |= inst.operands[0].reg;
+	      inst.instruction |= inst.operands[2].reg << 3;
+
+	      /* PR 12854: Error on extraneous shifts.  */
+	      constraint (inst.operands[2].shifted,
+			  _("extraneous shift as part of operand to shift insn"));
+	    }
+	  else
+	    {
+	      switch (shift_kind)
+		{
+		case SHIFT_ASR: inst.instruction = T_OPCODE_ASR_I; break;
+		case SHIFT_LSL: inst.instruction = T_OPCODE_LSL_I; break;
+		case SHIFT_LSR: inst.instruction = T_OPCODE_LSR_I; break;
+		default: abort ();
+		}
+	      inst.reloc.type = BFD_RELOC_ARM_THUMB_SHIFT;
+	      inst.instruction |= inst.operands[0].reg;
+	      inst.instruction |= inst.operands[1].reg << 3;
+	    }
+	}
+    }
+  else
+    {
+      constraint (inst.operands[0].reg > 7
+		  || inst.operands[1].reg > 7, BAD_HIREG);
+      constraint (THUMB_SETS_FLAGS (inst.instruction), BAD_THUMB32);
+
+      if (inst.operands[2].isreg)  /* Rd, {Rs,} Rn */
+	{
+	  constraint (inst.operands[2].reg > 7, BAD_HIREG);
+	  constraint (inst.operands[0].reg != inst.operands[1].reg,
+		      _("source1 and dest must be same register"));
+
+	  switch (inst.instruction)
+	    {
+	    case T_MNEM_asr: inst.instruction = T_OPCODE_ASR_R; break;
+	    case T_MNEM_lsl: inst.instruction = T_OPCODE_LSL_R; break;
+	    case T_MNEM_lsr: inst.instruction = T_OPCODE_LSR_R; break;
+	    case T_MNEM_ror: inst.instruction = T_OPCODE_ROR_R; break;
+	    default: abort ();
+	    }
+
+	  inst.instruction |= inst.operands[0].reg;
+	  inst.instruction |= inst.operands[2].reg << 3;
+
+	  /* PR 12854: Error on extraneous shifts.  */
+	  constraint (inst.operands[2].shifted,
+		      _("extraneous shift as part of operand to shift insn"));
+	}
+      else
+	{
+	  switch (inst.instruction)
+	    {
+	    case T_MNEM_asr: inst.instruction = T_OPCODE_ASR_I; break;
+	    case T_MNEM_lsl: inst.instruction = T_OPCODE_LSL_I; break;
+	    case T_MNEM_lsr: inst.instruction = T_OPCODE_LSR_I; break;
+	    case T_MNEM_ror: inst.error = _("ror #imm not supported"); return;
+	    default: abort ();
+	    }
+	  inst.reloc.type = BFD_RELOC_ARM_THUMB_SHIFT;
+	  inst.instruction |= inst.operands[0].reg;
+	  inst.instruction |= inst.operands[1].reg << 3;
+	}
+    }
+}
+
+static void
+do_t_simd (void)
+{
+  unsigned Rd, Rn, Rm;
+
+  Rd = inst.operands[0].reg;
+  Rn = inst.operands[1].reg;
+  Rm = inst.operands[2].reg;
+
+  reject_bad_reg (Rd);
+  reject_bad_reg (Rn);
+  reject_bad_reg (Rm);
+
+  inst.instruction |= Rd << 8;
+  inst.instruction |= Rn << 16;
+  inst.instruction |= Rm;
+}
+
+static void
+do_t_simd2 (void)
+{
+  unsigned Rd, Rn, Rm;
+
+  Rd = inst.operands[0].reg;
+  Rm = inst.operands[1].reg;
+  Rn = inst.operands[2].reg;
+
+  reject_bad_reg (Rd);
+  reject_bad_reg (Rn);
+  reject_bad_reg (Rm);
+
+  inst.instruction |= Rd << 8;
+  inst.instruction |= Rn << 16;
+  inst.instruction |= Rm;
+}
+
+static void
+do_t_smc (void)
+{
+  unsigned int value = inst.reloc.exp.X_add_number;
+  constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v7a),
+	      _("SMC is not permitted on this architecture"));
+  constraint (inst.reloc.exp.X_op != O_constant,
+	      _("expression too complex"));
+  inst.reloc.type = BFD_RELOC_UNUSED;
+  inst.instruction |= (value & 0xf000) >> 12;
+  inst.instruction |= (value & 0x0ff0);
+  inst.instruction |= (value & 0x000f) << 16;
+  /* PR gas/15623: SMC instructions must be last in an IT block.  */
+  set_it_insn_type_last ();
+}
+
+static void
+do_t_hvc (void)
+{
+  unsigned int value = inst.reloc.exp.X_add_number;
+
+  inst.reloc.type = BFD_RELOC_UNUSED;
+  inst.instruction |= (value & 0x0fff);
+  inst.instruction |= (value & 0xf000) << 4;
+}
+
+static void
+do_t_ssat_usat (int bias)
+{
+  unsigned Rd, Rn;
+
+  Rd = inst.operands[0].reg;
+  Rn = inst.operands[2].reg;
+
+  reject_bad_reg (Rd);
+  reject_bad_reg (Rn);
+
+  inst.instruction |= Rd << 8;
+  inst.instruction |= inst.operands[1].imm - bias;
+  inst.instruction |= Rn << 16;
+
+  if (inst.operands[3].present)
+    {
+      offsetT shift_amount = inst.reloc.exp.X_add_number;
+
+      inst.reloc.type = BFD_RELOC_UNUSED;
+
+      constraint (inst.reloc.exp.X_op != O_constant,
+		  _("expression too complex"));
+
+      if (shift_amount != 0)
+	{
+	  constraint (shift_amount > 31,
+		      _("shift expression is too large"));
+
+	  if (inst.operands[3].shift_kind == SHIFT_ASR)
+	    inst.instruction |= 0x00200000;  /* sh bit.  */
+
+	  inst.instruction |= (shift_amount & 0x1c) << 10;
+	  inst.instruction |= (shift_amount & 0x03) << 6;
+	}
+    }
+}
+
+static void
+do_t_ssat (void)
+{
+  do_t_ssat_usat (1);
+}
+
+static void
+do_t_ssat16 (void)
+{
+  unsigned Rd, Rn;
+
+  Rd = inst.operands[0].reg;
+  Rn = inst.operands[2].reg;
+
+  reject_bad_reg (Rd);
+  reject_bad_reg (Rn);
+
+  inst.instruction |= Rd << 8;
+  inst.instruction |= inst.operands[1].imm - 1;
+  inst.instruction |= Rn << 16;
+}
+
+static void
+do_t_strex (void)
+{
+  constraint (!inst.operands[2].isreg || !inst.operands[2].preind
+	      || inst.operands[2].postind || inst.operands[2].writeback
+	      || inst.operands[2].immisreg || inst.operands[2].shifted
+	      || inst.operands[2].negative,
+	      BAD_ADDR_MODE);
+
+  constraint (inst.operands[2].reg == REG_PC, BAD_PC);
+
+  inst.instruction |= inst.operands[0].reg << 8;
+  inst.instruction |= inst.operands[1].reg << 12;
+  inst.instruction |= inst.operands[2].reg << 16;
+  inst.reloc.type = BFD_RELOC_ARM_T32_OFFSET_U8;
+}
+
+static void
+do_t_strexd (void)
+{
+  if (!inst.operands[2].present)
+    inst.operands[2].reg = inst.operands[1].reg + 1;
+
+  constraint (inst.operands[0].reg == inst.operands[1].reg
+	      || inst.operands[0].reg == inst.operands[2].reg
+	      || inst.operands[0].reg == inst.operands[3].reg,
+	      BAD_OVERLAP);
+
+  inst.instruction |= inst.operands[0].reg;
+  inst.instruction |= inst.operands[1].reg << 12;
+  inst.instruction |= inst.operands[2].reg << 8;
+  inst.instruction |= inst.operands[3].reg << 16;
+}
+
+static void
+do_t_sxtah (void)
+{
+  unsigned Rd, Rn, Rm;
+
+  Rd = inst.operands[0].reg;
+  Rn = inst.operands[1].reg;
+  Rm = inst.operands[2].reg;
+
+  reject_bad_reg (Rd);
+  reject_bad_reg (Rn);
+  reject_bad_reg (Rm);
+
+  inst.instruction |= Rd << 8;
+  inst.instruction |= Rn << 16;
+  inst.instruction |= Rm;
+  inst.instruction |= inst.operands[3].imm << 4;
+}
+
+static void
+do_t_sxth (void)
+{
+  unsigned Rd, Rm;
+
+  Rd = inst.operands[0].reg;
+  Rm = inst.operands[1].reg;
+
+  reject_bad_reg (Rd);
+  reject_bad_reg (Rm);
+
+  if (inst.instruction <= 0xffff
+      && inst.size_req != 4
+      && Rd <= 7 && Rm <= 7
+      && (!inst.operands[2].present || inst.operands[2].imm == 0))
+    {
+      inst.instruction = THUMB_OP16 (inst.instruction);
+      inst.instruction |= Rd;
+      inst.instruction |= Rm << 3;
+    }
+  else if (unified_syntax)
+    {
+      if (inst.instruction <= 0xffff)
+	inst.instruction = THUMB_OP32 (inst.instruction);
+      inst.instruction |= Rd << 8;
+      inst.instruction |= Rm;
+      inst.instruction |= inst.operands[2].imm << 4;
+    }
+  else
+    {
+      constraint (inst.operands[2].present && inst.operands[2].imm != 0,
+		  _("Thumb encoding does not support rotation"));
+      constraint (1, BAD_HIREG);
+    }
+}
+
+static void
+do_t_swi (void)
+{
+  /* We have to do the following check manually as ARM_EXT_OS only applies
+     to ARM_EXT_V6M.  */
+  if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v6m))
+    {
+      if (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_os)
+	  /* This only applies to the v6m howver, not later architectures.  */
+	  && ! ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v7))
+	as_bad (_("SVC is not permitted on this architecture"));
+      ARM_MERGE_FEATURE_SETS (thumb_arch_used, thumb_arch_used, arm_ext_os);
+    }
+
+  inst.reloc.type = BFD_RELOC_ARM_SWI;
+}
+
+static void
+do_t_tb (void)
+{
+  unsigned Rn, Rm;
+  int half;
+
+  half = (inst.instruction & 0x10) != 0;
+  set_it_insn_type_last ();
+  constraint (inst.operands[0].immisreg,
+	      _("instruction requires register index"));
+
+  Rn = inst.operands[0].reg;
+  Rm = inst.operands[0].imm;
+
+  constraint (Rn == REG_SP, BAD_SP);
+  reject_bad_reg (Rm);
+
+  constraint (!half && inst.operands[0].shifted,
+	      _("instruction does not allow shifted index"));
+  inst.instruction |= (Rn << 16) | Rm;
+}
+
+static void
+do_t_udf (void)
+{
+  if (!inst.operands[0].present)
+    inst.operands[0].imm = 0;
+
+  if ((unsigned int) inst.operands[0].imm > 255 || inst.size_req == 4)
+    {
+      constraint (inst.size_req == 2,
+                  _("immediate value out of range"));
+      inst.instruction = THUMB_OP32 (inst.instruction);
+      inst.instruction |= (inst.operands[0].imm & 0xf000u) << 4;
+      inst.instruction |= (inst.operands[0].imm & 0x0fffu) << 0;
+    }
+  else
+    {
+      inst.instruction = THUMB_OP16 (inst.instruction);
+      inst.instruction |= inst.operands[0].imm;
+    }
+
+  set_it_insn_type (NEUTRAL_IT_INSN);
+}
+
+
+static void
+do_t_usat (void)
+{
+  do_t_ssat_usat (0);
+}
+
+static void
+do_t_usat16 (void)
+{
+  unsigned Rd, Rn;
+
+  Rd = inst.operands[0].reg;
+  Rn = inst.operands[2].reg;
+
+  reject_bad_reg (Rd);
+  reject_bad_reg (Rn);
+
+  inst.instruction |= Rd << 8;
+  inst.instruction |= inst.operands[1].imm;
+  inst.instruction |= Rn << 16;
+}
+
+/* Neon instruction encoder helpers.  */
+
+/* Encodings for the different types for various Neon opcodes.  */
+
+/* An "invalid" code for the following tables.  */
+#define N_INV -1u
+
+struct neon_tab_entry
+{
+  unsigned integer;
+  unsigned float_or_poly;
+  unsigned scalar_or_imm;
+};
+
+/* Map overloaded Neon opcodes to their respective encodings.  */
+#define NEON_ENC_TAB					\
+  X(vabd,	0x0000700, 0x1200d00, N_INV),		\
+  X(vmax,	0x0000600, 0x0000f00, N_INV),		\
+  X(vmin,	0x0000610, 0x0200f00, N_INV),		\
+  X(vpadd,	0x0000b10, 0x1000d00, N_INV),		\
+  X(vpmax,	0x0000a00, 0x1000f00, N_INV),		\
+  X(vpmin,	0x0000a10, 0x1200f00, N_INV),		\
+  X(vadd,	0x0000800, 0x0000d00, N_INV),		\
+  X(vsub,	0x1000800, 0x0200d00, N_INV),		\
+  X(vceq,	0x1000810, 0x0000e00, 0x1b10100),	\
+  X(vcge,	0x0000310, 0x1000e00, 0x1b10080),	\
+  X(vcgt,	0x0000300, 0x1200e00, 0x1b10000),	\
+  /* Register variants of the following two instructions are encoded as
+     vcge / vcgt with the operands reversed.  */  	\
+  X(vclt,	0x0000300, 0x1200e00, 0x1b10200),	\
+  X(vcle,	0x0000310, 0x1000e00, 0x1b10180),	\
+  X(vfma,	N_INV, 0x0000c10, N_INV),		\
+  X(vfms,	N_INV, 0x0200c10, N_INV),		\
+  X(vmla,	0x0000900, 0x0000d10, 0x0800040),	\
+  X(vmls,	0x1000900, 0x0200d10, 0x0800440),	\
+  X(vmul,	0x0000910, 0x1000d10, 0x0800840),	\
+  X(vmull,	0x0800c00, 0x0800e00, 0x0800a40), /* polynomial not float.  */ \
+  X(vmlal,	0x0800800, N_INV,     0x0800240),	\
+  X(vmlsl,	0x0800a00, N_INV,     0x0800640),	\
+  X(vqdmlal,	0x0800900, N_INV,     0x0800340),	\
+  X(vqdmlsl,	0x0800b00, N_INV,     0x0800740),	\
+  X(vqdmull,	0x0800d00, N_INV,     0x0800b40),	\
+  X(vqdmulh,    0x0000b00, N_INV,     0x0800c40),	\
+  X(vqrdmulh,   0x1000b00, N_INV,     0x0800d40),	\
+  X(vqrdmlah,   0x3000b10, N_INV,     0x0800e40),	\
+  X(vqrdmlsh,   0x3000c10, N_INV,     0x0800f40),	\
+  X(vshl,	0x0000400, N_INV,     0x0800510),	\
+  X(vqshl,	0x0000410, N_INV,     0x0800710),	\
+  X(vand,	0x0000110, N_INV,     0x0800030),	\
+  X(vbic,	0x0100110, N_INV,     0x0800030),	\
+  X(veor,	0x1000110, N_INV,     N_INV),		\
+  X(vorn,	0x0300110, N_INV,     0x0800010),	\
+  X(vorr,	0x0200110, N_INV,     0x0800010),	\
+  X(vmvn,	0x1b00580, N_INV,     0x0800030),	\
+  X(vshll,	0x1b20300, N_INV,     0x0800a10), /* max shift, immediate.  */ \
+  X(vcvt,       0x1b30600, N_INV,     0x0800e10), /* integer, fixed-point.  */ \
+  X(vdup,       0xe800b10, N_INV,     0x1b00c00), /* arm, scalar.  */ \
+  X(vld1,       0x0200000, 0x0a00000, 0x0a00c00), /* interlv, lane, dup.  */ \
+  X(vst1,	0x0000000, 0x0800000, N_INV),		\
+  X(vld2,	0x0200100, 0x0a00100, 0x0a00d00),	\
+  X(vst2,	0x0000100, 0x0800100, N_INV),		\
+  X(vld3,	0x0200200, 0x0a00200, 0x0a00e00),	\
+  X(vst3,	0x0000200, 0x0800200, N_INV),		\
+  X(vld4,	0x0200300, 0x0a00300, 0x0a00f00),	\
+  X(vst4,	0x0000300, 0x0800300, N_INV),		\
+  X(vmovn,	0x1b20200, N_INV,     N_INV),		\
+  X(vtrn,	0x1b20080, N_INV,     N_INV),		\
+  X(vqmovn,	0x1b20200, N_INV,     N_INV),		\
+  X(vqmovun,	0x1b20240, N_INV,     N_INV),		\
+  X(vnmul,      0xe200a40, 0xe200b40, N_INV),		\
+  X(vnmla,      0xe100a40, 0xe100b40, N_INV),		\
+  X(vnmls,      0xe100a00, 0xe100b00, N_INV),		\
+  X(vfnma,      0xe900a40, 0xe900b40, N_INV),		\
+  X(vfnms,      0xe900a00, 0xe900b00, N_INV),		\
+  X(vcmp,	0xeb40a40, 0xeb40b40, N_INV),		\
+  X(vcmpz,	0xeb50a40, 0xeb50b40, N_INV),		\
+  X(vcmpe,	0xeb40ac0, 0xeb40bc0, N_INV),		\
+  X(vcmpez,     0xeb50ac0, 0xeb50bc0, N_INV),		\
+  X(vseleq,	0xe000a00, N_INV,     N_INV),		\
+  X(vselvs,	0xe100a00, N_INV,     N_INV),		\
+  X(vselge,	0xe200a00, N_INV,     N_INV),		\
+  X(vselgt,	0xe300a00, N_INV,     N_INV),		\
+  X(vmaxnm,	0xe800a00, 0x3000f10, N_INV),		\
+  X(vminnm,	0xe800a40, 0x3200f10, N_INV),		\
+  X(vcvta,	0xebc0a40, 0x3bb0000, N_INV),		\
+  X(vrintr,	0xeb60a40, 0x3ba0400, N_INV),		\
+  X(vrinta,	0xeb80a40, 0x3ba0400, N_INV),		\
+  X(aes,	0x3b00300, N_INV,     N_INV),		\
+  X(sha3op,	0x2000c00, N_INV,     N_INV),		\
+  X(sha1h,	0x3b902c0, N_INV,     N_INV),           \
+  X(sha2op,     0x3ba0380, N_INV,     N_INV)
+
+enum neon_opc
+{
+#define X(OPC,I,F,S) N_MNEM_##OPC
+NEON_ENC_TAB
+#undef X
+};
+
+static const struct neon_tab_entry neon_enc_tab[] =
+{
+#define X(OPC,I,F,S) { (I), (F), (S) }
+NEON_ENC_TAB
+#undef X
+};
+
+/* Do not use these macros; instead, use NEON_ENCODE defined below.  */
+#define NEON_ENC_INTEGER_(X) (neon_enc_tab[(X) & 0x0fffffff].integer)
+#define NEON_ENC_ARMREG_(X)  (neon_enc_tab[(X) & 0x0fffffff].integer)
+#define NEON_ENC_POLY_(X)    (neon_enc_tab[(X) & 0x0fffffff].float_or_poly)
+#define NEON_ENC_FLOAT_(X)   (neon_enc_tab[(X) & 0x0fffffff].float_or_poly)
+#define NEON_ENC_SCALAR_(X)  (neon_enc_tab[(X) & 0x0fffffff].scalar_or_imm)
+#define NEON_ENC_IMMED_(X)   (neon_enc_tab[(X) & 0x0fffffff].scalar_or_imm)
+#define NEON_ENC_INTERLV_(X) (neon_enc_tab[(X) & 0x0fffffff].integer)
+#define NEON_ENC_LANE_(X)    (neon_enc_tab[(X) & 0x0fffffff].float_or_poly)
+#define NEON_ENC_DUP_(X)     (neon_enc_tab[(X) & 0x0fffffff].scalar_or_imm)
+#define NEON_ENC_SINGLE_(X) \
+  ((neon_enc_tab[(X) & 0x0fffffff].integer) | ((X) & 0xf0000000))
+#define NEON_ENC_DOUBLE_(X) \
+  ((neon_enc_tab[(X) & 0x0fffffff].float_or_poly) | ((X) & 0xf0000000))
+#define NEON_ENC_FPV8_(X) \
+  ((neon_enc_tab[(X) & 0x0fffffff].integer) | ((X) & 0xf000000))
+
+#define NEON_ENCODE(type, inst)					\
+  do								\
+    {								\
+      inst.instruction = NEON_ENC_##type##_ (inst.instruction);	\
+      inst.is_neon = 1;						\
+    }								\
+  while (0)
+
+#define check_neon_suffixes						\
+  do									\
+    {									\
+      if (!inst.error && inst.vectype.elems > 0 && !inst.is_neon)	\
+	{								\
+	  as_bad (_("invalid neon suffix for non neon instruction"));	\
+	  return;							\
+	}								\
+    }									\
+  while (0)
+
+/* Define shapes for instruction operands. The following mnemonic characters
+   are used in this table:
+
+     F - VFP S<n> register
+     D - Neon D<n> register
+     Q - Neon Q<n> register
+     I - Immediate
+     S - Scalar
+     R - ARM register
+     L - D<n> register list
+
+   This table is used to generate various data:
+     - enumerations of the form NS_DDR to be used as arguments to
+       neon_select_shape.
+     - a table classifying shapes into single, double, quad, mixed.
+     - a table used to drive neon_select_shape.  */
+
+#define NEON_SHAPE_DEF			\
+  X(3, (D, D, D), DOUBLE),		\
+  X(3, (Q, Q, Q), QUAD),		\
+  X(3, (D, D, I), DOUBLE),		\
+  X(3, (Q, Q, I), QUAD),		\
+  X(3, (D, D, S), DOUBLE),		\
+  X(3, (Q, Q, S), QUAD),		\
+  X(2, (D, D), DOUBLE),			\
+  X(2, (Q, Q), QUAD),			\
+  X(2, (D, S), DOUBLE),			\
+  X(2, (Q, S), QUAD),			\
+  X(2, (D, R), DOUBLE),			\
+  X(2, (Q, R), QUAD),			\
+  X(2, (D, I), DOUBLE),			\
+  X(2, (Q, I), QUAD),			\
+  X(3, (D, L, D), DOUBLE),		\
+  X(2, (D, Q), MIXED),			\
+  X(2, (Q, D), MIXED),			\
+  X(3, (D, Q, I), MIXED),		\
+  X(3, (Q, D, I), MIXED),		\
+  X(3, (Q, D, D), MIXED),		\
+  X(3, (D, Q, Q), MIXED),		\
+  X(3, (Q, Q, D), MIXED),		\
+  X(3, (Q, D, S), MIXED),		\
+  X(3, (D, Q, S), MIXED),		\
+  X(4, (D, D, D, I), DOUBLE),		\
+  X(4, (Q, Q, Q, I), QUAD),		\
+  X(2, (F, F), SINGLE),			\
+  X(3, (F, F, F), SINGLE),		\
+  X(2, (F, I), SINGLE),			\
+  X(2, (F, D), MIXED),			\
+  X(2, (D, F), MIXED),			\
+  X(3, (F, F, I), MIXED),		\
+  X(4, (R, R, F, F), SINGLE),		\
+  X(4, (F, F, R, R), SINGLE),		\
+  X(3, (D, R, R), DOUBLE),		\
+  X(3, (R, R, D), DOUBLE),		\
+  X(2, (S, R), SINGLE),			\
+  X(2, (R, S), SINGLE),			\
+  X(2, (F, R), SINGLE),			\
+  X(2, (R, F), SINGLE)
+
+#define S2(A,B)		NS_##A##B
+#define S3(A,B,C)	NS_##A##B##C
+#define S4(A,B,C,D)	NS_##A##B##C##D
+
+#define X(N, L, C) S##N L
+
+enum neon_shape
+{
+  NEON_SHAPE_DEF,
+  NS_NULL
+};
+
+#undef X
+#undef S2
+#undef S3
+#undef S4
+
+enum neon_shape_class
+{
+  SC_SINGLE,
+  SC_DOUBLE,
+  SC_QUAD,
+  SC_MIXED
+};
+
+#define X(N, L, C) SC_##C
+
+static enum neon_shape_class neon_shape_class[] =
+{
+  NEON_SHAPE_DEF
+};
+
+#undef X
+
+enum neon_shape_el
+{
+  SE_F,
+  SE_D,
+  SE_Q,
+  SE_I,
+  SE_S,
+  SE_R,
+  SE_L
+};
+
+/* Register widths of above.  */
+static unsigned neon_shape_el_size[] =
+{
+  32,
+  64,
+  128,
+  0,
+  32,
+  32,
+  0
+};
+
+struct neon_shape_info
+{
+  unsigned els;
+  enum neon_shape_el el[NEON_MAX_TYPE_ELS];
+};
+
+#define S2(A,B)		{ SE_##A, SE_##B }
+#define S3(A,B,C)	{ SE_##A, SE_##B, SE_##C }
+#define S4(A,B,C,D)	{ SE_##A, SE_##B, SE_##C, SE_##D }
+
+#define X(N, L, C) { N, S##N L }
+
+static struct neon_shape_info neon_shape_tab[] =
+{
+  NEON_SHAPE_DEF
+};
+
+#undef X
+#undef S2
+#undef S3
+#undef S4
+
+/* Bit masks used in type checking given instructions.
+  'N_EQK' means the type must be the same as (or based on in some way) the key
+   type, which itself is marked with the 'N_KEY' bit. If the 'N_EQK' bit is
+   set, various other bits can be set as well in order to modify the meaning of
+   the type constraint.  */
+
+enum neon_type_mask
+{
+  N_S8   = 0x0000001,
+  N_S16  = 0x0000002,
+  N_S32  = 0x0000004,
+  N_S64  = 0x0000008,
+  N_U8   = 0x0000010,
+  N_U16  = 0x0000020,
+  N_U32  = 0x0000040,
+  N_U64  = 0x0000080,
+  N_I8   = 0x0000100,
+  N_I16  = 0x0000200,
+  N_I32  = 0x0000400,
+  N_I64  = 0x0000800,
+  N_8    = 0x0001000,
+  N_16   = 0x0002000,
+  N_32   = 0x0004000,
+  N_64   = 0x0008000,
+  N_P8   = 0x0010000,
+  N_P16  = 0x0020000,
+  N_F16  = 0x0040000,
+  N_F32  = 0x0080000,
+  N_F64  = 0x0100000,
+  N_P64	 = 0x0200000,
+  N_KEY  = 0x1000000, /* Key element (main type specifier).  */
+  N_EQK  = 0x2000000, /* Given operand has the same type & size as the key.  */
+  N_VFP  = 0x4000000, /* VFP mode: operand size must match register width.  */
+  N_UNT  = 0x8000000, /* Must be explicitly untyped.  */
+  N_DBL  = 0x0000001, /* If N_EQK, this operand is twice the size.  */
+  N_HLF  = 0x0000002, /* If N_EQK, this operand is half the size.  */
+  N_SGN  = 0x0000004, /* If N_EQK, this operand is forced to be signed.  */
+  N_UNS  = 0x0000008, /* If N_EQK, this operand is forced to be unsigned.  */
+  N_INT  = 0x0000010, /* If N_EQK, this operand is forced to be integer.  */
+  N_FLT  = 0x0000020, /* If N_EQK, this operand is forced to be float.  */
+  N_SIZ  = 0x0000040, /* If N_EQK, this operand is forced to be size-only.  */
+  N_UTYP = 0,
+  N_MAX_NONSPECIAL = N_P64
+};
+
+#define N_ALLMODS  (N_DBL | N_HLF | N_SGN | N_UNS | N_INT | N_FLT | N_SIZ)
+
+#define N_SU_ALL   (N_S8 | N_S16 | N_S32 | N_S64 | N_U8 | N_U16 | N_U32 | N_U64)
+#define N_SU_32    (N_S8 | N_S16 | N_S32 | N_U8 | N_U16 | N_U32)
+#define N_SU_16_64 (N_S16 | N_S32 | N_S64 | N_U16 | N_U32 | N_U64)
+#define N_SUF_32   (N_SU_32 | N_F32)
+#define N_I_ALL    (N_I8 | N_I16 | N_I32 | N_I64)
+#define N_IF_32    (N_I8 | N_I16 | N_I32 | N_F32)
+
+/* Pass this as the first type argument to neon_check_type to ignore types
+   altogether.  */
+#define N_IGNORE_TYPE (N_KEY | N_EQK)
+
+/* Select a "shape" for the current instruction (describing register types or
+   sizes) from a list of alternatives. Return NS_NULL if the current instruction
+   doesn't fit. For non-polymorphic shapes, checking is usually done as a
+   function of operand parsing, so this function doesn't need to be called.
+   Shapes should be listed in order of decreasing length.  */
+
+static enum neon_shape
+neon_select_shape (enum neon_shape shape, ...)
+{
+  va_list ap;
+  enum neon_shape first_shape = shape;
+
+  /* Fix missing optional operands. FIXME: we don't know at this point how
+     many arguments we should have, so this makes the assumption that we have
+     > 1. This is true of all current Neon opcodes, I think, but may not be
+     true in the future.  */
+  if (!inst.operands[1].present)
+    inst.operands[1] = inst.operands[0];
+
+  va_start (ap, shape);
+
+  for (; shape != NS_NULL; shape = (enum neon_shape) va_arg (ap, int))
+    {
+      unsigned j;
+      int matches = 1;
+
+      for (j = 0; j < neon_shape_tab[shape].els; j++)
+	{
+	  if (!inst.operands[j].present)
+	    {
+	      matches = 0;
+	      break;
+	    }
+
+	  switch (neon_shape_tab[shape].el[j])
+	    {
+	    case SE_F:
+	      if (!(inst.operands[j].isreg
+		    && inst.operands[j].isvec
+		    && inst.operands[j].issingle
+		    && !inst.operands[j].isquad))
+		matches = 0;
+	      break;
+
+	    case SE_D:
+	      if (!(inst.operands[j].isreg
+		    && inst.operands[j].isvec
+		    && !inst.operands[j].isquad
+		    && !inst.operands[j].issingle))
+		matches = 0;
+	      break;
+
+	    case SE_R:
+	      if (!(inst.operands[j].isreg
+		    && !inst.operands[j].isvec))
+		matches = 0;
+	      break;
+
+	    case SE_Q:
+	      if (!(inst.operands[j].isreg
+		    && inst.operands[j].isvec
+		    && inst.operands[j].isquad
+		    && !inst.operands[j].issingle))
+		matches = 0;
+	      break;
+
+	    case SE_I:
+	      if (!(!inst.operands[j].isreg
+		    && !inst.operands[j].isscalar))
+		matches = 0;
+	      break;
+
+	    case SE_S:
+	      if (!(!inst.operands[j].isreg
+		    && inst.operands[j].isscalar))
+		matches = 0;
+	      break;
+
+	    case SE_L:
+	      break;
+	    }
+	  if (!matches)
+	    break;
+	}
+      if (matches && (j >= ARM_IT_MAX_OPERANDS || !inst.operands[j].present))
+	/* We've matched all the entries in the shape table, and we don't
+	   have any left over operands which have not been matched.  */
+	break;
+    }
+
+  va_end (ap);
+
+  if (shape == NS_NULL && first_shape != NS_NULL)
+    first_error (_("invalid instruction shape"));
+
+  return shape;
+}
+
+/* True if SHAPE is predominantly a quadword operation (most of the time, this
+   means the Q bit should be set).  */
+
+static int
+neon_quad (enum neon_shape shape)
+{
+  return neon_shape_class[shape] == SC_QUAD;
+}
+
+static void
+neon_modify_type_size (unsigned typebits, enum neon_el_type *g_type,
+		       unsigned *g_size)
+{
+  /* Allow modification to be made to types which are constrained to be
+     based on the key element, based on bits set alongside N_EQK.  */
+  if ((typebits & N_EQK) != 0)
+    {
+      if ((typebits & N_HLF) != 0)
+	*g_size /= 2;
+      else if ((typebits & N_DBL) != 0)
+	*g_size *= 2;
+      if ((typebits & N_SGN) != 0)
+	*g_type = NT_signed;
+      else if ((typebits & N_UNS) != 0)
+	*g_type = NT_unsigned;
+      else if ((typebits & N_INT) != 0)
+	*g_type = NT_integer;
+      else if ((typebits & N_FLT) != 0)
+	*g_type = NT_float;
+      else if ((typebits & N_SIZ) != 0)
+	*g_type = NT_untyped;
+    }
+}
+
+/* Return operand OPNO promoted by bits set in THISARG. KEY should be the "key"
+   operand type, i.e. the single type specified in a Neon instruction when it
+   is the only one given.  */
+
+static struct neon_type_el
+neon_type_promote (struct neon_type_el *key, unsigned thisarg)
+{
+  struct neon_type_el dest = *key;
+
+  gas_assert ((thisarg & N_EQK) != 0);
+
+  neon_modify_type_size (thisarg, &dest.type, &dest.size);
+
+  return dest;
+}
+
+/* Convert Neon type and size into compact bitmask representation.  */
+
+static enum neon_type_mask
+type_chk_of_el_type (enum neon_el_type type, unsigned size)
+{
+  switch (type)
+    {
+    case NT_untyped:
+      switch (size)
+	{
+	case 8:  return N_8;
+	case 16: return N_16;
+	case 32: return N_32;
+	case 64: return N_64;
+	default: ;
+	}
+      break;
+
+    case NT_integer:
+      switch (size)
+	{
+	case 8:  return N_I8;
+	case 16: return N_I16;
+	case 32: return N_I32;
+	case 64: return N_I64;
+	default: ;
+	}
+      break;
+
+    case NT_float:
+      switch (size)
+	{
+	case 16: return N_F16;
+	case 32: return N_F32;
+	case 64: return N_F64;
+	default: ;
+	}
+      break;
+
+    case NT_poly:
+      switch (size)
+	{
+	case 8:  return N_P8;
+	case 16: return N_P16;
+	case 64: return N_P64;
+	default: ;
+	}
+      break;
+
+    case NT_signed:
+      switch (size)
+	{
+	case 8:  return N_S8;
+	case 16: return N_S16;
+	case 32: return N_S32;
+	case 64: return N_S64;
+	default: ;
+	}
+      break;
+
+    case NT_unsigned:
+      switch (size)
+	{
+	case 8:  return N_U8;
+	case 16: return N_U16;
+	case 32: return N_U32;
+	case 64: return N_U64;
+	default: ;
+	}
+      break;
+
+    default: ;
+    }
+
+  return N_UTYP;
+}
+
+/* Convert compact Neon bitmask type representation to a type and size. Only
+   handles the case where a single bit is set in the mask.  */
+
+static int
+el_type_of_type_chk (enum neon_el_type *type, unsigned *size,
+		     enum neon_type_mask mask)
+{
+  if ((mask & N_EQK) != 0)
+    return FAIL;
+
+  if ((mask & (N_S8 | N_U8 | N_I8 | N_8 | N_P8)) != 0)
+    *size = 8;
+  else if ((mask & (N_S16 | N_U16 | N_I16 | N_16 | N_F16 | N_P16)) != 0)
+    *size = 16;
+  else if ((mask & (N_S32 | N_U32 | N_I32 | N_32 | N_F32)) != 0)
+    *size = 32;
+  else if ((mask & (N_S64 | N_U64 | N_I64 | N_64 | N_F64 | N_P64)) != 0)
+    *size = 64;
+  else
+    return FAIL;
+
+  if ((mask & (N_S8 | N_S16 | N_S32 | N_S64)) != 0)
+    *type = NT_signed;
+  else if ((mask & (N_U8 | N_U16 | N_U32 | N_U64)) != 0)
+    *type = NT_unsigned;
+  else if ((mask & (N_I8 | N_I16 | N_I32 | N_I64)) != 0)
+    *type = NT_integer;
+  else if ((mask & (N_8 | N_16 | N_32 | N_64)) != 0)
+    *type = NT_untyped;
+  else if ((mask & (N_P8 | N_P16 | N_P64)) != 0)
+    *type = NT_poly;
+  else if ((mask & (N_F16 | N_F32 | N_F64)) != 0)
+    *type = NT_float;
+  else
+    return FAIL;
+
+  return SUCCESS;
+}
+
+/* Modify a bitmask of allowed types. This is only needed for type
+   relaxation.  */
+
+static unsigned
+modify_types_allowed (unsigned allowed, unsigned mods)
+{
+  unsigned size;
+  enum neon_el_type type;
+  unsigned destmask;
+  int i;
+
+  destmask = 0;
+
+  for (i = 1; i <= N_MAX_NONSPECIAL; i <<= 1)
+    {
+      if (el_type_of_type_chk (&type, &size,
+			       (enum neon_type_mask) (allowed & i)) == SUCCESS)
+	{
+	  neon_modify_type_size (mods, &type, &size);
+	  destmask |= type_chk_of_el_type (type, size);
+	}
+    }
+
+  return destmask;
+}
+
+/* Check type and return type classification.
+   The manual states (paraphrase): If one datatype is given, it indicates the
+   type given in:
+    - the second operand, if there is one
+    - the operand, if there is no second operand
+    - the result, if there are no operands.
+   This isn't quite good enough though, so we use a concept of a "key" datatype
+   which is set on a per-instruction basis, which is the one which matters when
+   only one data type is written.
+   Note: this function has side-effects (e.g. filling in missing operands). All
+   Neon instructions should call it before performing bit encoding.  */
+
+static struct neon_type_el
+neon_check_type (unsigned els, enum neon_shape ns, ...)
+{
+  va_list ap;
+  unsigned i, pass, key_el = 0;
+  unsigned types[NEON_MAX_TYPE_ELS];
+  enum neon_el_type k_type = NT_invtype;
+  unsigned k_size = -1u;
+  struct neon_type_el badtype = {NT_invtype, -1};
+  unsigned key_allowed = 0;
+
+  /* Optional registers in Neon instructions are always (not) in operand 1.
+     Fill in the missing operand here, if it was omitted.  */
+  if (els > 1 && !inst.operands[1].present)
+    inst.operands[1] = inst.operands[0];
+
+  /* Suck up all the varargs.  */
+  va_start (ap, ns);
+  for (i = 0; i < els; i++)
+    {
+      unsigned thisarg = va_arg (ap, unsigned);
+      if (thisarg == N_IGNORE_TYPE)
+	{
+	  va_end (ap);
+	  return badtype;
+	}
+      types[i] = thisarg;
+      if ((thisarg & N_KEY) != 0)
+	key_el = i;
+    }
+  va_end (ap);
+
+  if (inst.vectype.elems > 0)
+    for (i = 0; i < els; i++)
+      if (inst.operands[i].vectype.type != NT_invtype)
+	{
+	  first_error (_("types specified in both the mnemonic and operands"));
+	  return badtype;
+	}
+
+  /* Duplicate inst.vectype elements here as necessary.
+     FIXME: No idea if this is exactly the same as the ARM assembler,
+     particularly when an insn takes one register and one non-register
+     operand. */
+  if (inst.vectype.elems == 1 && els > 1)
+    {
+      unsigned j;
+      inst.vectype.elems = els;
+      inst.vectype.el[key_el] = inst.vectype.el[0];
+      for (j = 0; j < els; j++)
+	if (j != key_el)
+	  inst.vectype.el[j] = neon_type_promote (&inst.vectype.el[key_el],
+						  types[j]);
+    }
+  else if (inst.vectype.elems == 0 && els > 0)
+    {
+      unsigned j;
+      /* No types were given after the mnemonic, so look for types specified
+	 after each operand. We allow some flexibility here; as long as the
+	 "key" operand has a type, we can infer the others.  */
+      for (j = 0; j < els; j++)
+	if (inst.operands[j].vectype.type != NT_invtype)
+	  inst.vectype.el[j] = inst.operands[j].vectype;
+
+      if (inst.operands[key_el].vectype.type != NT_invtype)
+	{
+	  for (j = 0; j < els; j++)
+	    if (inst.operands[j].vectype.type == NT_invtype)
+	      inst.vectype.el[j] = neon_type_promote (&inst.vectype.el[key_el],
+						      types[j]);
+	}
+      else
+	{
+	  first_error (_("operand types can't be inferred"));
+	  return badtype;
+	}
+    }
+  else if (inst.vectype.elems != els)
+    {
+      first_error (_("type specifier has the wrong number of parts"));
+      return badtype;
+    }
+
+  for (pass = 0; pass < 2; pass++)
+    {
+      for (i = 0; i < els; i++)
+	{
+	  unsigned thisarg = types[i];
+	  unsigned types_allowed = ((thisarg & N_EQK) != 0 && pass != 0)
+	    ? modify_types_allowed (key_allowed, thisarg) : thisarg;
+	  enum neon_el_type g_type = inst.vectype.el[i].type;
+	  unsigned g_size = inst.vectype.el[i].size;
+
+	  /* Decay more-specific signed & unsigned types to sign-insensitive
+	     integer types if sign-specific variants are unavailable.  */
+	  if ((g_type == NT_signed || g_type == NT_unsigned)
+	      && (types_allowed & N_SU_ALL) == 0)
+	    g_type = NT_integer;
+
+	  /* If only untyped args are allowed, decay any more specific types to
+	     them. Some instructions only care about signs for some element
+	     sizes, so handle that properly.  */
+	  if (((types_allowed & N_UNT) == 0)
+	      && ((g_size == 8 && (types_allowed & N_8) != 0)
+		  || (g_size == 16 && (types_allowed & N_16) != 0)
+		  || (g_size == 32 && (types_allowed & N_32) != 0)
+		  || (g_size == 64 && (types_allowed & N_64) != 0)))
+	    g_type = NT_untyped;
+
+	  if (pass == 0)
+	    {
+	      if ((thisarg & N_KEY) != 0)
+		{
+		  k_type = g_type;
+		  k_size = g_size;
+		  key_allowed = thisarg & ~N_KEY;
+		}
+	    }
+	  else
+	    {
+	      if ((thisarg & N_VFP) != 0)
+		{
+		  enum neon_shape_el regshape;
+		  unsigned regwidth, match;
+
+		  /* PR 11136: Catch the case where we are passed a shape of NS_NULL.  */
+		  if (ns == NS_NULL)
+		    {
+		      first_error (_("invalid instruction shape"));
+		      return badtype;
+		    }
+		  regshape = neon_shape_tab[ns].el[i];
+		  regwidth = neon_shape_el_size[regshape];
+
+		  /* In VFP mode, operands must match register widths. If we
+		     have a key operand, use its width, else use the width of
+		     the current operand.  */
+		  if (k_size != -1u)
+		    match = k_size;
+		  else
+		    match = g_size;
+
+		  if (regwidth != match)
+		    {
+		      first_error (_("operand size must match register width"));
+		      return badtype;
+		    }
+		}
+
+	      if ((thisarg & N_EQK) == 0)
+		{
+		  unsigned given_type = type_chk_of_el_type (g_type, g_size);
+
+		  if ((given_type & types_allowed) == 0)
+		    {
+		      first_error (_("bad type in Neon instruction"));
+		      return badtype;
+		    }
+		}
+	      else
+		{
+		  enum neon_el_type mod_k_type = k_type;
+		  unsigned mod_k_size = k_size;
+		  neon_modify_type_size (thisarg, &mod_k_type, &mod_k_size);
+		  if (g_type != mod_k_type || g_size != mod_k_size)
+		    {
+		      first_error (_("inconsistent types in Neon instruction"));
+		      return badtype;
+		    }
+		}
+	    }
+	}
+    }
+
+  return inst.vectype.el[key_el];
+}
+
+/* Neon-style VFP instruction forwarding.  */
+
+/* Thumb VFP instructions have 0xE in the condition field.  */
+
+static void
+do_vfp_cond_or_thumb (void)
+{
+  inst.is_neon = 1;
+
+  if (thumb_mode)
+    inst.instruction |= 0xe0000000;
+  else
+    inst.instruction |= inst.cond << 28;
+}
+
+/* Look up and encode a simple mnemonic, for use as a helper function for the
+   Neon-style VFP syntax.  This avoids duplication of bits of the insns table,
+   etc.  It is assumed that operand parsing has already been done, and that the
+   operands are in the form expected by the given opcode (this isn't necessarily
+   the same as the form in which they were parsed, hence some massaging must
+   take place before this function is called).
+   Checks current arch version against that in the looked-up opcode.  */
+
+static void
+do_vfp_nsyn_opcode (const char *opname)
+{
+  const struct asm_opcode *opcode;
+
+  opcode = (const struct asm_opcode *) hash_find (arm_ops_hsh, opname);
+
+  if (!opcode)
+    abort ();
+
+  constraint (!ARM_CPU_HAS_FEATURE (cpu_variant,
+		thumb_mode ? *opcode->tvariant : *opcode->avariant),
+	      _(BAD_FPU));
+
+  inst.is_neon = 1;
+
+  if (thumb_mode)
+    {
+      inst.instruction = opcode->tvalue;
+      opcode->tencode ();
+    }
+  else
+    {
+      inst.instruction = (inst.cond << 28) | opcode->avalue;
+      opcode->aencode ();
+    }
+}
+
+static void
+do_vfp_nsyn_add_sub (enum neon_shape rs)
+{
+  int is_add = (inst.instruction & 0x0fffffff) == N_MNEM_vadd;
+
+  if (rs == NS_FFF)
+    {
+      if (is_add)
+	do_vfp_nsyn_opcode ("fadds");
+      else
+	do_vfp_nsyn_opcode ("fsubs");
+    }
+  else
+    {
+      if (is_add)
+	do_vfp_nsyn_opcode ("faddd");
+      else
+	do_vfp_nsyn_opcode ("fsubd");
+    }
+}
+
+/* Check operand types to see if this is a VFP instruction, and if so call
+   PFN ().  */
+
+static int
+try_vfp_nsyn (int args, void (*pfn) (enum neon_shape))
+{
+  enum neon_shape rs;
+  struct neon_type_el et;
+
+  switch (args)
+    {
+    case 2:
+      rs = neon_select_shape (NS_FF, NS_DD, NS_NULL);
+      et = neon_check_type (2, rs,
+	N_EQK | N_VFP, N_F32 | N_F64 | N_KEY | N_VFP);
+      break;
+
+    case 3:
+      rs = neon_select_shape (NS_FFF, NS_DDD, NS_NULL);
+      et = neon_check_type (3, rs,
+	N_EQK | N_VFP, N_EQK | N_VFP, N_F32 | N_F64 | N_KEY | N_VFP);
+      break;
+
+    default:
+      abort ();
+    }
+
+  if (et.type != NT_invtype)
+    {
+      pfn (rs);
+      return SUCCESS;
+    }
+
+  inst.error = NULL;
+  return FAIL;
+}
+
+static void
+do_vfp_nsyn_mla_mls (enum neon_shape rs)
+{
+  int is_mla = (inst.instruction & 0x0fffffff) == N_MNEM_vmla;
+
+  if (rs == NS_FFF)
+    {
+      if (is_mla)
+	do_vfp_nsyn_opcode ("fmacs");
+      else
+	do_vfp_nsyn_opcode ("fnmacs");
+    }
+  else
+    {
+      if (is_mla)
+	do_vfp_nsyn_opcode ("fmacd");
+      else
+	do_vfp_nsyn_opcode ("fnmacd");
+    }
+}
+
+static void
+do_vfp_nsyn_fma_fms (enum neon_shape rs)
+{
+  int is_fma = (inst.instruction & 0x0fffffff) == N_MNEM_vfma;
+
+  if (rs == NS_FFF)
+    {
+      if (is_fma)
+	do_vfp_nsyn_opcode ("ffmas");
+      else
+	do_vfp_nsyn_opcode ("ffnmas");
+    }
+  else
+    {
+      if (is_fma)
+	do_vfp_nsyn_opcode ("ffmad");
+      else
+	do_vfp_nsyn_opcode ("ffnmad");
+    }
+}
+
+static void
+do_vfp_nsyn_mul (enum neon_shape rs)
+{
+  if (rs == NS_FFF)
+    do_vfp_nsyn_opcode ("fmuls");
+  else
+    do_vfp_nsyn_opcode ("fmuld");
+}
+
+static void
+do_vfp_nsyn_abs_neg (enum neon_shape rs)
+{
+  int is_neg = (inst.instruction & 0x80) != 0;
+  neon_check_type (2, rs, N_EQK | N_VFP, N_F32 | N_F64 | N_VFP | N_KEY);
+
+  if (rs == NS_FF)
+    {
+      if (is_neg)
+	do_vfp_nsyn_opcode ("fnegs");
+      else
+	do_vfp_nsyn_opcode ("fabss");
+    }
+  else
+    {
+      if (is_neg)
+	do_vfp_nsyn_opcode ("fnegd");
+      else
+	do_vfp_nsyn_opcode ("fabsd");
+    }
+}
+
+/* Encode single-precision (only!) VFP fldm/fstm instructions. Double precision
+   insns belong to Neon, and are handled elsewhere.  */
+
+static void
+do_vfp_nsyn_ldm_stm (int is_dbmode)
+{
+  int is_ldm = (inst.instruction & (1 << 20)) != 0;
+  if (is_ldm)
+    {
+      if (is_dbmode)
+	do_vfp_nsyn_opcode ("fldmdbs");
+      else
+	do_vfp_nsyn_opcode ("fldmias");
+    }
+  else
+    {
+      if (is_dbmode)
+	do_vfp_nsyn_opcode ("fstmdbs");
+      else
+	do_vfp_nsyn_opcode ("fstmias");
+    }
+}
+
+static void
+do_vfp_nsyn_sqrt (void)
+{
+  enum neon_shape rs = neon_select_shape (NS_FF, NS_DD, NS_NULL);
+  neon_check_type (2, rs, N_EQK | N_VFP, N_F32 | N_F64 | N_KEY | N_VFP);
+
+  if (rs == NS_FF)
+    do_vfp_nsyn_opcode ("fsqrts");
+  else
+    do_vfp_nsyn_opcode ("fsqrtd");
+}
+
+static void
+do_vfp_nsyn_div (void)
+{
+  enum neon_shape rs = neon_select_shape (NS_FFF, NS_DDD, NS_NULL);
+  neon_check_type (3, rs, N_EQK | N_VFP, N_EQK | N_VFP,
+    N_F32 | N_F64 | N_KEY | N_VFP);
+
+  if (rs == NS_FFF)
+    do_vfp_nsyn_opcode ("fdivs");
+  else
+    do_vfp_nsyn_opcode ("fdivd");
+}
+
+static void
+do_vfp_nsyn_nmul (void)
+{
+  enum neon_shape rs = neon_select_shape (NS_FFF, NS_DDD, NS_NULL);
+  neon_check_type (3, rs, N_EQK | N_VFP, N_EQK | N_VFP,
+    N_F32 | N_F64 | N_KEY | N_VFP);
+
+  if (rs == NS_FFF)
+    {
+      NEON_ENCODE (SINGLE, inst);
+      do_vfp_sp_dyadic ();
+    }
+  else
+    {
+      NEON_ENCODE (DOUBLE, inst);
+      do_vfp_dp_rd_rn_rm ();
+    }
+  do_vfp_cond_or_thumb ();
+}
+
+static void
+do_vfp_nsyn_cmp (void)
+{
+  if (inst.operands[1].isreg)
+    {
+      enum neon_shape rs = neon_select_shape (NS_FF, NS_DD, NS_NULL);
+      neon_check_type (2, rs, N_EQK | N_VFP, N_F32 | N_F64 | N_KEY | N_VFP);
+
+      if (rs == NS_FF)
+	{
+	  NEON_ENCODE (SINGLE, inst);
+	  do_vfp_sp_monadic ();
+	}
+      else
+	{
+	  NEON_ENCODE (DOUBLE, inst);
+	  do_vfp_dp_rd_rm ();
+	}
+    }
+  else
+    {
+      enum neon_shape rs = neon_select_shape (NS_FI, NS_DI, NS_NULL);
+      neon_check_type (2, rs, N_F32 | N_F64 | N_KEY | N_VFP, N_EQK);
+
+      switch (inst.instruction & 0x0fffffff)
+	{
+	case N_MNEM_vcmp:
+	  inst.instruction += N_MNEM_vcmpz - N_MNEM_vcmp;
+	  break;
+	case N_MNEM_vcmpe:
+	  inst.instruction += N_MNEM_vcmpez - N_MNEM_vcmpe;
+	  break;
+	default:
+	  abort ();
+	}
+
+      if (rs == NS_FI)
+	{
+	  NEON_ENCODE (SINGLE, inst);
+	  do_vfp_sp_compare_z ();
+	}
+      else
+	{
+	  NEON_ENCODE (DOUBLE, inst);
+	  do_vfp_dp_rd ();
+	}
+    }
+  do_vfp_cond_or_thumb ();
+}
+
+static void
+nsyn_insert_sp (void)
+{
+  inst.operands[1] = inst.operands[0];
+  memset (&inst.operands[0], '\0', sizeof (inst.operands[0]));
+  inst.operands[0].reg = REG_SP;
+  inst.operands[0].isreg = 1;
+  inst.operands[0].writeback = 1;
+  inst.operands[0].present = 1;
+}
+
+static void
+do_vfp_nsyn_push (void)
+{
+  nsyn_insert_sp ();
+  if (inst.operands[1].issingle)
+    do_vfp_nsyn_opcode ("fstmdbs");
+  else
+    do_vfp_nsyn_opcode ("fstmdbd");
+}
+
+static void
+do_vfp_nsyn_pop (void)
+{
+  nsyn_insert_sp ();
+  if (inst.operands[1].issingle)
+    do_vfp_nsyn_opcode ("fldmias");
+  else
+    do_vfp_nsyn_opcode ("fldmiad");
+}
+
+/* Fix up Neon data-processing instructions, ORing in the correct bits for
+   ARM mode or Thumb mode and moving the encoded bit 24 to bit 28.  */
+
+static void
+neon_dp_fixup (struct arm_it* insn)
+{
+  unsigned int i = insn->instruction;
+  insn->is_neon = 1;
+
+  if (thumb_mode)
+    {
+      /* The U bit is at bit 24 by default. Move to bit 28 in Thumb mode.  */
+      if (i & (1 << 24))
+	i |= 1 << 28;
+
+      i &= ~(1 << 24);
+
+      i |= 0xef000000;
+    }
+  else
+    i |= 0xf2000000;
+
+  insn->instruction = i;
+}
+
+/* Turn a size (8, 16, 32, 64) into the respective bit number minus 3
+   (0, 1, 2, 3).  */
+
+static unsigned
+neon_logbits (unsigned x)
+{
+  return ffs (x) - 4;
+}
+
+#define LOW4(R) ((R) & 0xf)
+#define HI1(R) (((R) >> 4) & 1)
+
+/* Encode insns with bit pattern:
+
+  |28/24|23|22 |21 20|19 16|15 12|11    8|7|6|5|4|3  0|
+  |  U  |x |D  |size | Rn  | Rd  |x x x x|N|Q|M|x| Rm |
+
+  SIZE is passed in bits. -1 means size field isn't changed, in case it has a
+  different meaning for some instruction.  */
+
+static void
+neon_three_same (int isquad, int ubit, int size)
+{
+  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
+  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
+  inst.instruction |= LOW4 (inst.operands[1].reg) << 16;
+  inst.instruction |= HI1 (inst.operands[1].reg) << 7;
+  inst.instruction |= LOW4 (inst.operands[2].reg);
+  inst.instruction |= HI1 (inst.operands[2].reg) << 5;
+  inst.instruction |= (isquad != 0) << 6;
+  inst.instruction |= (ubit != 0) << 24;
+  if (size != -1)
+    inst.instruction |= neon_logbits (size) << 20;
+
+  neon_dp_fixup (&inst);
+}
+
+/* Encode instructions of the form:
+
+  |28/24|23|22|21 20|19 18|17 16|15 12|11      7|6|5|4|3  0|
+  |  U  |x |D |x  x |size |x  x | Rd  |x x x x x|Q|M|x| Rm |
+
+  Don't write size if SIZE == -1.  */
+
+static void
+neon_two_same (int qbit, int ubit, int size)
+{
+  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
+  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
+  inst.instruction |= LOW4 (inst.operands[1].reg);
+  inst.instruction |= HI1 (inst.operands[1].reg) << 5;
+  inst.instruction |= (qbit != 0) << 6;
+  inst.instruction |= (ubit != 0) << 24;
+
+  if (size != -1)
+    inst.instruction |= neon_logbits (size) << 18;
+
+  neon_dp_fixup (&inst);
+}
+
+/* Neon instruction encoders, in approximate order of appearance.  */
+
+static void
+do_neon_dyadic_i_su (void)
+{
+  enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
+  struct neon_type_el et = neon_check_type (3, rs,
+    N_EQK, N_EQK, N_SU_32 | N_KEY);
+  neon_three_same (neon_quad (rs), et.type == NT_unsigned, et.size);
+}
+
+static void
+do_neon_dyadic_i64_su (void)
+{
+  enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
+  struct neon_type_el et = neon_check_type (3, rs,
+    N_EQK, N_EQK, N_SU_ALL | N_KEY);
+  neon_three_same (neon_quad (rs), et.type == NT_unsigned, et.size);
+}
+
+static void
+neon_imm_shift (int write_ubit, int uval, int isquad, struct neon_type_el et,
+		unsigned immbits)
+{
+  unsigned size = et.size >> 3;
+  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
+  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
+  inst.instruction |= LOW4 (inst.operands[1].reg);
+  inst.instruction |= HI1 (inst.operands[1].reg) << 5;
+  inst.instruction |= (isquad != 0) << 6;
+  inst.instruction |= immbits << 16;
+  inst.instruction |= (size >> 3) << 7;
+  inst.instruction |= (size & 0x7) << 19;
+  if (write_ubit)
+    inst.instruction |= (uval != 0) << 24;
+
+  neon_dp_fixup (&inst);
+}
+
+static void
+do_neon_shl_imm (void)
+{
+  if (!inst.operands[2].isreg)
+    {
+      enum neon_shape rs = neon_select_shape (NS_DDI, NS_QQI, NS_NULL);
+      struct neon_type_el et = neon_check_type (2, rs, N_EQK, N_KEY | N_I_ALL);
+      int imm = inst.operands[2].imm;
+
+      constraint (imm < 0 || (unsigned)imm >= et.size,
+		  _("immediate out of range for shift"));
+      NEON_ENCODE (IMMED, inst);
+      neon_imm_shift (FALSE, 0, neon_quad (rs), et, imm);
+    }
+  else
+    {
+      enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
+      struct neon_type_el et = neon_check_type (3, rs,
+	N_EQK, N_SU_ALL | N_KEY, N_EQK | N_SGN);
+      unsigned int tmp;
+
+      /* VSHL/VQSHL 3-register variants have syntax such as:
+	   vshl.xx Dd, Dm, Dn
+	 whereas other 3-register operations encoded by neon_three_same have
+	 syntax like:
+	   vadd.xx Dd, Dn, Dm
+	 (i.e. with Dn & Dm reversed). Swap operands[1].reg and operands[2].reg
+	 here.  */
+      tmp = inst.operands[2].reg;
+      inst.operands[2].reg = inst.operands[1].reg;
+      inst.operands[1].reg = tmp;
+      NEON_ENCODE (INTEGER, inst);
+      neon_three_same (neon_quad (rs), et.type == NT_unsigned, et.size);
+    }
+}
+
+static void
+do_neon_qshl_imm (void)
+{
+  if (!inst.operands[2].isreg)
+    {
+      enum neon_shape rs = neon_select_shape (NS_DDI, NS_QQI, NS_NULL);
+      struct neon_type_el et = neon_check_type (2, rs, N_EQK, N_SU_ALL | N_KEY);
+      int imm = inst.operands[2].imm;
+
+      constraint (imm < 0 || (unsigned)imm >= et.size,
+		  _("immediate out of range for shift"));
+      NEON_ENCODE (IMMED, inst);
+      neon_imm_shift (TRUE, et.type == NT_unsigned, neon_quad (rs), et, imm);
+    }
+  else
+    {
+      enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
+      struct neon_type_el et = neon_check_type (3, rs,
+	N_EQK, N_SU_ALL | N_KEY, N_EQK | N_SGN);
+      unsigned int tmp;
+
+      /* See note in do_neon_shl_imm.  */
+      tmp = inst.operands[2].reg;
+      inst.operands[2].reg = inst.operands[1].reg;
+      inst.operands[1].reg = tmp;
+      NEON_ENCODE (INTEGER, inst);
+      neon_three_same (neon_quad (rs), et.type == NT_unsigned, et.size);
+    }
+}
+
+static void
+do_neon_rshl (void)
+{
+  enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
+  struct neon_type_el et = neon_check_type (3, rs,
+    N_EQK, N_EQK, N_SU_ALL | N_KEY);
+  unsigned int tmp;
+
+  tmp = inst.operands[2].reg;
+  inst.operands[2].reg = inst.operands[1].reg;
+  inst.operands[1].reg = tmp;
+  neon_three_same (neon_quad (rs), et.type == NT_unsigned, et.size);
+}
+
+static int
+neon_cmode_for_logic_imm (unsigned immediate, unsigned *immbits, int size)
+{
+  /* Handle .I8 pseudo-instructions.  */
+  if (size == 8)
+    {
+      /* Unfortunately, this will make everything apart from zero out-of-range.
+	 FIXME is this the intended semantics? There doesn't seem much point in
+	 accepting .I8 if so.  */
+      immediate |= immediate << 8;
+      size = 16;
+    }
+
+  if (size >= 32)
+    {
+      if (immediate == (immediate & 0x000000ff))
+	{
+	  *immbits = immediate;
+	  return 0x1;
+	}
+      else if (immediate == (immediate & 0x0000ff00))
+	{
+	  *immbits = immediate >> 8;
+	  return 0x3;
+	}
+      else if (immediate == (immediate & 0x00ff0000))
+	{
+	  *immbits = immediate >> 16;
+	  return 0x5;
+	}
+      else if (immediate == (immediate & 0xff000000))
+	{
+	  *immbits = immediate >> 24;
+	  return 0x7;
+	}
+      if ((immediate & 0xffff) != (immediate >> 16))
+	goto bad_immediate;
+      immediate &= 0xffff;
+    }
+
+  if (immediate == (immediate & 0x000000ff))
+    {
+      *immbits = immediate;
+      return 0x9;
+    }
+  else if (immediate == (immediate & 0x0000ff00))
+    {
+      *immbits = immediate >> 8;
+      return 0xb;
+    }
+
+  bad_immediate:
+  first_error (_("immediate value out of range"));
+  return FAIL;
+}
+
+static void
+do_neon_logic (void)
+{
+  if (inst.operands[2].present && inst.operands[2].isreg)
+    {
+      enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
+      neon_check_type (3, rs, N_IGNORE_TYPE);
+      /* U bit and size field were set as part of the bitmask.  */
+      NEON_ENCODE (INTEGER, inst);
+      neon_three_same (neon_quad (rs), 0, -1);
+    }
+  else
+    {
+      const int three_ops_form = (inst.operands[2].present
+				  && !inst.operands[2].isreg);
+      const int immoperand = (three_ops_form ? 2 : 1);
+      enum neon_shape rs = (three_ops_form
+			    ? neon_select_shape (NS_DDI, NS_QQI, NS_NULL)
+			    : neon_select_shape (NS_DI, NS_QI, NS_NULL));
+      struct neon_type_el et = neon_check_type (2, rs,
+	N_I8 | N_I16 | N_I32 | N_I64 | N_F32 | N_KEY, N_EQK);
+      enum neon_opc opcode = (enum neon_opc) inst.instruction & 0x0fffffff;
+      unsigned immbits;
+      int cmode;
+
+      if (et.type == NT_invtype)
+	return;
+
+      if (three_ops_form)
+	constraint (inst.operands[0].reg != inst.operands[1].reg,
+		    _("first and second operands shall be the same register"));
+
+      NEON_ENCODE (IMMED, inst);
+
+      immbits = inst.operands[immoperand].imm;
+      if (et.size == 64)
+	{
+	  /* .i64 is a pseudo-op, so the immediate must be a repeating
+	     pattern.  */
+	  if (immbits != (inst.operands[immoperand].regisimm ?
+			  inst.operands[immoperand].reg : 0))
+	    {
+	      /* Set immbits to an invalid constant.  */
+	      immbits = 0xdeadbeef;
+	    }
+	}
+
+      switch (opcode)
+	{
+	case N_MNEM_vbic:
+	  cmode = neon_cmode_for_logic_imm (immbits, &immbits, et.size);
+	  break;
+
+	case N_MNEM_vorr:
+	  cmode = neon_cmode_for_logic_imm (immbits, &immbits, et.size);
+	  break;
+
+	case N_MNEM_vand:
+	  /* Pseudo-instruction for VBIC.  */
+	  neon_invert_size (&immbits, 0, et.size);
+	  cmode = neon_cmode_for_logic_imm (immbits, &immbits, et.size);
+	  break;
+
+	case N_MNEM_vorn:
+	  /* Pseudo-instruction for VORR.  */
+	  neon_invert_size (&immbits, 0, et.size);
+	  cmode = neon_cmode_for_logic_imm (immbits, &immbits, et.size);
+	  break;
+
+	default:
+	  abort ();
+	}
+
+      if (cmode == FAIL)
+	return;
+
+      inst.instruction |= neon_quad (rs) << 6;
+      inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
+      inst.instruction |= HI1 (inst.operands[0].reg) << 22;
+      inst.instruction |= cmode << 8;
+      neon_write_immbits (immbits);
+
+      neon_dp_fixup (&inst);
+    }
+}
+
+static void
+do_neon_bitfield (void)
+{
+  enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
+  neon_check_type (3, rs, N_IGNORE_TYPE);
+  neon_three_same (neon_quad (rs), 0, -1);
+}
+
+static void
+neon_dyadic_misc (enum neon_el_type ubit_meaning, unsigned types,
+		  unsigned destbits)
+{
+  enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
+  struct neon_type_el et = neon_check_type (3, rs, N_EQK | destbits, N_EQK,
+					    types | N_KEY);
+  if (et.type == NT_float)
+    {
+      NEON_ENCODE (FLOAT, inst);
+      neon_three_same (neon_quad (rs), 0, -1);
+    }
+  else
+    {
+      NEON_ENCODE (INTEGER, inst);
+      neon_three_same (neon_quad (rs), et.type == ubit_meaning, et.size);
+    }
+}
+
+static void
+do_neon_dyadic_if_su (void)
+{
+  neon_dyadic_misc (NT_unsigned, N_SUF_32, 0);
+}
+
+static void
+do_neon_dyadic_if_su_d (void)
+{
+  /* This version only allow D registers, but that constraint is enforced during
+     operand parsing so we don't need to do anything extra here.  */
+  neon_dyadic_misc (NT_unsigned, N_SUF_32, 0);
+}
+
+static void
+do_neon_dyadic_if_i_d (void)
+{
+  /* The "untyped" case can't happen. Do this to stop the "U" bit being
+     affected if we specify unsigned args.  */
+  neon_dyadic_misc (NT_untyped, N_IF_32, 0);
+}
+
+enum vfp_or_neon_is_neon_bits
+{
+  NEON_CHECK_CC = 1,
+  NEON_CHECK_ARCH = 2,
+  NEON_CHECK_ARCH8 = 4
+};
+
+/* Call this function if an instruction which may have belonged to the VFP or
+   Neon instruction sets, but turned out to be a Neon instruction (due to the
+   operand types involved, etc.). We have to check and/or fix-up a couple of
+   things:
+
+     - Make sure the user hasn't attempted to make a Neon instruction
+       conditional.
+     - Alter the value in the condition code field if necessary.
+     - Make sure that the arch supports Neon instructions.
+
+   Which of these operations take place depends on bits from enum
+   vfp_or_neon_is_neon_bits.
+
+   WARNING: This function has side effects! If NEON_CHECK_CC is used and the
+   current instruction's condition is COND_ALWAYS, the condition field is
+   changed to inst.uncond_value. This is necessary because instructions shared
+   between VFP and Neon may be conditional for the VFP variants only, and the
+   unconditional Neon version must have, e.g., 0xF in the condition field.  */
+
+static int
+vfp_or_neon_is_neon (unsigned check)
+{
+  /* Conditions are always legal in Thumb mode (IT blocks).  */
+  if (!thumb_mode && (check & NEON_CHECK_CC))
+    {
+      if (inst.cond != COND_ALWAYS)
+	{
+	  first_error (_(BAD_COND));
+	  return FAIL;
+	}
+      if (inst.uncond_value != -1)
+	inst.instruction |= inst.uncond_value << 28;
+    }
+
+  if ((check & NEON_CHECK_ARCH)
+      && !mark_feature_used (&fpu_neon_ext_v1))
+    {
+      first_error (_(BAD_FPU));
+      return FAIL;
+    }
+
+  if ((check & NEON_CHECK_ARCH8)
+      && !mark_feature_used (&fpu_neon_ext_armv8))
+    {
+      first_error (_(BAD_FPU));
+      return FAIL;
+    }
+
+  return SUCCESS;
+}
+
+static void
+do_neon_addsub_if_i (void)
+{
+  if (try_vfp_nsyn (3, do_vfp_nsyn_add_sub) == SUCCESS)
+    return;
+
+  if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)
+    return;
+
+  /* The "untyped" case can't happen. Do this to stop the "U" bit being
+     affected if we specify unsigned args.  */
+  neon_dyadic_misc (NT_untyped, N_IF_32 | N_I64, 0);
+}
+
+/* Swaps operands 1 and 2. If operand 1 (optional arg) was omitted, we want the
+   result to be:
+     V<op> A,B     (A is operand 0, B is operand 2)
+   to mean:
+     V<op> A,B,A
+   not:
+     V<op> A,B,B
+   so handle that case specially.  */
+
+static void
+neon_exchange_operands (void)
+{
+  void *scratch = alloca (sizeof (inst.operands[0]));
+  if (inst.operands[1].present)
+    {
+      /* Swap operands[1] and operands[2].  */
+      memcpy (scratch, &inst.operands[1], sizeof (inst.operands[0]));
+      inst.operands[1] = inst.operands[2];
+      memcpy (&inst.operands[2], scratch, sizeof (inst.operands[0]));
+    }
+  else
+    {
+      inst.operands[1] = inst.operands[2];
+      inst.operands[2] = inst.operands[0];
+    }
+}
+
+static void
+neon_compare (unsigned regtypes, unsigned immtypes, int invert)
+{
+  if (inst.operands[2].isreg)
+    {
+      if (invert)
+	neon_exchange_operands ();
+      neon_dyadic_misc (NT_unsigned, regtypes, N_SIZ);
+    }
+  else
+    {
+      enum neon_shape rs = neon_select_shape (NS_DDI, NS_QQI, NS_NULL);
+      struct neon_type_el et = neon_check_type (2, rs,
+	N_EQK | N_SIZ, immtypes | N_KEY);
+
+      NEON_ENCODE (IMMED, inst);
+      inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
+      inst.instruction |= HI1 (inst.operands[0].reg) << 22;
+      inst.instruction |= LOW4 (inst.operands[1].reg);
+      inst.instruction |= HI1 (inst.operands[1].reg) << 5;
+      inst.instruction |= neon_quad (rs) << 6;
+      inst.instruction |= (et.type == NT_float) << 10;
+      inst.instruction |= neon_logbits (et.size) << 18;
+
+      neon_dp_fixup (&inst);
+    }
+}
+
+static void
+do_neon_cmp (void)
+{
+  neon_compare (N_SUF_32, N_S8 | N_S16 | N_S32 | N_F32, FALSE);
+}
+
+static void
+do_neon_cmp_inv (void)
+{
+  neon_compare (N_SUF_32, N_S8 | N_S16 | N_S32 | N_F32, TRUE);
+}
+
+static void
+do_neon_ceq (void)
+{
+  neon_compare (N_IF_32, N_IF_32, FALSE);
+}
+
+/* For multiply instructions, we have the possibility of 16-bit or 32-bit
+   scalars, which are encoded in 5 bits, M : Rm.
+   For 16-bit scalars, the register is encoded in Rm[2:0] and the index in
+   M:Rm[3], and for 32-bit scalars, the register is encoded in Rm[3:0] and the
+   index in M.  */
+
+static unsigned
+neon_scalar_for_mul (unsigned scalar, unsigned elsize)
+{
+  unsigned regno = NEON_SCALAR_REG (scalar);
+  unsigned elno = NEON_SCALAR_INDEX (scalar);
+
+  switch (elsize)
+    {
+    case 16:
+      if (regno > 7 || elno > 3)
+	goto bad_scalar;
+      return regno | (elno << 3);
+
+    case 32:
+      if (regno > 15 || elno > 1)
+	goto bad_scalar;
+      return regno | (elno << 4);
+
+    default:
+    bad_scalar:
+      first_error (_("scalar out of range for multiply instruction"));
+    }
+
+  return 0;
+}
+
+/* Encode multiply / multiply-accumulate scalar instructions.  */
+
+static void
+neon_mul_mac (struct neon_type_el et, int ubit)
+{
+  unsigned scalar;
+
+  /* Give a more helpful error message if we have an invalid type.  */
+  if (et.type == NT_invtype)
+    return;
+
+  scalar = neon_scalar_for_mul (inst.operands[2].reg, et.size);
+  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
+  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
+  inst.instruction |= LOW4 (inst.operands[1].reg) << 16;
+  inst.instruction |= HI1 (inst.operands[1].reg) << 7;
+  inst.instruction |= LOW4 (scalar);
+  inst.instruction |= HI1 (scalar) << 5;
+  inst.instruction |= (et.type == NT_float) << 8;
+  inst.instruction |= neon_logbits (et.size) << 20;
+  inst.instruction |= (ubit != 0) << 24;
+
+  neon_dp_fixup (&inst);
+}
+
+static void
+do_neon_mac_maybe_scalar (void)
+{
+  if (try_vfp_nsyn (3, do_vfp_nsyn_mla_mls) == SUCCESS)
+    return;
+
+  if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)
+    return;
+
+  if (inst.operands[2].isscalar)
+    {
+      enum neon_shape rs = neon_select_shape (NS_DDS, NS_QQS, NS_NULL);
+      struct neon_type_el et = neon_check_type (3, rs,
+	N_EQK, N_EQK, N_I16 | N_I32 | N_F32 | N_KEY);
+      NEON_ENCODE (SCALAR, inst);
+      neon_mul_mac (et, neon_quad (rs));
+    }
+  else
+    {
+      /* The "untyped" case can't happen.  Do this to stop the "U" bit being
+	 affected if we specify unsigned args.  */
+      neon_dyadic_misc (NT_untyped, N_IF_32, 0);
+    }
+}
+
+static void
+do_neon_fmac (void)
+{
+  if (try_vfp_nsyn (3, do_vfp_nsyn_fma_fms) == SUCCESS)
+    return;
+
+  if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)
+    return;
+
+  neon_dyadic_misc (NT_untyped, N_IF_32, 0);
+}
+
+static void
+do_neon_tst (void)
+{
+  enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
+  struct neon_type_el et = neon_check_type (3, rs,
+    N_EQK, N_EQK, N_8 | N_16 | N_32 | N_KEY);
+  neon_three_same (neon_quad (rs), 0, et.size);
+}
+
+/* VMUL with 3 registers allows the P8 type. The scalar version supports the
+   same types as the MAC equivalents. The polynomial type for this instruction
+   is encoded the same as the integer type.  */
+
+static void
+do_neon_mul (void)
+{
+  if (try_vfp_nsyn (3, do_vfp_nsyn_mul) == SUCCESS)
+    return;
+
+  if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)
+    return;
+
+  if (inst.operands[2].isscalar)
+    do_neon_mac_maybe_scalar ();
+  else
+    neon_dyadic_misc (NT_poly, N_I8 | N_I16 | N_I32 | N_F32 | N_P8, 0);
+}
+
+static void
+do_neon_qdmulh (void)
+{
+  if (inst.operands[2].isscalar)
+    {
+      enum neon_shape rs = neon_select_shape (NS_DDS, NS_QQS, NS_NULL);
+      struct neon_type_el et = neon_check_type (3, rs,
+	N_EQK, N_EQK, N_S16 | N_S32 | N_KEY);
+      NEON_ENCODE (SCALAR, inst);
+      neon_mul_mac (et, neon_quad (rs));
+    }
+  else
+    {
+      enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
+      struct neon_type_el et = neon_check_type (3, rs,
+	N_EQK, N_EQK, N_S16 | N_S32 | N_KEY);
+      NEON_ENCODE (INTEGER, inst);
+      /* The U bit (rounding) comes from bit mask.  */
+      neon_three_same (neon_quad (rs), 0, et.size);
+    }
+}
+
+static void
+do_neon_fcmp_absolute (void)
+{
+  enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
+  neon_check_type (3, rs, N_EQK, N_EQK, N_F32 | N_KEY);
+  /* Size field comes from bit mask.  */
+  neon_three_same (neon_quad (rs), 1, -1);
+}
+
+static void
+do_neon_fcmp_absolute_inv (void)
+{
+  neon_exchange_operands ();
+  do_neon_fcmp_absolute ();
+}
+
+static void
+do_neon_step (void)
+{
+  enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);
+  neon_check_type (3, rs, N_EQK, N_EQK, N_F32 | N_KEY);
+  neon_three_same (neon_quad (rs), 0, -1);
+}
+
+static void
+do_neon_abs_neg (void)
+{
+  enum neon_shape rs;
+  struct neon_type_el et;
+
+  if (try_vfp_nsyn (2, do_vfp_nsyn_abs_neg) == SUCCESS)
+    return;
+
+  if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)
+    return;
+
+  rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
+  et = neon_check_type (2, rs, N_EQK, N_S8 | N_S16 | N_S32 | N_F32 | N_KEY);
+
+  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
+  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
+  inst.instruction |= LOW4 (inst.operands[1].reg);
+  inst.instruction |= HI1 (inst.operands[1].reg) << 5;
+  inst.instruction |= neon_quad (rs) << 6;
+  inst.instruction |= (et.type == NT_float) << 10;
+  inst.instruction |= neon_logbits (et.size) << 18;
+
+  neon_dp_fixup (&inst);
+}
+
+static void
+do_neon_sli (void)
+{
+  enum neon_shape rs = neon_select_shape (NS_DDI, NS_QQI, NS_NULL);
+  struct neon_type_el et = neon_check_type (2, rs,
+    N_EQK, N_8 | N_16 | N_32 | N_64 | N_KEY);
+  int imm = inst.operands[2].imm;
+  constraint (imm < 0 || (unsigned)imm >= et.size,
+	      _("immediate out of range for insert"));
+  neon_imm_shift (FALSE, 0, neon_quad (rs), et, imm);
+}
+
+static void
+do_neon_sri (void)
+{
+  enum neon_shape rs = neon_select_shape (NS_DDI, NS_QQI, NS_NULL);
+  struct neon_type_el et = neon_check_type (2, rs,
+    N_EQK, N_8 | N_16 | N_32 | N_64 | N_KEY);
+  int imm = inst.operands[2].imm;
+  constraint (imm < 1 || (unsigned)imm > et.size,
+	      _("immediate out of range for insert"));
+  neon_imm_shift (FALSE, 0, neon_quad (rs), et, et.size - imm);
+}
+
+static void
+do_neon_qshlu_imm (void)
+{
+  enum neon_shape rs = neon_select_shape (NS_DDI, NS_QQI, NS_NULL);
+  struct neon_type_el et = neon_check_type (2, rs,
+    N_EQK | N_UNS, N_S8 | N_S16 | N_S32 | N_S64 | N_KEY);
+  int imm = inst.operands[2].imm;
+  constraint (imm < 0 || (unsigned)imm >= et.size,
+	      _("immediate out of range for shift"));
+  /* Only encodes the 'U present' variant of the instruction.
+     In this case, signed types have OP (bit 8) set to 0.
+     Unsigned types have OP set to 1.  */
+  inst.instruction |= (et.type == NT_unsigned) << 8;
+  /* The rest of the bits are the same as other immediate shifts.  */
+  neon_imm_shift (FALSE, 0, neon_quad (rs), et, imm);
+}
+
+static void
+do_neon_qmovn (void)
+{
+  struct neon_type_el et = neon_check_type (2, NS_DQ,
+    N_EQK | N_HLF, N_SU_16_64 | N_KEY);
+  /* Saturating move where operands can be signed or unsigned, and the
+     destination has the same signedness.  */
+  NEON_ENCODE (INTEGER, inst);
+  if (et.type == NT_unsigned)
+    inst.instruction |= 0xc0;
+  else
+    inst.instruction |= 0x80;
+  neon_two_same (0, 1, et.size / 2);
+}
+
+static void
+do_neon_qmovun (void)
+{
+  struct neon_type_el et = neon_check_type (2, NS_DQ,
+    N_EQK | N_HLF | N_UNS, N_S16 | N_S32 | N_S64 | N_KEY);
+  /* Saturating move with unsigned results. Operands must be signed.  */
+  NEON_ENCODE (INTEGER, inst);
+  neon_two_same (0, 1, et.size / 2);
+}
+
+static void
+do_neon_rshift_sat_narrow (void)
+{
+  /* FIXME: Types for narrowing. If operands are signed, results can be signed
+     or unsigned. If operands are unsigned, results must also be unsigned.  */
+  struct neon_type_el et = neon_check_type (2, NS_DQI,
+    N_EQK | N_HLF, N_SU_16_64 | N_KEY);
+  int imm = inst.operands[2].imm;
+  /* This gets the bounds check, size encoding and immediate bits calculation
+     right.  */
+  et.size /= 2;
+
+  /* VQ{R}SHRN.I<size> <Dd>, <Qm>, #0 is a synonym for
+     VQMOVN.I<size> <Dd>, <Qm>.  */
+  if (imm == 0)
+    {
+      inst.operands[2].present = 0;
+      inst.instruction = N_MNEM_vqmovn;
+      do_neon_qmovn ();
+      return;
+    }
+
+  constraint (imm < 1 || (unsigned)imm > et.size,
+	      _("immediate out of range"));
+  neon_imm_shift (TRUE, et.type == NT_unsigned, 0, et, et.size - imm);
+}
+
+static void
+do_neon_rshift_sat_narrow_u (void)
+{
+  /* FIXME: Types for narrowing. If operands are signed, results can be signed
+     or unsigned. If operands are unsigned, results must also be unsigned.  */
+  struct neon_type_el et = neon_check_type (2, NS_DQI,
+    N_EQK | N_HLF | N_UNS, N_S16 | N_S32 | N_S64 | N_KEY);
+  int imm = inst.operands[2].imm;
+  /* This gets the bounds check, size encoding and immediate bits calculation
+     right.  */
+  et.size /= 2;
+
+  /* VQSHRUN.I<size> <Dd>, <Qm>, #0 is a synonym for
+     VQMOVUN.I<size> <Dd>, <Qm>.  */
+  if (imm == 0)
+    {
+      inst.operands[2].present = 0;
+      inst.instruction = N_MNEM_vqmovun;
+      do_neon_qmovun ();
+      return;
+    }
+
+  constraint (imm < 1 || (unsigned)imm > et.size,
+	      _("immediate out of range"));
+  /* FIXME: The manual is kind of unclear about what value U should have in
+     VQ{R}SHRUN instructions, but U=0, op=0 definitely encodes VRSHR, so it
+     must be 1.  */
+  neon_imm_shift (TRUE, 1, 0, et, et.size - imm);
+}
+
+static void
+do_neon_movn (void)
+{
+  struct neon_type_el et = neon_check_type (2, NS_DQ,
+    N_EQK | N_HLF, N_I16 | N_I32 | N_I64 | N_KEY);
+  NEON_ENCODE (INTEGER, inst);
+  neon_two_same (0, 1, et.size / 2);
+}
+
+static void
+do_neon_rshift_narrow (void)
+{
+  struct neon_type_el et = neon_check_type (2, NS_DQI,
+    N_EQK | N_HLF, N_I16 | N_I32 | N_I64 | N_KEY);
+  int imm = inst.operands[2].imm;
+  /* This gets the bounds check, size encoding and immediate bits calculation
+     right.  */
+  et.size /= 2;
+
+  /* If immediate is zero then we are a pseudo-instruction for
+     VMOVN.I<size> <Dd>, <Qm>  */
+  if (imm == 0)
+    {
+      inst.operands[2].present = 0;
+      inst.instruction = N_MNEM_vmovn;
+      do_neon_movn ();
+      return;
+    }
+
+  constraint (imm < 1 || (unsigned)imm > et.size,
+	      _("immediate out of range for narrowing operation"));
+  neon_imm_shift (FALSE, 0, 0, et, et.size - imm);
+}
+
+static void
+do_neon_shll (void)
+{
+  /* FIXME: Type checking when lengthening.  */
+  struct neon_type_el et = neon_check_type (2, NS_QDI,
+    N_EQK | N_DBL, N_I8 | N_I16 | N_I32 | N_KEY);
+  unsigned imm = inst.operands[2].imm;
+
+  if (imm == et.size)
+    {
+      /* Maximum shift variant.  */
+      NEON_ENCODE (INTEGER, inst);
+      inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
+      inst.instruction |= HI1 (inst.operands[0].reg) << 22;
+      inst.instruction |= LOW4 (inst.operands[1].reg);
+      inst.instruction |= HI1 (inst.operands[1].reg) << 5;
+      inst.instruction |= neon_logbits (et.size) << 18;
+
+      neon_dp_fixup (&inst);
+    }
+  else
+    {
+      /* A more-specific type check for non-max versions.  */
+      et = neon_check_type (2, NS_QDI,
+	N_EQK | N_DBL, N_SU_32 | N_KEY);
+      NEON_ENCODE (IMMED, inst);
+      neon_imm_shift (TRUE, et.type == NT_unsigned, 0, et, imm);
+    }
+}
+
+/* Check the various types for the VCVT instruction, and return which version
+   the current instruction is.  */
+
+#define CVT_FLAVOUR_VAR							      \
+  CVT_VAR (s32_f32, N_S32, N_F32, whole_reg,   "ftosls", "ftosis", "ftosizs") \
+  CVT_VAR (u32_f32, N_U32, N_F32, whole_reg,   "ftouls", "ftouis", "ftouizs") \
+  CVT_VAR (f32_s32, N_F32, N_S32, whole_reg,   "fsltos", "fsitos", NULL)      \
+  CVT_VAR (f32_u32, N_F32, N_U32, whole_reg,   "fultos", "fuitos", NULL)      \
+  /* Half-precision conversions.  */					      \
+  CVT_VAR (f32_f16, N_F32, N_F16, whole_reg,   NULL,     NULL,     NULL)      \
+  CVT_VAR (f16_f32, N_F16, N_F32, whole_reg,   NULL,     NULL,     NULL)      \
+  /* VFP instructions.  */						      \
+  CVT_VAR (f32_f64, N_F32, N_F64, N_VFP,       NULL,     "fcvtsd", NULL)      \
+  CVT_VAR (f64_f32, N_F64, N_F32, N_VFP,       NULL,     "fcvtds", NULL)      \
+  CVT_VAR (s32_f64, N_S32, N_F64 | key, N_VFP, "ftosld", "ftosid", "ftosizd") \
+  CVT_VAR (u32_f64, N_U32, N_F64 | key, N_VFP, "ftould", "ftouid", "ftouizd") \
+  CVT_VAR (f64_s32, N_F64 | key, N_S32, N_VFP, "fsltod", "fsitod", NULL)      \
+  CVT_VAR (f64_u32, N_F64 | key, N_U32, N_VFP, "fultod", "fuitod", NULL)      \
+  /* VFP instructions with bitshift.  */				      \
+  CVT_VAR (f32_s16, N_F32 | key, N_S16, N_VFP, "fshtos", NULL,     NULL)      \
+  CVT_VAR (f32_u16, N_F32 | key, N_U16, N_VFP, "fuhtos", NULL,     NULL)      \
+  CVT_VAR (f64_s16, N_F64 | key, N_S16, N_VFP, "fshtod", NULL,     NULL)      \
+  CVT_VAR (f64_u16, N_F64 | key, N_U16, N_VFP, "fuhtod", NULL,     NULL)      \
+  CVT_VAR (s16_f32, N_S16, N_F32 | key, N_VFP, "ftoshs", NULL,     NULL)      \
+  CVT_VAR (u16_f32, N_U16, N_F32 | key, N_VFP, "ftouhs", NULL,     NULL)      \
+  CVT_VAR (s16_f64, N_S16, N_F64 | key, N_VFP, "ftoshd", NULL,     NULL)      \
+  CVT_VAR (u16_f64, N_U16, N_F64 | key, N_VFP, "ftouhd", NULL,     NULL)
+
+#define CVT_VAR(C, X, Y, R, BSN, CN, ZN) \
+  neon_cvt_flavour_##C,
+
+/* The different types of conversions we can do.  */
+enum neon_cvt_flavour
+{
+  CVT_FLAVOUR_VAR
+  neon_cvt_flavour_invalid,
+  neon_cvt_flavour_first_fp = neon_cvt_flavour_f32_f64
+};
+
+#undef CVT_VAR
+
+static enum neon_cvt_flavour
+get_neon_cvt_flavour (enum neon_shape rs)
+{
+#define CVT_VAR(C,X,Y,R,BSN,CN,ZN)			\
+  et = neon_check_type (2, rs, (R) | (X), (R) | (Y));	\
+  if (et.type != NT_invtype)				\
+    {							\
+      inst.error = NULL;				\
+      return (neon_cvt_flavour_##C);			\
+    }
+
+  struct neon_type_el et;
+  unsigned whole_reg = (rs == NS_FFI || rs == NS_FD || rs == NS_DF
+			|| rs == NS_FF) ? N_VFP : 0;
+  /* The instruction versions which take an immediate take one register
+     argument, which is extended to the width of the full register. Thus the
+     "source" and "destination" registers must have the same width.  Hack that
+     here by making the size equal to the key (wider, in this case) operand.  */
+  unsigned key = (rs == NS_QQI || rs == NS_DDI || rs == NS_FFI) ? N_KEY : 0;
+
+  CVT_FLAVOUR_VAR;
+
+  return neon_cvt_flavour_invalid;
+#undef CVT_VAR
+}
+
+enum neon_cvt_mode
+{
+  neon_cvt_mode_a,
+  neon_cvt_mode_n,
+  neon_cvt_mode_p,
+  neon_cvt_mode_m,
+  neon_cvt_mode_z,
+  neon_cvt_mode_x,
+  neon_cvt_mode_r
+};
+
+/* Neon-syntax VFP conversions.  */
+
+static void
+do_vfp_nsyn_cvt (enum neon_shape rs, enum neon_cvt_flavour flavour)
+{
+  const char *opname = 0;
+
+  if (rs == NS_DDI || rs == NS_QQI || rs == NS_FFI)
+    {
+      /* Conversions with immediate bitshift.  */
+      const char *enc[] =
+	{
+#define CVT_VAR(C,A,B,R,BSN,CN,ZN) BSN,
+	  CVT_FLAVOUR_VAR
+	  NULL
+#undef CVT_VAR
+	};
+
+      if (flavour < (int) ARRAY_SIZE (enc))
+	{
+	  opname = enc[flavour];
+	  constraint (inst.operands[0].reg != inst.operands[1].reg,
+		      _("operands 0 and 1 must be the same register"));
+	  inst.operands[1] = inst.operands[2];
+	  memset (&inst.operands[2], '\0', sizeof (inst.operands[2]));
+	}
+    }
+  else
+    {
+      /* Conversions without bitshift.  */
+      const char *enc[] =
+	{
+#define CVT_VAR(C,A,B,R,BSN,CN,ZN) CN,
+	  CVT_FLAVOUR_VAR
+	  NULL
+#undef CVT_VAR
+	};
+
+      if (flavour < (int) ARRAY_SIZE (enc))
+	opname = enc[flavour];
+    }
+
+  if (opname)
+    do_vfp_nsyn_opcode (opname);
+}
+
+static void
+do_vfp_nsyn_cvtz (void)
+{
+  enum neon_shape rs = neon_select_shape (NS_FF, NS_FD, NS_NULL);
+  enum neon_cvt_flavour flavour = get_neon_cvt_flavour (rs);
+  const char *enc[] =
+    {
+#define CVT_VAR(C,A,B,R,BSN,CN,ZN) ZN,
+      CVT_FLAVOUR_VAR
+      NULL
+#undef CVT_VAR
+    };
+
+  if (flavour < (int) ARRAY_SIZE (enc) && enc[flavour])
+    do_vfp_nsyn_opcode (enc[flavour]);
+}
+
+static void
+do_vfp_nsyn_cvt_fpv8 (enum neon_cvt_flavour flavour,
+		      enum neon_cvt_mode mode)
+{
+  int sz, op;
+  int rm;
+
+  /* Targets like FPv5-SP-D16 don't support FP v8 instructions with
+     D register operands.  */
+  if (flavour == neon_cvt_flavour_s32_f64
+      || flavour == neon_cvt_flavour_u32_f64)
+    constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_armv8),
+		_(BAD_FPU));
+
+  set_it_insn_type (OUTSIDE_IT_INSN);
+
+  switch (flavour)
+    {
+    case neon_cvt_flavour_s32_f64:
+      sz = 1;
+      op = 1;
+      break;
+    case neon_cvt_flavour_s32_f32:
+      sz = 0;
+      op = 1;
+      break;
+    case neon_cvt_flavour_u32_f64:
+      sz = 1;
+      op = 0;
+      break;
+    case neon_cvt_flavour_u32_f32:
+      sz = 0;
+      op = 0;
+      break;
+    default:
+      first_error (_("invalid instruction shape"));
+      return;
+    }
+
+  switch (mode)
+    {
+    case neon_cvt_mode_a: rm = 0; break;
+    case neon_cvt_mode_n: rm = 1; break;
+    case neon_cvt_mode_p: rm = 2; break;
+    case neon_cvt_mode_m: rm = 3; break;
+    default: first_error (_("invalid rounding mode")); return;
+    }
+
+  NEON_ENCODE (FPV8, inst);
+  encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sd);
+  encode_arm_vfp_reg (inst.operands[1].reg, sz == 1 ? VFP_REG_Dm : VFP_REG_Sm);
+  inst.instruction |= sz << 8;
+  inst.instruction |= op << 7;
+  inst.instruction |= rm << 16;
+  inst.instruction |= 0xf0000000;
+  inst.is_neon = TRUE;
+}
+
+static void
+do_neon_cvt_1 (enum neon_cvt_mode mode)
+{
+  enum neon_shape rs = neon_select_shape (NS_DDI, NS_QQI, NS_FFI, NS_DD, NS_QQ,
+    NS_FD, NS_DF, NS_FF, NS_QD, NS_DQ, NS_NULL);
+  enum neon_cvt_flavour flavour = get_neon_cvt_flavour (rs);
+
+  /* PR11109: Handle round-to-zero for VCVT conversions.  */
+  if (mode == neon_cvt_mode_z
+      && ARM_CPU_HAS_FEATURE (cpu_variant, fpu_arch_vfp_v2)
+      && (flavour == neon_cvt_flavour_s32_f32
+	  || flavour == neon_cvt_flavour_u32_f32
+	  || flavour == neon_cvt_flavour_s32_f64
+	  || flavour == neon_cvt_flavour_u32_f64)
+      && (rs == NS_FD || rs == NS_FF))
+    {
+      do_vfp_nsyn_cvtz ();
+      return;
+    }
+
+  /* VFP rather than Neon conversions.  */
+  if (flavour >= neon_cvt_flavour_first_fp)
+    {
+      if (mode == neon_cvt_mode_x || mode == neon_cvt_mode_z)
+	do_vfp_nsyn_cvt (rs, flavour);
+      else
+	do_vfp_nsyn_cvt_fpv8 (flavour, mode);
+
+      return;
+    }
+
+  switch (rs)
+    {
+    case NS_DDI:
+    case NS_QQI:
+      {
+	unsigned immbits;
+	unsigned enctab[] = { 0x0000100, 0x1000100, 0x0, 0x1000000 };
+
+	if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)
+	  return;
+
+	/* Fixed-point conversion with #0 immediate is encoded as an
+	   integer conversion.  */
+	if (inst.operands[2].present && inst.operands[2].imm == 0)
+	  goto int_encode;
+       immbits = 32 - inst.operands[2].imm;
+	NEON_ENCODE (IMMED, inst);
+	if (flavour != neon_cvt_flavour_invalid)
+	  inst.instruction |= enctab[flavour];
+	inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
+	inst.instruction |= HI1 (inst.operands[0].reg) << 22;
+	inst.instruction |= LOW4 (inst.operands[1].reg);
+	inst.instruction |= HI1 (inst.operands[1].reg) << 5;
+	inst.instruction |= neon_quad (rs) << 6;
+	inst.instruction |= 1 << 21;
+	inst.instruction |= immbits << 16;
+
+	neon_dp_fixup (&inst);
+      }
+      break;
+
+    case NS_DD:
+    case NS_QQ:
+      if (mode != neon_cvt_mode_x && mode != neon_cvt_mode_z)
+	{
+	  NEON_ENCODE (FLOAT, inst);
+	  set_it_insn_type (OUTSIDE_IT_INSN);
+
+	  if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH8) == FAIL)
+	    return;
+
+	  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
+	  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
+	  inst.instruction |= LOW4 (inst.operands[1].reg);
+	  inst.instruction |= HI1 (inst.operands[1].reg) << 5;
+	  inst.instruction |= neon_quad (rs) << 6;
+	  inst.instruction |= (flavour == neon_cvt_flavour_u32_f32) << 7;
+	  inst.instruction |= mode << 8;
+	  if (thumb_mode)
+	    inst.instruction |= 0xfc000000;
+	  else
+	    inst.instruction |= 0xf0000000;
+	}
+      else
+	{
+    int_encode:
+	  {
+	    unsigned enctab[] = { 0x100, 0x180, 0x0, 0x080 };
+
+	    NEON_ENCODE (INTEGER, inst);
+
+	    if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)
+	      return;
+
+	    if (flavour != neon_cvt_flavour_invalid)
+	      inst.instruction |= enctab[flavour];
+
+	    inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
+	    inst.instruction |= HI1 (inst.operands[0].reg) << 22;
+	    inst.instruction |= LOW4 (inst.operands[1].reg);
+	    inst.instruction |= HI1 (inst.operands[1].reg) << 5;
+	    inst.instruction |= neon_quad (rs) << 6;
+	    inst.instruction |= 2 << 18;
+
+	    neon_dp_fixup (&inst);
+	  }
+	}
+      break;
+
+    /* Half-precision conversions for Advanced SIMD -- neon.  */
+    case NS_QD:
+    case NS_DQ:
+
+      if ((rs == NS_DQ)
+	  && (inst.vectype.el[0].size != 16 || inst.vectype.el[1].size != 32))
+	  {
+	    as_bad (_("operand size must match register width"));
+	    break;
+	  }
+
+      if ((rs == NS_QD)
+	  && ((inst.vectype.el[0].size != 32 || inst.vectype.el[1].size != 16)))
+	  {
+	    as_bad (_("operand size must match register width"));
+	    break;
+	  }
+
+      if (rs == NS_DQ)
+	inst.instruction = 0x3b60600;
+      else
+	inst.instruction = 0x3b60700;
+
+      inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
+      inst.instruction |= HI1 (inst.operands[0].reg) << 22;
+      inst.instruction |= LOW4 (inst.operands[1].reg);
+      inst.instruction |= HI1 (inst.operands[1].reg) << 5;
+      neon_dp_fixup (&inst);
+      break;
+
+    default:
+      /* Some VFP conversions go here (s32 <-> f32, u32 <-> f32).  */
+      if (mode == neon_cvt_mode_x || mode == neon_cvt_mode_z)
+	do_vfp_nsyn_cvt (rs, flavour);
+      else
+	do_vfp_nsyn_cvt_fpv8 (flavour, mode);
+    }
+}
+
+static void
+do_neon_cvtr (void)
+{
+  do_neon_cvt_1 (neon_cvt_mode_x);
+}
+
+static void
+do_neon_cvt (void)
+{
+  do_neon_cvt_1 (neon_cvt_mode_z);
+}
+
+static void
+do_neon_cvta (void)
+{
+  do_neon_cvt_1 (neon_cvt_mode_a);
+}
+
+static void
+do_neon_cvtn (void)
+{
+  do_neon_cvt_1 (neon_cvt_mode_n);
+}
+
+static void
+do_neon_cvtp (void)
+{
+  do_neon_cvt_1 (neon_cvt_mode_p);
+}
+
+static void
+do_neon_cvtm (void)
+{
+  do_neon_cvt_1 (neon_cvt_mode_m);
+}
+
+static void
+do_neon_cvttb_2 (bfd_boolean t, bfd_boolean to, bfd_boolean is_double)
+{
+  if (is_double)
+    mark_feature_used (&fpu_vfp_ext_armv8);
+
+  encode_arm_vfp_reg (inst.operands[0].reg,
+		      (is_double && !to) ? VFP_REG_Dd : VFP_REG_Sd);
+  encode_arm_vfp_reg (inst.operands[1].reg,
+		      (is_double && to) ? VFP_REG_Dm : VFP_REG_Sm);
+  inst.instruction |= to ? 0x10000 : 0;
+  inst.instruction |= t ? 0x80 : 0;
+  inst.instruction |= is_double ? 0x100 : 0;
+  do_vfp_cond_or_thumb ();
+}
+
+static void
+do_neon_cvttb_1 (bfd_boolean t)
+{
+  enum neon_shape rs = neon_select_shape (NS_FF, NS_FD, NS_DF, NS_NULL);
+
+  if (rs == NS_NULL)
+    return;
+  else if (neon_check_type (2, rs, N_F16, N_F32 | N_VFP).type != NT_invtype)
+    {
+      inst.error = NULL;
+      do_neon_cvttb_2 (t, /*to=*/TRUE, /*is_double=*/FALSE);
+    }
+  else if (neon_check_type (2, rs, N_F32 | N_VFP, N_F16).type != NT_invtype)
+    {
+      inst.error = NULL;
+      do_neon_cvttb_2 (t, /*to=*/FALSE, /*is_double=*/FALSE);
+    }
+  else if (neon_check_type (2, rs, N_F16, N_F64 | N_VFP).type != NT_invtype)
+    {
+      /* The VCVTB and VCVTT instructions with D-register operands
+         don't work for SP only targets.  */
+      constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_armv8),
+		  _(BAD_FPU));
+
+      inst.error = NULL;
+      do_neon_cvttb_2 (t, /*to=*/TRUE, /*is_double=*/TRUE);
+    }
+  else if (neon_check_type (2, rs, N_F64 | N_VFP, N_F16).type != NT_invtype)
+    {
+      /* The VCVTB and VCVTT instructions with D-register operands
+         don't work for SP only targets.  */
+      constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_armv8),
+		  _(BAD_FPU));
+
+      inst.error = NULL;
+      do_neon_cvttb_2 (t, /*to=*/FALSE, /*is_double=*/TRUE);
+    }
+  else
+    return;
+}
+
+static void
+do_neon_cvtb (void)
+{
+  do_neon_cvttb_1 (FALSE);
+}
+
+
+static void
+do_neon_cvtt (void)
+{
+  do_neon_cvttb_1 (TRUE);
+}
+
+static void
+neon_move_immediate (void)
+{
+  enum neon_shape rs = neon_select_shape (NS_DI, NS_QI, NS_NULL);
+  struct neon_type_el et = neon_check_type (2, rs,
+    N_I8 | N_I16 | N_I32 | N_I64 | N_F32 | N_KEY, N_EQK);
+  unsigned immlo, immhi = 0, immbits;
+  int op, cmode, float_p;
+
+  constraint (et.type == NT_invtype,
+	      _("operand size must be specified for immediate VMOV"));
+
+  /* We start out as an MVN instruction if OP = 1, MOV otherwise.  */
+  op = (inst.instruction & (1 << 5)) != 0;
+
+  immlo = inst.operands[1].imm;
+  if (inst.operands[1].regisimm)
+    immhi = inst.operands[1].reg;
+
+  constraint (et.size < 32 && (immlo & ~((1 << et.size) - 1)) != 0,
+	      _("immediate has bits set outside the operand size"));
+
+  float_p = inst.operands[1].immisfloat;
+
+  if ((cmode = neon_cmode_for_move_imm (immlo, immhi, float_p, &immbits, &op,
+					et.size, et.type)) == FAIL)
+    {
+      /* Invert relevant bits only.  */
+      neon_invert_size (&immlo, &immhi, et.size);
+      /* Flip from VMOV/VMVN to VMVN/VMOV. Some immediate types are unavailable
+	 with one or the other; those cases are caught by
+	 neon_cmode_for_move_imm.  */
+      op = !op;
+      if ((cmode = neon_cmode_for_move_imm (immlo, immhi, float_p, &immbits,
+					    &op, et.size, et.type)) == FAIL)
+	{
+	  first_error (_("immediate out of range"));
+	  return;
+	}
+    }
+
+  inst.instruction &= ~(1 << 5);
+  inst.instruction |= op << 5;
+
+  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
+  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
+  inst.instruction |= neon_quad (rs) << 6;
+  inst.instruction |= cmode << 8;
+
+  neon_write_immbits (immbits);
+}
+
+static void
+do_neon_mvn (void)
+{
+  if (inst.operands[1].isreg)
+    {
+      enum neon_shape rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
+
+      NEON_ENCODE (INTEGER, inst);
+      inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
+      inst.instruction |= HI1 (inst.operands[0].reg) << 22;
+      inst.instruction |= LOW4 (inst.operands[1].reg);
+      inst.instruction |= HI1 (inst.operands[1].reg) << 5;
+      inst.instruction |= neon_quad (rs) << 6;
+    }
+  else
+    {
+      NEON_ENCODE (IMMED, inst);
+      neon_move_immediate ();
+    }
+
+  neon_dp_fixup (&inst);
+}
+
+/* Encode instructions of form:
+
+  |28/24|23|22|21 20|19 16|15 12|11    8|7|6|5|4|3  0|
+  |  U  |x |D |size | Rn  | Rd  |x x x x|N|x|M|x| Rm |  */
+
+static void
+neon_mixed_length (struct neon_type_el et, unsigned size)
+{
+  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
+  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
+  inst.instruction |= LOW4 (inst.operands[1].reg) << 16;
+  inst.instruction |= HI1 (inst.operands[1].reg) << 7;
+  inst.instruction |= LOW4 (inst.operands[2].reg);
+  inst.instruction |= HI1 (inst.operands[2].reg) << 5;
+  inst.instruction |= (et.type == NT_unsigned) << 24;
+  inst.instruction |= neon_logbits (size) << 20;
+
+  neon_dp_fixup (&inst);
+}
+
+static void
+do_neon_dyadic_long (void)
+{
+  /* FIXME: Type checking for lengthening op.  */
+  struct neon_type_el et = neon_check_type (3, NS_QDD,
+    N_EQK | N_DBL, N_EQK, N_SU_32 | N_KEY);
+  neon_mixed_length (et, et.size);
+}
+
+static void
+do_neon_abal (void)
+{
+  struct neon_type_el et = neon_check_type (3, NS_QDD,
+    N_EQK | N_INT | N_DBL, N_EQK, N_SU_32 | N_KEY);
+  neon_mixed_length (et, et.size);
+}
+
+static void
+neon_mac_reg_scalar_long (unsigned regtypes, unsigned scalartypes)
+{
+  if (inst.operands[2].isscalar)
+    {
+      struct neon_type_el et = neon_check_type (3, NS_QDS,
+	N_EQK | N_DBL, N_EQK, regtypes | N_KEY);
+      NEON_ENCODE (SCALAR, inst);
+      neon_mul_mac (et, et.type == NT_unsigned);
+    }
+  else
+    {
+      struct neon_type_el et = neon_check_type (3, NS_QDD,
+	N_EQK | N_DBL, N_EQK, scalartypes | N_KEY);
+      NEON_ENCODE (INTEGER, inst);
+      neon_mixed_length (et, et.size);
+    }
+}
+
+static void
+do_neon_mac_maybe_scalar_long (void)
+{
+  neon_mac_reg_scalar_long (N_S16 | N_S32 | N_U16 | N_U32, N_SU_32);
+}
+
+static void
+do_neon_dyadic_wide (void)
+{
+  struct neon_type_el et = neon_check_type (3, NS_QQD,
+    N_EQK | N_DBL, N_EQK | N_DBL, N_SU_32 | N_KEY);
+  neon_mixed_length (et, et.size);
+}
+
+static void
+do_neon_dyadic_narrow (void)
+{
+  struct neon_type_el et = neon_check_type (3, NS_QDD,
+    N_EQK | N_DBL, N_EQK, N_I16 | N_I32 | N_I64 | N_KEY);
+  /* Operand sign is unimportant, and the U bit is part of the opcode,
+     so force the operand type to integer.  */
+  et.type = NT_integer;
+  neon_mixed_length (et, et.size / 2);
+}
+
+static void
+do_neon_mul_sat_scalar_long (void)
+{
+  neon_mac_reg_scalar_long (N_S16 | N_S32, N_S16 | N_S32);
+}
+
+static void
+do_neon_vmull (void)
+{
+  if (inst.operands[2].isscalar)
+    do_neon_mac_maybe_scalar_long ();
+  else
+    {
+      struct neon_type_el et = neon_check_type (3, NS_QDD,
+	N_EQK | N_DBL, N_EQK, N_SU_32 | N_P8 | N_P64 | N_KEY);
+
+      if (et.type == NT_poly)
+	NEON_ENCODE (POLY, inst);
+      else
+	NEON_ENCODE (INTEGER, inst);
+
+      /* For polynomial encoding the U bit must be zero, and the size must
+	 be 8 (encoded as 0b00) or, on ARMv8 or later 64 (encoded, non
+	 obviously, as 0b10).  */
+      if (et.size == 64)
+	{
+	  /* Check we're on the correct architecture.  */
+	  if (!mark_feature_used (&fpu_crypto_ext_armv8))
+	    inst.error =
+	      _("Instruction form not available on this architecture.");
+
+	  et.size = 32;
+	}
+
+      neon_mixed_length (et, et.size);
+    }
+}
+
+static void
+do_neon_ext (void)
+{
+  enum neon_shape rs = neon_select_shape (NS_DDDI, NS_QQQI, NS_NULL);
+  struct neon_type_el et = neon_check_type (3, rs,
+    N_EQK, N_EQK, N_8 | N_16 | N_32 | N_64 | N_KEY);
+  unsigned imm = (inst.operands[3].imm * et.size) / 8;
+
+  constraint (imm >= (unsigned) (neon_quad (rs) ? 16 : 8),
+	      _("shift out of range"));
+  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
+  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
+  inst.instruction |= LOW4 (inst.operands[1].reg) << 16;
+  inst.instruction |= HI1 (inst.operands[1].reg) << 7;
+  inst.instruction |= LOW4 (inst.operands[2].reg);
+  inst.instruction |= HI1 (inst.operands[2].reg) << 5;
+  inst.instruction |= neon_quad (rs) << 6;
+  inst.instruction |= imm << 8;
+
+  neon_dp_fixup (&inst);
+}
+
+static void
+do_neon_rev (void)
+{
+  enum neon_shape rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
+  struct neon_type_el et = neon_check_type (2, rs,
+    N_EQK, N_8 | N_16 | N_32 | N_KEY);
+  unsigned op = (inst.instruction >> 7) & 3;
+  /* N (width of reversed regions) is encoded as part of the bitmask. We
+     extract it here to check the elements to be reversed are smaller.
+     Otherwise we'd get a reserved instruction.  */
+  unsigned elsize = (op == 2) ? 16 : (op == 1) ? 32 : (op == 0) ? 64 : 0;
+  gas_assert (elsize != 0);
+  constraint (et.size >= elsize,
+	      _("elements must be smaller than reversal region"));
+  neon_two_same (neon_quad (rs), 1, et.size);
+}
+
+static void
+do_neon_dup (void)
+{
+  if (inst.operands[1].isscalar)
+    {
+      enum neon_shape rs = neon_select_shape (NS_DS, NS_QS, NS_NULL);
+      struct neon_type_el et = neon_check_type (2, rs,
+	N_EQK, N_8 | N_16 | N_32 | N_KEY);
+      unsigned sizebits = et.size >> 3;
+      unsigned dm = NEON_SCALAR_REG (inst.operands[1].reg);
+      int logsize = neon_logbits (et.size);
+      unsigned x = NEON_SCALAR_INDEX (inst.operands[1].reg) << logsize;
+
+      if (vfp_or_neon_is_neon (NEON_CHECK_CC) == FAIL)
+	return;
+
+      NEON_ENCODE (SCALAR, inst);
+      inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
+      inst.instruction |= HI1 (inst.operands[0].reg) << 22;
+      inst.instruction |= LOW4 (dm);
+      inst.instruction |= HI1 (dm) << 5;
+      inst.instruction |= neon_quad (rs) << 6;
+      inst.instruction |= x << 17;
+      inst.instruction |= sizebits << 16;
+
+      neon_dp_fixup (&inst);
+    }
+  else
+    {
+      enum neon_shape rs = neon_select_shape (NS_DR, NS_QR, NS_NULL);
+      struct neon_type_el et = neon_check_type (2, rs,
+	N_8 | N_16 | N_32 | N_KEY, N_EQK);
+      /* Duplicate ARM register to lanes of vector.  */
+      NEON_ENCODE (ARMREG, inst);
+      switch (et.size)
+	{
+	case 8:  inst.instruction |= 0x400000; break;
+	case 16: inst.instruction |= 0x000020; break;
+	case 32: inst.instruction |= 0x000000; break;
+	default: break;
+	}
+      inst.instruction |= LOW4 (inst.operands[1].reg) << 12;
+      inst.instruction |= LOW4 (inst.operands[0].reg) << 16;
+      inst.instruction |= HI1 (inst.operands[0].reg) << 7;
+      inst.instruction |= neon_quad (rs) << 21;
+      /* The encoding for this instruction is identical for the ARM and Thumb
+	 variants, except for the condition field.  */
+      do_vfp_cond_or_thumb ();
+    }
+}
+
+/* VMOV has particularly many variations. It can be one of:
+     0. VMOV<c><q> <Qd>, <Qm>
+     1. VMOV<c><q> <Dd>, <Dm>
+   (Register operations, which are VORR with Rm = Rn.)
+     2. VMOV<c><q>.<dt> <Qd>, #<imm>
+     3. VMOV<c><q>.<dt> <Dd>, #<imm>
+   (Immediate loads.)
+     4. VMOV<c><q>.<size> <Dn[x]>, <Rd>
+   (ARM register to scalar.)
+     5. VMOV<c><q> <Dm>, <Rd>, <Rn>
+   (Two ARM registers to vector.)
+     6. VMOV<c><q>.<dt> <Rd>, <Dn[x]>
+   (Scalar to ARM register.)
+     7. VMOV<c><q> <Rd>, <Rn>, <Dm>
+   (Vector to two ARM registers.)
+     8. VMOV.F32 <Sd>, <Sm>
+     9. VMOV.F64 <Dd>, <Dm>
+   (VFP register moves.)
+    10. VMOV.F32 <Sd>, #imm
+    11. VMOV.F64 <Dd>, #imm
+   (VFP float immediate load.)
+    12. VMOV <Rd>, <Sm>
+   (VFP single to ARM reg.)
+    13. VMOV <Sd>, <Rm>
+   (ARM reg to VFP single.)
+    14. VMOV <Rd>, <Re>, <Sn>, <Sm>
+   (Two ARM regs to two VFP singles.)
+    15. VMOV <Sd>, <Se>, <Rn>, <Rm>
+   (Two VFP singles to two ARM regs.)
+
+   These cases can be disambiguated using neon_select_shape, except cases 1/9
+   and 3/11 which depend on the operand type too.
+
+   All the encoded bits are hardcoded by this function.
+
+   Cases 4, 6 may be used with VFPv1 and above (only 32-bit transfers!).
+   Cases 5, 7 may be used with VFPv2 and above.
+
+   FIXME: Some of the checking may be a bit sloppy (in a couple of cases you
+   can specify a type where it doesn't make sense to, and is ignored).  */
+
+static void
+do_neon_mov (void)
+{
+  enum neon_shape rs = neon_select_shape (NS_RRFF, NS_FFRR, NS_DRR, NS_RRD,
+    NS_QQ, NS_DD, NS_QI, NS_DI, NS_SR, NS_RS, NS_FF, NS_FI, NS_RF, NS_FR,
+    NS_NULL);
+  struct neon_type_el et;
+  const char *ldconst = 0;
+
+  switch (rs)
+    {
+    case NS_DD:  /* case 1/9.  */
+      et = neon_check_type (2, rs, N_EQK, N_F64 | N_KEY);
+      /* It is not an error here if no type is given.  */
+      inst.error = NULL;
+      if (et.type == NT_float && et.size == 64)
+	{
+	  do_vfp_nsyn_opcode ("fcpyd");
+	  break;
+	}
+      /* fall through.  */
+
+    case NS_QQ:  /* case 0/1.  */
+      {
+	if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)
+	  return;
+	/* The architecture manual I have doesn't explicitly state which
+	   value the U bit should have for register->register moves, but
+	   the equivalent VORR instruction has U = 0, so do that.  */
+	inst.instruction = 0x0200110;
+	inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
+	inst.instruction |= HI1 (inst.operands[0].reg) << 22;
+	inst.instruction |= LOW4 (inst.operands[1].reg);
+	inst.instruction |= HI1 (inst.operands[1].reg) << 5;
+	inst.instruction |= LOW4 (inst.operands[1].reg) << 16;
+	inst.instruction |= HI1 (inst.operands[1].reg) << 7;
+	inst.instruction |= neon_quad (rs) << 6;
+
+	neon_dp_fixup (&inst);
+      }
+      break;
+
+    case NS_DI:  /* case 3/11.  */
+      et = neon_check_type (2, rs, N_EQK, N_F64 | N_KEY);
+      inst.error = NULL;
+      if (et.type == NT_float && et.size == 64)
+	{
+	  /* case 11 (fconstd).  */
+	  ldconst = "fconstd";
+	  goto encode_fconstd;
+	}
+      /* fall through.  */
+
+    case NS_QI:  /* case 2/3.  */
+      if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)
+	return;
+      inst.instruction = 0x0800010;
+      neon_move_immediate ();
+      neon_dp_fixup (&inst);
+      break;
+
+    case NS_SR:  /* case 4.  */
+      {
+	unsigned bcdebits = 0;
+	int logsize;
+	unsigned dn = NEON_SCALAR_REG (inst.operands[0].reg);
+	unsigned x = NEON_SCALAR_INDEX (inst.operands[0].reg);
+
+	/* .<size> is optional here, defaulting to .32. */
+	if (inst.vectype.elems == 0
+	    && inst.operands[0].vectype.type == NT_invtype
+	    && inst.operands[1].vectype.type == NT_invtype)
+	  {
+	    inst.vectype.el[0].type = NT_untyped;
+	    inst.vectype.el[0].size = 32;
+	    inst.vectype.elems = 1;
+	  }
+
+	et = neon_check_type (2, NS_NULL, N_8 | N_16 | N_32 | N_KEY, N_EQK);
+	logsize = neon_logbits (et.size);
+
+	constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v1),
+		    _(BAD_FPU));
+	constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_neon_ext_v1)
+		    && et.size != 32, _(BAD_FPU));
+	constraint (et.type == NT_invtype, _("bad type for scalar"));
+	constraint (x >= 64 / et.size, _("scalar index out of range"));
+
+	switch (et.size)
+	  {
+	  case 8:  bcdebits = 0x8; break;
+	  case 16: bcdebits = 0x1; break;
+	  case 32: bcdebits = 0x0; break;
+	  default: ;
+	  }
+
+	bcdebits |= x << logsize;
+
+	inst.instruction = 0xe000b10;
+	do_vfp_cond_or_thumb ();
+	inst.instruction |= LOW4 (dn) << 16;
+	inst.instruction |= HI1 (dn) << 7;
+	inst.instruction |= inst.operands[1].reg << 12;
+	inst.instruction |= (bcdebits & 3) << 5;
+	inst.instruction |= (bcdebits >> 2) << 21;
+      }
+      break;
+
+    case NS_DRR:  /* case 5 (fmdrr).  */
+      constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v2),
+		  _(BAD_FPU));
+
+      inst.instruction = 0xc400b10;
+      do_vfp_cond_or_thumb ();
+      inst.instruction |= LOW4 (inst.operands[0].reg);
+      inst.instruction |= HI1 (inst.operands[0].reg) << 5;
+      inst.instruction |= inst.operands[1].reg << 12;
+      inst.instruction |= inst.operands[2].reg << 16;
+      break;
+
+    case NS_RS:  /* case 6.  */
+      {
+	unsigned logsize;
+	unsigned dn = NEON_SCALAR_REG (inst.operands[1].reg);
+	unsigned x = NEON_SCALAR_INDEX (inst.operands[1].reg);
+	unsigned abcdebits = 0;
+
+	/* .<dt> is optional here, defaulting to .32. */
+	if (inst.vectype.elems == 0
+	    && inst.operands[0].vectype.type == NT_invtype
+	    && inst.operands[1].vectype.type == NT_invtype)
+	  {
+	    inst.vectype.el[0].type = NT_untyped;
+	    inst.vectype.el[0].size = 32;
+	    inst.vectype.elems = 1;
+	  }
+
+	et = neon_check_type (2, NS_NULL,
+			      N_EQK, N_S8 | N_S16 | N_U8 | N_U16 | N_32 | N_KEY);
+	logsize = neon_logbits (et.size);
+
+	constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v1),
+		    _(BAD_FPU));
+	constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_neon_ext_v1)
+		    && et.size != 32, _(BAD_FPU));
+	constraint (et.type == NT_invtype, _("bad type for scalar"));
+	constraint (x >= 64 / et.size, _("scalar index out of range"));
+
+	switch (et.size)
+	  {
+	  case 8:  abcdebits = (et.type == NT_signed) ? 0x08 : 0x18; break;
+	  case 16: abcdebits = (et.type == NT_signed) ? 0x01 : 0x11; break;
+	  case 32: abcdebits = 0x00; break;
+	  default: ;
+	  }
+
+	abcdebits |= x << logsize;
+	inst.instruction = 0xe100b10;
+	do_vfp_cond_or_thumb ();
+	inst.instruction |= LOW4 (dn) << 16;
+	inst.instruction |= HI1 (dn) << 7;
+	inst.instruction |= inst.operands[0].reg << 12;
+	inst.instruction |= (abcdebits & 3) << 5;
+	inst.instruction |= (abcdebits >> 2) << 21;
+      }
+      break;
+
+    case NS_RRD:  /* case 7 (fmrrd).  */
+      constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v2),
+		  _(BAD_FPU));
+
+      inst.instruction = 0xc500b10;
+      do_vfp_cond_or_thumb ();
+      inst.instruction |= inst.operands[0].reg << 12;
+      inst.instruction |= inst.operands[1].reg << 16;
+      inst.instruction |= LOW4 (inst.operands[2].reg);
+      inst.instruction |= HI1 (inst.operands[2].reg) << 5;
+      break;
+
+    case NS_FF:  /* case 8 (fcpys).  */
+      do_vfp_nsyn_opcode ("fcpys");
+      break;
+
+    case NS_FI:  /* case 10 (fconsts).  */
+      ldconst = "fconsts";
+      encode_fconstd:
+      if (is_quarter_float (inst.operands[1].imm))
+	{
+	  inst.operands[1].imm = neon_qfloat_bits (inst.operands[1].imm);
+	  do_vfp_nsyn_opcode (ldconst);
+	}
+      else
+	first_error (_("immediate out of range"));
+      break;
+
+    case NS_RF:  /* case 12 (fmrs).  */
+      do_vfp_nsyn_opcode ("fmrs");
+      break;
+
+    case NS_FR:  /* case 13 (fmsr).  */
+      do_vfp_nsyn_opcode ("fmsr");
+      break;
+
+    /* The encoders for the fmrrs and fmsrr instructions expect three operands
+       (one of which is a list), but we have parsed four.  Do some fiddling to
+       make the operands what do_vfp_reg2_from_sp2 and do_vfp_sp2_from_reg2
+       expect.  */
+    case NS_RRFF:  /* case 14 (fmrrs).  */
+      constraint (inst.operands[3].reg != inst.operands[2].reg + 1,
+		  _("VFP registers must be adjacent"));
+      inst.operands[2].imm = 2;
+      memset (&inst.operands[3], '\0', sizeof (inst.operands[3]));
+      do_vfp_nsyn_opcode ("fmrrs");
+      break;
+
+    case NS_FFRR:  /* case 15 (fmsrr).  */
+      constraint (inst.operands[1].reg != inst.operands[0].reg + 1,
+		  _("VFP registers must be adjacent"));
+      inst.operands[1] = inst.operands[2];
+      inst.operands[2] = inst.operands[3];
+      inst.operands[0].imm = 2;
+      memset (&inst.operands[3], '\0', sizeof (inst.operands[3]));
+      do_vfp_nsyn_opcode ("fmsrr");
+      break;
+
+    case NS_NULL:
+      /* neon_select_shape has determined that the instruction
+	 shape is wrong and has already set the error message.  */
+      break;
+
+    default:
+      abort ();
+    }
+}
+
+static void
+do_neon_rshift_round_imm (void)
+{
+  enum neon_shape rs = neon_select_shape (NS_DDI, NS_QQI, NS_NULL);
+  struct neon_type_el et = neon_check_type (2, rs, N_EQK, N_SU_ALL | N_KEY);
+  int imm = inst.operands[2].imm;
+
+  /* imm == 0 case is encoded as VMOV for V{R}SHR.  */
+  if (imm == 0)
+    {
+      inst.operands[2].present = 0;
+      do_neon_mov ();
+      return;
+    }
+
+  constraint (imm < 1 || (unsigned)imm > et.size,
+	      _("immediate out of range for shift"));
+  neon_imm_shift (TRUE, et.type == NT_unsigned, neon_quad (rs), et,
+		  et.size - imm);
+}
+
+static void
+do_neon_movl (void)
+{
+  struct neon_type_el et = neon_check_type (2, NS_QD,
+    N_EQK | N_DBL, N_SU_32 | N_KEY);
+  unsigned sizebits = et.size >> 3;
+  inst.instruction |= sizebits << 19;
+  neon_two_same (0, et.type == NT_unsigned, -1);
+}
+
+static void
+do_neon_trn (void)
+{
+  enum neon_shape rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
+  struct neon_type_el et = neon_check_type (2, rs,
+    N_EQK, N_8 | N_16 | N_32 | N_KEY);
+  NEON_ENCODE (INTEGER, inst);
+  neon_two_same (neon_quad (rs), 1, et.size);
+}
+
+static void
+do_neon_zip_uzp (void)
+{
+  enum neon_shape rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
+  struct neon_type_el et = neon_check_type (2, rs,
+    N_EQK, N_8 | N_16 | N_32 | N_KEY);
+  if (rs == NS_DD && et.size == 32)
+    {
+      /* Special case: encode as VTRN.32 <Dd>, <Dm>.  */
+      inst.instruction = N_MNEM_vtrn;
+      do_neon_trn ();
+      return;
+    }
+  neon_two_same (neon_quad (rs), 1, et.size);
+}
+
+static void
+do_neon_sat_abs_neg (void)
+{
+  enum neon_shape rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
+  struct neon_type_el et = neon_check_type (2, rs,
+    N_EQK, N_S8 | N_S16 | N_S32 | N_KEY);
+  neon_two_same (neon_quad (rs), 1, et.size);
+}
+
+static void
+do_neon_pair_long (void)
+{
+  enum neon_shape rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
+  struct neon_type_el et = neon_check_type (2, rs, N_EQK, N_SU_32 | N_KEY);
+  /* Unsigned is encoded in OP field (bit 7) for these instruction.  */
+  inst.instruction |= (et.type == NT_unsigned) << 7;
+  neon_two_same (neon_quad (rs), 1, et.size);
+}
+
+static void
+do_neon_recip_est (void)
+{
+  enum neon_shape rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
+  struct neon_type_el et = neon_check_type (2, rs,
+    N_EQK | N_FLT, N_F32 | N_U32 | N_KEY);
+  inst.instruction |= (et.type == NT_float) << 8;
+  neon_two_same (neon_quad (rs), 1, et.size);
+}
+
+static void
+do_neon_cls (void)
+{
+  enum neon_shape rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
+  struct neon_type_el et = neon_check_type (2, rs,
+    N_EQK, N_S8 | N_S16 | N_S32 | N_KEY);
+  neon_two_same (neon_quad (rs), 1, et.size);
+}
+
+static void
+do_neon_clz (void)
+{
+  enum neon_shape rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
+  struct neon_type_el et = neon_check_type (2, rs,
+    N_EQK, N_I8 | N_I16 | N_I32 | N_KEY);
+  neon_two_same (neon_quad (rs), 1, et.size);
+}
+
+static void
+do_neon_cnt (void)
+{
+  enum neon_shape rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
+  struct neon_type_el et = neon_check_type (2, rs,
+    N_EQK | N_INT, N_8 | N_KEY);
+  neon_two_same (neon_quad (rs), 1, et.size);
+}
+
+static void
+do_neon_swp (void)
+{
+  enum neon_shape rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);
+  neon_two_same (neon_quad (rs), 1, -1);
+}
+
+static void
+do_neon_tbl_tbx (void)
+{
+  unsigned listlenbits;
+  neon_check_type (3, NS_DLD, N_EQK, N_EQK, N_8 | N_KEY);
+
+  if (inst.operands[1].imm < 1 || inst.operands[1].imm > 4)
+    {
+      first_error (_("bad list length for table lookup"));
+      return;
+    }
+
+  listlenbits = inst.operands[1].imm - 1;
+  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
+  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
+  inst.instruction |= LOW4 (inst.operands[1].reg) << 16;
+  inst.instruction |= HI1 (inst.operands[1].reg) << 7;
+  inst.instruction |= LOW4 (inst.operands[2].reg);
+  inst.instruction |= HI1 (inst.operands[2].reg) << 5;
+  inst.instruction |= listlenbits << 8;
+
+  neon_dp_fixup (&inst);
+}
+
+static void
+do_neon_ldm_stm (void)
+{
+  /* P, U and L bits are part of bitmask.  */
+  int is_dbmode = (inst.instruction & (1 << 24)) != 0;
+  unsigned offsetbits = inst.operands[1].imm * 2;
+
+  if (inst.operands[1].issingle)
+    {
+      do_vfp_nsyn_ldm_stm (is_dbmode);
+      return;
+    }
+
+  constraint (is_dbmode && !inst.operands[0].writeback,
+	      _("writeback (!) must be used for VLDMDB and VSTMDB"));
+
+  constraint (inst.operands[1].imm < 1 || inst.operands[1].imm > 16,
+	      _("register list must contain at least 1 and at most 16 "
+		"registers"));
+
+  inst.instruction |= inst.operands[0].reg << 16;
+  inst.instruction |= inst.operands[0].writeback << 21;
+  inst.instruction |= LOW4 (inst.operands[1].reg) << 12;
+  inst.instruction |= HI1 (inst.operands[1].reg) << 22;
+
+  inst.instruction |= offsetbits;
+
+  do_vfp_cond_or_thumb ();
+}
+
+static void
+do_neon_ldr_str (void)
+{
+  int is_ldr = (inst.instruction & (1 << 20)) != 0;
+
+  /* Use of PC in vstr in ARM mode is deprecated in ARMv7.
+     And is UNPREDICTABLE in thumb mode.  */
+  if (!is_ldr
+      && inst.operands[1].reg == REG_PC
+      && (ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v7) || thumb_mode))
+    {
+      if (thumb_mode)
+	inst.error = _("Use of PC here is UNPREDICTABLE");
+      else if (warn_on_deprecated)
+	as_tsktsk (_("Use of PC here is deprecated"));
+    }
+
+  if (inst.operands[0].issingle)
+    {
+      if (is_ldr)
+	do_vfp_nsyn_opcode ("flds");
+      else
+	do_vfp_nsyn_opcode ("fsts");
+    }
+  else
+    {
+      if (is_ldr)
+	do_vfp_nsyn_opcode ("fldd");
+      else
+	do_vfp_nsyn_opcode ("fstd");
+    }
+}
+
+/* "interleave" version also handles non-interleaving register VLD1/VST1
+   instructions.  */
+
+static void
+do_neon_ld_st_interleave (void)
+{
+  struct neon_type_el et = neon_check_type (1, NS_NULL,
+					    N_8 | N_16 | N_32 | N_64);
+  unsigned alignbits = 0;
+  unsigned idx;
+  /* The bits in this table go:
+     0: register stride of one (0) or two (1)
+     1,2: register list length, minus one (1, 2, 3, 4).
+     3,4: <n> in instruction type, minus one (VLD<n> / VST<n>).
+     We use -1 for invalid entries.  */
+  const int typetable[] =
+    {
+      0x7,  -1, 0xa,  -1, 0x6,  -1, 0x2,  -1, /* VLD1 / VST1.  */
+       -1,  -1, 0x8, 0x9,  -1,  -1, 0x3,  -1, /* VLD2 / VST2.  */
+       -1,  -1,  -1,  -1, 0x4, 0x5,  -1,  -1, /* VLD3 / VST3.  */
+       -1,  -1,  -1,  -1,  -1,  -1, 0x0, 0x1  /* VLD4 / VST4.  */
+    };
+  int typebits;
+
+  if (et.type == NT_invtype)
+    return;
+
+  if (inst.operands[1].immisalign)
+    switch (inst.operands[1].imm >> 8)
+      {
+      case 64: alignbits = 1; break;
+      case 128:
+	if (NEON_REGLIST_LENGTH (inst.operands[0].imm) != 2
+	    && NEON_REGLIST_LENGTH (inst.operands[0].imm) != 4)
+	  goto bad_alignment;
+	alignbits = 2;
+	break;
+      case 256:
+	if (NEON_REGLIST_LENGTH (inst.operands[0].imm) != 4)
+	  goto bad_alignment;
+	alignbits = 3;
+	break;
+      default:
+      bad_alignment:
+	first_error (_("bad alignment"));
+	return;
+      }
+
+  inst.instruction |= alignbits << 4;
+  inst.instruction |= neon_logbits (et.size) << 6;
+
+  /* Bits [4:6] of the immediate in a list specifier encode register stride
+     (minus 1) in bit 4, and list length in bits [5:6]. We put the <n> of
+     VLD<n>/VST<n> in bits [9:8] of the initial bitmask. Suck it out here, look
+     up the right value for "type" in a table based on this value and the given
+     list style, then stick it back.  */
+  idx = ((inst.operands[0].imm >> 4) & 7)
+	| (((inst.instruction >> 8) & 3) << 3);
+
+  typebits = typetable[idx];
+
+  constraint (typebits == -1, _("bad list type for instruction"));
+  constraint (((inst.instruction >> 8) & 3) && et.size == 64,
+	      _("bad element type for instruction"));
+
+  inst.instruction &= ~0xf00;
+  inst.instruction |= typebits << 8;
+}
+
+/* Check alignment is valid for do_neon_ld_st_lane and do_neon_ld_dup.
+   *DO_ALIGN is set to 1 if the relevant alignment bit should be set, 0
+   otherwise. The variable arguments are a list of pairs of legal (size, align)
+   values, terminated with -1.  */
+
+static int
+neon_alignment_bit (int size, int align, int *do_align, ...)
+{
+  va_list ap;
+  int result = FAIL, thissize, thisalign;
+
+  if (!inst.operands[1].immisalign)
+    {
+      *do_align = 0;
+      return SUCCESS;
+    }
+
+  va_start (ap, do_align);
+
+  do
+    {
+      thissize = va_arg (ap, int);
+      if (thissize == -1)
+	break;
+      thisalign = va_arg (ap, int);
+
+      if (size == thissize && align == thisalign)
+	result = SUCCESS;
+    }
+  while (result != SUCCESS);
+
+  va_end (ap);
+
+  if (result == SUCCESS)
+    *do_align = 1;
+  else
+    first_error (_("unsupported alignment for instruction"));
+
+  return result;
+}
+
+static void
+do_neon_ld_st_lane (void)
+{
+  struct neon_type_el et = neon_check_type (1, NS_NULL, N_8 | N_16 | N_32);
+  int align_good, do_align = 0;
+  int logsize = neon_logbits (et.size);
+  int align = inst.operands[1].imm >> 8;
+  int n = (inst.instruction >> 8) & 3;
+  int max_el = 64 / et.size;
+
+  if (et.type == NT_invtype)
+    return;
+
+  constraint (NEON_REGLIST_LENGTH (inst.operands[0].imm) != n + 1,
+	      _("bad list length"));
+  constraint (NEON_LANE (inst.operands[0].imm) >= max_el,
+	      _("scalar index out of range"));
+  constraint (n != 0 && NEON_REG_STRIDE (inst.operands[0].imm) == 2
+	      && et.size == 8,
+	      _("stride of 2 unavailable when element size is 8"));
+
+  switch (n)
+    {
+    case 0:  /* VLD1 / VST1.  */
+      align_good = neon_alignment_bit (et.size, align, &do_align, 16, 16,
+				       32, 32, -1);
+      if (align_good == FAIL)
+	return;
+      if (do_align)
+	{
+	  unsigned alignbits = 0;
+	  switch (et.size)
+	    {
+	    case 16: alignbits = 0x1; break;
+	    case 32: alignbits = 0x3; break;
+	    default: ;
+	    }
+	  inst.instruction |= alignbits << 4;
+	}
+      break;
+
+    case 1:  /* VLD2 / VST2.  */
+      align_good = neon_alignment_bit (et.size, align, &do_align, 8, 16, 16, 32,
+				       32, 64, -1);
+      if (align_good == FAIL)
+	return;
+      if (do_align)
+	inst.instruction |= 1 << 4;
+      break;
+
+    case 2:  /* VLD3 / VST3.  */
+      constraint (inst.operands[1].immisalign,
+		  _("can't use alignment with this instruction"));
+      break;
+
+    case 3:  /* VLD4 / VST4.  */
+      align_good = neon_alignment_bit (et.size, align, &do_align, 8, 32,
+				       16, 64, 32, 64, 32, 128, -1);
+      if (align_good == FAIL)
+	return;
+      if (do_align)
+	{
+	  unsigned alignbits = 0;
+	  switch (et.size)
+	    {
+	    case 8:  alignbits = 0x1; break;
+	    case 16: alignbits = 0x1; break;
+	    case 32: alignbits = (align == 64) ? 0x1 : 0x2; break;
+	    default: ;
+	    }
+	  inst.instruction |= alignbits << 4;
+	}
+      break;
+
+    default: ;
+    }
+
+  /* Reg stride of 2 is encoded in bit 5 when size==16, bit 6 when size==32.  */
+  if (n != 0 && NEON_REG_STRIDE (inst.operands[0].imm) == 2)
+    inst.instruction |= 1 << (4 + logsize);
+
+  inst.instruction |= NEON_LANE (inst.operands[0].imm) << (logsize + 5);
+  inst.instruction |= logsize << 10;
+}
+
+/* Encode single n-element structure to all lanes VLD<n> instructions.  */
+
+static void
+do_neon_ld_dup (void)
+{
+  struct neon_type_el et = neon_check_type (1, NS_NULL, N_8 | N_16 | N_32);
+  int align_good, do_align = 0;
+
+  if (et.type == NT_invtype)
+    return;
+
+  switch ((inst.instruction >> 8) & 3)
+    {
+    case 0:  /* VLD1.  */
+      gas_assert (NEON_REG_STRIDE (inst.operands[0].imm) != 2);
+      align_good = neon_alignment_bit (et.size, inst.operands[1].imm >> 8,
+				       &do_align, 16, 16, 32, 32, -1);
+      if (align_good == FAIL)
+	return;
+      switch (NEON_REGLIST_LENGTH (inst.operands[0].imm))
+	{
+	case 1: break;
+	case 2: inst.instruction |= 1 << 5; break;
+	default: first_error (_("bad list length")); return;
+	}
+      inst.instruction |= neon_logbits (et.size) << 6;
+      break;
+
+    case 1:  /* VLD2.  */
+      align_good = neon_alignment_bit (et.size, inst.operands[1].imm >> 8,
+				       &do_align, 8, 16, 16, 32, 32, 64, -1);
+      if (align_good == FAIL)
+	return;
+      constraint (NEON_REGLIST_LENGTH (inst.operands[0].imm) != 2,
+		  _("bad list length"));
+      if (NEON_REG_STRIDE (inst.operands[0].imm) == 2)
+	inst.instruction |= 1 << 5;
+      inst.instruction |= neon_logbits (et.size) << 6;
+      break;
+
+    case 2:  /* VLD3.  */
+      constraint (inst.operands[1].immisalign,
+		  _("can't use alignment with this instruction"));
+      constraint (NEON_REGLIST_LENGTH (inst.operands[0].imm) != 3,
+		  _("bad list length"));
+      if (NEON_REG_STRIDE (inst.operands[0].imm) == 2)
+	inst.instruction |= 1 << 5;
+      inst.instruction |= neon_logbits (et.size) << 6;
+      break;
+
+    case 3:  /* VLD4.  */
+      {
+	int align = inst.operands[1].imm >> 8;
+	align_good = neon_alignment_bit (et.size, align, &do_align, 8, 32,
+					 16, 64, 32, 64, 32, 128, -1);
+	if (align_good == FAIL)
+	  return;
+	constraint (NEON_REGLIST_LENGTH (inst.operands[0].imm) != 4,
+		    _("bad list length"));
+	if (NEON_REG_STRIDE (inst.operands[0].imm) == 2)
+	  inst.instruction |= 1 << 5;
+	if (et.size == 32 && align == 128)
+	  inst.instruction |= 0x3 << 6;
+	else
+	  inst.instruction |= neon_logbits (et.size) << 6;
+      }
+      break;
+
+    default: ;
+    }
+
+  inst.instruction |= do_align << 4;
+}
+
+/* Disambiguate VLD<n> and VST<n> instructions, and fill in common bits (those
+   apart from bits [11:4].  */
+
+static void
+do_neon_ldx_stx (void)
+{
+  if (inst.operands[1].isreg)
+    constraint (inst.operands[1].reg == REG_PC, BAD_PC);
+
+  switch (NEON_LANE (inst.operands[0].imm))
+    {
+    case NEON_INTERLEAVE_LANES:
+      NEON_ENCODE (INTERLV, inst);
+      do_neon_ld_st_interleave ();
+      break;
+
+    case NEON_ALL_LANES:
+      NEON_ENCODE (DUP, inst);
+      if (inst.instruction == N_INV)
+	{
+	  first_error ("only loads support such operands");
+	  break;
+	}
+      do_neon_ld_dup ();
+      break;
+
+    default:
+      NEON_ENCODE (LANE, inst);
+      do_neon_ld_st_lane ();
+    }
+
+  /* L bit comes from bit mask.  */
+  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
+  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
+  inst.instruction |= inst.operands[1].reg << 16;
+
+  if (inst.operands[1].postind)
+    {
+      int postreg = inst.operands[1].imm & 0xf;
+      constraint (!inst.operands[1].immisreg,
+		  _("post-index must be a register"));
+      constraint (postreg == 0xd || postreg == 0xf,
+		  _("bad register for post-index"));
+      inst.instruction |= postreg;
+    }
+  else
+    {
+      constraint (inst.operands[1].immisreg, BAD_ADDR_MODE);
+      constraint (inst.reloc.exp.X_op != O_constant
+		  || inst.reloc.exp.X_add_number != 0,
+		  BAD_ADDR_MODE);
+
+      if (inst.operands[1].writeback)
+	{
+	  inst.instruction |= 0xd;
+	}
+      else
+	inst.instruction |= 0xf;
+    }
+
+  if (thumb_mode)
+    inst.instruction |= 0xf9000000;
+  else
+    inst.instruction |= 0xf4000000;
+}
+
+/* FP v8.  */
+static void
+do_vfp_nsyn_fpv8 (enum neon_shape rs)
+{
+  /* Targets like FPv5-SP-D16 don't support FP v8 instructions with
+     D register operands.  */
+  if (neon_shape_class[rs] == SC_DOUBLE)
+    constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_armv8),
+		_(BAD_FPU));
+
+  NEON_ENCODE (FPV8, inst);
+
+  if (rs == NS_FFF)
+    do_vfp_sp_dyadic ();
+  else
+    do_vfp_dp_rd_rn_rm ();
+
+  if (rs == NS_DDD)
+    inst.instruction |= 0x100;
+
+  inst.instruction |= 0xf0000000;
+}
+
+static void
+do_vsel (void)
+{
+  set_it_insn_type (OUTSIDE_IT_INSN);
+
+  if (try_vfp_nsyn (3, do_vfp_nsyn_fpv8) != SUCCESS)
+    first_error (_("invalid instruction shape"));
+}
+
+static void
+do_vmaxnm (void)
+{
+  set_it_insn_type (OUTSIDE_IT_INSN);
+
+  if (try_vfp_nsyn (3, do_vfp_nsyn_fpv8) == SUCCESS)
+    return;
+
+  if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH8) == FAIL)
+    return;
+
+  neon_dyadic_misc (NT_untyped, N_F32, 0);
+}
+
+static void
+do_vrint_1 (enum neon_cvt_mode mode)
+{
+  enum neon_shape rs = neon_select_shape (NS_FF, NS_DD, NS_QQ, NS_NULL);
+  struct neon_type_el et;
+
+  if (rs == NS_NULL)
+    return;
+
+  /* Targets like FPv5-SP-D16 don't support FP v8 instructions with
+     D register operands.  */
+  if (neon_shape_class[rs] == SC_DOUBLE)
+    constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_armv8),
+		_(BAD_FPU));
+
+  et = neon_check_type (2, rs, N_EQK | N_VFP, N_F32 | N_F64 | N_KEY | N_VFP);
+  if (et.type != NT_invtype)
+    {
+      /* VFP encodings.  */
+      if (mode == neon_cvt_mode_a || mode == neon_cvt_mode_n
+	  || mode == neon_cvt_mode_p || mode == neon_cvt_mode_m)
+	set_it_insn_type (OUTSIDE_IT_INSN);
+
+      NEON_ENCODE (FPV8, inst);
+      if (rs == NS_FF)
+	do_vfp_sp_monadic ();
+      else
+	do_vfp_dp_rd_rm ();
+
+      switch (mode)
+	{
+	case neon_cvt_mode_r: inst.instruction |= 0x00000000; break;
+	case neon_cvt_mode_z: inst.instruction |= 0x00000080; break;
+	case neon_cvt_mode_x: inst.instruction |= 0x00010000; break;
+	case neon_cvt_mode_a: inst.instruction |= 0xf0000000; break;
+	case neon_cvt_mode_n: inst.instruction |= 0xf0010000; break;
+	case neon_cvt_mode_p: inst.instruction |= 0xf0020000; break;
+	case neon_cvt_mode_m: inst.instruction |= 0xf0030000; break;
+	default: abort ();
+	}
+
+      inst.instruction |= (rs == NS_DD) << 8;
+      do_vfp_cond_or_thumb ();
+    }
+  else
+    {
+      /* Neon encodings (or something broken...).  */
+      inst.error = NULL;
+      et = neon_check_type (2, rs, N_EQK, N_F32 | N_KEY);
+
+      if (et.type == NT_invtype)
+	return;
+
+      set_it_insn_type (OUTSIDE_IT_INSN);
+      NEON_ENCODE (FLOAT, inst);
+
+      if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH8) == FAIL)
+	return;
+
+      inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
+      inst.instruction |= HI1 (inst.operands[0].reg) << 22;
+      inst.instruction |= LOW4 (inst.operands[1].reg);
+      inst.instruction |= HI1 (inst.operands[1].reg) << 5;
+      inst.instruction |= neon_quad (rs) << 6;
+      switch (mode)
+	{
+	case neon_cvt_mode_z: inst.instruction |= 3 << 7; break;
+	case neon_cvt_mode_x: inst.instruction |= 1 << 7; break;
+	case neon_cvt_mode_a: inst.instruction |= 2 << 7; break;
+	case neon_cvt_mode_n: inst.instruction |= 0 << 7; break;
+	case neon_cvt_mode_p: inst.instruction |= 7 << 7; break;
+	case neon_cvt_mode_m: inst.instruction |= 5 << 7; break;
+	case neon_cvt_mode_r: inst.error = _("invalid rounding mode"); break;
+	default: abort ();
+	}
+
+      if (thumb_mode)
+	inst.instruction |= 0xfc000000;
+      else
+	inst.instruction |= 0xf0000000;
+    }
+}
+
+static void
+do_vrintx (void)
+{
+  do_vrint_1 (neon_cvt_mode_x);
+}
+
+static void
+do_vrintz (void)
+{
+  do_vrint_1 (neon_cvt_mode_z);
+}
+
+static void
+do_vrintr (void)
+{
+  do_vrint_1 (neon_cvt_mode_r);
+}
+
+static void
+do_vrinta (void)
+{
+  do_vrint_1 (neon_cvt_mode_a);
+}
+
+static void
+do_vrintn (void)
+{
+  do_vrint_1 (neon_cvt_mode_n);
+}
+
+static void
+do_vrintp (void)
+{
+  do_vrint_1 (neon_cvt_mode_p);
+}
+
+static void
+do_vrintm (void)
+{
+  do_vrint_1 (neon_cvt_mode_m);
+}
+
+/* Crypto v1 instructions.  */
+static void
+do_crypto_2op_1 (unsigned elttype, int op)
+{
+  set_it_insn_type (OUTSIDE_IT_INSN);
+
+  if (neon_check_type (2, NS_QQ, N_EQK | N_UNT, elttype | N_UNT | N_KEY).type
+      == NT_invtype)
+    return;
+
+  inst.error = NULL;
+
+  NEON_ENCODE (INTEGER, inst);
+  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;
+  inst.instruction |= HI1 (inst.operands[0].reg) << 22;
+  inst.instruction |= LOW4 (inst.operands[1].reg);
+  inst.instruction |= HI1 (inst.operands[1].reg) << 5;
+  if (op != -1)
+    inst.instruction |= op << 6;
+
+  if (thumb_mode)
+    inst.instruction |= 0xfc000000;
+  else
+    inst.instruction |= 0xf0000000;
+}
+
+static void
+do_crypto_3op_1 (int u, int op)
+{
+  set_it_insn_type (OUTSIDE_IT_INSN);
+
+  if (neon_check_type (3, NS_QQQ, N_EQK | N_UNT, N_EQK | N_UNT,
+		       N_32 | N_UNT | N_KEY).type == NT_invtype)
+    return;
+
+  inst.error = NULL;
+
+  NEON_ENCODE (INTEGER, inst);
+  neon_three_same (1, u, 8 << op);
+}
+
+static void
+do_aese (void)
+{
+  do_crypto_2op_1 (N_8, 0);
+}
+
+static void
+do_aesd (void)
+{
+  do_crypto_2op_1 (N_8, 1);
+}
+
+static void
+do_aesmc (void)
+{
+  do_crypto_2op_1 (N_8, 2);
+}
+
+static void
+do_aesimc (void)
+{
+  do_crypto_2op_1 (N_8, 3);
+}
+
+static void
+do_sha1c (void)
+{
+  do_crypto_3op_1 (0, 0);
+}
+
+static void
+do_sha1p (void)
+{
+  do_crypto_3op_1 (0, 1);
+}
+
+static void
+do_sha1m (void)
+{
+  do_crypto_3op_1 (0, 2);
+}
+
+static void
+do_sha1su0 (void)
+{
+  do_crypto_3op_1 (0, 3);
+}
+
+static void
+do_sha256h (void)
+{
+  do_crypto_3op_1 (1, 0);
+}
+
+static void
+do_sha256h2 (void)
+{
+  do_crypto_3op_1 (1, 1);
+}
+
+static void
+do_sha256su1 (void)
+{
+  do_crypto_3op_1 (1, 2);
+}
+
+static void
+do_sha1h (void)
+{
+  do_crypto_2op_1 (N_32, -1);
+}
+
+static void
+do_sha1su1 (void)
+{
+  do_crypto_2op_1 (N_32, 0);
+}
+
+static void
+do_sha256su0 (void)
+{
+  do_crypto_2op_1 (N_32, 1);
+}
+
+static void
+do_crc32_1 (unsigned int poly, unsigned int sz)
+{
+  unsigned int Rd = inst.operands[0].reg;
+  unsigned int Rn = inst.operands[1].reg;
+  unsigned int Rm = inst.operands[2].reg;
+
+  set_it_insn_type (OUTSIDE_IT_INSN);
+  inst.instruction |= LOW4 (Rd) << (thumb_mode ? 8 : 12);
+  inst.instruction |= LOW4 (Rn) << 16;
+  inst.instruction |= LOW4 (Rm);
+  inst.instruction |= sz << (thumb_mode ? 4 : 21);
+  inst.instruction |= poly << (thumb_mode ? 20 : 9);
+
+  if (Rd == REG_PC || Rn == REG_PC || Rm == REG_PC)
+    as_warn (UNPRED_REG ("r15"));
+  if (thumb_mode && (Rd == REG_SP || Rn == REG_SP || Rm == REG_SP))
+    as_warn (UNPRED_REG ("r13"));
+}
+
+static void
+do_crc32b (void)
+{
+  do_crc32_1 (0, 0);
+}
+
+static void
+do_crc32h (void)
+{
+  do_crc32_1 (0, 1);
+}
+
+static void
+do_crc32w (void)
+{
+  do_crc32_1 (0, 2);
+}
+
+static void
+do_crc32cb (void)
+{
+  do_crc32_1 (1, 0);
+}
+
+static void
+do_crc32ch (void)
+{
+  do_crc32_1 (1, 1);
+}
+
+static void
+do_crc32cw (void)
+{
+  do_crc32_1 (1, 2);
+}
+
+
+/* Overall per-instruction processing.	*/
+
+/* We need to be able to fix up arbitrary expressions in some statements.
+   This is so that we can handle symbols that are an arbitrary distance from
+   the pc.  The most common cases are of the form ((+/-sym -/+ . - 8) & mask),
+   which returns part of an address in a form which will be valid for
+   a data instruction.	We do this by pushing the expression into a symbol
+   in the expr_section, and creating a fix for that.  */
+
+static void
+fix_new_arm (fragS *	   frag,
+	     int	   where,
+	     short int	   size,
+	     expressionS * exp,
+	     int	   pc_rel,
+	     int	   reloc)
+{
+  fixS *	   new_fix;
+
+  switch (exp->X_op)
+    {
+    case O_constant:
+      if (pc_rel)
+	{
+	  /* Create an absolute valued symbol, so we have something to
+	     refer to in the object file.  Unfortunately for us, gas's
+	     generic expression parsing will already have folded out
+	     any use of .set foo/.type foo %function that may have
+	     been used to set type information of the target location,
+	     that's being specified symbolically.  We have to presume
+	     the user knows what they are doing.  */
+	  char name[16 + 8];
+	  symbolS *symbol;
+
+	  sprintf (name, "*ABS*0x%lx", (unsigned long)exp->X_add_number);
+
+	  symbol = symbol_find_or_make (name);
+	  S_SET_SEGMENT (symbol, absolute_section);
+	  symbol_set_frag (symbol, &zero_address_frag);
+	  S_SET_VALUE (symbol, exp->X_add_number);
+	  exp->X_op = O_symbol;
+	  exp->X_add_symbol = symbol;
+	  exp->X_add_number = 0;
+	}
+      /* FALLTHROUGH */
+    case O_symbol:
+    case O_add:
+    case O_subtract:
+      new_fix = fix_new_exp (frag, where, size, exp, pc_rel,
+			     (enum bfd_reloc_code_real) reloc);
+      break;
+
+    default:
+      new_fix = (fixS *) fix_new (frag, where, size, make_expr_symbol (exp), 0,
+				  pc_rel, (enum bfd_reloc_code_real) reloc);
+      break;
+    }
+
+  /* Mark whether the fix is to a THUMB instruction, or an ARM
+     instruction.  */
+  new_fix->tc_fix_data = thumb_mode;
+}
+
+/* Create a frg for an instruction requiring relaxation.  */
+static void
+output_relax_insn (void)
+{
+  char * to;
+  symbolS *sym;
+  int offset;
+
+  /* The size of the instruction is unknown, so tie the debug info to the
+     start of the instruction.  */
+  dwarf2_emit_insn (0);
+
+  switch (inst.reloc.exp.X_op)
+    {
+    case O_symbol:
+      sym = inst.reloc.exp.X_add_symbol;
+      offset = inst.reloc.exp.X_add_number;
+      break;
+    case O_constant:
+      sym = NULL;
+      offset = inst.reloc.exp.X_add_number;
+      break;
+    default:
+      sym = make_expr_symbol (&inst.reloc.exp);
+      offset = 0;
+      break;
+  }
+  to = frag_var (rs_machine_dependent, INSN_SIZE, THUMB_SIZE,
+		 inst.relax, sym, offset, NULL/*offset, opcode*/);
+  md_number_to_chars (to, inst.instruction, THUMB_SIZE);
+}
+
+/* Write a 32-bit thumb instruction to buf.  */
+static void
+put_thumb32_insn (char * buf, unsigned long insn)
+{
+  md_number_to_chars (buf, insn >> 16, THUMB_SIZE);
+  md_number_to_chars (buf + THUMB_SIZE, insn, THUMB_SIZE);
+}
+
+static void
+output_inst (const char * str)
+{
+  char * to = NULL;
+
+  if (inst.error)
+    {
+      as_bad ("%s -- `%s'", inst.error, str);
+      return;
+    }
+  if (inst.relax)
+    {
+      output_relax_insn ();
+      return;
+    }
+  if (inst.size == 0)
+    return;
+
+  to = frag_more (inst.size);
+  /* PR 9814: Record the thumb mode into the current frag so that we know
+     what type of NOP padding to use, if necessary.  We override any previous
+     setting so that if the mode has changed then the NOPS that we use will
+     match the encoding of the last instruction in the frag.  */
+  frag_now->tc_frag_data.thumb_mode = thumb_mode | MODE_RECORDED;
+
+  if (thumb_mode && (inst.size > THUMB_SIZE))
+    {
+      gas_assert (inst.size == (2 * THUMB_SIZE));
+      put_thumb32_insn (to, inst.instruction);
+    }
+  else if (inst.size > INSN_SIZE)
+    {
+      gas_assert (inst.size == (2 * INSN_SIZE));
+      md_number_to_chars (to, inst.instruction, INSN_SIZE);
+      md_number_to_chars (to + INSN_SIZE, inst.instruction, INSN_SIZE);
+    }
+  else
+    md_number_to_chars (to, inst.instruction, inst.size);
+
+  if (inst.reloc.type != BFD_RELOC_UNUSED)
+    fix_new_arm (frag_now, to - frag_now->fr_literal,
+		 inst.size, & inst.reloc.exp, inst.reloc.pc_rel,
+		 inst.reloc.type);
+
+  dwarf2_emit_insn (inst.size);
+}
+
+static char *
+output_it_inst (int cond, int mask, char * to)
+{
+  unsigned long instruction = 0xbf00;
+
+  mask &= 0xf;
+  instruction |= mask;
+  instruction |= cond << 4;
+
+  if (to == NULL)
+    {
+      to = frag_more (2);
+#ifdef OBJ_ELF
+      dwarf2_emit_insn (2);
+#endif
+    }
+
+  md_number_to_chars (to, instruction, 2);
+
+  return to;
+}
+
+/* Tag values used in struct asm_opcode's tag field.  */
+enum opcode_tag
+{
+  OT_unconditional,	/* Instruction cannot be conditionalized.
+			   The ARM condition field is still 0xE.  */
+  OT_unconditionalF,	/* Instruction cannot be conditionalized
+			   and carries 0xF in its ARM condition field.  */
+  OT_csuffix,		/* Instruction takes a conditional suffix.  */
+  OT_csuffixF,		/* Some forms of the instruction take a conditional
+			   suffix, others place 0xF where the condition field
+			   would be.  */
+  OT_cinfix3,		/* Instruction takes a conditional infix,
+			   beginning at character index 3.  (In
+			   unified mode, it becomes a suffix.)  */
+  OT_cinfix3_deprecated, /* The same as OT_cinfix3.  This is used for
+			    tsts, cmps, cmns, and teqs. */
+  OT_cinfix3_legacy,	/* Legacy instruction takes a conditional infix at
+			   character index 3, even in unified mode.  Used for
+			   legacy instructions where suffix and infix forms
+			   may be ambiguous.  */
+  OT_csuf_or_in3,	/* Instruction takes either a conditional
+			   suffix or an infix at character index 3.  */
+  OT_odd_infix_unc,	/* This is the unconditional variant of an
+			   instruction that takes a conditional infix
+			   at an unusual position.  In unified mode,
+			   this variant will accept a suffix.  */
+  OT_odd_infix_0	/* Values greater than or equal to OT_odd_infix_0
+			   are the conditional variants of instructions that
+			   take conditional infixes in unusual positions.
+			   The infix appears at character index
+			   (tag - OT_odd_infix_0).  These are not accepted
+			   in unified mode.  */
+};
+
+/* Subroutine of md_assemble, responsible for looking up the primary
+   opcode from the mnemonic the user wrote.  STR points to the
+   beginning of the mnemonic.
+
+   This is not simply a hash table lookup, because of conditional
+   variants.  Most instructions have conditional variants, which are
+   expressed with a _conditional affix_ to the mnemonic.  If we were
+   to encode each conditional variant as a literal string in the opcode
+   table, it would have approximately 20,000 entries.
+
+   Most mnemonics take this affix as a suffix, and in unified syntax,
+   'most' is upgraded to 'all'.  However, in the divided syntax, some
+   instructions take the affix as an infix, notably the s-variants of
+   the arithmetic instructions.  Of those instructions, all but six
+   have the infix appear after the third character of the mnemonic.
+
+   Accordingly, the algorithm for looking up primary opcodes given
+   an identifier is:
+
+   1. Look up the identifier in the opcode table.
+      If we find a match, go to step U.
+
+   2. Look up the last two characters of the identifier in the
+      conditions table.  If we find a match, look up the first N-2
+      characters of the identifier in the opcode table.  If we
+      find a match, go to step CE.
+
+   3. Look up the fourth and fifth characters of the identifier in
+      the conditions table.  If we find a match, extract those
+      characters from the identifier, and look up the remaining
+      characters in the opcode table.  If we find a match, go
+      to step CM.
+
+   4. Fail.
+
+   U. Examine the tag field of the opcode structure, in case this is
+      one of the six instructions with its conditional infix in an
+      unusual place.  If it is, the tag tells us where to find the
+      infix; look it up in the conditions table and set inst.cond
+      accordingly.  Otherwise, this is an unconditional instruction.
+      Again set inst.cond accordingly.  Return the opcode structure.
+
+  CE. Examine the tag field to make sure this is an instruction that
+      should receive a conditional suffix.  If it is not, fail.
+      Otherwise, set inst.cond from the suffix we already looked up,
+      and return the opcode structure.
+
+  CM. Examine the tag field to make sure this is an instruction that
+      should receive a conditional infix after the third character.
+      If it is not, fail.  Otherwise, undo the edits to the current
+      line of input and proceed as for case CE.  */
+
+static const struct asm_opcode *
+opcode_lookup (char **str)
+{
+  char *end, *base;
+  char *affix;
+  const struct asm_opcode *opcode;
+  const struct asm_cond *cond;
+  char save[2];
+
+  /* Scan up to the end of the mnemonic, which must end in white space,
+     '.' (in unified mode, or for Neon/VFP instructions), or end of string.  */
+  for (base = end = *str; *end != '\0'; end++)
+    if (*end == ' ' || *end == '.')
+      break;
+
+  if (end == base)
+    return NULL;
+
+  /* Handle a possible width suffix and/or Neon type suffix.  */
+  if (end[0] == '.')
+    {
+      int offset = 2;
+
+      /* The .w and .n suffixes are only valid if the unified syntax is in
+	 use.  */
+      if (unified_syntax && end[1] == 'w')
+	inst.size_req = 4;
+      else if (unified_syntax && end[1] == 'n')
+	inst.size_req = 2;
+      else
+	offset = 0;
+
+      inst.vectype.elems = 0;
+
+      *str = end + offset;
+
+      if (end[offset] == '.')
+	{
+	  /* See if we have a Neon type suffix (possible in either unified or
+	     non-unified ARM syntax mode).  */
+	  if (parse_neon_type (&inst.vectype, str) == FAIL)
+	    return NULL;
+	}
+      else if (end[offset] != '\0' && end[offset] != ' ')
+	return NULL;
+    }
+  else
+    *str = end;
+
+  /* Look for unaffixed or special-case affixed mnemonic.  */
+  opcode = (const struct asm_opcode *) hash_find_n (arm_ops_hsh, base,
+						    end - base);
+  if (opcode)
+    {
+      /* step U */
+      if (opcode->tag < OT_odd_infix_0)
+	{
+	  inst.cond = COND_ALWAYS;
+	  return opcode;
+	}
+
+      if (warn_on_deprecated && unified_syntax)
+	as_tsktsk (_("conditional infixes are deprecated in unified syntax"));
+      affix = base + (opcode->tag - OT_odd_infix_0);
+      cond = (const struct asm_cond *) hash_find_n (arm_cond_hsh, affix, 2);
+      gas_assert (cond);
+
+      inst.cond = cond->value;
+      return opcode;
+    }
+
+  /* Cannot have a conditional suffix on a mnemonic of less than two
+     characters.  */
+  if (end - base < 3)
+    return NULL;
+
+  /* Look for suffixed mnemonic.  */
+  affix = end - 2;
+  cond = (const struct asm_cond *) hash_find_n (arm_cond_hsh, affix, 2);
+  opcode = (const struct asm_opcode *) hash_find_n (arm_ops_hsh, base,
+						    affix - base);
+  if (opcode && cond)
+    {
+      /* step CE */
+      switch (opcode->tag)
+	{
+	case OT_cinfix3_legacy:
+	  /* Ignore conditional suffixes matched on infix only mnemonics.  */
+	  break;
+
+	case OT_cinfix3:
+	case OT_cinfix3_deprecated:
+	case OT_odd_infix_unc:
+	  if (!unified_syntax)
+	    return 0;
+	  /* else fall through */
+
+	case OT_csuffix:
+	case OT_csuffixF:
+	case OT_csuf_or_in3:
+	  inst.cond = cond->value;
+	  return opcode;
+
+	case OT_unconditional:
+	case OT_unconditionalF:
+	  if (thumb_mode)
+	    inst.cond = cond->value;
+	  else
+	    {
+	      /* Delayed diagnostic.  */
+	      inst.error = BAD_COND;
+	      inst.cond = COND_ALWAYS;
+	    }
+	  return opcode;
+
+	default:
+	  return NULL;
+	}
+    }
+
+  /* Cannot have a usual-position infix on a mnemonic of less than
+     six characters (five would be a suffix).  */
+  if (end - base < 6)
+    return NULL;
+
+  /* Look for infixed mnemonic in the usual position.  */
+  affix = base + 3;
+  cond = (const struct asm_cond *) hash_find_n (arm_cond_hsh, affix, 2);
+  if (!cond)
+    return NULL;
+
+  memcpy (save, affix, 2);
+  memmove (affix, affix + 2, (end - affix) - 2);
+  opcode = (const struct asm_opcode *) hash_find_n (arm_ops_hsh, base,
+						    (end - base) - 2);
+  memmove (affix + 2, affix, (end - affix) - 2);
+  memcpy (affix, save, 2);
+
+  if (opcode
+      && (opcode->tag == OT_cinfix3
+	  || opcode->tag == OT_cinfix3_deprecated
+	  || opcode->tag == OT_csuf_or_in3
+	  || opcode->tag == OT_cinfix3_legacy))
+    {
+      /* Step CM.  */
+      if (warn_on_deprecated && unified_syntax
+	  && (opcode->tag == OT_cinfix3
+	      || opcode->tag == OT_cinfix3_deprecated))
+	as_tsktsk (_("conditional infixes are deprecated in unified syntax"));
+
+      inst.cond = cond->value;
+      return opcode;
+    }
+
+  return NULL;
+}
+
+/* This function generates an initial IT instruction, leaving its block
+   virtually open for the new instructions. Eventually,
+   the mask will be updated by now_it_add_mask () each time
+   a new instruction needs to be included in the IT block.
+   Finally, the block is closed with close_automatic_it_block ().
+   The block closure can be requested either from md_assemble (),
+   a tencode (), or due to a label hook.  */
+
+static void
+new_automatic_it_block (int cond)
+{
+  now_it.state = AUTOMATIC_IT_BLOCK;
+  now_it.mask = 0x18;
+  now_it.cc = cond;
+  now_it.block_length = 1;
+  mapping_state (MAP_THUMB);
+  now_it.insn = output_it_inst (cond, now_it.mask, NULL);
+  now_it.warn_deprecated = FALSE;
+  now_it.insn_cond = TRUE;
+}
+
+/* Close an automatic IT block.
+   See comments in new_automatic_it_block ().  */
+
+static void
+close_automatic_it_block (void)
+{
+  now_it.mask = 0x10;
+  now_it.block_length = 0;
+}
+
+/* Update the mask of the current automatically-generated IT
+   instruction. See comments in new_automatic_it_block ().  */
+
+static void
+now_it_add_mask (int cond)
+{
+#define CLEAR_BIT(value, nbit)  ((value) & ~(1 << (nbit)))
+#define SET_BIT_VALUE(value, bitvalue, nbit)  (CLEAR_BIT (value, nbit) \
+					      | ((bitvalue) << (nbit)))
+  const int resulting_bit = (cond & 1);
+
+  now_it.mask &= 0xf;
+  now_it.mask = SET_BIT_VALUE (now_it.mask,
+				   resulting_bit,
+				  (5 - now_it.block_length));
+  now_it.mask = SET_BIT_VALUE (now_it.mask,
+				   1,
+				   ((5 - now_it.block_length) - 1) );
+  output_it_inst (now_it.cc, now_it.mask, now_it.insn);
+
+#undef CLEAR_BIT
+#undef SET_BIT_VALUE
+}
+
+/* The IT blocks handling machinery is accessed through the these functions:
+     it_fsm_pre_encode ()               from md_assemble ()
+     set_it_insn_type ()                optional, from the tencode functions
+     set_it_insn_type_last ()           ditto
+     in_it_block ()                     ditto
+     it_fsm_post_encode ()              from md_assemble ()
+     force_automatic_it_block_close ()  from label habdling functions
+
+   Rationale:
+     1) md_assemble () calls it_fsm_pre_encode () before calling tencode (),
+	initializing the IT insn type with a generic initial value depending
+	on the inst.condition.
+     2) During the tencode function, two things may happen:
+	a) The tencode function overrides the IT insn type by
+	   calling either set_it_insn_type (type) or set_it_insn_type_last ().
+	b) The tencode function queries the IT block state by
+	   calling in_it_block () (i.e. to determine narrow/not narrow mode).
+
+	Both set_it_insn_type and in_it_block run the internal FSM state
+	handling function (handle_it_state), because: a) setting the IT insn
+	type may incur in an invalid state (exiting the function),
+	and b) querying the state requires the FSM to be updated.
+	Specifically we want to avoid creating an IT block for conditional
+	branches, so it_fsm_pre_encode is actually a guess and we can't
+	determine whether an IT block is required until the tencode () routine
+	has decided what type of instruction this actually it.
+	Because of this, if set_it_insn_type and in_it_block have to be used,
+	set_it_insn_type has to be called first.
+
+	set_it_insn_type_last () is a wrapper of set_it_insn_type (type), that
+	determines the insn IT type depending on the inst.cond code.
+	When a tencode () routine encodes an instruction that can be
+	either outside an IT block, or, in the case of being inside, has to be
+	the last one, set_it_insn_type_last () will determine the proper
+	IT instruction type based on the inst.cond code. Otherwise,
+	set_it_insn_type can be called for overriding that logic or
+	for covering other cases.
+
+	Calling handle_it_state () may not transition the IT block state to
+	OUTSIDE_IT_BLOCK immediatelly, since the (current) state could be
+	still queried. Instead, if the FSM determines that the state should
+	be transitioned to OUTSIDE_IT_BLOCK, a flag is marked to be closed
+	after the tencode () function: that's what it_fsm_post_encode () does.
+
+	Since in_it_block () calls the state handling function to get an
+	updated state, an error may occur (due to invalid insns combination).
+	In that case, inst.error is set.
+	Therefore, inst.error has to be checked after the execution of
+	the tencode () routine.
+
+     3) Back in md_assemble(), it_fsm_post_encode () is called to commit
+	any pending state change (if any) that didn't take place in
+	handle_it_state () as explained above.  */
+
+static void
+it_fsm_pre_encode (void)
+{
+  if (inst.cond != COND_ALWAYS)
+    inst.it_insn_type = INSIDE_IT_INSN;
+  else
+    inst.it_insn_type = OUTSIDE_IT_INSN;
+
+  now_it.state_handled = 0;
+}
+
+/* IT state FSM handling function.  */
+
+static int
+handle_it_state (void)
+{
+  now_it.state_handled = 1;
+  now_it.insn_cond = FALSE;
+
+  switch (now_it.state)
+    {
+    case OUTSIDE_IT_BLOCK:
+      switch (inst.it_insn_type)
+	{
+	case OUTSIDE_IT_INSN:
+	  break;
+
+	case INSIDE_IT_INSN:
+	case INSIDE_IT_LAST_INSN:
+	  if (thumb_mode == 0)
+	    {
+	      if (unified_syntax
+		  && !(implicit_it_mode & IMPLICIT_IT_MODE_ARM))
+		as_tsktsk (_("Warning: conditional outside an IT block"\
+			     " for Thumb."));
+	    }
+	  else
+	    {
+	      if ((implicit_it_mode & IMPLICIT_IT_MODE_THUMB)
+		  && ARM_CPU_HAS_FEATURE (cpu_variant, arm_arch_t2))
+		{
+		  /* Automatically generate the IT instruction.  */
+		  new_automatic_it_block (inst.cond);
+		  if (inst.it_insn_type == INSIDE_IT_LAST_INSN)
+		    close_automatic_it_block ();
+		}
+	      else
+		{
+		  inst.error = BAD_OUT_IT;
+		  return FAIL;
+		}
+	    }
+	  break;
+
+	case IF_INSIDE_IT_LAST_INSN:
+	case NEUTRAL_IT_INSN:
+	  break;
+
+	case IT_INSN:
+	  now_it.state = MANUAL_IT_BLOCK;
+	  now_it.block_length = 0;
+	  break;
+	}
+      break;
+
+    case AUTOMATIC_IT_BLOCK:
+      /* Three things may happen now:
+	 a) We should increment current it block size;
+	 b) We should close current it block (closing insn or 4 insns);
+	 c) We should close current it block and start a new one (due
+	 to incompatible conditions or
+	 4 insns-length block reached).  */
+
+      switch (inst.it_insn_type)
+	{
+	case OUTSIDE_IT_INSN:
+	  /* The closure of the block shall happen immediatelly,
+	     so any in_it_block () call reports the block as closed.  */
+	  force_automatic_it_block_close ();
+	  break;
+
+	case INSIDE_IT_INSN:
+	case INSIDE_IT_LAST_INSN:
+	case IF_INSIDE_IT_LAST_INSN:
+	  now_it.block_length++;
+
+	  if (now_it.block_length > 4
+	      || !now_it_compatible (inst.cond))
+	    {
+	      force_automatic_it_block_close ();
+	      if (inst.it_insn_type != IF_INSIDE_IT_LAST_INSN)
+		new_automatic_it_block (inst.cond);
+	    }
+	  else
+	    {
+	      now_it.insn_cond = TRUE;
+	      now_it_add_mask (inst.cond);
+	    }
+
+	  if (now_it.state == AUTOMATIC_IT_BLOCK
+	      && (inst.it_insn_type == INSIDE_IT_LAST_INSN
+		  || inst.it_insn_type == IF_INSIDE_IT_LAST_INSN))
+	    close_automatic_it_block ();
+	  break;
+
+	case NEUTRAL_IT_INSN:
+	  now_it.block_length++;
+	  now_it.insn_cond = TRUE;
+
+	  if (now_it.block_length > 4)
+	    force_automatic_it_block_close ();
+	  else
+	    now_it_add_mask (now_it.cc & 1);
+	  break;
+
+	case IT_INSN:
+	  close_automatic_it_block ();
+	  now_it.state = MANUAL_IT_BLOCK;
+	  break;
+	}
+      break;
+
+    case MANUAL_IT_BLOCK:
+      {
+	/* Check conditional suffixes.  */
+	const int cond = now_it.cc ^ ((now_it.mask >> 4) & 1) ^ 1;
+	int is_last;
+	now_it.mask <<= 1;
+	now_it.mask &= 0x1f;
+	is_last = (now_it.mask == 0x10);
+	now_it.insn_cond = TRUE;
+
+	switch (inst.it_insn_type)
+	  {
+	  case OUTSIDE_IT_INSN:
+	    inst.error = BAD_NOT_IT;
+	    return FAIL;
+
+	  case INSIDE_IT_INSN:
+	    if (cond != inst.cond)
+	      {
+		inst.error = BAD_IT_COND;
+		return FAIL;
+	      }
+	    break;
+
+	  case INSIDE_IT_LAST_INSN:
+	  case IF_INSIDE_IT_LAST_INSN:
+	    if (cond != inst.cond)
+	      {
+		inst.error = BAD_IT_COND;
+		return FAIL;
+	      }
+	    if (!is_last)
+	      {
+		inst.error = BAD_BRANCH;
+		return FAIL;
+	      }
+	    break;
+
+	  case NEUTRAL_IT_INSN:
+	    /* The BKPT instruction is unconditional even in an IT block.  */
+	    break;
+
+	  case IT_INSN:
+	    inst.error = BAD_IT_IT;
+	    return FAIL;
+	  }
+      }
+      break;
+    }
+
+  return SUCCESS;
+}
+
+struct depr_insn_mask
+{
+  unsigned long pattern;
+  unsigned long mask;
+  const char* description;
+};
+
+/* List of 16-bit instruction patterns deprecated in an IT block in
+   ARMv8.  */
+static const struct depr_insn_mask depr_it_insns[] = {
+  { 0xc000, 0xc000, N_("Short branches, Undefined, SVC, LDM/STM") },
+  { 0xb000, 0xb000, N_("Miscellaneous 16-bit instructions") },
+  { 0xa000, 0xb800, N_("ADR") },
+  { 0x4800, 0xf800, N_("Literal loads") },
+  { 0x4478, 0xf478, N_("Hi-register ADD, MOV, CMP, BX, BLX using pc") },
+  { 0x4487, 0xfc87, N_("Hi-register ADD, MOV, CMP using pc") },
+  /* NOTE: 0x00dd is not the real encoding, instead, it is the 'tvalue'
+     field in asm_opcode. 'tvalue' is used at the stage this check happen.  */
+  { 0x00dd, 0x7fff, N_("ADD/SUB sp, sp #imm") },
+  { 0, 0, NULL }
+};
+
+static void
+it_fsm_post_encode (void)
+{
+  int is_last;
+
+  if (!now_it.state_handled)
+    handle_it_state ();
+
+  if (now_it.insn_cond
+      && !now_it.warn_deprecated
+      && warn_on_deprecated
+      && ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v8))
+    {
+      if (inst.instruction >= 0x10000)
+	{
+	  as_tsktsk (_("IT blocks containing 32-bit Thumb instructions are "
+		     "deprecated in ARMv8"));
+	  now_it.warn_deprecated = TRUE;
+	}
+      else
+	{
+	  const struct depr_insn_mask *p = depr_it_insns;
+
+	  while (p->mask != 0)
+	    {
+	      if ((inst.instruction & p->mask) == p->pattern)
+		{
+		  as_tsktsk (_("IT blocks containing 16-bit Thumb instructions "
+			     "of the following class are deprecated in ARMv8: "
+			     "%s"), p->description);
+		  now_it.warn_deprecated = TRUE;
+		  break;
+		}
+
+	      ++p;
+	    }
+	}
+
+      if (now_it.block_length > 1)
+	{
+	  as_tsktsk (_("IT blocks containing more than one conditional "
+		     "instruction are deprecated in ARMv8"));
+	  now_it.warn_deprecated = TRUE;
+	}
+    }
+
+  is_last = (now_it.mask == 0x10);
+  if (is_last)
+    {
+      now_it.state = OUTSIDE_IT_BLOCK;
+      now_it.mask = 0;
+    }
+}
+
+static void
+force_automatic_it_block_close (void)
+{
+  if (now_it.state == AUTOMATIC_IT_BLOCK)
+    {
+      close_automatic_it_block ();
+      now_it.state = OUTSIDE_IT_BLOCK;
+      now_it.mask = 0;
+    }
+}
+
+static int
+in_it_block (void)
+{
+  if (!now_it.state_handled)
+    handle_it_state ();
+
+  return now_it.state != OUTSIDE_IT_BLOCK;
+}
+
+void
+md_assemble (char *str)
+{
+  char *p = str;
+  const struct asm_opcode * opcode;
+
+  /* Align the previous label if needed.  */
+  if (last_label_seen != NULL)
+    {
+      symbol_set_frag (last_label_seen, frag_now);
+      S_SET_VALUE (last_label_seen, (valueT) frag_now_fix ());
+      S_SET_SEGMENT (last_label_seen, now_seg);
+    }
+
+  memset (&inst, '\0', sizeof (inst));
+  inst.reloc.type = BFD_RELOC_UNUSED;
+
+  opcode = opcode_lookup (&p);
+  if (!opcode)
+    {
+      /* It wasn't an instruction, but it might be a register alias of
+	 the form alias .req reg, or a Neon .dn/.qn directive.  */
+      if (! create_register_alias (str, p)
+	  && ! create_neon_reg_alias (str, p))
+	as_bad (_("bad instruction `%s'"), str);
+
+      return;
+    }
+
+  if (warn_on_deprecated && opcode->tag == OT_cinfix3_deprecated)
+    as_tsktsk (_("s suffix on comparison instruction is deprecated"));
+
+  /* The value which unconditional instructions should have in place of the
+     condition field.  */
+  inst.uncond_value = (opcode->tag == OT_csuffixF) ? 0xf : -1;
+
+  if (thumb_mode)
+    {
+      arm_feature_set variant;
+
+      variant = cpu_variant;
+      /* Only allow coprocessor instructions on Thumb-2 capable devices.  */
+      if (!ARM_CPU_HAS_FEATURE (variant, arm_arch_t2))
+	ARM_CLEAR_FEATURE (variant, variant, fpu_any_hard);
+      /* Check that this instruction is supported for this CPU.  */
+      if (!opcode->tvariant
+	  || (thumb_mode == 1
+	      && !ARM_CPU_HAS_FEATURE (variant, *opcode->tvariant)))
+	{
+	  as_bad (_("selected processor does not support `%s' in Thumb mode"), str);
+	  return;
+	}
+      if (inst.cond != COND_ALWAYS && !unified_syntax
+	  && opcode->tencode != do_t_branch)
+	{
+	  as_bad (_("Thumb does not support conditional execution"));
+	  return;
+	}
+
+      if (!ARM_CPU_HAS_FEATURE (variant, arm_ext_v6t2))
+	{
+	  if (opcode->tencode != do_t_blx && opcode->tencode != do_t_branch23
+	      && !(ARM_CPU_HAS_FEATURE(*opcode->tvariant, arm_ext_msr)
+		   || ARM_CPU_HAS_FEATURE(*opcode->tvariant, arm_ext_barrier)))
+	    {
+	      /* Two things are addressed here.
+		 1) Implicit require narrow instructions on Thumb-1.
+		    This avoids relaxation accidentally introducing Thumb-2
+		     instructions.
+		 2) Reject wide instructions in non Thumb-2 cores.  */
+	      if (inst.size_req == 0)
+		inst.size_req = 2;
+	      else if (inst.size_req == 4)
+		{
+		  as_bad (_("selected processor does not support `%s' in Thumb-2 mode"), str);
+		  return;
+		}
+	    }
+	}
+
+      inst.instruction = opcode->tvalue;
+
+      if (!parse_operands (p, opcode->operands, /*thumb=*/TRUE))
+	{
+	  /* Prepare the it_insn_type for those encodings that don't set
+	     it.  */
+	  it_fsm_pre_encode ();
+
+	  opcode->tencode ();
+
+	  it_fsm_post_encode ();
+	}
+
+      if (!(inst.error || inst.relax))
+	{
+	  gas_assert (inst.instruction < 0xe800 || inst.instruction > 0xffff);
+	  inst.size = (inst.instruction > 0xffff ? 4 : 2);
+	  if (inst.size_req && inst.size_req != inst.size)
+	    {
+	      as_bad (_("cannot honor width suffix -- `%s'"), str);
+	      return;
+	    }
+	}
+
+      /* Something has gone badly wrong if we try to relax a fixed size
+	 instruction.  */
+      gas_assert (inst.size_req == 0 || !inst.relax);
+
+      ARM_MERGE_FEATURE_SETS (thumb_arch_used, thumb_arch_used,
+			      *opcode->tvariant);
+      /* Many Thumb-2 instructions also have Thumb-1 variants, so explicitly
+	 set those bits when Thumb-2 32-bit instructions are seen.  ie.
+	 anything other than bl/blx and v6-M instructions.
+	 The impact of relaxable instructions will be considered later after we
+	 finish all relaxation.  */
+      if ((inst.size == 4 && (inst.instruction & 0xf800e800) != 0xf000e800)
+	  && !(ARM_CPU_HAS_FEATURE (*opcode->tvariant, arm_ext_msr)
+	       || ARM_CPU_HAS_FEATURE (*opcode->tvariant, arm_ext_barrier)))
+	ARM_MERGE_FEATURE_SETS (thumb_arch_used, thumb_arch_used,
+				arm_ext_v6t2);
+
+      check_neon_suffixes;
+
+      if (!inst.error)
+	{
+	  mapping_state (MAP_THUMB);
+	}
+    }
+  else if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v1))
+    {
+      bfd_boolean is_bx;
+
+      /* bx is allowed on v5 cores, and sometimes on v4 cores.  */
+      is_bx = (opcode->aencode == do_bx);
+
+      /* Check that this instruction is supported for this CPU.  */
+      if (!(is_bx && fix_v4bx)
+	  && !(opcode->avariant &&
+	       ARM_CPU_HAS_FEATURE (cpu_variant, *opcode->avariant)))
+	{
+	  as_bad (_("selected processor does not support `%s' in ARM mode"), str);
+	  return;
+	}
+      if (inst.size_req)
+	{
+	  as_bad (_("width suffixes are invalid in ARM mode -- `%s'"), str);
+	  return;
+	}
+
+      inst.instruction = opcode->avalue;
+      if (opcode->tag == OT_unconditionalF)
+	inst.instruction |= 0xFU << 28;
+      else
+	inst.instruction |= inst.cond << 28;
+      inst.size = INSN_SIZE;
+      if (!parse_operands (p, opcode->operands, /*thumb=*/FALSE))
+	{
+	  it_fsm_pre_encode ();
+	  opcode->aencode ();
+	  it_fsm_post_encode ();
+	}
+      /* Arm mode bx is marked as both v4T and v5 because it's still required
+	 on a hypothetical non-thumb v5 core.  */
+      if (is_bx)
+	ARM_MERGE_FEATURE_SETS (arm_arch_used, arm_arch_used, arm_ext_v4t);
+      else
+	ARM_MERGE_FEATURE_SETS (arm_arch_used, arm_arch_used,
+				*opcode->avariant);
+
+      check_neon_suffixes;
+
+      if (!inst.error)
+	{
+	  mapping_state (MAP_ARM);
+	}
+    }
+  else
+    {
+      as_bad (_("attempt to use an ARM instruction on a Thumb-only processor "
+		"-- `%s'"), str);
+      return;
+    }
+  output_inst (str);
+}
+
+static void
+check_it_blocks_finished (void)
+{
+#ifdef OBJ_ELF
+  asection *sect;
+
+  for (sect = stdoutput->sections; sect != NULL; sect = sect->next)
+    if (seg_info (sect)->tc_segment_info_data.current_it.state
+	== MANUAL_IT_BLOCK)
+      {
+	as_warn (_("section '%s' finished with an open IT block."),
+		 sect->name);
+      }
+#else
+  if (now_it.state == MANUAL_IT_BLOCK)
+    as_warn (_("file finished with an open IT block."));
+#endif
+}
+
+/* Various frobbings of labels and their addresses.  */
+
+void
+arm_start_line_hook (void)
+{
+  last_label_seen = NULL;
+}
+
+void
+arm_frob_label (symbolS * sym)
+{
+  last_label_seen = sym;
+
+  ARM_SET_THUMB (sym, thumb_mode);
+
+#if defined OBJ_COFF || defined OBJ_ELF
+  ARM_SET_INTERWORK (sym, support_interwork);
+#endif
+
+  force_automatic_it_block_close ();
+
+  /* Note - do not allow local symbols (.Lxxx) to be labelled
+     as Thumb functions.  This is because these labels, whilst
+     they exist inside Thumb code, are not the entry points for
+     possible ARM->Thumb calls.	 Also, these labels can be used
+     as part of a computed goto or switch statement.  eg gcc
+     can generate code that looks like this:
+
+		ldr  r2, [pc, .Laaa]
+		lsl  r3, r3, #2
+		ldr  r2, [r3, r2]
+		mov  pc, r2
+
+       .Lbbb:  .word .Lxxx
+       .Lccc:  .word .Lyyy
+       ..etc...
+       .Laaa:	.word Lbbb
+
+     The first instruction loads the address of the jump table.
+     The second instruction converts a table index into a byte offset.
+     The third instruction gets the jump address out of the table.
+     The fourth instruction performs the jump.
+
+     If the address stored at .Laaa is that of a symbol which has the
+     Thumb_Func bit set, then the linker will arrange for this address
+     to have the bottom bit set, which in turn would mean that the
+     address computation performed by the third instruction would end
+     up with the bottom bit set.  Since the ARM is capable of unaligned
+     word loads, the instruction would then load the incorrect address
+     out of the jump table, and chaos would ensue.  */
+  if (label_is_thumb_function_name
+      && (S_GET_NAME (sym)[0] != '.' || S_GET_NAME (sym)[1] != 'L')
+      && (bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)
+    {
+      /* When the address of a Thumb function is taken the bottom
+	 bit of that address should be set.  This will allow
+	 interworking between Arm and Thumb functions to work
+	 correctly.  */
+
+      THUMB_SET_FUNC (sym, 1);
+
+      label_is_thumb_function_name = FALSE;
+    }
+
+  dwarf2_emit_label (sym);
+}
+
+bfd_boolean
+arm_data_in_code (void)
+{
+  if (thumb_mode && ! strncmp (input_line_pointer + 1, "data:", 5))
+    {
+      *input_line_pointer = '/';
+      input_line_pointer += 5;
+      *input_line_pointer = 0;
+      return TRUE;
+    }
+
+  return FALSE;
+}
+
+char *
+arm_canonicalize_symbol_name (char * name)
+{
+  int len;
+
+  if (thumb_mode && (len = strlen (name)) > 5
+      && streq (name + len - 5, "/data"))
+    *(name + len - 5) = 0;
+
+  return name;
+}
+
+/* Table of all register names defined by default.  The user can
+   define additional names with .req.  Note that all register names
+   should appear in both upper and lowercase variants.	Some registers
+   also have mixed-case names.	*/
+
+#define REGDEF(s,n,t) { #s, n, REG_TYPE_##t, TRUE, 0 }
+#define REGNUM(p,n,t) REGDEF(p##n, n, t)
+#define REGNUM2(p,n,t) REGDEF(p##n, 2 * n, t)
+#define REGSET(p,t) \
+  REGNUM(p, 0,t), REGNUM(p, 1,t), REGNUM(p, 2,t), REGNUM(p, 3,t), \
+  REGNUM(p, 4,t), REGNUM(p, 5,t), REGNUM(p, 6,t), REGNUM(p, 7,t), \
+  REGNUM(p, 8,t), REGNUM(p, 9,t), REGNUM(p,10,t), REGNUM(p,11,t), \
+  REGNUM(p,12,t), REGNUM(p,13,t), REGNUM(p,14,t), REGNUM(p,15,t)
+#define REGSETH(p,t) \
+  REGNUM(p,16,t), REGNUM(p,17,t), REGNUM(p,18,t), REGNUM(p,19,t), \
+  REGNUM(p,20,t), REGNUM(p,21,t), REGNUM(p,22,t), REGNUM(p,23,t), \
+  REGNUM(p,24,t), REGNUM(p,25,t), REGNUM(p,26,t), REGNUM(p,27,t), \
+  REGNUM(p,28,t), REGNUM(p,29,t), REGNUM(p,30,t), REGNUM(p,31,t)
+#define REGSET2(p,t) \
+  REGNUM2(p, 0,t), REGNUM2(p, 1,t), REGNUM2(p, 2,t), REGNUM2(p, 3,t), \
+  REGNUM2(p, 4,t), REGNUM2(p, 5,t), REGNUM2(p, 6,t), REGNUM2(p, 7,t), \
+  REGNUM2(p, 8,t), REGNUM2(p, 9,t), REGNUM2(p,10,t), REGNUM2(p,11,t), \
+  REGNUM2(p,12,t), REGNUM2(p,13,t), REGNUM2(p,14,t), REGNUM2(p,15,t)
+#define SPLRBANK(base,bank,t) \
+  REGDEF(lr_##bank, 768|((base+0)<<16), t), \
+  REGDEF(sp_##bank, 768|((base+1)<<16), t), \
+  REGDEF(spsr_##bank, 768|(base<<16)|SPSR_BIT, t), \
+  REGDEF(LR_##bank, 768|((base+0)<<16), t), \
+  REGDEF(SP_##bank, 768|((base+1)<<16), t), \
+  REGDEF(SPSR_##bank, 768|(base<<16)|SPSR_BIT, t)
+
+static const struct reg_entry reg_names[] =
+{
+  /* ARM integer registers.  */
+  REGSET(r, RN), REGSET(R, RN),
+
+  /* ATPCS synonyms.  */
+  REGDEF(a1,0,RN), REGDEF(a2,1,RN), REGDEF(a3, 2,RN), REGDEF(a4, 3,RN),
+  REGDEF(v1,4,RN), REGDEF(v2,5,RN), REGDEF(v3, 6,RN), REGDEF(v4, 7,RN),
+  REGDEF(v5,8,RN), REGDEF(v6,9,RN), REGDEF(v7,10,RN), REGDEF(v8,11,RN),
+
+  REGDEF(A1,0,RN), REGDEF(A2,1,RN), REGDEF(A3, 2,RN), REGDEF(A4, 3,RN),
+  REGDEF(V1,4,RN), REGDEF(V2,5,RN), REGDEF(V3, 6,RN), REGDEF(V4, 7,RN),
+  REGDEF(V5,8,RN), REGDEF(V6,9,RN), REGDEF(V7,10,RN), REGDEF(V8,11,RN),
+
+  /* Well-known aliases.  */
+  REGDEF(wr, 7,RN), REGDEF(sb, 9,RN), REGDEF(sl,10,RN), REGDEF(fp,11,RN),
+  REGDEF(ip,12,RN), REGDEF(sp,13,RN), REGDEF(lr,14,RN), REGDEF(pc,15,RN),
+
+  REGDEF(WR, 7,RN), REGDEF(SB, 9,RN), REGDEF(SL,10,RN), REGDEF(FP,11,RN),
+  REGDEF(IP,12,RN), REGDEF(SP,13,RN), REGDEF(LR,14,RN), REGDEF(PC,15,RN),
+
+  /* Coprocessor numbers.  */
+  REGSET(p, CP), REGSET(P, CP),
+
+  /* Coprocessor register numbers.  The "cr" variants are for backward
+     compatibility.  */
+  REGSET(c,  CN), REGSET(C, CN),
+  REGSET(cr, CN), REGSET(CR, CN),
+
+  /* ARM banked registers.  */
+  REGDEF(R8_usr,512|(0<<16),RNB), REGDEF(r8_usr,512|(0<<16),RNB),
+  REGDEF(R9_usr,512|(1<<16),RNB), REGDEF(r9_usr,512|(1<<16),RNB),
+  REGDEF(R10_usr,512|(2<<16),RNB), REGDEF(r10_usr,512|(2<<16),RNB),
+  REGDEF(R11_usr,512|(3<<16),RNB), REGDEF(r11_usr,512|(3<<16),RNB),
+  REGDEF(R12_usr,512|(4<<16),RNB), REGDEF(r12_usr,512|(4<<16),RNB),
+  REGDEF(SP_usr,512|(5<<16),RNB), REGDEF(sp_usr,512|(5<<16),RNB),
+  REGDEF(LR_usr,512|(6<<16),RNB), REGDEF(lr_usr,512|(6<<16),RNB),
+
+  REGDEF(R8_fiq,512|(8<<16),RNB), REGDEF(r8_fiq,512|(8<<16),RNB),
+  REGDEF(R9_fiq,512|(9<<16),RNB), REGDEF(r9_fiq,512|(9<<16),RNB),
+  REGDEF(R10_fiq,512|(10<<16),RNB), REGDEF(r10_fiq,512|(10<<16),RNB),
+  REGDEF(R11_fiq,512|(11<<16),RNB), REGDEF(r11_fiq,512|(11<<16),RNB),
+  REGDEF(R12_fiq,512|(12<<16),RNB), REGDEF(r12_fiq,512|(12<<16),RNB),
+  REGDEF(SP_fiq,512|(13<<16),RNB), REGDEF(sp_fiq,512|(13<<16),RNB),
+  REGDEF(LR_fiq,512|(14<<16),RNB), REGDEF(lr_fiq,512|(14<<16),RNB),
+  REGDEF(SPSR_fiq,512|(14<<16)|SPSR_BIT,RNB), REGDEF(spsr_fiq,512|(14<<16)|SPSR_BIT,RNB),
+
+  SPLRBANK(0,IRQ,RNB), SPLRBANK(0,irq,RNB),
+  SPLRBANK(2,SVC,RNB), SPLRBANK(2,svc,RNB),
+  SPLRBANK(4,ABT,RNB), SPLRBANK(4,abt,RNB),
+  SPLRBANK(6,UND,RNB), SPLRBANK(6,und,RNB),
+  SPLRBANK(12,MON,RNB), SPLRBANK(12,mon,RNB),
+  REGDEF(elr_hyp,768|(14<<16),RNB), REGDEF(ELR_hyp,768|(14<<16),RNB),
+  REGDEF(sp_hyp,768|(15<<16),RNB), REGDEF(SP_hyp,768|(15<<16),RNB),
+  REGDEF(spsr_hyp,768|(14<<16)|SPSR_BIT,RNB),
+  REGDEF(SPSR_hyp,768|(14<<16)|SPSR_BIT,RNB),
+
+  /* FPA registers.  */
+  REGNUM(f,0,FN), REGNUM(f,1,FN), REGNUM(f,2,FN), REGNUM(f,3,FN),
+  REGNUM(f,4,FN), REGNUM(f,5,FN), REGNUM(f,6,FN), REGNUM(f,7, FN),
+
+  REGNUM(F,0,FN), REGNUM(F,1,FN), REGNUM(F,2,FN), REGNUM(F,3,FN),
+  REGNUM(F,4,FN), REGNUM(F,5,FN), REGNUM(F,6,FN), REGNUM(F,7, FN),
+
+  /* VFP SP registers.	*/
+  REGSET(s,VFS),  REGSET(S,VFS),
+  REGSETH(s,VFS), REGSETH(S,VFS),
+
+  /* VFP DP Registers.	*/
+  REGSET(d,VFD),  REGSET(D,VFD),
+  /* Extra Neon DP registers.  */
+  REGSETH(d,VFD), REGSETH(D,VFD),
+
+  /* Neon QP registers.  */
+  REGSET2(q,NQ),  REGSET2(Q,NQ),
+
+  /* VFP control registers.  */
+  REGDEF(fpsid,0,VFC), REGDEF(fpscr,1,VFC), REGDEF(fpexc,8,VFC),
+  REGDEF(FPSID,0,VFC), REGDEF(FPSCR,1,VFC), REGDEF(FPEXC,8,VFC),
+  REGDEF(fpinst,9,VFC), REGDEF(fpinst2,10,VFC),
+  REGDEF(FPINST,9,VFC), REGDEF(FPINST2,10,VFC),
+  REGDEF(mvfr0,7,VFC), REGDEF(mvfr1,6,VFC),
+  REGDEF(MVFR0,7,VFC), REGDEF(MVFR1,6,VFC),
+
+  /* Maverick DSP coprocessor registers.  */
+  REGSET(mvf,MVF),  REGSET(mvd,MVD),  REGSET(mvfx,MVFX),  REGSET(mvdx,MVDX),
+  REGSET(MVF,MVF),  REGSET(MVD,MVD),  REGSET(MVFX,MVFX),  REGSET(MVDX,MVDX),
+
+  REGNUM(mvax,0,MVAX), REGNUM(mvax,1,MVAX),
+  REGNUM(mvax,2,MVAX), REGNUM(mvax,3,MVAX),
+  REGDEF(dspsc,0,DSPSC),
+
+  REGNUM(MVAX,0,MVAX), REGNUM(MVAX,1,MVAX),
+  REGNUM(MVAX,2,MVAX), REGNUM(MVAX,3,MVAX),
+  REGDEF(DSPSC,0,DSPSC),
+
+  /* iWMMXt data registers - p0, c0-15.	 */
+  REGSET(wr,MMXWR), REGSET(wR,MMXWR), REGSET(WR, MMXWR),
+
+  /* iWMMXt control registers - p1, c0-3.  */
+  REGDEF(wcid,	0,MMXWC),  REGDEF(wCID,	 0,MMXWC),  REGDEF(WCID,  0,MMXWC),
+  REGDEF(wcon,	1,MMXWC),  REGDEF(wCon,	 1,MMXWC),  REGDEF(WCON,  1,MMXWC),
+  REGDEF(wcssf, 2,MMXWC),  REGDEF(wCSSF, 2,MMXWC),  REGDEF(WCSSF, 2,MMXWC),
+  REGDEF(wcasf, 3,MMXWC),  REGDEF(wCASF, 3,MMXWC),  REGDEF(WCASF, 3,MMXWC),
+
+  /* iWMMXt scalar (constant/offset) registers - p1, c8-11.  */
+  REGDEF(wcgr0, 8,MMXWCG),  REGDEF(wCGR0, 8,MMXWCG),  REGDEF(WCGR0, 8,MMXWCG),
+  REGDEF(wcgr1, 9,MMXWCG),  REGDEF(wCGR1, 9,MMXWCG),  REGDEF(WCGR1, 9,MMXWCG),
+  REGDEF(wcgr2,10,MMXWCG),  REGDEF(wCGR2,10,MMXWCG),  REGDEF(WCGR2,10,MMXWCG),
+  REGDEF(wcgr3,11,MMXWCG),  REGDEF(wCGR3,11,MMXWCG),  REGDEF(WCGR3,11,MMXWCG),
+
+  /* XScale accumulator registers.  */
+  REGNUM(acc,0,XSCALE), REGNUM(ACC,0,XSCALE),
+};
+#undef REGDEF
+#undef REGNUM
+#undef REGSET
+
+/* Table of all PSR suffixes.  Bare "CPSR" and "SPSR" are handled
+   within psr_required_here.  */
+static const struct asm_psr psrs[] =
+{
+  /* Backward compatibility notation.  Note that "all" is no longer
+     truly all possible PSR bits.  */
+  {"all",  PSR_c | PSR_f},
+  {"flg",  PSR_f},
+  {"ctl",  PSR_c},
+
+  /* Individual flags.	*/
+  {"f",	   PSR_f},
+  {"c",	   PSR_c},
+  {"x",	   PSR_x},
+  {"s",	   PSR_s},
+
+  /* Combinations of flags.  */
+  {"fs",   PSR_f | PSR_s},
+  {"fx",   PSR_f | PSR_x},
+  {"fc",   PSR_f | PSR_c},
+  {"sf",   PSR_s | PSR_f},
+  {"sx",   PSR_s | PSR_x},
+  {"sc",   PSR_s | PSR_c},
+  {"xf",   PSR_x | PSR_f},
+  {"xs",   PSR_x | PSR_s},
+  {"xc",   PSR_x | PSR_c},
+  {"cf",   PSR_c | PSR_f},
+  {"cs",   PSR_c | PSR_s},
+  {"cx",   PSR_c | PSR_x},
+  {"fsx",  PSR_f | PSR_s | PSR_x},
+  {"fsc",  PSR_f | PSR_s | PSR_c},
+  {"fxs",  PSR_f | PSR_x | PSR_s},
+  {"fxc",  PSR_f | PSR_x | PSR_c},
+  {"fcs",  PSR_f | PSR_c | PSR_s},
+  {"fcx",  PSR_f | PSR_c | PSR_x},
+  {"sfx",  PSR_s | PSR_f | PSR_x},
+  {"sfc",  PSR_s | PSR_f | PSR_c},
+  {"sxf",  PSR_s | PSR_x | PSR_f},
+  {"sxc",  PSR_s | PSR_x | PSR_c},
+  {"scf",  PSR_s | PSR_c | PSR_f},
+  {"scx",  PSR_s | PSR_c | PSR_x},
+  {"xfs",  PSR_x | PSR_f | PSR_s},
+  {"xfc",  PSR_x | PSR_f | PSR_c},
+  {"xsf",  PSR_x | PSR_s | PSR_f},
+  {"xsc",  PSR_x | PSR_s | PSR_c},
+  {"xcf",  PSR_x | PSR_c | PSR_f},
+  {"xcs",  PSR_x | PSR_c | PSR_s},
+  {"cfs",  PSR_c | PSR_f | PSR_s},
+  {"cfx",  PSR_c | PSR_f | PSR_x},
+  {"csf",  PSR_c | PSR_s | PSR_f},
+  {"csx",  PSR_c | PSR_s | PSR_x},
+  {"cxf",  PSR_c | PSR_x | PSR_f},
+  {"cxs",  PSR_c | PSR_x | PSR_s},
+  {"fsxc", PSR_f | PSR_s | PSR_x | PSR_c},
+  {"fscx", PSR_f | PSR_s | PSR_c | PSR_x},
+  {"fxsc", PSR_f | PSR_x | PSR_s | PSR_c},
+  {"fxcs", PSR_f | PSR_x | PSR_c | PSR_s},
+  {"fcsx", PSR_f | PSR_c | PSR_s | PSR_x},
+  {"fcxs", PSR_f | PSR_c | PSR_x | PSR_s},
+  {"sfxc", PSR_s | PSR_f | PSR_x | PSR_c},
+  {"sfcx", PSR_s | PSR_f | PSR_c | PSR_x},
+  {"sxfc", PSR_s | PSR_x | PSR_f | PSR_c},
+  {"sxcf", PSR_s | PSR_x | PSR_c | PSR_f},
+  {"scfx", PSR_s | PSR_c | PSR_f | PSR_x},
+  {"scxf", PSR_s | PSR_c | PSR_x | PSR_f},
+  {"xfsc", PSR_x | PSR_f | PSR_s | PSR_c},
+  {"xfcs", PSR_x | PSR_f | PSR_c | PSR_s},
+  {"xsfc", PSR_x | PSR_s | PSR_f | PSR_c},
+  {"xscf", PSR_x | PSR_s | PSR_c | PSR_f},
+  {"xcfs", PSR_x | PSR_c | PSR_f | PSR_s},
+  {"xcsf", PSR_x | PSR_c | PSR_s | PSR_f},
+  {"cfsx", PSR_c | PSR_f | PSR_s | PSR_x},
+  {"cfxs", PSR_c | PSR_f | PSR_x | PSR_s},
+  {"csfx", PSR_c | PSR_s | PSR_f | PSR_x},
+  {"csxf", PSR_c | PSR_s | PSR_x | PSR_f},
+  {"cxfs", PSR_c | PSR_x | PSR_f | PSR_s},
+  {"cxsf", PSR_c | PSR_x | PSR_s | PSR_f},
+};
+
+/* Table of V7M psr names.  */
+static const struct asm_psr v7m_psrs[] =
+{
+  {"apsr",	  0 }, {"APSR",		0 },
+  {"iapsr",	  1 }, {"IAPSR",	1 },
+  {"eapsr",	  2 }, {"EAPSR",	2 },
+  {"psr",	  3 }, {"PSR",		3 },
+  {"xpsr",	  3 }, {"XPSR",		3 }, {"xPSR",	  3 },
+  {"ipsr",	  5 }, {"IPSR",		5 },
+  {"epsr",	  6 }, {"EPSR",		6 },
+  {"iepsr",	  7 }, {"IEPSR",	7 },
+  {"msp",	  8 }, {"MSP",		8 },
+  {"psp",	  9 }, {"PSP",		9 },
+  {"primask",	  16}, {"PRIMASK",	16},
+  {"basepri",	  17}, {"BASEPRI",	17},
+  {"basepri_max", 18}, {"BASEPRI_MAX",	18},
+  {"basepri_max", 18}, {"BASEPRI_MASK",	18}, /* Typo, preserved for backwards compatibility.  */
+  {"faultmask",	  19}, {"FAULTMASK",	19},
+  {"control",	  20}, {"CONTROL",	20}
+};
+
+/* Table of all shift-in-operand names.	 */
+static const struct asm_shift_name shift_names [] =
+{
+  { "asl", SHIFT_LSL },	 { "ASL", SHIFT_LSL },
+  { "lsl", SHIFT_LSL },	 { "LSL", SHIFT_LSL },
+  { "lsr", SHIFT_LSR },	 { "LSR", SHIFT_LSR },
+  { "asr", SHIFT_ASR },	 { "ASR", SHIFT_ASR },
+  { "ror", SHIFT_ROR },	 { "ROR", SHIFT_ROR },
+  { "rrx", SHIFT_RRX },	 { "RRX", SHIFT_RRX }
+};
+
+/* Table of all explicit relocation names.  */
+#ifdef OBJ_ELF
+static struct reloc_entry reloc_names[] =
+{
+  { "got",     BFD_RELOC_ARM_GOT32   },	 { "GOT",     BFD_RELOC_ARM_GOT32   },
+  { "gotoff",  BFD_RELOC_ARM_GOTOFF  },	 { "GOTOFF",  BFD_RELOC_ARM_GOTOFF  },
+  { "plt",     BFD_RELOC_ARM_PLT32   },	 { "PLT",     BFD_RELOC_ARM_PLT32   },
+  { "target1", BFD_RELOC_ARM_TARGET1 },	 { "TARGET1", BFD_RELOC_ARM_TARGET1 },
+  { "target2", BFD_RELOC_ARM_TARGET2 },	 { "TARGET2", BFD_RELOC_ARM_TARGET2 },
+  { "sbrel",   BFD_RELOC_ARM_SBREL32 },	 { "SBREL",   BFD_RELOC_ARM_SBREL32 },
+  { "tlsgd",   BFD_RELOC_ARM_TLS_GD32},  { "TLSGD",   BFD_RELOC_ARM_TLS_GD32},
+  { "tlsldm",  BFD_RELOC_ARM_TLS_LDM32}, { "TLSLDM",  BFD_RELOC_ARM_TLS_LDM32},
+  { "tlsldo",  BFD_RELOC_ARM_TLS_LDO32}, { "TLSLDO",  BFD_RELOC_ARM_TLS_LDO32},
+  { "gottpoff",BFD_RELOC_ARM_TLS_IE32},  { "GOTTPOFF",BFD_RELOC_ARM_TLS_IE32},
+  { "tpoff",   BFD_RELOC_ARM_TLS_LE32},  { "TPOFF",   BFD_RELOC_ARM_TLS_LE32},
+  { "got_prel", BFD_RELOC_ARM_GOT_PREL}, { "GOT_PREL", BFD_RELOC_ARM_GOT_PREL},
+  { "tlsdesc", BFD_RELOC_ARM_TLS_GOTDESC},
+	{ "TLSDESC", BFD_RELOC_ARM_TLS_GOTDESC},
+  { "tlscall", BFD_RELOC_ARM_TLS_CALL},
+	{ "TLSCALL", BFD_RELOC_ARM_TLS_CALL},
+  { "tlsdescseq", BFD_RELOC_ARM_TLS_DESCSEQ},
+	{ "TLSDESCSEQ", BFD_RELOC_ARM_TLS_DESCSEQ}
+};
+#endif
+
+/* Table of all conditional affixes.  0xF is not defined as a condition code.  */
+static const struct asm_cond conds[] =
+{
+  {"eq", 0x0},
+  {"ne", 0x1},
+  {"cs", 0x2}, {"hs", 0x2},
+  {"cc", 0x3}, {"ul", 0x3}, {"lo", 0x3},
+  {"mi", 0x4},
+  {"pl", 0x5},
+  {"vs", 0x6},
+  {"vc", 0x7},
+  {"hi", 0x8},
+  {"ls", 0x9},
+  {"ge", 0xa},
+  {"lt", 0xb},
+  {"gt", 0xc},
+  {"le", 0xd},
+  {"al", 0xe}
+};
+
+#define UL_BARRIER(L,U,CODE,FEAT) \
+  { L, CODE, ARM_FEATURE_CORE_LOW (FEAT) }, \
+  { U, CODE, ARM_FEATURE_CORE_LOW (FEAT) }
+
+static struct asm_barrier_opt barrier_opt_names[] =
+{
+  UL_BARRIER ("sy",	"SY",	 0xf, ARM_EXT_BARRIER),
+  UL_BARRIER ("st",	"ST",	 0xe, ARM_EXT_BARRIER),
+  UL_BARRIER ("ld",	"LD",	 0xd, ARM_EXT_V8),
+  UL_BARRIER ("ish",	"ISH",	 0xb, ARM_EXT_BARRIER),
+  UL_BARRIER ("sh",	"SH",	 0xb, ARM_EXT_BARRIER),
+  UL_BARRIER ("ishst",	"ISHST", 0xa, ARM_EXT_BARRIER),
+  UL_BARRIER ("shst",	"SHST",	 0xa, ARM_EXT_BARRIER),
+  UL_BARRIER ("ishld",	"ISHLD", 0x9, ARM_EXT_V8),
+  UL_BARRIER ("un",	"UN",	 0x7, ARM_EXT_BARRIER),
+  UL_BARRIER ("nsh",	"NSH",	 0x7, ARM_EXT_BARRIER),
+  UL_BARRIER ("unst",	"UNST",	 0x6, ARM_EXT_BARRIER),
+  UL_BARRIER ("nshst",	"NSHST", 0x6, ARM_EXT_BARRIER),
+  UL_BARRIER ("nshld",	"NSHLD", 0x5, ARM_EXT_V8),
+  UL_BARRIER ("osh",	"OSH",	 0x3, ARM_EXT_BARRIER),
+  UL_BARRIER ("oshst",	"OSHST", 0x2, ARM_EXT_BARRIER),
+  UL_BARRIER ("oshld",	"OSHLD", 0x1, ARM_EXT_V8)
+};
+
+#undef UL_BARRIER
+
+/* Table of ARM-format instructions.	*/
+
+/* Macros for gluing together operand strings.  N.B. In all cases
+   other than OPS0, the trailing OP_stop comes from default
+   zero-initialization of the unspecified elements of the array.  */
+#define OPS0()		  { OP_stop, }
+#define OPS1(a)		  { OP_##a, }
+#define OPS2(a,b)	  { OP_##a,OP_##b, }
+#define OPS3(a,b,c)	  { OP_##a,OP_##b,OP_##c, }
+#define OPS4(a,b,c,d)	  { OP_##a,OP_##b,OP_##c,OP_##d, }
+#define OPS5(a,b,c,d,e)	  { OP_##a,OP_##b,OP_##c,OP_##d,OP_##e, }
+#define OPS6(a,b,c,d,e,f) { OP_##a,OP_##b,OP_##c,OP_##d,OP_##e,OP_##f, }
+
+/* These macros are similar to the OPSn, but do not prepend the OP_ prefix.
+   This is useful when mixing operands for ARM and THUMB, i.e. using the
+   MIX_ARM_THUMB_OPERANDS macro.
+   In order to use these macros, prefix the number of operands with _
+   e.g. _3.  */
+#define OPS_1(a)	   { a, }
+#define OPS_2(a,b)	   { a,b, }
+#define OPS_3(a,b,c)	   { a,b,c, }
+#define OPS_4(a,b,c,d)	   { a,b,c,d, }
+#define OPS_5(a,b,c,d,e)   { a,b,c,d,e, }
+#define OPS_6(a,b,c,d,e,f) { a,b,c,d,e,f, }
+
+/* These macros abstract out the exact format of the mnemonic table and
+   save some repeated characters.  */
+
+/* The normal sort of mnemonic; has a Thumb variant; takes a conditional suffix.  */
+#define TxCE(mnem, op, top, nops, ops, ae, te) \
+  { mnem, OPS##nops ops, OT_csuffix, 0x##op, top, ARM_VARIANT, \
+    THUMB_VARIANT, do_##ae, do_##te }
+
+/* Two variants of the above - TCE for a numeric Thumb opcode, tCE for
+   a T_MNEM_xyz enumerator.  */
+#define TCE(mnem, aop, top, nops, ops, ae, te) \
+      TxCE (mnem, aop, 0x##top, nops, ops, ae, te)
+#define tCE(mnem, aop, top, nops, ops, ae, te) \
+      TxCE (mnem, aop, T_MNEM##top, nops, ops, ae, te)
+
+/* Second most common sort of mnemonic: has a Thumb variant, takes a conditional
+   infix after the third character.  */
+#define TxC3(mnem, op, top, nops, ops, ae, te) \
+  { mnem, OPS##nops ops, OT_cinfix3, 0x##op, top, ARM_VARIANT, \
+    THUMB_VARIANT, do_##ae, do_##te }
+#define TxC3w(mnem, op, top, nops, ops, ae, te) \
+  { mnem, OPS##nops ops, OT_cinfix3_deprecated, 0x##op, top, ARM_VARIANT, \
+    THUMB_VARIANT, do_##ae, do_##te }
+#define TC3(mnem, aop, top, nops, ops, ae, te) \
+      TxC3 (mnem, aop, 0x##top, nops, ops, ae, te)
+#define TC3w(mnem, aop, top, nops, ops, ae, te) \
+      TxC3w (mnem, aop, 0x##top, nops, ops, ae, te)
+#define tC3(mnem, aop, top, nops, ops, ae, te) \
+      TxC3 (mnem, aop, T_MNEM##top, nops, ops, ae, te)
+#define tC3w(mnem, aop, top, nops, ops, ae, te) \
+      TxC3w (mnem, aop, T_MNEM##top, nops, ops, ae, te)
+
+/* Mnemonic that cannot be conditionalized.  The ARM condition-code
+   field is still 0xE.  Many of the Thumb variants can be executed
+   conditionally, so this is checked separately.  */
+#define TUE(mnem, op, top, nops, ops, ae, te)				\
+  { mnem, OPS##nops ops, OT_unconditional, 0x##op, 0x##top, ARM_VARIANT, \
+    THUMB_VARIANT, do_##ae, do_##te }
+
+/* Same as TUE but the encoding function for ARM and Thumb modes is the same.
+   Used by mnemonics that have very minimal differences in the encoding for
+   ARM and Thumb variants and can be handled in a common function.  */
+#define TUEc(mnem, op, top, nops, ops, en) \
+  { mnem, OPS##nops ops, OT_unconditional, 0x##op, 0x##top, ARM_VARIANT, \
+    THUMB_VARIANT, do_##en, do_##en }
+
+/* Mnemonic that cannot be conditionalized, and bears 0xF in its ARM
+   condition code field.  */
+#define TUF(mnem, op, top, nops, ops, ae, te)				\
+  { mnem, OPS##nops ops, OT_unconditionalF, 0x##op, 0x##top, ARM_VARIANT, \
+    THUMB_VARIANT, do_##ae, do_##te }
+
+/* ARM-only variants of all the above.  */
+#define CE(mnem,  op, nops, ops, ae)	\
+  { mnem, OPS##nops ops, OT_csuffix, 0x##op, 0x0, ARM_VARIANT, 0, do_##ae, NULL }
+
+#define C3(mnem, op, nops, ops, ae)	\
+  { #mnem, OPS##nops ops, OT_cinfix3, 0x##op, 0x0, ARM_VARIANT, 0, do_##ae, NULL }
+
+/* Legacy mnemonics that always have conditional infix after the third
+   character.  */
+#define CL(mnem, op, nops, ops, ae)	\
+  { mnem, OPS##nops ops, OT_cinfix3_legacy, \
+    0x##op, 0x0, ARM_VARIANT, 0, do_##ae, NULL }
+
+/* Coprocessor instructions.  Isomorphic between Arm and Thumb-2.  */
+#define cCE(mnem,  op, nops, ops, ae)	\
+  { mnem, OPS##nops ops, OT_csuffix, 0x##op, 0xe##op, ARM_VARIANT, ARM_VARIANT, do_##ae, do_##ae }
+
+/* Legacy coprocessor instructions where conditional infix and conditional
+   suffix are ambiguous.  For consistency this includes all FPA instructions,
+   not just the potentially ambiguous ones.  */
+#define cCL(mnem, op, nops, ops, ae)	\
+  { mnem, OPS##nops ops, OT_cinfix3_legacy, \
+    0x##op, 0xe##op, ARM_VARIANT, ARM_VARIANT, do_##ae, do_##ae }
+
+/* Coprocessor, takes either a suffix or a position-3 infix
+   (for an FPA corner case). */
+#define C3E(mnem, op, nops, ops, ae) \
+  { mnem, OPS##nops ops, OT_csuf_or_in3, \
+    0x##op, 0xe##op, ARM_VARIANT, ARM_VARIANT, do_##ae, do_##ae }
+
+#define xCM_(m1, m2, m3, op, nops, ops, ae)	\
+  { m1 #m2 m3, OPS##nops ops, \
+    sizeof (#m2) == 1 ? OT_odd_infix_unc : OT_odd_infix_0 + sizeof (m1) - 1, \
+    0x##op, 0x0, ARM_VARIANT, 0, do_##ae, NULL }
+
+#define CM(m1, m2, op, nops, ops, ae)	\
+  xCM_ (m1,   , m2, op, nops, ops, ae),	\
+  xCM_ (m1, eq, m2, op, nops, ops, ae),	\
+  xCM_ (m1, ne, m2, op, nops, ops, ae),	\
+  xCM_ (m1, cs, m2, op, nops, ops, ae),	\
+  xCM_ (m1, hs, m2, op, nops, ops, ae),	\
+  xCM_ (m1, cc, m2, op, nops, ops, ae),	\
+  xCM_ (m1, ul, m2, op, nops, ops, ae),	\
+  xCM_ (m1, lo, m2, op, nops, ops, ae),	\
+  xCM_ (m1, mi, m2, op, nops, ops, ae),	\
+  xCM_ (m1, pl, m2, op, nops, ops, ae),	\
+  xCM_ (m1, vs, m2, op, nops, ops, ae),	\
+  xCM_ (m1, vc, m2, op, nops, ops, ae),	\
+  xCM_ (m1, hi, m2, op, nops, ops, ae),	\
+  xCM_ (m1, ls, m2, op, nops, ops, ae),	\
+  xCM_ (m1, ge, m2, op, nops, ops, ae),	\
+  xCM_ (m1, lt, m2, op, nops, ops, ae),	\
+  xCM_ (m1, gt, m2, op, nops, ops, ae),	\
+  xCM_ (m1, le, m2, op, nops, ops, ae),	\
+  xCM_ (m1, al, m2, op, nops, ops, ae)
+
+#define UE(mnem, op, nops, ops, ae)	\
+  { #mnem, OPS##nops ops, OT_unconditional, 0x##op, 0, ARM_VARIANT, 0, do_##ae, NULL }
+
+#define UF(mnem, op, nops, ops, ae)	\
+  { #mnem, OPS##nops ops, OT_unconditionalF, 0x##op, 0, ARM_VARIANT, 0, do_##ae, NULL }
+
+/* Neon data-processing. ARM versions are unconditional with cond=0xf.
+   The Thumb and ARM variants are mostly the same (bits 0-23 and 24/28), so we
+   use the same encoding function for each.  */
+#define NUF(mnem, op, nops, ops, enc)					\
+  { #mnem, OPS##nops ops, OT_unconditionalF, 0x##op, 0x##op,		\
+    ARM_VARIANT, THUMB_VARIANT, do_##enc, do_##enc }
+
+/* Neon data processing, version which indirects through neon_enc_tab for
+   the various overloaded versions of opcodes.  */
+#define nUF(mnem, op, nops, ops, enc)					\
+  { #mnem, OPS##nops ops, OT_unconditionalF, N_MNEM##op, N_MNEM##op,	\
+    ARM_VARIANT, THUMB_VARIANT, do_##enc, do_##enc }
+
+/* Neon insn with conditional suffix for the ARM version, non-overloaded
+   version.  */
+#define NCE_tag(mnem, op, nops, ops, enc, tag)				\
+  { #mnem, OPS##nops ops, tag, 0x##op, 0x##op, ARM_VARIANT,		\
+    THUMB_VARIANT, do_##enc, do_##enc }
+
+#define NCE(mnem, op, nops, ops, enc)					\
+   NCE_tag (mnem, op, nops, ops, enc, OT_csuffix)
+
+#define NCEF(mnem, op, nops, ops, enc)					\
+    NCE_tag (mnem, op, nops, ops, enc, OT_csuffixF)
+
+/* Neon insn with conditional suffix for the ARM version, overloaded types.  */
+#define nCE_tag(mnem, op, nops, ops, enc, tag)				\
+  { #mnem, OPS##nops ops, tag, N_MNEM##op, N_MNEM##op,		\
+    ARM_VARIANT, THUMB_VARIANT, do_##enc, do_##enc }
+
+#define nCE(mnem, op, nops, ops, enc)					\
+   nCE_tag (mnem, op, nops, ops, enc, OT_csuffix)
+
+#define nCEF(mnem, op, nops, ops, enc)					\
+    nCE_tag (mnem, op, nops, ops, enc, OT_csuffixF)
+
+#define do_0 0
+
+static const struct asm_opcode insns[] =
+{
+#define ARM_VARIANT    & arm_ext_v1 /* Core ARM Instructions.  */
+#define THUMB_VARIANT  & arm_ext_v4t
+ tCE("and",	0000000, _and,     3, (RR, oRR, SH), arit, t_arit3c),
+ tC3("ands",	0100000, _ands,	   3, (RR, oRR, SH), arit, t_arit3c),
+ tCE("eor",	0200000, _eor,	   3, (RR, oRR, SH), arit, t_arit3c),
+ tC3("eors",	0300000, _eors,	   3, (RR, oRR, SH), arit, t_arit3c),
+ tCE("sub",	0400000, _sub,	   3, (RR, oRR, SH), arit, t_add_sub),
+ tC3("subs",	0500000, _subs,	   3, (RR, oRR, SH), arit, t_add_sub),
+ tCE("add",	0800000, _add,	   3, (RR, oRR, SHG), arit, t_add_sub),
+ tC3("adds",	0900000, _adds,	   3, (RR, oRR, SHG), arit, t_add_sub),
+ tCE("adc",	0a00000, _adc,	   3, (RR, oRR, SH), arit, t_arit3c),
+ tC3("adcs",	0b00000, _adcs,	   3, (RR, oRR, SH), arit, t_arit3c),
+ tCE("sbc",	0c00000, _sbc,	   3, (RR, oRR, SH), arit, t_arit3),
+ tC3("sbcs",	0d00000, _sbcs,	   3, (RR, oRR, SH), arit, t_arit3),
+ tCE("orr",	1800000, _orr,	   3, (RR, oRR, SH), arit, t_arit3c),
+ tC3("orrs",	1900000, _orrs,	   3, (RR, oRR, SH), arit, t_arit3c),
+ tCE("bic",	1c00000, _bic,	   3, (RR, oRR, SH), arit, t_arit3),
+ tC3("bics",	1d00000, _bics,	   3, (RR, oRR, SH), arit, t_arit3),
+
+ /* The p-variants of tst/cmp/cmn/teq (below) are the pre-V6 mechanism
+    for setting PSR flag bits.  They are obsolete in V6 and do not
+    have Thumb equivalents. */
+ tCE("tst",	1100000, _tst,	   2, (RR, SH),      cmp,  t_mvn_tst),
+ tC3w("tsts",	1100000, _tst,	   2, (RR, SH),      cmp,  t_mvn_tst),
+  CL("tstp",	110f000,     	   2, (RR, SH),      cmp),
+ tCE("cmp",	1500000, _cmp,	   2, (RR, SH),      cmp,  t_mov_cmp),
+ tC3w("cmps",	1500000, _cmp,	   2, (RR, SH),      cmp,  t_mov_cmp),
+  CL("cmpp",	150f000,     	   2, (RR, SH),      cmp),
+ tCE("cmn",	1700000, _cmn,	   2, (RR, SH),      cmp,  t_mvn_tst),
+ tC3w("cmns",	1700000, _cmn,	   2, (RR, SH),      cmp,  t_mvn_tst),
+  CL("cmnp",	170f000,     	   2, (RR, SH),      cmp),
+
+ tCE("mov",	1a00000, _mov,	   2, (RR, SH),      mov,  t_mov_cmp),
+ tC3("movs",	1b00000, _movs,	   2, (RR, SH),      mov,  t_mov_cmp),
+ tCE("mvn",	1e00000, _mvn,	   2, (RR, SH),      mov,  t_mvn_tst),
+ tC3("mvns",	1f00000, _mvns,	   2, (RR, SH),      mov,  t_mvn_tst),
+
+ tCE("ldr",	4100000, _ldr,	   2, (RR, ADDRGLDR),ldst, t_ldst),
+ tC3("ldrb",	4500000, _ldrb,	   2, (RRnpc_npcsp, ADDRGLDR),ldst, t_ldst),
+ tCE("str",	4000000, _str,	   _2, (MIX_ARM_THUMB_OPERANDS (OP_RR,
+								OP_RRnpc),
+					OP_ADDRGLDR),ldst, t_ldst),
+ tC3("strb",	4400000, _strb,	   2, (RRnpc_npcsp, ADDRGLDR),ldst, t_ldst),
+
+ tCE("stm",	8800000, _stmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),
+ tC3("stmia",	8800000, _stmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),
+ tC3("stmea",	8800000, _stmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),
+ tCE("ldm",	8900000, _ldmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),
+ tC3("ldmia",	8900000, _ldmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),
+ tC3("ldmfd",	8900000, _ldmia,    2, (RRw, REGLST), ldmstm, t_ldmstm),
+
+ TCE("swi",	f000000, df00,     1, (EXPi),        swi, t_swi),
+ TCE("svc",	f000000, df00,     1, (EXPi),        swi, t_swi),
+ tCE("b",	a000000, _b,	   1, (EXPr),	     branch, t_branch),
+ TCE("bl",	b000000, f000f800, 1, (EXPr),	     bl, t_branch23),
+
+  /* Pseudo ops.  */
+ tCE("adr",	28f0000, _adr,	   2, (RR, EXP),     adr,  t_adr),
+  C3(adrl,	28f0000,           2, (RR, EXP),     adrl),
+ tCE("nop",	1a00000, _nop,	   1, (oI255c),	     nop,  t_nop),
+ tCE("udf",	7f000f0, _udf,     1, (oIffffb),     bkpt, t_udf),
+
+  /* Thumb-compatibility pseudo ops.  */
+ tCE("lsl",	1a00000, _lsl,	   3, (RR, oRR, SH), shift, t_shift),
+ tC3("lsls",	1b00000, _lsls,	   3, (RR, oRR, SH), shift, t_shift),
+ tCE("lsr",	1a00020, _lsr,	   3, (RR, oRR, SH), shift, t_shift),
+ tC3("lsrs",	1b00020, _lsrs,	   3, (RR, oRR, SH), shift, t_shift),
+ tCE("asr",	1a00040, _asr,	   3, (RR, oRR, SH), shift, t_shift),
+ tC3("asrs",      1b00040, _asrs,     3, (RR, oRR, SH), shift, t_shift),
+ tCE("ror",	1a00060, _ror,	   3, (RR, oRR, SH), shift, t_shift),
+ tC3("rors",	1b00060, _rors,	   3, (RR, oRR, SH), shift, t_shift),
+ tCE("neg",	2600000, _neg,	   2, (RR, RR),      rd_rn, t_neg),
+ tC3("negs",	2700000, _negs,	   2, (RR, RR),      rd_rn, t_neg),
+ tCE("push",	92d0000, _push,     1, (REGLST),	     push_pop, t_push_pop),
+ tCE("pop",	8bd0000, _pop,	   1, (REGLST),	     push_pop, t_push_pop),
+
+ /* These may simplify to neg.  */
+ TCE("rsb",	0600000, ebc00000, 3, (RR, oRR, SH), arit, t_rsb),
+ TC3("rsbs",	0700000, ebd00000, 3, (RR, oRR, SH), arit, t_rsb),
+
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT  & arm_ext_v6
+
+ TCE("cpy",       1a00000, 4600,     2, (RR, RR),      rd_rm, t_cpy),
+
+ /* V1 instructions with no Thumb analogue prior to V6T2.  */
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT  & arm_ext_v6t2
+
+ TCE("teq",	1300000, ea900f00, 2, (RR, SH),      cmp,  t_mvn_tst),
+ TC3w("teqs",	1300000, ea900f00, 2, (RR, SH),      cmp,  t_mvn_tst),
+  CL("teqp",	130f000,           2, (RR, SH),      cmp),
+
+ TC3("ldrt",	4300000, f8500e00, 2, (RRnpc_npcsp, ADDR),ldstt, t_ldstt),
+ TC3("ldrbt",	4700000, f8100e00, 2, (RRnpc_npcsp, ADDR),ldstt, t_ldstt),
+ TC3("strt",	4200000, f8400e00, 2, (RR_npcsp, ADDR),   ldstt, t_ldstt),
+ TC3("strbt",	4600000, f8000e00, 2, (RRnpc_npcsp, ADDR),ldstt, t_ldstt),
+
+ TC3("stmdb",	9000000, e9000000, 2, (RRw, REGLST), ldmstm, t_ldmstm),
+ TC3("stmfd",     9000000, e9000000, 2, (RRw, REGLST), ldmstm, t_ldmstm),
+
+ TC3("ldmdb",	9100000, e9100000, 2, (RRw, REGLST), ldmstm, t_ldmstm),
+ TC3("ldmea",	9100000, e9100000, 2, (RRw, REGLST), ldmstm, t_ldmstm),
+
+ /* V1 instructions with no Thumb analogue at all.  */
+  CE("rsc",	0e00000,	   3, (RR, oRR, SH), arit),
+  C3(rscs,	0f00000,	   3, (RR, oRR, SH), arit),
+
+  C3(stmib,	9800000,	   2, (RRw, REGLST), ldmstm),
+  C3(stmfa,	9800000,	   2, (RRw, REGLST), ldmstm),
+  C3(stmda,	8000000,	   2, (RRw, REGLST), ldmstm),
+  C3(stmed,	8000000,	   2, (RRw, REGLST), ldmstm),
+  C3(ldmib,	9900000,	   2, (RRw, REGLST), ldmstm),
+  C3(ldmed,	9900000,	   2, (RRw, REGLST), ldmstm),
+  C3(ldmda,	8100000,	   2, (RRw, REGLST), ldmstm),
+  C3(ldmfa,	8100000,	   2, (RRw, REGLST), ldmstm),
+
+#undef  ARM_VARIANT
+#define ARM_VARIANT    & arm_ext_v2	/* ARM 2 - multiplies.	*/
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT  & arm_ext_v4t
+
+ tCE("mul",	0000090, _mul,	   3, (RRnpc, RRnpc, oRR), mul, t_mul),
+ tC3("muls",	0100090, _muls,	   3, (RRnpc, RRnpc, oRR), mul, t_mul),
+
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT  & arm_ext_v6t2
+
+ TCE("mla",	0200090, fb000000, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mlas, t_mla),
+  C3(mlas,	0300090,           4, (RRnpc, RRnpc, RRnpc, RRnpc), mlas),
+
+  /* Generic coprocessor instructions.	*/
+ TCE("cdp",	e000000, ee000000, 6, (RCP, I15b, RCN, RCN, RCN, oI7b), cdp,    cdp),
+ TCE("ldc",	c100000, ec100000, 3, (RCP, RCN, ADDRGLDC),	        lstc,   lstc),
+ TC3("ldcl",	c500000, ec500000, 3, (RCP, RCN, ADDRGLDC),	        lstc,   lstc),
+ TCE("stc",	c000000, ec000000, 3, (RCP, RCN, ADDRGLDC),	        lstc,   lstc),
+ TC3("stcl",	c400000, ec400000, 3, (RCP, RCN, ADDRGLDC),	        lstc,   lstc),
+ TCE("mcr",	e000010, ee000010, 6, (RCP, I7b, RR, RCN, RCN, oI7b),   co_reg, co_reg),
+ TCE("mrc",	e100010, ee100010, 6, (RCP, I7b, APSR_RR, RCN, RCN, oI7b),   co_reg, co_reg),
+
+#undef  ARM_VARIANT
+#define ARM_VARIANT  & arm_ext_v2s /* ARM 3 - swp instructions.  */
+
+  CE("swp",	1000090,           3, (RRnpc, RRnpc, RRnpcb), rd_rm_rn),
+  C3(swpb,	1400090,           3, (RRnpc, RRnpc, RRnpcb), rd_rm_rn),
+
+#undef  ARM_VARIANT
+#define ARM_VARIANT    & arm_ext_v3	/* ARM 6 Status register instructions.	*/
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT  & arm_ext_msr
+
+ TCE("mrs",	1000000, f3e08000, 2, (RRnpc, rPSR), mrs, t_mrs),
+ TCE("msr",	120f000, f3808000, 2, (wPSR, RR_EXi), msr, t_msr),
+
+#undef  ARM_VARIANT
+#define ARM_VARIANT    & arm_ext_v3m	 /* ARM 7M long multiplies.  */
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT  & arm_ext_v6t2
+
+ TCE("smull",	0c00090, fb800000, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mull, t_mull),
+  CM("smull","s",	0d00090,           4, (RRnpc, RRnpc, RRnpc, RRnpc), mull),
+ TCE("umull",	0800090, fba00000, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mull, t_mull),
+  CM("umull","s",	0900090,           4, (RRnpc, RRnpc, RRnpc, RRnpc), mull),
+ TCE("smlal",	0e00090, fbc00000, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mull, t_mull),
+  CM("smlal","s",	0f00090,           4, (RRnpc, RRnpc, RRnpc, RRnpc), mull),
+ TCE("umlal",	0a00090, fbe00000, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mull, t_mull),
+  CM("umlal","s",	0b00090,           4, (RRnpc, RRnpc, RRnpc, RRnpc), mull),
+
+#undef  ARM_VARIANT
+#define ARM_VARIANT    & arm_ext_v4	/* ARM Architecture 4.	*/
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT  & arm_ext_v4t
+
+ tC3("ldrh",	01000b0, _ldrh,     2, (RRnpc_npcsp, ADDRGLDRS), ldstv4, t_ldst),
+ tC3("strh",	00000b0, _strh,     2, (RRnpc_npcsp, ADDRGLDRS), ldstv4, t_ldst),
+ tC3("ldrsh",	01000f0, _ldrsh,    2, (RRnpc_npcsp, ADDRGLDRS), ldstv4, t_ldst),
+ tC3("ldrsb",	01000d0, _ldrsb,    2, (RRnpc_npcsp, ADDRGLDRS), ldstv4, t_ldst),
+ tC3("ldsh",	01000f0, _ldrsh,    2, (RRnpc_npcsp, ADDRGLDRS), ldstv4, t_ldst),
+ tC3("ldsb",	01000d0, _ldrsb,    2, (RRnpc_npcsp, ADDRGLDRS), ldstv4, t_ldst),
+
+#undef  ARM_VARIANT
+#define ARM_VARIANT  & arm_ext_v4t_5
+
+  /* ARM Architecture 4T.  */
+  /* Note: bx (and blx) are required on V5, even if the processor does
+     not support Thumb.	 */
+ TCE("bx",	12fff10, 4700, 1, (RR),	bx, t_bx),
+
+#undef  ARM_VARIANT
+#define ARM_VARIANT    & arm_ext_v5 /*  ARM Architecture 5T.	 */
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT  & arm_ext_v5t
+
+  /* Note: blx has 2 variants; the .value coded here is for
+     BLX(2).  Only this variant has conditional execution.  */
+ TCE("blx",	12fff30, 4780, 1, (RR_EXr),			    blx,  t_blx),
+ TUE("bkpt",	1200070, be00, 1, (oIffffb),			    bkpt, t_bkpt),
+
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT  & arm_ext_v6t2
+
+ TCE("clz",	16f0f10, fab0f080, 2, (RRnpc, RRnpc),		        rd_rm,  t_clz),
+ TUF("ldc2",	c100000, fc100000, 3, (RCP, RCN, ADDRGLDC),	        lstc,	lstc),
+ TUF("ldc2l",	c500000, fc500000, 3, (RCP, RCN, ADDRGLDC),		        lstc,	lstc),
+ TUF("stc2",	c000000, fc000000, 3, (RCP, RCN, ADDRGLDC),	        lstc,	lstc),
+ TUF("stc2l",	c400000, fc400000, 3, (RCP, RCN, ADDRGLDC),		        lstc,	lstc),
+ TUF("cdp2",	e000000, fe000000, 6, (RCP, I15b, RCN, RCN, RCN, oI7b), cdp,    cdp),
+ TUF("mcr2",	e000010, fe000010, 6, (RCP, I7b, RR, RCN, RCN, oI7b),   co_reg, co_reg),
+ TUF("mrc2",	e100010, fe100010, 6, (RCP, I7b, RR, RCN, RCN, oI7b),   co_reg, co_reg),
+
+#undef  ARM_VARIANT
+#define ARM_VARIANT    & arm_ext_v5exp /*  ARM Architecture 5TExP.  */
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT  & arm_ext_v5exp
+
+ TCE("smlabb",	1000080, fb100000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),
+ TCE("smlatb",	10000a0, fb100020, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),
+ TCE("smlabt",	10000c0, fb100010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),
+ TCE("smlatt",	10000e0, fb100030, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),
+
+ TCE("smlawb",	1200080, fb300000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),
+ TCE("smlawt",	12000c0, fb300010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smla, t_mla),
+
+ TCE("smlalbb",	1400080, fbc00080, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smlal, t_mlal),
+ TCE("smlaltb",	14000a0, fbc000a0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smlal, t_mlal),
+ TCE("smlalbt",	14000c0, fbc00090, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smlal, t_mlal),
+ TCE("smlaltt",	14000e0, fbc000b0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),   smlal, t_mlal),
+
+ TCE("smulbb",	1600080, fb10f000, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),
+ TCE("smultb",	16000a0, fb10f020, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),
+ TCE("smulbt",	16000c0, fb10f010, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),
+ TCE("smultt",	16000e0, fb10f030, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),
+
+ TCE("smulwb",	12000a0, fb30f000, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),
+ TCE("smulwt",	12000e0, fb30f010, 3, (RRnpc, RRnpc, RRnpc),	    smul, t_simd),
+
+ TCE("qadd",	1000050, fa80f080, 3, (RRnpc, RRnpc, RRnpc),	    rd_rm_rn, t_simd2),
+ TCE("qdadd",	1400050, fa80f090, 3, (RRnpc, RRnpc, RRnpc),	    rd_rm_rn, t_simd2),
+ TCE("qsub",	1200050, fa80f0a0, 3, (RRnpc, RRnpc, RRnpc),	    rd_rm_rn, t_simd2),
+ TCE("qdsub",	1600050, fa80f0b0, 3, (RRnpc, RRnpc, RRnpc),	    rd_rm_rn, t_simd2),
+
+#undef  ARM_VARIANT
+#define ARM_VARIANT    & arm_ext_v5e /*  ARM Architecture 5TE.  */
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT  & arm_ext_v6t2
+
+ TUF("pld",	450f000, f810f000, 1, (ADDR),		     pld,  t_pld),
+ TC3("ldrd",	00000d0, e8500000, 3, (RRnpc_npcsp, oRRnpc_npcsp, ADDRGLDRS),
+     ldrd, t_ldstd),
+ TC3("strd",	00000f0, e8400000, 3, (RRnpc_npcsp, oRRnpc_npcsp,
+				       ADDRGLDRS), ldrd, t_ldstd),
+
+ TCE("mcrr",	c400000, ec400000, 5, (RCP, I15b, RRnpc, RRnpc, RCN), co_reg2c, co_reg2c),
+ TCE("mrrc",	c500000, ec500000, 5, (RCP, I15b, RRnpc, RRnpc, RCN), co_reg2c, co_reg2c),
+
+#undef  ARM_VARIANT
+#define ARM_VARIANT  & arm_ext_v5j /*  ARM Architecture 5TEJ.  */
+
+ TCE("bxj",	12fff20, f3c08f00, 1, (RR),			  bxj, t_bxj),
+
+#undef  ARM_VARIANT
+#define ARM_VARIANT    & arm_ext_v6 /*  ARM V6.  */
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT  & arm_ext_v6
+
+ TUF("cpsie",     1080000, b660,     2, (CPSF, oI31b),              cpsi,   t_cpsi),
+ TUF("cpsid",     10c0000, b670,     2, (CPSF, oI31b),              cpsi,   t_cpsi),
+ tCE("rev",       6bf0f30, _rev,      2, (RRnpc, RRnpc),             rd_rm,  t_rev),
+ tCE("rev16",     6bf0fb0, _rev16,    2, (RRnpc, RRnpc),             rd_rm,  t_rev),
+ tCE("revsh",     6ff0fb0, _revsh,    2, (RRnpc, RRnpc),             rd_rm,  t_rev),
+ tCE("sxth",      6bf0070, _sxth,     3, (RRnpc, RRnpc, oROR),       sxth,   t_sxth),
+ tCE("uxth",      6ff0070, _uxth,     3, (RRnpc, RRnpc, oROR),       sxth,   t_sxth),
+ tCE("sxtb",      6af0070, _sxtb,     3, (RRnpc, RRnpc, oROR),       sxth,   t_sxth),
+ tCE("uxtb",      6ef0070, _uxtb,     3, (RRnpc, RRnpc, oROR),       sxth,   t_sxth),
+ TUF("setend",    1010000, b650,     1, (ENDI),                     setend, t_setend),
+
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT  & arm_ext_v6t2
+
+ TCE("ldrex",	1900f9f, e8500f00, 2, (RRnpc_npcsp, ADDR),	  ldrex, t_ldrex),
+ TCE("strex",	1800f90, e8400000, 3, (RRnpc_npcsp, RRnpc_npcsp, ADDR),
+				      strex,  t_strex),
+ TUF("mcrr2",	c400000, fc400000, 5, (RCP, I15b, RRnpc, RRnpc, RCN), co_reg2c, co_reg2c),
+ TUF("mrrc2",	c500000, fc500000, 5, (RCP, I15b, RRnpc, RRnpc, RCN), co_reg2c, co_reg2c),
+
+ TCE("ssat",	6a00010, f3000000, 4, (RRnpc, I32, RRnpc, oSHllar),ssat,   t_ssat),
+ TCE("usat",	6e00010, f3800000, 4, (RRnpc, I31, RRnpc, oSHllar),usat,   t_usat),
+
+/*  ARM V6 not included in V7M.  */
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT  & arm_ext_v6_notm
+ TUF("rfeia",	8900a00, e990c000, 1, (RRw),			   rfe, rfe),
+ TUF("rfe",	8900a00, e990c000, 1, (RRw),			   rfe, rfe),
+  UF(rfeib,	9900a00,           1, (RRw),			   rfe),
+  UF(rfeda,	8100a00,           1, (RRw),			   rfe),
+ TUF("rfedb",	9100a00, e810c000, 1, (RRw),			   rfe, rfe),
+ TUF("rfefd",	8900a00, e990c000, 1, (RRw),			   rfe, rfe),
+  UF(rfefa,	8100a00,           1, (RRw),			   rfe),
+ TUF("rfeea",	9100a00, e810c000, 1, (RRw),			   rfe, rfe),
+  UF(rfeed,	9900a00,           1, (RRw),			   rfe),
+ TUF("srsia",	8c00500, e980c000, 2, (oRRw, I31w),		   srs,  srs),
+ TUF("srs",	8c00500, e980c000, 2, (oRRw, I31w),		   srs,  srs),
+ TUF("srsea",	8c00500, e980c000, 2, (oRRw, I31w),		   srs,  srs),
+  UF(srsib,	9c00500,           2, (oRRw, I31w),		   srs),
+  UF(srsfa,	9c00500,           2, (oRRw, I31w),		   srs),
+  UF(srsda,	8400500,	   2, (oRRw, I31w),		   srs),
+  UF(srsed,	8400500,	   2, (oRRw, I31w),		   srs),
+ TUF("srsdb",	9400500, e800c000, 2, (oRRw, I31w),		   srs,  srs),
+ TUF("srsfd",	9400500, e800c000, 2, (oRRw, I31w),		   srs,  srs),
+ TUF("cps",	1020000, f3af8100, 1, (I31b),			  imm0, t_cps),
+
+/*  ARM V6 not included in V7M (eg. integer SIMD).  */
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT  & arm_ext_v6_dsp
+ TCE("pkhbt",	6800010, eac00000, 4, (RRnpc, RRnpc, RRnpc, oSHll),   pkhbt, t_pkhbt),
+ TCE("pkhtb",	6800050, eac00020, 4, (RRnpc, RRnpc, RRnpc, oSHar),   pkhtb, t_pkhtb),
+ TCE("qadd16",	6200f10, fa90f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("qadd8",	6200f90, fa80f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("qasx",	6200f30, faa0f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ /* Old name for QASX.  */
+ TCE("qaddsubx",6200f30, faa0f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("qsax",	6200f50, fae0f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ /* Old name for QSAX.  */
+ TCE("qsubaddx",6200f50, fae0f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("qsub16",	6200f70, fad0f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("qsub8",	6200ff0, fac0f010, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("sadd16",	6100f10, fa90f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("sadd8",	6100f90, fa80f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("sasx",	6100f30, faa0f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ /* Old name for SASX.  */
+ TCE("saddsubx",6100f30, faa0f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("shadd16",	6300f10, fa90f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("shadd8",	6300f90, fa80f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("shasx",   6300f30, faa0f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ /* Old name for SHASX.  */
+ TCE("shaddsubx", 6300f30, faa0f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("shsax",     6300f50, fae0f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ /* Old name for SHSAX.  */
+ TCE("shsubaddx", 6300f50, fae0f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("shsub16",	6300f70, fad0f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("shsub8",	6300ff0, fac0f020, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("ssax",	6100f50, fae0f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ /* Old name for SSAX.  */
+ TCE("ssubaddx",6100f50, fae0f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("ssub16",	6100f70, fad0f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("ssub8",	6100ff0, fac0f000, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("uadd16",	6500f10, fa90f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("uadd8",	6500f90, fa80f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("uasx",	6500f30, faa0f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ /* Old name for UASX.  */
+ TCE("uaddsubx",6500f30, faa0f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("uhadd16",	6700f10, fa90f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("uhadd8",	6700f90, fa80f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("uhasx",   6700f30, faa0f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ /* Old name for UHASX.  */
+ TCE("uhaddsubx", 6700f30, faa0f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("uhsax",     6700f50, fae0f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ /* Old name for UHSAX.  */
+ TCE("uhsubaddx", 6700f50, fae0f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("uhsub16",	6700f70, fad0f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("uhsub8",	6700ff0, fac0f060, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("uqadd16",	6600f10, fa90f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("uqadd8",	6600f90, fa80f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("uqasx",   6600f30, faa0f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ /* Old name for UQASX.  */
+ TCE("uqaddsubx", 6600f30, faa0f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("uqsax",     6600f50, fae0f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ /* Old name for UQSAX.  */
+ TCE("uqsubaddx", 6600f50, fae0f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("uqsub16",	6600f70, fad0f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("uqsub8",	6600ff0, fac0f050, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("usub16",	6500f70, fad0f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("usax",	6500f50, fae0f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ /* Old name for USAX.  */
+ TCE("usubaddx",6500f50, fae0f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("usub8",	6500ff0, fac0f040, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("sxtah",	6b00070, fa00f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
+ TCE("sxtab16",	6800070, fa20f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
+ TCE("sxtab",	6a00070, fa40f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
+ TCE("sxtb16",	68f0070, fa2ff080, 3, (RRnpc, RRnpc, oROR),	   sxth,  t_sxth),
+ TCE("uxtah",	6f00070, fa10f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
+ TCE("uxtab16",	6c00070, fa30f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
+ TCE("uxtab",	6e00070, fa50f080, 4, (RRnpc, RRnpc, RRnpc, oROR), sxtah, t_sxtah),
+ TCE("uxtb16",	6cf0070, fa3ff080, 3, (RRnpc, RRnpc, oROR),	   sxth,  t_sxth),
+ TCE("sel",	6800fb0, faa0f080, 3, (RRnpc, RRnpc, RRnpc),	   rd_rn_rm, t_simd),
+ TCE("smlad",	7000010, fb200000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
+ TCE("smladx",	7000030, fb200010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
+ TCE("smlald",	7400010, fbc000c0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smlal,t_mlal),
+ TCE("smlaldx",	7400030, fbc000d0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smlal,t_mlal),
+ TCE("smlsd",	7000050, fb400000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
+ TCE("smlsdx",	7000070, fb400010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
+ TCE("smlsld",	7400050, fbd000c0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smlal,t_mlal),
+ TCE("smlsldx",	7400070, fbd000d0, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smlal,t_mlal),
+ TCE("smmla",	7500010, fb500000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
+ TCE("smmlar",	7500030, fb500010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
+ TCE("smmls",	75000d0, fb600000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
+ TCE("smmlsr",	75000f0, fb600010, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla, t_mla),
+ TCE("smmul",	750f010, fb50f000, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
+ TCE("smmulr",	750f030, fb50f010, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
+ TCE("smuad",	700f010, fb20f000, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
+ TCE("smuadx",	700f030, fb20f010, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
+ TCE("smusd",	700f050, fb40f000, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
+ TCE("smusdx",	700f070, fb40f010, 3, (RRnpc, RRnpc, RRnpc),	   smul, t_simd),
+ TCE("ssat16",	6a00f30, f3200000, 3, (RRnpc, I16, RRnpc),	   ssat16, t_ssat16),
+ TCE("umaal",	0400090, fbe00060, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smlal,  t_mlal),
+ TCE("usad8",	780f010, fb70f000, 3, (RRnpc, RRnpc, RRnpc),	   smul,   t_simd),
+ TCE("usada8",	7800010, fb700000, 4, (RRnpc, RRnpc, RRnpc, RRnpc),smla,   t_mla),
+ TCE("usat16",	6e00f30, f3a00000, 3, (RRnpc, I15, RRnpc),	   usat16, t_usat16),
+
+#undef  ARM_VARIANT
+#define ARM_VARIANT   & arm_ext_v6k
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT & arm_ext_v6k
+
+ tCE("yield",	320f001, _yield,    0, (), noargs, t_hint),
+ tCE("wfe",	320f002, _wfe,      0, (), noargs, t_hint),
+ tCE("wfi",	320f003, _wfi,      0, (), noargs, t_hint),
+ tCE("sev",	320f004, _sev,      0, (), noargs, t_hint),
+
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT  & arm_ext_v6_notm
+ TCE("ldrexd",	1b00f9f, e8d0007f, 3, (RRnpc_npcsp, oRRnpc_npcsp, RRnpcb),
+				      ldrexd, t_ldrexd),
+ TCE("strexd",	1a00f90, e8c00070, 4, (RRnpc_npcsp, RRnpc_npcsp, oRRnpc_npcsp,
+				       RRnpcb), strexd, t_strexd),
+
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT  & arm_ext_v6t2
+ TCE("ldrexb",	1d00f9f, e8d00f4f, 2, (RRnpc_npcsp,RRnpcb),
+     rd_rn,  rd_rn),
+ TCE("ldrexh",	1f00f9f, e8d00f5f, 2, (RRnpc_npcsp, RRnpcb),
+     rd_rn,  rd_rn),
+ TCE("strexb",	1c00f90, e8c00f40, 3, (RRnpc_npcsp, RRnpc_npcsp, ADDR),
+     strex, t_strexbh),
+ TCE("strexh",	1e00f90, e8c00f50, 3, (RRnpc_npcsp, RRnpc_npcsp, ADDR),
+     strex, t_strexbh),
+ TUF("clrex",	57ff01f, f3bf8f2f, 0, (),			      noargs, noargs),
+
+#undef  ARM_VARIANT
+#define ARM_VARIANT    & arm_ext_sec
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT  & arm_ext_sec
+
+ TCE("smc",	1600070, f7f08000, 1, (EXPi), smc, t_smc),
+
+#undef	ARM_VARIANT
+#define	ARM_VARIANT    & arm_ext_virt
+#undef	THUMB_VARIANT
+#define	THUMB_VARIANT    & arm_ext_virt
+
+ TCE("hvc",	1400070, f7e08000, 1, (EXPi), hvc, t_hvc),
+ TCE("eret",	160006e, f3de8f00, 0, (), noargs, noargs),
+
+#undef	ARM_VARIANT
+#define	ARM_VARIANT    & arm_ext_pan
+#undef	THUMB_VARIANT
+#define	THUMB_VARIANT  & arm_ext_pan
+
+ TUF("setpan",	1100000, b610, 1, (I7), setpan, t_setpan),
+
+#undef  ARM_VARIANT
+#define ARM_VARIANT    & arm_ext_v6t2
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT  & arm_ext_v6t2
+
+ TCE("bfc",	7c0001f, f36f0000, 3, (RRnpc, I31, I32),	   bfc, t_bfc),
+ TCE("bfi",	7c00010, f3600000, 4, (RRnpc, RRnpc_I0, I31, I32), bfi, t_bfi),
+ TCE("sbfx",	7a00050, f3400000, 4, (RR, RR, I31, I32),	   bfx, t_bfx),
+ TCE("ubfx",	7e00050, f3c00000, 4, (RR, RR, I31, I32),	   bfx, t_bfx),
+
+ TCE("mls",	0600090, fb000010, 4, (RRnpc, RRnpc, RRnpc, RRnpc), mlas, t_mla),
+ TCE("movw",	3000000, f2400000, 2, (RRnpc, HALF),		    mov16, t_mov16),
+ TCE("movt",	3400000, f2c00000, 2, (RRnpc, HALF),		    mov16, t_mov16),
+ TCE("rbit",	6ff0f30, fa90f0a0, 2, (RR, RR),			    rd_rm, t_rbit),
+
+ TC3("ldrht",	03000b0, f8300e00, 2, (RRnpc_npcsp, ADDR), ldsttv4, t_ldstt),
+ TC3("ldrsht",	03000f0, f9300e00, 2, (RRnpc_npcsp, ADDR), ldsttv4, t_ldstt),
+ TC3("ldrsbt",	03000d0, f9100e00, 2, (RRnpc_npcsp, ADDR), ldsttv4, t_ldstt),
+ TC3("strht",	02000b0, f8200e00, 2, (RRnpc_npcsp, ADDR), ldsttv4, t_ldstt),
+
+ /* Thumb-only instructions.  */
+#undef  ARM_VARIANT
+#define ARM_VARIANT NULL
+  TUE("cbnz",     0,           b900,     2, (RR, EXP), 0, t_cbz),
+  TUE("cbz",      0,           b100,     2, (RR, EXP), 0, t_cbz),
+
+ /* ARM does not really have an IT instruction, so always allow it.
+    The opcode is copied from Thumb in order to allow warnings in
+    -mimplicit-it=[never | arm] modes.  */
+#undef  ARM_VARIANT
+#define ARM_VARIANT  & arm_ext_v1
+
+ TUE("it",        bf08,        bf08,     1, (COND),   it,    t_it),
+ TUE("itt",       bf0c,        bf0c,     1, (COND),   it,    t_it),
+ TUE("ite",       bf04,        bf04,     1, (COND),   it,    t_it),
+ TUE("ittt",      bf0e,        bf0e,     1, (COND),   it,    t_it),
+ TUE("itet",      bf06,        bf06,     1, (COND),   it,    t_it),
+ TUE("itte",      bf0a,        bf0a,     1, (COND),   it,    t_it),
+ TUE("itee",      bf02,        bf02,     1, (COND),   it,    t_it),
+ TUE("itttt",     bf0f,        bf0f,     1, (COND),   it,    t_it),
+ TUE("itett",     bf07,        bf07,     1, (COND),   it,    t_it),
+ TUE("ittet",     bf0b,        bf0b,     1, (COND),   it,    t_it),
+ TUE("iteet",     bf03,        bf03,     1, (COND),   it,    t_it),
+ TUE("ittte",     bf0d,        bf0d,     1, (COND),   it,    t_it),
+ TUE("itete",     bf05,        bf05,     1, (COND),   it,    t_it),
+ TUE("ittee",     bf09,        bf09,     1, (COND),   it,    t_it),
+ TUE("iteee",     bf01,        bf01,     1, (COND),   it,    t_it),
+ /* ARM/Thumb-2 instructions with no Thumb-1 equivalent.  */
+ TC3("rrx",       01a00060, ea4f0030, 2, (RR, RR), rd_rm, t_rrx),
+ TC3("rrxs",      01b00060, ea5f0030, 2, (RR, RR), rd_rm, t_rrx),
+
+ /* Thumb2 only instructions.  */
+#undef  ARM_VARIANT
+#define ARM_VARIANT  NULL
+
+ TCE("addw",	0, f2000000, 3, (RR, RR, EXPi), 0, t_add_sub_w),
+ TCE("subw",	0, f2a00000, 3, (RR, RR, EXPi), 0, t_add_sub_w),
+ TCE("orn",       0, ea600000, 3, (RR, oRR, SH),  0, t_orn),
+ TCE("orns",      0, ea700000, 3, (RR, oRR, SH),  0, t_orn),
+ TCE("tbb",       0, e8d0f000, 1, (TB), 0, t_tb),
+ TCE("tbh",       0, e8d0f010, 1, (TB), 0, t_tb),
+
+ /* Hardware division instructions.  */
+#undef  ARM_VARIANT
+#define ARM_VARIANT    & arm_ext_adiv
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT  & arm_ext_div
+
+ TCE("sdiv",	710f010, fb90f0f0, 3, (RR, oRR, RR), div, t_div),
+ TCE("udiv",	730f010, fbb0f0f0, 3, (RR, oRR, RR), div, t_div),
+
+ /* ARM V6M/V7 instructions.  */
+#undef  ARM_VARIANT
+#define ARM_VARIANT    & arm_ext_barrier
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT  & arm_ext_barrier
+
+ TUF("dmb",	57ff050, f3bf8f50, 1, (oBARRIER_I15), barrier, barrier),
+ TUF("dsb",	57ff040, f3bf8f40, 1, (oBARRIER_I15), barrier, barrier),
+ TUF("isb",	57ff060, f3bf8f60, 1, (oBARRIER_I15), barrier, barrier),
+
+ /* ARM V7 instructions.  */
+#undef  ARM_VARIANT
+#define ARM_VARIANT    & arm_ext_v7
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT  & arm_ext_v7
+
+ TUF("pli",	450f000, f910f000, 1, (ADDR),	  pli,	    t_pld),
+ TCE("dbg",	320f0f0, f3af80f0, 1, (I15),	  dbg,	    t_dbg),
+
+#undef  ARM_VARIANT
+#define ARM_VARIANT    & arm_ext_mp
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT  & arm_ext_mp
+
+ TUF("pldw",	410f000, f830f000, 1, (ADDR),	pld,	t_pld),
+
+ /* AArchv8 instructions.  */
+#undef  ARM_VARIANT
+#define ARM_VARIANT   & arm_ext_v8
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT & arm_ext_v8
+
+ tCE("sevl",	320f005, _sevl,    0, (),		noargs,	t_hint),
+ TUE("hlt",	1000070, ba80,     1, (oIffffb),	bkpt,	t_hlt),
+ TCE("ldaex",	1900e9f, e8d00fef, 2, (RRnpc, RRnpcb),	rd_rn,	rd_rn),
+ TCE("ldaexd",	1b00e9f, e8d000ff, 3, (RRnpc, oRRnpc, RRnpcb),
+							ldrexd, t_ldrexd),
+ TCE("ldaexb",	1d00e9f, e8d00fcf, 2, (RRnpc,RRnpcb),	rd_rn,  rd_rn),
+ TCE("ldaexh",	1f00e9f, e8d00fdf, 2, (RRnpc, RRnpcb),	rd_rn,  rd_rn),
+ TCE("stlex",	1800e90, e8c00fe0, 3, (RRnpc, RRnpc, RRnpcb),
+							stlex,  t_stlex),
+ TCE("stlexd",	1a00e90, e8c000f0, 4, (RRnpc, RRnpc, oRRnpc, RRnpcb),
+							strexd, t_strexd),
+ TCE("stlexb",	1c00e90, e8c00fc0, 3, (RRnpc, RRnpc, RRnpcb),
+							stlex, t_stlex),
+ TCE("stlexh",	1e00e90, e8c00fd0, 3, (RRnpc, RRnpc, RRnpcb),
+							stlex, t_stlex),
+ TCE("lda",	1900c9f, e8d00faf, 2, (RRnpc, RRnpcb),	rd_rn,	rd_rn),
+ TCE("ldab",	1d00c9f, e8d00f8f, 2, (RRnpc, RRnpcb),	rd_rn,  rd_rn),
+ TCE("ldah",	1f00c9f, e8d00f9f, 2, (RRnpc, RRnpcb),	rd_rn,  rd_rn),
+ TCE("stl",	180fc90, e8c00faf, 2, (RRnpc, RRnpcb),	rm_rn,  rd_rn),
+ TCE("stlb",	1c0fc90, e8c00f8f, 2, (RRnpc, RRnpcb),	rm_rn,  rd_rn),
+ TCE("stlh",	1e0fc90, e8c00f9f, 2, (RRnpc, RRnpcb),	rm_rn,  rd_rn),
+
+ /* ARMv8 T32 only.  */
+#undef  ARM_VARIANT
+#define ARM_VARIANT  NULL
+ TUF("dcps1",	0,	 f78f8001, 0, (),	noargs, noargs),
+ TUF("dcps2",	0,	 f78f8002, 0, (),	noargs, noargs),
+ TUF("dcps3",	0,	 f78f8003, 0, (),	noargs, noargs),
+
+  /* FP for ARMv8.  */
+#undef  ARM_VARIANT
+#define ARM_VARIANT   & fpu_vfp_ext_armv8xd
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT & fpu_vfp_ext_armv8xd
+
+  nUF(vseleq, _vseleq, 3, (RVSD, RVSD, RVSD),		vsel),
+  nUF(vselvs, _vselvs, 3, (RVSD, RVSD, RVSD),		vsel),
+  nUF(vselge, _vselge, 3, (RVSD, RVSD, RVSD),		vsel),
+  nUF(vselgt, _vselgt, 3, (RVSD, RVSD, RVSD),		vsel),
+  nUF(vmaxnm, _vmaxnm, 3, (RNSDQ, oRNSDQ, RNSDQ),	vmaxnm),
+  nUF(vminnm, _vminnm, 3, (RNSDQ, oRNSDQ, RNSDQ),	vmaxnm),
+  nUF(vcvta,  _vcvta,  2, (RNSDQ, oRNSDQ),		neon_cvta),
+  nUF(vcvtn,  _vcvta,  2, (RNSDQ, oRNSDQ),		neon_cvtn),
+  nUF(vcvtp,  _vcvta,  2, (RNSDQ, oRNSDQ),		neon_cvtp),
+  nUF(vcvtm,  _vcvta,  2, (RNSDQ, oRNSDQ),		neon_cvtm),
+  nCE(vrintr, _vrintr, 2, (RNSDQ, oRNSDQ),		vrintr),
+  nCE(vrintz, _vrintr, 2, (RNSDQ, oRNSDQ),		vrintz),
+  nCE(vrintx, _vrintr, 2, (RNSDQ, oRNSDQ),		vrintx),
+  nUF(vrinta, _vrinta, 2, (RNSDQ, oRNSDQ),		vrinta),
+  nUF(vrintn, _vrinta, 2, (RNSDQ, oRNSDQ),		vrintn),
+  nUF(vrintp, _vrinta, 2, (RNSDQ, oRNSDQ),		vrintp),
+  nUF(vrintm, _vrinta, 2, (RNSDQ, oRNSDQ),		vrintm),
+
+  /* Crypto v1 extensions.  */
+#undef  ARM_VARIANT
+#define ARM_VARIANT & fpu_crypto_ext_armv8
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT & fpu_crypto_ext_armv8
+
+  nUF(aese, _aes, 2, (RNQ, RNQ), aese),
+  nUF(aesd, _aes, 2, (RNQ, RNQ), aesd),
+  nUF(aesmc, _aes, 2, (RNQ, RNQ), aesmc),
+  nUF(aesimc, _aes, 2, (RNQ, RNQ), aesimc),
+  nUF(sha1c, _sha3op, 3, (RNQ, RNQ, RNQ), sha1c),
+  nUF(sha1p, _sha3op, 3, (RNQ, RNQ, RNQ), sha1p),
+  nUF(sha1m, _sha3op, 3, (RNQ, RNQ, RNQ), sha1m),
+  nUF(sha1su0, _sha3op, 3, (RNQ, RNQ, RNQ), sha1su0),
+  nUF(sha256h, _sha3op, 3, (RNQ, RNQ, RNQ), sha256h),
+  nUF(sha256h2, _sha3op, 3, (RNQ, RNQ, RNQ), sha256h2),
+  nUF(sha256su1, _sha3op, 3, (RNQ, RNQ, RNQ), sha256su1),
+  nUF(sha1h, _sha1h, 2, (RNQ, RNQ), sha1h),
+  nUF(sha1su1, _sha2op, 2, (RNQ, RNQ), sha1su1),
+  nUF(sha256su0, _sha2op, 2, (RNQ, RNQ), sha256su0),
+
+#undef  ARM_VARIANT
+#define ARM_VARIANT   & crc_ext_armv8
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT & crc_ext_armv8
+  TUEc("crc32b", 1000040, fac0f080, 3, (RR, oRR, RR), crc32b),
+  TUEc("crc32h", 1200040, fac0f090, 3, (RR, oRR, RR), crc32h),
+  TUEc("crc32w", 1400040, fac0f0a0, 3, (RR, oRR, RR), crc32w),
+  TUEc("crc32cb",1000240, fad0f080, 3, (RR, oRR, RR), crc32cb),
+  TUEc("crc32ch",1200240, fad0f090, 3, (RR, oRR, RR), crc32ch),
+  TUEc("crc32cw",1400240, fad0f0a0, 3, (RR, oRR, RR), crc32cw),
+
+#undef  ARM_VARIANT
+#define ARM_VARIANT  & fpu_fpa_ext_v1  /* Core FPA instruction set (V1).  */
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT NULL
+
+ cCE("wfs",	e200110, 1, (RR),	     rd),
+ cCE("rfs",	e300110, 1, (RR),	     rd),
+ cCE("wfc",	e400110, 1, (RR),	     rd),
+ cCE("rfc",	e500110, 1, (RR),	     rd),
+
+ cCL("ldfs",	c100100, 2, (RF, ADDRGLDC),  rd_cpaddr),
+ cCL("ldfd",	c108100, 2, (RF, ADDRGLDC),  rd_cpaddr),
+ cCL("ldfe",	c500100, 2, (RF, ADDRGLDC),  rd_cpaddr),
+ cCL("ldfp",	c508100, 2, (RF, ADDRGLDC),  rd_cpaddr),
+
+ cCL("stfs",	c000100, 2, (RF, ADDRGLDC),  rd_cpaddr),
+ cCL("stfd",	c008100, 2, (RF, ADDRGLDC),  rd_cpaddr),
+ cCL("stfe",	c400100, 2, (RF, ADDRGLDC),  rd_cpaddr),
+ cCL("stfp",	c408100, 2, (RF, ADDRGLDC),  rd_cpaddr),
+
+ cCL("mvfs",	e008100, 2, (RF, RF_IF),     rd_rm),
+ cCL("mvfsp",	e008120, 2, (RF, RF_IF),     rd_rm),
+ cCL("mvfsm",	e008140, 2, (RF, RF_IF),     rd_rm),
+ cCL("mvfsz",	e008160, 2, (RF, RF_IF),     rd_rm),
+ cCL("mvfd",	e008180, 2, (RF, RF_IF),     rd_rm),
+ cCL("mvfdp",	e0081a0, 2, (RF, RF_IF),     rd_rm),
+ cCL("mvfdm",	e0081c0, 2, (RF, RF_IF),     rd_rm),
+ cCL("mvfdz",	e0081e0, 2, (RF, RF_IF),     rd_rm),
+ cCL("mvfe",	e088100, 2, (RF, RF_IF),     rd_rm),
+ cCL("mvfep",	e088120, 2, (RF, RF_IF),     rd_rm),
+ cCL("mvfem",	e088140, 2, (RF, RF_IF),     rd_rm),
+ cCL("mvfez",	e088160, 2, (RF, RF_IF),     rd_rm),
+
+ cCL("mnfs",	e108100, 2, (RF, RF_IF),     rd_rm),
+ cCL("mnfsp",	e108120, 2, (RF, RF_IF),     rd_rm),
+ cCL("mnfsm",	e108140, 2, (RF, RF_IF),     rd_rm),
+ cCL("mnfsz",	e108160, 2, (RF, RF_IF),     rd_rm),
+ cCL("mnfd",	e108180, 2, (RF, RF_IF),     rd_rm),
+ cCL("mnfdp",	e1081a0, 2, (RF, RF_IF),     rd_rm),
+ cCL("mnfdm",	e1081c0, 2, (RF, RF_IF),     rd_rm),
+ cCL("mnfdz",	e1081e0, 2, (RF, RF_IF),     rd_rm),
+ cCL("mnfe",	e188100, 2, (RF, RF_IF),     rd_rm),
+ cCL("mnfep",	e188120, 2, (RF, RF_IF),     rd_rm),
+ cCL("mnfem",	e188140, 2, (RF, RF_IF),     rd_rm),
+ cCL("mnfez",	e188160, 2, (RF, RF_IF),     rd_rm),
+
+ cCL("abss",	e208100, 2, (RF, RF_IF),     rd_rm),
+ cCL("abssp",	e208120, 2, (RF, RF_IF),     rd_rm),
+ cCL("abssm",	e208140, 2, (RF, RF_IF),     rd_rm),
+ cCL("abssz",	e208160, 2, (RF, RF_IF),     rd_rm),
+ cCL("absd",	e208180, 2, (RF, RF_IF),     rd_rm),
+ cCL("absdp",	e2081a0, 2, (RF, RF_IF),     rd_rm),
+ cCL("absdm",	e2081c0, 2, (RF, RF_IF),     rd_rm),
+ cCL("absdz",	e2081e0, 2, (RF, RF_IF),     rd_rm),
+ cCL("abse",	e288100, 2, (RF, RF_IF),     rd_rm),
+ cCL("absep",	e288120, 2, (RF, RF_IF),     rd_rm),
+ cCL("absem",	e288140, 2, (RF, RF_IF),     rd_rm),
+ cCL("absez",	e288160, 2, (RF, RF_IF),     rd_rm),
+
+ cCL("rnds",	e308100, 2, (RF, RF_IF),     rd_rm),
+ cCL("rndsp",	e308120, 2, (RF, RF_IF),     rd_rm),
+ cCL("rndsm",	e308140, 2, (RF, RF_IF),     rd_rm),
+ cCL("rndsz",	e308160, 2, (RF, RF_IF),     rd_rm),
+ cCL("rndd",	e308180, 2, (RF, RF_IF),     rd_rm),
+ cCL("rnddp",	e3081a0, 2, (RF, RF_IF),     rd_rm),
+ cCL("rnddm",	e3081c0, 2, (RF, RF_IF),     rd_rm),
+ cCL("rnddz",	e3081e0, 2, (RF, RF_IF),     rd_rm),
+ cCL("rnde",	e388100, 2, (RF, RF_IF),     rd_rm),
+ cCL("rndep",	e388120, 2, (RF, RF_IF),     rd_rm),
+ cCL("rndem",	e388140, 2, (RF, RF_IF),     rd_rm),
+ cCL("rndez",	e388160, 2, (RF, RF_IF),     rd_rm),
+
+ cCL("sqts",	e408100, 2, (RF, RF_IF),     rd_rm),
+ cCL("sqtsp",	e408120, 2, (RF, RF_IF),     rd_rm),
+ cCL("sqtsm",	e408140, 2, (RF, RF_IF),     rd_rm),
+ cCL("sqtsz",	e408160, 2, (RF, RF_IF),     rd_rm),
+ cCL("sqtd",	e408180, 2, (RF, RF_IF),     rd_rm),
+ cCL("sqtdp",	e4081a0, 2, (RF, RF_IF),     rd_rm),
+ cCL("sqtdm",	e4081c0, 2, (RF, RF_IF),     rd_rm),
+ cCL("sqtdz",	e4081e0, 2, (RF, RF_IF),     rd_rm),
+ cCL("sqte",	e488100, 2, (RF, RF_IF),     rd_rm),
+ cCL("sqtep",	e488120, 2, (RF, RF_IF),     rd_rm),
+ cCL("sqtem",	e488140, 2, (RF, RF_IF),     rd_rm),
+ cCL("sqtez",	e488160, 2, (RF, RF_IF),     rd_rm),
+
+ cCL("logs",	e508100, 2, (RF, RF_IF),     rd_rm),
+ cCL("logsp",	e508120, 2, (RF, RF_IF),     rd_rm),
+ cCL("logsm",	e508140, 2, (RF, RF_IF),     rd_rm),
+ cCL("logsz",	e508160, 2, (RF, RF_IF),     rd_rm),
+ cCL("logd",	e508180, 2, (RF, RF_IF),     rd_rm),
+ cCL("logdp",	e5081a0, 2, (RF, RF_IF),     rd_rm),
+ cCL("logdm",	e5081c0, 2, (RF, RF_IF),     rd_rm),
+ cCL("logdz",	e5081e0, 2, (RF, RF_IF),     rd_rm),
+ cCL("loge",	e588100, 2, (RF, RF_IF),     rd_rm),
+ cCL("logep",	e588120, 2, (RF, RF_IF),     rd_rm),
+ cCL("logem",	e588140, 2, (RF, RF_IF),     rd_rm),
+ cCL("logez",	e588160, 2, (RF, RF_IF),     rd_rm),
+
+ cCL("lgns",	e608100, 2, (RF, RF_IF),     rd_rm),
+ cCL("lgnsp",	e608120, 2, (RF, RF_IF),     rd_rm),
+ cCL("lgnsm",	e608140, 2, (RF, RF_IF),     rd_rm),
+ cCL("lgnsz",	e608160, 2, (RF, RF_IF),     rd_rm),
+ cCL("lgnd",	e608180, 2, (RF, RF_IF),     rd_rm),
+ cCL("lgndp",	e6081a0, 2, (RF, RF_IF),     rd_rm),
+ cCL("lgndm",	e6081c0, 2, (RF, RF_IF),     rd_rm),
+ cCL("lgndz",	e6081e0, 2, (RF, RF_IF),     rd_rm),
+ cCL("lgne",	e688100, 2, (RF, RF_IF),     rd_rm),
+ cCL("lgnep",	e688120, 2, (RF, RF_IF),     rd_rm),
+ cCL("lgnem",	e688140, 2, (RF, RF_IF),     rd_rm),
+ cCL("lgnez",	e688160, 2, (RF, RF_IF),     rd_rm),
+
+ cCL("exps",	e708100, 2, (RF, RF_IF),     rd_rm),
+ cCL("expsp",	e708120, 2, (RF, RF_IF),     rd_rm),
+ cCL("expsm",	e708140, 2, (RF, RF_IF),     rd_rm),
+ cCL("expsz",	e708160, 2, (RF, RF_IF),     rd_rm),
+ cCL("expd",	e708180, 2, (RF, RF_IF),     rd_rm),
+ cCL("expdp",	e7081a0, 2, (RF, RF_IF),     rd_rm),
+ cCL("expdm",	e7081c0, 2, (RF, RF_IF),     rd_rm),
+ cCL("expdz",	e7081e0, 2, (RF, RF_IF),     rd_rm),
+ cCL("expe",	e788100, 2, (RF, RF_IF),     rd_rm),
+ cCL("expep",	e788120, 2, (RF, RF_IF),     rd_rm),
+ cCL("expem",	e788140, 2, (RF, RF_IF),     rd_rm),
+ cCL("expdz",	e788160, 2, (RF, RF_IF),     rd_rm),
+
+ cCL("sins",	e808100, 2, (RF, RF_IF),     rd_rm),
+ cCL("sinsp",	e808120, 2, (RF, RF_IF),     rd_rm),
+ cCL("sinsm",	e808140, 2, (RF, RF_IF),     rd_rm),
+ cCL("sinsz",	e808160, 2, (RF, RF_IF),     rd_rm),
+ cCL("sind",	e808180, 2, (RF, RF_IF),     rd_rm),
+ cCL("sindp",	e8081a0, 2, (RF, RF_IF),     rd_rm),
+ cCL("sindm",	e8081c0, 2, (RF, RF_IF),     rd_rm),
+ cCL("sindz",	e8081e0, 2, (RF, RF_IF),     rd_rm),
+ cCL("sine",	e888100, 2, (RF, RF_IF),     rd_rm),
+ cCL("sinep",	e888120, 2, (RF, RF_IF),     rd_rm),
+ cCL("sinem",	e888140, 2, (RF, RF_IF),     rd_rm),
+ cCL("sinez",	e888160, 2, (RF, RF_IF),     rd_rm),
+
+ cCL("coss",	e908100, 2, (RF, RF_IF),     rd_rm),
+ cCL("cossp",	e908120, 2, (RF, RF_IF),     rd_rm),
+ cCL("cossm",	e908140, 2, (RF, RF_IF),     rd_rm),
+ cCL("cossz",	e908160, 2, (RF, RF_IF),     rd_rm),
+ cCL("cosd",	e908180, 2, (RF, RF_IF),     rd_rm),
+ cCL("cosdp",	e9081a0, 2, (RF, RF_IF),     rd_rm),
+ cCL("cosdm",	e9081c0, 2, (RF, RF_IF),     rd_rm),
+ cCL("cosdz",	e9081e0, 2, (RF, RF_IF),     rd_rm),
+ cCL("cose",	e988100, 2, (RF, RF_IF),     rd_rm),
+ cCL("cosep",	e988120, 2, (RF, RF_IF),     rd_rm),
+ cCL("cosem",	e988140, 2, (RF, RF_IF),     rd_rm),
+ cCL("cosez",	e988160, 2, (RF, RF_IF),     rd_rm),
+
+ cCL("tans",	ea08100, 2, (RF, RF_IF),     rd_rm),
+ cCL("tansp",	ea08120, 2, (RF, RF_IF),     rd_rm),
+ cCL("tansm",	ea08140, 2, (RF, RF_IF),     rd_rm),
+ cCL("tansz",	ea08160, 2, (RF, RF_IF),     rd_rm),
+ cCL("tand",	ea08180, 2, (RF, RF_IF),     rd_rm),
+ cCL("tandp",	ea081a0, 2, (RF, RF_IF),     rd_rm),
+ cCL("tandm",	ea081c0, 2, (RF, RF_IF),     rd_rm),
+ cCL("tandz",	ea081e0, 2, (RF, RF_IF),     rd_rm),
+ cCL("tane",	ea88100, 2, (RF, RF_IF),     rd_rm),
+ cCL("tanep",	ea88120, 2, (RF, RF_IF),     rd_rm),
+ cCL("tanem",	ea88140, 2, (RF, RF_IF),     rd_rm),
+ cCL("tanez",	ea88160, 2, (RF, RF_IF),     rd_rm),
+
+ cCL("asns",	eb08100, 2, (RF, RF_IF),     rd_rm),
+ cCL("asnsp",	eb08120, 2, (RF, RF_IF),     rd_rm),
+ cCL("asnsm",	eb08140, 2, (RF, RF_IF),     rd_rm),
+ cCL("asnsz",	eb08160, 2, (RF, RF_IF),     rd_rm),
+ cCL("asnd",	eb08180, 2, (RF, RF_IF),     rd_rm),
+ cCL("asndp",	eb081a0, 2, (RF, RF_IF),     rd_rm),
+ cCL("asndm",	eb081c0, 2, (RF, RF_IF),     rd_rm),
+ cCL("asndz",	eb081e0, 2, (RF, RF_IF),     rd_rm),
+ cCL("asne",	eb88100, 2, (RF, RF_IF),     rd_rm),
+ cCL("asnep",	eb88120, 2, (RF, RF_IF),     rd_rm),
+ cCL("asnem",	eb88140, 2, (RF, RF_IF),     rd_rm),
+ cCL("asnez",	eb88160, 2, (RF, RF_IF),     rd_rm),
+
+ cCL("acss",	ec08100, 2, (RF, RF_IF),     rd_rm),
+ cCL("acssp",	ec08120, 2, (RF, RF_IF),     rd_rm),
+ cCL("acssm",	ec08140, 2, (RF, RF_IF),     rd_rm),
+ cCL("acssz",	ec08160, 2, (RF, RF_IF),     rd_rm),
+ cCL("acsd",	ec08180, 2, (RF, RF_IF),     rd_rm),
+ cCL("acsdp",	ec081a0, 2, (RF, RF_IF),     rd_rm),
+ cCL("acsdm",	ec081c0, 2, (RF, RF_IF),     rd_rm),
+ cCL("acsdz",	ec081e0, 2, (RF, RF_IF),     rd_rm),
+ cCL("acse",	ec88100, 2, (RF, RF_IF),     rd_rm),
+ cCL("acsep",	ec88120, 2, (RF, RF_IF),     rd_rm),
+ cCL("acsem",	ec88140, 2, (RF, RF_IF),     rd_rm),
+ cCL("acsez",	ec88160, 2, (RF, RF_IF),     rd_rm),
+
+ cCL("atns",	ed08100, 2, (RF, RF_IF),     rd_rm),
+ cCL("atnsp",	ed08120, 2, (RF, RF_IF),     rd_rm),
+ cCL("atnsm",	ed08140, 2, (RF, RF_IF),     rd_rm),
+ cCL("atnsz",	ed08160, 2, (RF, RF_IF),     rd_rm),
+ cCL("atnd",	ed08180, 2, (RF, RF_IF),     rd_rm),
+ cCL("atndp",	ed081a0, 2, (RF, RF_IF),     rd_rm),
+ cCL("atndm",	ed081c0, 2, (RF, RF_IF),     rd_rm),
+ cCL("atndz",	ed081e0, 2, (RF, RF_IF),     rd_rm),
+ cCL("atne",	ed88100, 2, (RF, RF_IF),     rd_rm),
+ cCL("atnep",	ed88120, 2, (RF, RF_IF),     rd_rm),
+ cCL("atnem",	ed88140, 2, (RF, RF_IF),     rd_rm),
+ cCL("atnez",	ed88160, 2, (RF, RF_IF),     rd_rm),
+
+ cCL("urds",	ee08100, 2, (RF, RF_IF),     rd_rm),
+ cCL("urdsp",	ee08120, 2, (RF, RF_IF),     rd_rm),
+ cCL("urdsm",	ee08140, 2, (RF, RF_IF),     rd_rm),
+ cCL("urdsz",	ee08160, 2, (RF, RF_IF),     rd_rm),
+ cCL("urdd",	ee08180, 2, (RF, RF_IF),     rd_rm),
+ cCL("urddp",	ee081a0, 2, (RF, RF_IF),     rd_rm),
+ cCL("urddm",	ee081c0, 2, (RF, RF_IF),     rd_rm),
+ cCL("urddz",	ee081e0, 2, (RF, RF_IF),     rd_rm),
+ cCL("urde",	ee88100, 2, (RF, RF_IF),     rd_rm),
+ cCL("urdep",	ee88120, 2, (RF, RF_IF),     rd_rm),
+ cCL("urdem",	ee88140, 2, (RF, RF_IF),     rd_rm),
+ cCL("urdez",	ee88160, 2, (RF, RF_IF),     rd_rm),
+
+ cCL("nrms",	ef08100, 2, (RF, RF_IF),     rd_rm),
+ cCL("nrmsp",	ef08120, 2, (RF, RF_IF),     rd_rm),
+ cCL("nrmsm",	ef08140, 2, (RF, RF_IF),     rd_rm),
+ cCL("nrmsz",	ef08160, 2, (RF, RF_IF),     rd_rm),
+ cCL("nrmd",	ef08180, 2, (RF, RF_IF),     rd_rm),
+ cCL("nrmdp",	ef081a0, 2, (RF, RF_IF),     rd_rm),
+ cCL("nrmdm",	ef081c0, 2, (RF, RF_IF),     rd_rm),
+ cCL("nrmdz",	ef081e0, 2, (RF, RF_IF),     rd_rm),
+ cCL("nrme",	ef88100, 2, (RF, RF_IF),     rd_rm),
+ cCL("nrmep",	ef88120, 2, (RF, RF_IF),     rd_rm),
+ cCL("nrmem",	ef88140, 2, (RF, RF_IF),     rd_rm),
+ cCL("nrmez",	ef88160, 2, (RF, RF_IF),     rd_rm),
+
+ cCL("adfs",	e000100, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("adfsp",	e000120, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("adfsm",	e000140, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("adfsz",	e000160, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("adfd",	e000180, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("adfdp",	e0001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("adfdm",	e0001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("adfdz",	e0001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("adfe",	e080100, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("adfep",	e080120, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("adfem",	e080140, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("adfez",	e080160, 3, (RF, RF, RF_IF), rd_rn_rm),
+
+ cCL("sufs",	e200100, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("sufsp",	e200120, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("sufsm",	e200140, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("sufsz",	e200160, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("sufd",	e200180, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("sufdp",	e2001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("sufdm",	e2001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("sufdz",	e2001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("sufe",	e280100, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("sufep",	e280120, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("sufem",	e280140, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("sufez",	e280160, 3, (RF, RF, RF_IF), rd_rn_rm),
+
+ cCL("rsfs",	e300100, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rsfsp",	e300120, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rsfsm",	e300140, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rsfsz",	e300160, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rsfd",	e300180, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rsfdp",	e3001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rsfdm",	e3001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rsfdz",	e3001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rsfe",	e380100, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rsfep",	e380120, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rsfem",	e380140, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rsfez",	e380160, 3, (RF, RF, RF_IF), rd_rn_rm),
+
+ cCL("mufs",	e100100, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("mufsp",	e100120, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("mufsm",	e100140, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("mufsz",	e100160, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("mufd",	e100180, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("mufdp",	e1001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("mufdm",	e1001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("mufdz",	e1001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("mufe",	e180100, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("mufep",	e180120, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("mufem",	e180140, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("mufez",	e180160, 3, (RF, RF, RF_IF), rd_rn_rm),
+
+ cCL("dvfs",	e400100, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("dvfsp",	e400120, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("dvfsm",	e400140, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("dvfsz",	e400160, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("dvfd",	e400180, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("dvfdp",	e4001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("dvfdm",	e4001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("dvfdz",	e4001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("dvfe",	e480100, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("dvfep",	e480120, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("dvfem",	e480140, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("dvfez",	e480160, 3, (RF, RF, RF_IF), rd_rn_rm),
+
+ cCL("rdfs",	e500100, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rdfsp",	e500120, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rdfsm",	e500140, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rdfsz",	e500160, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rdfd",	e500180, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rdfdp",	e5001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rdfdm",	e5001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rdfdz",	e5001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rdfe",	e580100, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rdfep",	e580120, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rdfem",	e580140, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rdfez",	e580160, 3, (RF, RF, RF_IF), rd_rn_rm),
+
+ cCL("pows",	e600100, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("powsp",	e600120, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("powsm",	e600140, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("powsz",	e600160, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("powd",	e600180, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("powdp",	e6001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("powdm",	e6001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("powdz",	e6001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("powe",	e680100, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("powep",	e680120, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("powem",	e680140, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("powez",	e680160, 3, (RF, RF, RF_IF), rd_rn_rm),
+
+ cCL("rpws",	e700100, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rpwsp",	e700120, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rpwsm",	e700140, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rpwsz",	e700160, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rpwd",	e700180, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rpwdp",	e7001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rpwdm",	e7001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rpwdz",	e7001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rpwe",	e780100, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rpwep",	e780120, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rpwem",	e780140, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rpwez",	e780160, 3, (RF, RF, RF_IF), rd_rn_rm),
+
+ cCL("rmfs",	e800100, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rmfsp",	e800120, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rmfsm",	e800140, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rmfsz",	e800160, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rmfd",	e800180, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rmfdp",	e8001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rmfdm",	e8001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rmfdz",	e8001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rmfe",	e880100, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rmfep",	e880120, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rmfem",	e880140, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("rmfez",	e880160, 3, (RF, RF, RF_IF), rd_rn_rm),
+
+ cCL("fmls",	e900100, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("fmlsp",	e900120, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("fmlsm",	e900140, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("fmlsz",	e900160, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("fmld",	e900180, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("fmldp",	e9001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("fmldm",	e9001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("fmldz",	e9001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("fmle",	e980100, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("fmlep",	e980120, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("fmlem",	e980140, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("fmlez",	e980160, 3, (RF, RF, RF_IF), rd_rn_rm),
+
+ cCL("fdvs",	ea00100, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("fdvsp",	ea00120, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("fdvsm",	ea00140, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("fdvsz",	ea00160, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("fdvd",	ea00180, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("fdvdp",	ea001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("fdvdm",	ea001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("fdvdz",	ea001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("fdve",	ea80100, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("fdvep",	ea80120, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("fdvem",	ea80140, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("fdvez",	ea80160, 3, (RF, RF, RF_IF), rd_rn_rm),
+
+ cCL("frds",	eb00100, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("frdsp",	eb00120, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("frdsm",	eb00140, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("frdsz",	eb00160, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("frdd",	eb00180, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("frddp",	eb001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("frddm",	eb001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("frddz",	eb001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("frde",	eb80100, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("frdep",	eb80120, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("frdem",	eb80140, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("frdez",	eb80160, 3, (RF, RF, RF_IF), rd_rn_rm),
+
+ cCL("pols",	ec00100, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("polsp",	ec00120, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("polsm",	ec00140, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("polsz",	ec00160, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("pold",	ec00180, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("poldp",	ec001a0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("poldm",	ec001c0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("poldz",	ec001e0, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("pole",	ec80100, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("polep",	ec80120, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("polem",	ec80140, 3, (RF, RF, RF_IF), rd_rn_rm),
+ cCL("polez",	ec80160, 3, (RF, RF, RF_IF), rd_rn_rm),
+
+ cCE("cmf",	e90f110, 2, (RF, RF_IF),     fpa_cmp),
+ C3E("cmfe",	ed0f110, 2, (RF, RF_IF),     fpa_cmp),
+ cCE("cnf",	eb0f110, 2, (RF, RF_IF),     fpa_cmp),
+ C3E("cnfe",	ef0f110, 2, (RF, RF_IF),     fpa_cmp),
+
+ cCL("flts",	e000110, 2, (RF, RR),	     rn_rd),
+ cCL("fltsp",	e000130, 2, (RF, RR),	     rn_rd),
+ cCL("fltsm",	e000150, 2, (RF, RR),	     rn_rd),
+ cCL("fltsz",	e000170, 2, (RF, RR),	     rn_rd),
+ cCL("fltd",	e000190, 2, (RF, RR),	     rn_rd),
+ cCL("fltdp",	e0001b0, 2, (RF, RR),	     rn_rd),
+ cCL("fltdm",	e0001d0, 2, (RF, RR),	     rn_rd),
+ cCL("fltdz",	e0001f0, 2, (RF, RR),	     rn_rd),
+ cCL("flte",	e080110, 2, (RF, RR),	     rn_rd),
+ cCL("fltep",	e080130, 2, (RF, RR),	     rn_rd),
+ cCL("fltem",	e080150, 2, (RF, RR),	     rn_rd),
+ cCL("fltez",	e080170, 2, (RF, RR),	     rn_rd),
+
+  /* The implementation of the FIX instruction is broken on some
+     assemblers, in that it accepts a precision specifier as well as a
+     rounding specifier, despite the fact that this is meaningless.
+     To be more compatible, we accept it as well, though of course it
+     does not set any bits.  */
+ cCE("fix",	e100110, 2, (RR, RF),	     rd_rm),
+ cCL("fixp",	e100130, 2, (RR, RF),	     rd_rm),
+ cCL("fixm",	e100150, 2, (RR, RF),	     rd_rm),
+ cCL("fixz",	e100170, 2, (RR, RF),	     rd_rm),
+ cCL("fixsp",	e100130, 2, (RR, RF),	     rd_rm),
+ cCL("fixsm",	e100150, 2, (RR, RF),	     rd_rm),
+ cCL("fixsz",	e100170, 2, (RR, RF),	     rd_rm),
+ cCL("fixdp",	e100130, 2, (RR, RF),	     rd_rm),
+ cCL("fixdm",	e100150, 2, (RR, RF),	     rd_rm),
+ cCL("fixdz",	e100170, 2, (RR, RF),	     rd_rm),
+ cCL("fixep",	e100130, 2, (RR, RF),	     rd_rm),
+ cCL("fixem",	e100150, 2, (RR, RF),	     rd_rm),
+ cCL("fixez",	e100170, 2, (RR, RF),	     rd_rm),
+
+  /* Instructions that were new with the real FPA, call them V2.  */
+#undef  ARM_VARIANT
+#define ARM_VARIANT  & fpu_fpa_ext_v2
+
+ cCE("lfm",	c100200, 3, (RF, I4b, ADDR), fpa_ldmstm),
+ cCL("lfmfd",	c900200, 3, (RF, I4b, ADDR), fpa_ldmstm),
+ cCL("lfmea",	d100200, 3, (RF, I4b, ADDR), fpa_ldmstm),
+ cCE("sfm",	c000200, 3, (RF, I4b, ADDR), fpa_ldmstm),
+ cCL("sfmfd",	d000200, 3, (RF, I4b, ADDR), fpa_ldmstm),
+ cCL("sfmea",	c800200, 3, (RF, I4b, ADDR), fpa_ldmstm),
+
+#undef  ARM_VARIANT
+#define ARM_VARIANT  & fpu_vfp_ext_v1xd  /* VFP V1xD (single precision).  */
+
+  /* Moves and type conversions.  */
+ cCE("fcpys",	eb00a40, 2, (RVS, RVS),	      vfp_sp_monadic),
+ cCE("fmrs",	e100a10, 2, (RR, RVS),	      vfp_reg_from_sp),
+ cCE("fmsr",	e000a10, 2, (RVS, RR),	      vfp_sp_from_reg),
+ cCE("fmstat",	ef1fa10, 0, (),		      noargs),
+ cCE("vmrs",	ef00a10, 2, (APSR_RR, RVC),   vmrs),
+ cCE("vmsr",	ee00a10, 2, (RVC, RR),        vmsr),
+ cCE("fsitos",	eb80ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
+ cCE("fuitos",	eb80a40, 2, (RVS, RVS),	      vfp_sp_monadic),
+ cCE("ftosis",	ebd0a40, 2, (RVS, RVS),	      vfp_sp_monadic),
+ cCE("ftosizs",	ebd0ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
+ cCE("ftouis",	ebc0a40, 2, (RVS, RVS),	      vfp_sp_monadic),
+ cCE("ftouizs",	ebc0ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
+ cCE("fmrx",	ef00a10, 2, (RR, RVC),	      rd_rn),
+ cCE("fmxr",	ee00a10, 2, (RVC, RR),	      rn_rd),
+
+  /* Memory operations.	 */
+ cCE("flds",	d100a00, 2, (RVS, ADDRGLDC),  vfp_sp_ldst),
+ cCE("fsts",	d000a00, 2, (RVS, ADDRGLDC),  vfp_sp_ldst),
+ cCE("fldmias",	c900a00, 2, (RRnpctw, VRSLST),    vfp_sp_ldstmia),
+ cCE("fldmfds",	c900a00, 2, (RRnpctw, VRSLST),    vfp_sp_ldstmia),
+ cCE("fldmdbs",	d300a00, 2, (RRnpctw, VRSLST),    vfp_sp_ldstmdb),
+ cCE("fldmeas",	d300a00, 2, (RRnpctw, VRSLST),    vfp_sp_ldstmdb),
+ cCE("fldmiax",	c900b00, 2, (RRnpctw, VRDLST),    vfp_xp_ldstmia),
+ cCE("fldmfdx",	c900b00, 2, (RRnpctw, VRDLST),    vfp_xp_ldstmia),
+ cCE("fldmdbx",	d300b00, 2, (RRnpctw, VRDLST),    vfp_xp_ldstmdb),
+ cCE("fldmeax",	d300b00, 2, (RRnpctw, VRDLST),    vfp_xp_ldstmdb),
+ cCE("fstmias",	c800a00, 2, (RRnpctw, VRSLST),    vfp_sp_ldstmia),
+ cCE("fstmeas",	c800a00, 2, (RRnpctw, VRSLST),    vfp_sp_ldstmia),
+ cCE("fstmdbs",	d200a00, 2, (RRnpctw, VRSLST),    vfp_sp_ldstmdb),
+ cCE("fstmfds",	d200a00, 2, (RRnpctw, VRSLST),    vfp_sp_ldstmdb),
+ cCE("fstmiax",	c800b00, 2, (RRnpctw, VRDLST),    vfp_xp_ldstmia),
+ cCE("fstmeax",	c800b00, 2, (RRnpctw, VRDLST),    vfp_xp_ldstmia),
+ cCE("fstmdbx",	d200b00, 2, (RRnpctw, VRDLST),    vfp_xp_ldstmdb),
+ cCE("fstmfdx",	d200b00, 2, (RRnpctw, VRDLST),    vfp_xp_ldstmdb),
+
+  /* Monadic operations.  */
+ cCE("fabss",	eb00ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
+ cCE("fnegs",	eb10a40, 2, (RVS, RVS),	      vfp_sp_monadic),
+ cCE("fsqrts",	eb10ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
+
+  /* Dyadic operations.	 */
+ cCE("fadds",	e300a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
+ cCE("fsubs",	e300a40, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
+ cCE("fmuls",	e200a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
+ cCE("fdivs",	e800a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
+ cCE("fmacs",	e000a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
+ cCE("fmscs",	e100a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
+ cCE("fnmuls",	e200a40, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
+ cCE("fnmacs",	e000a40, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
+ cCE("fnmscs",	e100a40, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
+
+  /* Comparisons.  */
+ cCE("fcmps",	eb40a40, 2, (RVS, RVS),	      vfp_sp_monadic),
+ cCE("fcmpzs",	eb50a40, 1, (RVS),	      vfp_sp_compare_z),
+ cCE("fcmpes",	eb40ac0, 2, (RVS, RVS),	      vfp_sp_monadic),
+ cCE("fcmpezs",	eb50ac0, 1, (RVS),	      vfp_sp_compare_z),
+
+ /* Double precision load/store are still present on single precision
+    implementations.  */
+ cCE("fldd",	d100b00, 2, (RVD, ADDRGLDC),  vfp_dp_ldst),
+ cCE("fstd",	d000b00, 2, (RVD, ADDRGLDC),  vfp_dp_ldst),
+ cCE("fldmiad",	c900b00, 2, (RRnpctw, VRDLST),    vfp_dp_ldstmia),
+ cCE("fldmfdd",	c900b00, 2, (RRnpctw, VRDLST),    vfp_dp_ldstmia),
+ cCE("fldmdbd",	d300b00, 2, (RRnpctw, VRDLST),    vfp_dp_ldstmdb),
+ cCE("fldmead",	d300b00, 2, (RRnpctw, VRDLST),    vfp_dp_ldstmdb),
+ cCE("fstmiad",	c800b00, 2, (RRnpctw, VRDLST),    vfp_dp_ldstmia),
+ cCE("fstmead",	c800b00, 2, (RRnpctw, VRDLST),    vfp_dp_ldstmia),
+ cCE("fstmdbd",	d200b00, 2, (RRnpctw, VRDLST),    vfp_dp_ldstmdb),
+ cCE("fstmfdd",	d200b00, 2, (RRnpctw, VRDLST),    vfp_dp_ldstmdb),
+
+#undef  ARM_VARIANT
+#define ARM_VARIANT  & fpu_vfp_ext_v1 /* VFP V1 (Double precision).  */
+
+  /* Moves and type conversions.  */
+ cCE("fcpyd",	eb00b40, 2, (RVD, RVD),	      vfp_dp_rd_rm),
+ cCE("fcvtds",	eb70ac0, 2, (RVD, RVS),	      vfp_dp_sp_cvt),
+ cCE("fcvtsd",	eb70bc0, 2, (RVS, RVD),	      vfp_sp_dp_cvt),
+ cCE("fmdhr",	e200b10, 2, (RVD, RR),	      vfp_dp_rn_rd),
+ cCE("fmdlr",	e000b10, 2, (RVD, RR),	      vfp_dp_rn_rd),
+ cCE("fmrdh",	e300b10, 2, (RR, RVD),	      vfp_dp_rd_rn),
+ cCE("fmrdl",	e100b10, 2, (RR, RVD),	      vfp_dp_rd_rn),
+ cCE("fsitod",	eb80bc0, 2, (RVD, RVS),	      vfp_dp_sp_cvt),
+ cCE("fuitod",	eb80b40, 2, (RVD, RVS),	      vfp_dp_sp_cvt),
+ cCE("ftosid",	ebd0b40, 2, (RVS, RVD),	      vfp_sp_dp_cvt),
+ cCE("ftosizd",	ebd0bc0, 2, (RVS, RVD),	      vfp_sp_dp_cvt),
+ cCE("ftouid",	ebc0b40, 2, (RVS, RVD),	      vfp_sp_dp_cvt),
+ cCE("ftouizd",	ebc0bc0, 2, (RVS, RVD),	      vfp_sp_dp_cvt),
+
+  /* Monadic operations.  */
+ cCE("fabsd",	eb00bc0, 2, (RVD, RVD),	      vfp_dp_rd_rm),
+ cCE("fnegd",	eb10b40, 2, (RVD, RVD),	      vfp_dp_rd_rm),
+ cCE("fsqrtd",	eb10bc0, 2, (RVD, RVD),	      vfp_dp_rd_rm),
+
+  /* Dyadic operations.	 */
+ cCE("faddd",	e300b00, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
+ cCE("fsubd",	e300b40, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
+ cCE("fmuld",	e200b00, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
+ cCE("fdivd",	e800b00, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
+ cCE("fmacd",	e000b00, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
+ cCE("fmscd",	e100b00, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
+ cCE("fnmuld",	e200b40, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
+ cCE("fnmacd",	e000b40, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
+ cCE("fnmscd",	e100b40, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
+
+  /* Comparisons.  */
+ cCE("fcmpd",	eb40b40, 2, (RVD, RVD),	      vfp_dp_rd_rm),
+ cCE("fcmpzd",	eb50b40, 1, (RVD),	      vfp_dp_rd),
+ cCE("fcmped",	eb40bc0, 2, (RVD, RVD),	      vfp_dp_rd_rm),
+ cCE("fcmpezd",	eb50bc0, 1, (RVD),	      vfp_dp_rd),
+
+#undef  ARM_VARIANT
+#define ARM_VARIANT  & fpu_vfp_ext_v2
+
+ cCE("fmsrr",	c400a10, 3, (VRSLST, RR, RR), vfp_sp2_from_reg2),
+ cCE("fmrrs",	c500a10, 3, (RR, RR, VRSLST), vfp_reg2_from_sp2),
+ cCE("fmdrr",	c400b10, 3, (RVD, RR, RR),    vfp_dp_rm_rd_rn),
+ cCE("fmrrd",	c500b10, 3, (RR, RR, RVD),    vfp_dp_rd_rn_rm),
+
+/* Instructions which may belong to either the Neon or VFP instruction sets.
+   Individual encoder functions perform additional architecture checks.  */
+#undef  ARM_VARIANT
+#define ARM_VARIANT    & fpu_vfp_ext_v1xd
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT  & fpu_vfp_ext_v1xd
+
+  /* These mnemonics are unique to VFP.  */
+ NCE(vsqrt,     0,       2, (RVSD, RVSD),       vfp_nsyn_sqrt),
+ NCE(vdiv,      0,       3, (RVSD, RVSD, RVSD), vfp_nsyn_div),
+ nCE(vnmul,     _vnmul,   3, (RVSD, RVSD, RVSD), vfp_nsyn_nmul),
+ nCE(vnmla,     _vnmla,   3, (RVSD, RVSD, RVSD), vfp_nsyn_nmul),
+ nCE(vnmls,     _vnmls,   3, (RVSD, RVSD, RVSD), vfp_nsyn_nmul),
+ nCE(vcmp,      _vcmp,    2, (RVSD, RSVD_FI0),    vfp_nsyn_cmp),
+ nCE(vcmpe,     _vcmpe,   2, (RVSD, RSVD_FI0),    vfp_nsyn_cmp),
+ NCE(vpush,     0,       1, (VRSDLST),          vfp_nsyn_push),
+ NCE(vpop,      0,       1, (VRSDLST),          vfp_nsyn_pop),
+ NCE(vcvtz,     0,       2, (RVSD, RVSD),       vfp_nsyn_cvtz),
+
+  /* Mnemonics shared by Neon and VFP.  */
+ nCEF(vmul,     _vmul,    3, (RNSDQ, oRNSDQ, RNSDQ_RNSC), neon_mul),
+ nCEF(vmla,     _vmla,    3, (RNSDQ, oRNSDQ, RNSDQ_RNSC), neon_mac_maybe_scalar),
+ nCEF(vmls,     _vmls,    3, (RNSDQ, oRNSDQ, RNSDQ_RNSC), neon_mac_maybe_scalar),
+
+ nCEF(vadd,     _vadd,    3, (RNSDQ, oRNSDQ, RNSDQ), neon_addsub_if_i),
+ nCEF(vsub,     _vsub,    3, (RNSDQ, oRNSDQ, RNSDQ), neon_addsub_if_i),
+
+ NCEF(vabs,     1b10300, 2, (RNSDQ, RNSDQ), neon_abs_neg),
+ NCEF(vneg,     1b10380, 2, (RNSDQ, RNSDQ), neon_abs_neg),
+
+ NCE(vldm,      c900b00, 2, (RRnpctw, VRSDLST), neon_ldm_stm),
+ NCE(vldmia,    c900b00, 2, (RRnpctw, VRSDLST), neon_ldm_stm),
+ NCE(vldmdb,    d100b00, 2, (RRnpctw, VRSDLST), neon_ldm_stm),
+ NCE(vstm,      c800b00, 2, (RRnpctw, VRSDLST), neon_ldm_stm),
+ NCE(vstmia,    c800b00, 2, (RRnpctw, VRSDLST), neon_ldm_stm),
+ NCE(vstmdb,    d000b00, 2, (RRnpctw, VRSDLST), neon_ldm_stm),
+ NCE(vldr,      d100b00, 2, (RVSD, ADDRGLDC), neon_ldr_str),
+ NCE(vstr,      d000b00, 2, (RVSD, ADDRGLDC), neon_ldr_str),
+
+ nCEF(vcvt,     _vcvt,   3, (RNSDQ, RNSDQ, oI32z), neon_cvt),
+ nCEF(vcvtr,    _vcvt,   2, (RNSDQ, RNSDQ), neon_cvtr),
+ NCEF(vcvtb,	eb20a40, 2, (RVSD, RVSD), neon_cvtb),
+ NCEF(vcvtt,	eb20a40, 2, (RVSD, RVSD), neon_cvtt),
+
+
+  /* NOTE: All VMOV encoding is special-cased!  */
+ NCE(vmov,      0,       1, (VMOV), neon_mov),
+ NCE(vmovq,     0,       1, (VMOV), neon_mov),
+
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT  & fpu_neon_ext_v1
+#undef  ARM_VARIANT
+#define ARM_VARIANT    & fpu_neon_ext_v1
+
+  /* Data processing with three registers of the same length.  */
+  /* integer ops, valid types S8 S16 S32 U8 U16 U32.  */
+ NUF(vaba,      0000710, 3, (RNDQ, RNDQ,  RNDQ), neon_dyadic_i_su),
+ NUF(vabaq,     0000710, 3, (RNQ,  RNQ,   RNQ),  neon_dyadic_i_su),
+ NUF(vhadd,     0000000, 3, (RNDQ, oRNDQ, RNDQ), neon_dyadic_i_su),
+ NUF(vhaddq,    0000000, 3, (RNQ,  oRNQ,  RNQ),  neon_dyadic_i_su),
+ NUF(vrhadd,    0000100, 3, (RNDQ, oRNDQ, RNDQ), neon_dyadic_i_su),
+ NUF(vrhaddq,   0000100, 3, (RNQ,  oRNQ,  RNQ),  neon_dyadic_i_su),
+ NUF(vhsub,     0000200, 3, (RNDQ, oRNDQ, RNDQ), neon_dyadic_i_su),
+ NUF(vhsubq,    0000200, 3, (RNQ,  oRNQ,  RNQ),  neon_dyadic_i_su),
+  /* integer ops, valid types S8 S16 S32 S64 U8 U16 U32 U64.  */
+ NUF(vqadd,     0000010, 3, (RNDQ, oRNDQ, RNDQ), neon_dyadic_i64_su),
+ NUF(vqaddq,    0000010, 3, (RNQ,  oRNQ,  RNQ),  neon_dyadic_i64_su),
+ NUF(vqsub,     0000210, 3, (RNDQ, oRNDQ, RNDQ), neon_dyadic_i64_su),
+ NUF(vqsubq,    0000210, 3, (RNQ,  oRNQ,  RNQ),  neon_dyadic_i64_su),
+ NUF(vrshl,     0000500, 3, (RNDQ, oRNDQ, RNDQ), neon_rshl),
+ NUF(vrshlq,    0000500, 3, (RNQ,  oRNQ,  RNQ),  neon_rshl),
+ NUF(vqrshl,    0000510, 3, (RNDQ, oRNDQ, RNDQ), neon_rshl),
+ NUF(vqrshlq,   0000510, 3, (RNQ,  oRNQ,  RNQ),  neon_rshl),
+  /* If not immediate, fall back to neon_dyadic_i64_su.
+     shl_imm should accept I8 I16 I32 I64,
+     qshl_imm should accept S8 S16 S32 S64 U8 U16 U32 U64.  */
+ nUF(vshl,      _vshl,    3, (RNDQ, oRNDQ, RNDQ_I63b), neon_shl_imm),
+ nUF(vshlq,     _vshl,    3, (RNQ,  oRNQ,  RNDQ_I63b), neon_shl_imm),
+ nUF(vqshl,     _vqshl,   3, (RNDQ, oRNDQ, RNDQ_I63b), neon_qshl_imm),
+ nUF(vqshlq,    _vqshl,   3, (RNQ,  oRNQ,  RNDQ_I63b), neon_qshl_imm),
+  /* Logic ops, types optional & ignored.  */
+ nUF(vand,      _vand,    3, (RNDQ, oRNDQ, RNDQ_Ibig), neon_logic),
+ nUF(vandq,     _vand,    3, (RNQ,  oRNQ,  RNDQ_Ibig), neon_logic),
+ nUF(vbic,      _vbic,    3, (RNDQ, oRNDQ, RNDQ_Ibig), neon_logic),
+ nUF(vbicq,     _vbic,    3, (RNQ,  oRNQ,  RNDQ_Ibig), neon_logic),
+ nUF(vorr,      _vorr,    3, (RNDQ, oRNDQ, RNDQ_Ibig), neon_logic),
+ nUF(vorrq,     _vorr,    3, (RNQ,  oRNQ,  RNDQ_Ibig), neon_logic),
+ nUF(vorn,      _vorn,    3, (RNDQ, oRNDQ, RNDQ_Ibig), neon_logic),
+ nUF(vornq,     _vorn,    3, (RNQ,  oRNQ,  RNDQ_Ibig), neon_logic),
+ nUF(veor,      _veor,    3, (RNDQ, oRNDQ, RNDQ),      neon_logic),
+ nUF(veorq,     _veor,    3, (RNQ,  oRNQ,  RNQ),       neon_logic),
+  /* Bitfield ops, untyped.  */
+ NUF(vbsl,      1100110, 3, (RNDQ, RNDQ, RNDQ), neon_bitfield),
+ NUF(vbslq,     1100110, 3, (RNQ,  RNQ,  RNQ),  neon_bitfield),
+ NUF(vbit,      1200110, 3, (RNDQ, RNDQ, RNDQ), neon_bitfield),
+ NUF(vbitq,     1200110, 3, (RNQ,  RNQ,  RNQ),  neon_bitfield),
+ NUF(vbif,      1300110, 3, (RNDQ, RNDQ, RNDQ), neon_bitfield),
+ NUF(vbifq,     1300110, 3, (RNQ,  RNQ,  RNQ),  neon_bitfield),
+  /* Int and float variants, types S8 S16 S32 U8 U16 U32 F32.  */
+ nUF(vabd,      _vabd,    3, (RNDQ, oRNDQ, RNDQ), neon_dyadic_if_su),
+ nUF(vabdq,     _vabd,    3, (RNQ,  oRNQ,  RNQ),  neon_dyadic_if_su),
+ nUF(vmax,      _vmax,    3, (RNDQ, oRNDQ, RNDQ), neon_dyadic_if_su),
+ nUF(vmaxq,     _vmax,    3, (RNQ,  oRNQ,  RNQ),  neon_dyadic_if_su),
+ nUF(vmin,      _vmin,    3, (RNDQ, oRNDQ, RNDQ), neon_dyadic_if_su),
+ nUF(vminq,     _vmin,    3, (RNQ,  oRNQ,  RNQ),  neon_dyadic_if_su),
+  /* Comparisons. Types S8 S16 S32 U8 U16 U32 F32. Non-immediate versions fall
+     back to neon_dyadic_if_su.  */
+ nUF(vcge,      _vcge,    3, (RNDQ, oRNDQ, RNDQ_I0), neon_cmp),
+ nUF(vcgeq,     _vcge,    3, (RNQ,  oRNQ,  RNDQ_I0), neon_cmp),
+ nUF(vcgt,      _vcgt,    3, (RNDQ, oRNDQ, RNDQ_I0), neon_cmp),
+ nUF(vcgtq,     _vcgt,    3, (RNQ,  oRNQ,  RNDQ_I0), neon_cmp),
+ nUF(vclt,      _vclt,    3, (RNDQ, oRNDQ, RNDQ_I0), neon_cmp_inv),
+ nUF(vcltq,     _vclt,    3, (RNQ,  oRNQ,  RNDQ_I0), neon_cmp_inv),
+ nUF(vcle,      _vcle,    3, (RNDQ, oRNDQ, RNDQ_I0), neon_cmp_inv),
+ nUF(vcleq,     _vcle,    3, (RNQ,  oRNQ,  RNDQ_I0), neon_cmp_inv),
+  /* Comparison. Type I8 I16 I32 F32.  */
+ nUF(vceq,      _vceq,    3, (RNDQ, oRNDQ, RNDQ_I0), neon_ceq),
+ nUF(vceqq,     _vceq,    3, (RNQ,  oRNQ,  RNDQ_I0), neon_ceq),
+  /* As above, D registers only.  */
+ nUF(vpmax,     _vpmax,   3, (RND, oRND, RND), neon_dyadic_if_su_d),
+ nUF(vpmin,     _vpmin,   3, (RND, oRND, RND), neon_dyadic_if_su_d),
+  /* Int and float variants, signedness unimportant.  */
+ nUF(vmlaq,     _vmla,    3, (RNQ,  oRNQ,  RNDQ_RNSC), neon_mac_maybe_scalar),
+ nUF(vmlsq,     _vmls,    3, (RNQ,  oRNQ,  RNDQ_RNSC), neon_mac_maybe_scalar),
+ nUF(vpadd,     _vpadd,   3, (RND,  oRND,  RND),       neon_dyadic_if_i_d),
+  /* Add/sub take types I8 I16 I32 I64 F32.  */
+ nUF(vaddq,     _vadd,    3, (RNQ,  oRNQ,  RNQ),  neon_addsub_if_i),
+ nUF(vsubq,     _vsub,    3, (RNQ,  oRNQ,  RNQ),  neon_addsub_if_i),
+  /* vtst takes sizes 8, 16, 32.  */
+ NUF(vtst,      0000810, 3, (RNDQ, oRNDQ, RNDQ), neon_tst),
+ NUF(vtstq,     0000810, 3, (RNQ,  oRNQ,  RNQ),  neon_tst),
+  /* VMUL takes I8 I16 I32 F32 P8.  */
+ nUF(vmulq,     _vmul,     3, (RNQ,  oRNQ,  RNDQ_RNSC), neon_mul),
+  /* VQD{R}MULH takes S16 S32.  */
+ nUF(vqdmulh,   _vqdmulh,  3, (RNDQ, oRNDQ, RNDQ_RNSC), neon_qdmulh),
+ nUF(vqdmulhq,  _vqdmulh,  3, (RNQ,  oRNQ,  RNDQ_RNSC), neon_qdmulh),
+ nUF(vqrdmulh,  _vqrdmulh, 3, (RNDQ, oRNDQ, RNDQ_RNSC), neon_qdmulh),
+ nUF(vqrdmulhq, _vqrdmulh, 3, (RNQ,  oRNQ,  RNDQ_RNSC), neon_qdmulh),
+ NUF(vacge,     0000e10,  3, (RNDQ, oRNDQ, RNDQ), neon_fcmp_absolute),
+ NUF(vacgeq,    0000e10,  3, (RNQ,  oRNQ,  RNQ),  neon_fcmp_absolute),
+ NUF(vacgt,     0200e10,  3, (RNDQ, oRNDQ, RNDQ), neon_fcmp_absolute),
+ NUF(vacgtq,    0200e10,  3, (RNQ,  oRNQ,  RNQ),  neon_fcmp_absolute),
+ NUF(vaclt,     0200e10,  3, (RNDQ, oRNDQ, RNDQ), neon_fcmp_absolute_inv),
+ NUF(vacltq,    0200e10,  3, (RNQ,  oRNQ,  RNQ),  neon_fcmp_absolute_inv),
+ NUF(vacle,     0000e10,  3, (RNDQ, oRNDQ, RNDQ), neon_fcmp_absolute_inv),
+ NUF(vacleq,    0000e10,  3, (RNQ,  oRNQ,  RNQ),  neon_fcmp_absolute_inv),
+ NUF(vrecps,    0000f10,  3, (RNDQ, oRNDQ, RNDQ), neon_step),
+ NUF(vrecpsq,   0000f10,  3, (RNQ,  oRNQ,  RNQ),  neon_step),
+ NUF(vrsqrts,   0200f10,  3, (RNDQ, oRNDQ, RNDQ), neon_step),
+ NUF(vrsqrtsq,  0200f10,  3, (RNQ,  oRNQ,  RNQ),  neon_step),
+ /* ARM v8.1 extension.  */
+ nUF(vqrdmlah,  _vqrdmlah, 3, (RNDQ, oRNDQ, RNDQ_RNSC), neon_qdmulh),
+ nUF(vqrdmlahq, _vqrdmlah, 3, (RNQ,  oRNQ,  RNDQ_RNSC), neon_qdmulh),
+ nUF(vqrdmlsh,  _vqrdmlsh, 3, (RNDQ, oRNDQ, RNDQ_RNSC), neon_qdmulh),
+ nUF(vqrdmlshq, _vqrdmlsh, 3, (RNQ,  oRNQ,  RNDQ_RNSC), neon_qdmulh),
+
+  /* Two address, int/float. Types S8 S16 S32 F32.  */
+ NUF(vabsq,     1b10300, 2, (RNQ,  RNQ),      neon_abs_neg),
+ NUF(vnegq,     1b10380, 2, (RNQ,  RNQ),      neon_abs_neg),
+
+  /* Data processing with two registers and a shift amount.  */
+  /* Right shifts, and variants with rounding.
+     Types accepted S8 S16 S32 S64 U8 U16 U32 U64.  */
+ NUF(vshr,      0800010, 3, (RNDQ, oRNDQ, I64z), neon_rshift_round_imm),
+ NUF(vshrq,     0800010, 3, (RNQ,  oRNQ,  I64z), neon_rshift_round_imm),
+ NUF(vrshr,     0800210, 3, (RNDQ, oRNDQ, I64z), neon_rshift_round_imm),
+ NUF(vrshrq,    0800210, 3, (RNQ,  oRNQ,  I64z), neon_rshift_round_imm),
+ NUF(vsra,      0800110, 3, (RNDQ, oRNDQ, I64),  neon_rshift_round_imm),
+ NUF(vsraq,     0800110, 3, (RNQ,  oRNQ,  I64),  neon_rshift_round_imm),
+ NUF(vrsra,     0800310, 3, (RNDQ, oRNDQ, I64),  neon_rshift_round_imm),
+ NUF(vrsraq,    0800310, 3, (RNQ,  oRNQ,  I64),  neon_rshift_round_imm),
+  /* Shift and insert. Sizes accepted 8 16 32 64.  */
+ NUF(vsli,      1800510, 3, (RNDQ, oRNDQ, I63), neon_sli),
+ NUF(vsliq,     1800510, 3, (RNQ,  oRNQ,  I63), neon_sli),
+ NUF(vsri,      1800410, 3, (RNDQ, oRNDQ, I64), neon_sri),
+ NUF(vsriq,     1800410, 3, (RNQ,  oRNQ,  I64), neon_sri),
+  /* QSHL{U} immediate accepts S8 S16 S32 S64 U8 U16 U32 U64.  */
+ NUF(vqshlu,    1800610, 3, (RNDQ, oRNDQ, I63), neon_qshlu_imm),
+ NUF(vqshluq,   1800610, 3, (RNQ,  oRNQ,  I63), neon_qshlu_imm),
+  /* Right shift immediate, saturating & narrowing, with rounding variants.
+     Types accepted S16 S32 S64 U16 U32 U64.  */
+ NUF(vqshrn,    0800910, 3, (RND, RNQ, I32z), neon_rshift_sat_narrow),
+ NUF(vqrshrn,   0800950, 3, (RND, RNQ, I32z), neon_rshift_sat_narrow),
+  /* As above, unsigned. Types accepted S16 S32 S64.  */
+ NUF(vqshrun,   0800810, 3, (RND, RNQ, I32z), neon_rshift_sat_narrow_u),
+ NUF(vqrshrun,  0800850, 3, (RND, RNQ, I32z), neon_rshift_sat_narrow_u),
+  /* Right shift narrowing. Types accepted I16 I32 I64.  */
+ NUF(vshrn,     0800810, 3, (RND, RNQ, I32z), neon_rshift_narrow),
+ NUF(vrshrn,    0800850, 3, (RND, RNQ, I32z), neon_rshift_narrow),
+  /* Special case. Types S8 S16 S32 U8 U16 U32. Handles max shift variant.  */
+ nUF(vshll,     _vshll,   3, (RNQ, RND, I32),  neon_shll),
+  /* CVT with optional immediate for fixed-point variant.  */
+ nUF(vcvtq,     _vcvt,    3, (RNQ, RNQ, oI32b), neon_cvt),
+
+ nUF(vmvn,      _vmvn,    2, (RNDQ, RNDQ_Ibig), neon_mvn),
+ nUF(vmvnq,     _vmvn,    2, (RNQ,  RNDQ_Ibig), neon_mvn),
+
+  /* Data processing, three registers of different lengths.  */
+  /* Dyadic, long insns. Types S8 S16 S32 U8 U16 U32.  */
+ NUF(vabal,     0800500, 3, (RNQ, RND, RND),  neon_abal),
+ NUF(vabdl,     0800700, 3, (RNQ, RND, RND),  neon_dyadic_long),
+ NUF(vaddl,     0800000, 3, (RNQ, RND, RND),  neon_dyadic_long),
+ NUF(vsubl,     0800200, 3, (RNQ, RND, RND),  neon_dyadic_long),
+  /* If not scalar, fall back to neon_dyadic_long.
+     Vector types as above, scalar types S16 S32 U16 U32.  */
+ nUF(vmlal,     _vmlal,   3, (RNQ, RND, RND_RNSC), neon_mac_maybe_scalar_long),
+ nUF(vmlsl,     _vmlsl,   3, (RNQ, RND, RND_RNSC), neon_mac_maybe_scalar_long),
+  /* Dyadic, widening insns. Types S8 S16 S32 U8 U16 U32.  */
+ NUF(vaddw,     0800100, 3, (RNQ, oRNQ, RND), neon_dyadic_wide),
+ NUF(vsubw,     0800300, 3, (RNQ, oRNQ, RND), neon_dyadic_wide),
+  /* Dyadic, narrowing insns. Types I16 I32 I64.  */
+ NUF(vaddhn,    0800400, 3, (RND, RNQ, RNQ),  neon_dyadic_narrow),
+ NUF(vraddhn,   1800400, 3, (RND, RNQ, RNQ),  neon_dyadic_narrow),
+ NUF(vsubhn,    0800600, 3, (RND, RNQ, RNQ),  neon_dyadic_narrow),
+ NUF(vrsubhn,   1800600, 3, (RND, RNQ, RNQ),  neon_dyadic_narrow),
+  /* Saturating doubling multiplies. Types S16 S32.  */
+ nUF(vqdmlal,   _vqdmlal, 3, (RNQ, RND, RND_RNSC), neon_mul_sat_scalar_long),
+ nUF(vqdmlsl,   _vqdmlsl, 3, (RNQ, RND, RND_RNSC), neon_mul_sat_scalar_long),
+ nUF(vqdmull,   _vqdmull, 3, (RNQ, RND, RND_RNSC), neon_mul_sat_scalar_long),
+  /* VMULL. Vector types S8 S16 S32 U8 U16 U32 P8, scalar types
+     S16 S32 U16 U32.  */
+ nUF(vmull,     _vmull,   3, (RNQ, RND, RND_RNSC), neon_vmull),
+
+  /* Extract. Size 8.  */
+ NUF(vext,      0b00000, 4, (RNDQ, oRNDQ, RNDQ, I15), neon_ext),
+ NUF(vextq,     0b00000, 4, (RNQ,  oRNQ,  RNQ,  I15), neon_ext),
+
+  /* Two registers, miscellaneous.  */
+  /* Reverse. Sizes 8 16 32 (must be < size in opcode).  */
+ NUF(vrev64,    1b00000, 2, (RNDQ, RNDQ),     neon_rev),
+ NUF(vrev64q,   1b00000, 2, (RNQ,  RNQ),      neon_rev),
+ NUF(vrev32,    1b00080, 2, (RNDQ, RNDQ),     neon_rev),
+ NUF(vrev32q,   1b00080, 2, (RNQ,  RNQ),      neon_rev),
+ NUF(vrev16,    1b00100, 2, (RNDQ, RNDQ),     neon_rev),
+ NUF(vrev16q,   1b00100, 2, (RNQ,  RNQ),      neon_rev),
+  /* Vector replicate. Sizes 8 16 32.  */
+ nCE(vdup,      _vdup,    2, (RNDQ, RR_RNSC),  neon_dup),
+ nCE(vdupq,     _vdup,    2, (RNQ,  RR_RNSC),  neon_dup),
+  /* VMOVL. Types S8 S16 S32 U8 U16 U32.  */
+ NUF(vmovl,     0800a10, 2, (RNQ, RND),       neon_movl),
+  /* VMOVN. Types I16 I32 I64.  */
+ nUF(vmovn,     _vmovn,   2, (RND, RNQ),       neon_movn),
+  /* VQMOVN. Types S16 S32 S64 U16 U32 U64.  */
+ nUF(vqmovn,    _vqmovn,  2, (RND, RNQ),       neon_qmovn),
+  /* VQMOVUN. Types S16 S32 S64.  */
+ nUF(vqmovun,   _vqmovun, 2, (RND, RNQ),       neon_qmovun),
+  /* VZIP / VUZP. Sizes 8 16 32.  */
+ NUF(vzip,      1b20180, 2, (RNDQ, RNDQ),     neon_zip_uzp),
+ NUF(vzipq,     1b20180, 2, (RNQ,  RNQ),      neon_zip_uzp),
+ NUF(vuzp,      1b20100, 2, (RNDQ, RNDQ),     neon_zip_uzp),
+ NUF(vuzpq,     1b20100, 2, (RNQ,  RNQ),      neon_zip_uzp),
+  /* VQABS / VQNEG. Types S8 S16 S32.  */
+ NUF(vqabs,     1b00700, 2, (RNDQ, RNDQ),     neon_sat_abs_neg),
+ NUF(vqabsq,    1b00700, 2, (RNQ,  RNQ),      neon_sat_abs_neg),
+ NUF(vqneg,     1b00780, 2, (RNDQ, RNDQ),     neon_sat_abs_neg),
+ NUF(vqnegq,    1b00780, 2, (RNQ,  RNQ),      neon_sat_abs_neg),
+  /* Pairwise, lengthening. Types S8 S16 S32 U8 U16 U32.  */
+ NUF(vpadal,    1b00600, 2, (RNDQ, RNDQ),     neon_pair_long),
+ NUF(vpadalq,   1b00600, 2, (RNQ,  RNQ),      neon_pair_long),
+ NUF(vpaddl,    1b00200, 2, (RNDQ, RNDQ),     neon_pair_long),
+ NUF(vpaddlq,   1b00200, 2, (RNQ,  RNQ),      neon_pair_long),
+  /* Reciprocal estimates. Types U32 F32.  */
+ NUF(vrecpe,    1b30400, 2, (RNDQ, RNDQ),     neon_recip_est),
+ NUF(vrecpeq,   1b30400, 2, (RNQ,  RNQ),      neon_recip_est),
+ NUF(vrsqrte,   1b30480, 2, (RNDQ, RNDQ),     neon_recip_est),
+ NUF(vrsqrteq,  1b30480, 2, (RNQ,  RNQ),      neon_recip_est),
+  /* VCLS. Types S8 S16 S32.  */
+ NUF(vcls,      1b00400, 2, (RNDQ, RNDQ),     neon_cls),
+ NUF(vclsq,     1b00400, 2, (RNQ,  RNQ),      neon_cls),
+  /* VCLZ. Types I8 I16 I32.  */
+ NUF(vclz,      1b00480, 2, (RNDQ, RNDQ),     neon_clz),
+ NUF(vclzq,     1b00480, 2, (RNQ,  RNQ),      neon_clz),
+  /* VCNT. Size 8.  */
+ NUF(vcnt,      1b00500, 2, (RNDQ, RNDQ),     neon_cnt),
+ NUF(vcntq,     1b00500, 2, (RNQ,  RNQ),      neon_cnt),
+  /* Two address, untyped.  */
+ NUF(vswp,      1b20000, 2, (RNDQ, RNDQ),     neon_swp),
+ NUF(vswpq,     1b20000, 2, (RNQ,  RNQ),      neon_swp),
+  /* VTRN. Sizes 8 16 32.  */
+ nUF(vtrn,      _vtrn,    2, (RNDQ, RNDQ),     neon_trn),
+ nUF(vtrnq,     _vtrn,    2, (RNQ,  RNQ),      neon_trn),
+
+  /* Table lookup. Size 8.  */
+ NUF(vtbl,      1b00800, 3, (RND, NRDLST, RND), neon_tbl_tbx),
+ NUF(vtbx,      1b00840, 3, (RND, NRDLST, RND), neon_tbl_tbx),
+
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT  & fpu_vfp_v3_or_neon_ext
+#undef  ARM_VARIANT
+#define ARM_VARIANT    & fpu_vfp_v3_or_neon_ext
+
+  /* Neon element/structure load/store.  */
+ nUF(vld1,      _vld1,    2, (NSTRLST, ADDR),  neon_ldx_stx),
+ nUF(vst1,      _vst1,    2, (NSTRLST, ADDR),  neon_ldx_stx),
+ nUF(vld2,      _vld2,    2, (NSTRLST, ADDR),  neon_ldx_stx),
+ nUF(vst2,      _vst2,    2, (NSTRLST, ADDR),  neon_ldx_stx),
+ nUF(vld3,      _vld3,    2, (NSTRLST, ADDR),  neon_ldx_stx),
+ nUF(vst3,      _vst3,    2, (NSTRLST, ADDR),  neon_ldx_stx),
+ nUF(vld4,      _vld4,    2, (NSTRLST, ADDR),  neon_ldx_stx),
+ nUF(vst4,      _vst4,    2, (NSTRLST, ADDR),  neon_ldx_stx),
+
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT & fpu_vfp_ext_v3xd
+#undef  ARM_VARIANT
+#define ARM_VARIANT   & fpu_vfp_ext_v3xd
+ cCE("fconsts",   eb00a00, 2, (RVS, I255),      vfp_sp_const),
+ cCE("fshtos",    eba0a40, 2, (RVS, I16z),      vfp_sp_conv_16),
+ cCE("fsltos",    eba0ac0, 2, (RVS, I32),       vfp_sp_conv_32),
+ cCE("fuhtos",    ebb0a40, 2, (RVS, I16z),      vfp_sp_conv_16),
+ cCE("fultos",    ebb0ac0, 2, (RVS, I32),       vfp_sp_conv_32),
+ cCE("ftoshs",    ebe0a40, 2, (RVS, I16z),      vfp_sp_conv_16),
+ cCE("ftosls",    ebe0ac0, 2, (RVS, I32),       vfp_sp_conv_32),
+ cCE("ftouhs",    ebf0a40, 2, (RVS, I16z),      vfp_sp_conv_16),
+ cCE("ftouls",    ebf0ac0, 2, (RVS, I32),       vfp_sp_conv_32),
+
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT  & fpu_vfp_ext_v3
+#undef  ARM_VARIANT
+#define ARM_VARIANT    & fpu_vfp_ext_v3
+
+ cCE("fconstd",   eb00b00, 2, (RVD, I255),      vfp_dp_const),
+ cCE("fshtod",    eba0b40, 2, (RVD, I16z),      vfp_dp_conv_16),
+ cCE("fsltod",    eba0bc0, 2, (RVD, I32),       vfp_dp_conv_32),
+ cCE("fuhtod",    ebb0b40, 2, (RVD, I16z),      vfp_dp_conv_16),
+ cCE("fultod",    ebb0bc0, 2, (RVD, I32),       vfp_dp_conv_32),
+ cCE("ftoshd",    ebe0b40, 2, (RVD, I16z),      vfp_dp_conv_16),
+ cCE("ftosld",    ebe0bc0, 2, (RVD, I32),       vfp_dp_conv_32),
+ cCE("ftouhd",    ebf0b40, 2, (RVD, I16z),      vfp_dp_conv_16),
+ cCE("ftould",    ebf0bc0, 2, (RVD, I32),       vfp_dp_conv_32),
+
+#undef  ARM_VARIANT
+#define ARM_VARIANT    & fpu_vfp_ext_fma
+#undef  THUMB_VARIANT
+#define THUMB_VARIANT  & fpu_vfp_ext_fma
+ /* Mnemonics shared by Neon and VFP.  These are included in the
+    VFP FMA variant; NEON and VFP FMA always includes the NEON
+    FMA instructions.  */
+ nCEF(vfma,     _vfma,    3, (RNSDQ, oRNSDQ, RNSDQ), neon_fmac),
+ nCEF(vfms,     _vfms,    3, (RNSDQ, oRNSDQ, RNSDQ), neon_fmac),
+ /* ffmas/ffmad/ffmss/ffmsd are dummy mnemonics to satisfy gas;
+    the v form should always be used.  */
+ cCE("ffmas",	ea00a00, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
+ cCE("ffnmas",	ea00a40, 3, (RVS, RVS, RVS),  vfp_sp_dyadic),
+ cCE("ffmad",	ea00b00, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
+ cCE("ffnmad",	ea00b40, 3, (RVD, RVD, RVD),  vfp_dp_rd_rn_rm),
+ nCE(vfnma,     _vfnma,   3, (RVSD, RVSD, RVSD), vfp_nsyn_nmul),
+ nCE(vfnms,     _vfnms,   3, (RVSD, RVSD, RVSD), vfp_nsyn_nmul),
+
+#undef THUMB_VARIANT
+#undef  ARM_VARIANT
+#define ARM_VARIANT  & arm_cext_xscale /* Intel XScale extensions.  */
+
+ cCE("mia",	e200010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
+ cCE("miaph",	e280010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
+ cCE("miabb",	e2c0010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
+ cCE("miabt",	e2d0010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
+ cCE("miatb",	e2e0010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
+ cCE("miatt",	e2f0010, 3, (RXA, RRnpc, RRnpc), xsc_mia),
+ cCE("mar",	c400000, 3, (RXA, RRnpc, RRnpc), xsc_mar),
+ cCE("mra",	c500000, 3, (RRnpc, RRnpc, RXA), xsc_mra),
+
+#undef  ARM_VARIANT
+#define ARM_VARIANT  & arm_cext_iwmmxt /* Intel Wireless MMX technology.  */
+
+ cCE("tandcb",	e13f130, 1, (RR),		    iwmmxt_tandorc),
+ cCE("tandch",	e53f130, 1, (RR),		    iwmmxt_tandorc),
+ cCE("tandcw",	e93f130, 1, (RR),		    iwmmxt_tandorc),
+ cCE("tbcstb",	e400010, 2, (RIWR, RR),		    rn_rd),
+ cCE("tbcsth",	e400050, 2, (RIWR, RR),		    rn_rd),
+ cCE("tbcstw",	e400090, 2, (RIWR, RR),		    rn_rd),
+ cCE("textrcb",	e130170, 2, (RR, I7),		    iwmmxt_textrc),
+ cCE("textrch",	e530170, 2, (RR, I7),		    iwmmxt_textrc),
+ cCE("textrcw",	e930170, 2, (RR, I7),		    iwmmxt_textrc),
+ cCE("textrmub",e100070, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
+ cCE("textrmuh",e500070, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
+ cCE("textrmuw",e900070, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
+ cCE("textrmsb",e100078, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
+ cCE("textrmsh",e500078, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
+ cCE("textrmsw",e900078, 3, (RR, RIWR, I7),	    iwmmxt_textrm),
+ cCE("tinsrb",	e600010, 3, (RIWR, RR, I7),	    iwmmxt_tinsr),
+ cCE("tinsrh",	e600050, 3, (RIWR, RR, I7),	    iwmmxt_tinsr),
+ cCE("tinsrw",	e600090, 3, (RIWR, RR, I7),	    iwmmxt_tinsr),
+ cCE("tmcr",	e000110, 2, (RIWC_RIWG, RR),	    rn_rd),
+ cCE("tmcrr",	c400000, 3, (RIWR, RR, RR),	    rm_rd_rn),
+ cCE("tmia",	e200010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
+ cCE("tmiaph",	e280010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
+ cCE("tmiabb",	e2c0010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
+ cCE("tmiabt",	e2d0010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
+ cCE("tmiatb",	e2e0010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
+ cCE("tmiatt",	e2f0010, 3, (RIWR, RR, RR),	    iwmmxt_tmia),
+ cCE("tmovmskb",e100030, 2, (RR, RIWR),		    rd_rn),
+ cCE("tmovmskh",e500030, 2, (RR, RIWR),		    rd_rn),
+ cCE("tmovmskw",e900030, 2, (RR, RIWR),		    rd_rn),
+ cCE("tmrc",	e100110, 2, (RR, RIWC_RIWG),	    rd_rn),
+ cCE("tmrrc",	c500000, 3, (RR, RR, RIWR),	    rd_rn_rm),
+ cCE("torcb",	e13f150, 1, (RR),		    iwmmxt_tandorc),
+ cCE("torch",	e53f150, 1, (RR),		    iwmmxt_tandorc),
+ cCE("torcw",	e93f150, 1, (RR),		    iwmmxt_tandorc),
+ cCE("waccb",	e0001c0, 2, (RIWR, RIWR),	    rd_rn),
+ cCE("wacch",	e4001c0, 2, (RIWR, RIWR),	    rd_rn),
+ cCE("waccw",	e8001c0, 2, (RIWR, RIWR),	    rd_rn),
+ cCE("waddbss",	e300180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("waddb",	e000180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("waddbus",	e100180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("waddhss",	e700180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("waddh",	e400180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("waddhus",	e500180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("waddwss",	eb00180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("waddw",	e800180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("waddwus",	e900180, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("waligni",	e000020, 4, (RIWR, RIWR, RIWR, I7), iwmmxt_waligni),
+ cCE("walignr0",e800020, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("walignr1",e900020, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("walignr2",ea00020, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("walignr3",eb00020, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wand",	e200000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wandn",	e300000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wavg2b",	e800000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wavg2br",	e900000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wavg2h",	ec00000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wavg2hr",	ed00000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wcmpeqb",	e000060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wcmpeqh",	e400060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wcmpeqw",	e800060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wcmpgtub",e100060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wcmpgtuh",e500060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wcmpgtuw",e900060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wcmpgtsb",e300060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wcmpgtsh",e700060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wcmpgtsw",eb00060, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wldrb",	c100000, 2, (RIWR, ADDR),	    iwmmxt_wldstbh),
+ cCE("wldrh",	c500000, 2, (RIWR, ADDR),	    iwmmxt_wldstbh),
+ cCE("wldrw",	c100100, 2, (RIWR_RIWC, ADDR),	    iwmmxt_wldstw),
+ cCE("wldrd",	c500100, 2, (RIWR, ADDR),	    iwmmxt_wldstd),
+ cCE("wmacs",	e600100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wmacsz",	e700100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wmacu",	e400100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wmacuz",	e500100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wmadds",	ea00100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wmaddu",	e800100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wmaxsb",	e200160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wmaxsh",	e600160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wmaxsw",	ea00160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wmaxub",	e000160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wmaxuh",	e400160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wmaxuw",	e800160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wminsb",	e300160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wminsh",	e700160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wminsw",	eb00160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wminub",	e100160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wminuh",	e500160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wminuw",	e900160, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wmov",	e000000, 2, (RIWR, RIWR),	    iwmmxt_wmov),
+ cCE("wmulsm",	e300100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wmulsl",	e200100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wmulum",	e100100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wmulul",	e000100, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wor",	e000000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wpackhss",e700080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wpackhus",e500080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wpackwss",eb00080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wpackwus",e900080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wpackdss",ef00080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wpackdus",ed00080, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wrorh",	e700040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
+ cCE("wrorhg",	e700148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
+ cCE("wrorw",	eb00040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
+ cCE("wrorwg",	eb00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
+ cCE("wrord",	ef00040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
+ cCE("wrordg",	ef00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
+ cCE("wsadb",	e000120, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wsadbz",	e100120, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wsadh",	e400120, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wsadhz",	e500120, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wshufh",	e0001e0, 3, (RIWR, RIWR, I255),	    iwmmxt_wshufh),
+ cCE("wsllh",	e500040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
+ cCE("wsllhg",	e500148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
+ cCE("wsllw",	e900040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
+ cCE("wsllwg",	e900148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
+ cCE("wslld",	ed00040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
+ cCE("wslldg",	ed00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
+ cCE("wsrah",	e400040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
+ cCE("wsrahg",	e400148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
+ cCE("wsraw",	e800040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
+ cCE("wsrawg",	e800148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
+ cCE("wsrad",	ec00040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
+ cCE("wsradg",	ec00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
+ cCE("wsrlh",	e600040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
+ cCE("wsrlhg",	e600148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
+ cCE("wsrlw",	ea00040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
+ cCE("wsrlwg",	ea00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
+ cCE("wsrld",	ee00040, 3, (RIWR, RIWR, RIWR_I32z),iwmmxt_wrwrwr_or_imm5),
+ cCE("wsrldg",	ee00148, 3, (RIWR, RIWR, RIWG),	    rd_rn_rm),
+ cCE("wstrb",	c000000, 2, (RIWR, ADDR),	    iwmmxt_wldstbh),
+ cCE("wstrh",	c400000, 2, (RIWR, ADDR),	    iwmmxt_wldstbh),
+ cCE("wstrw",	c000100, 2, (RIWR_RIWC, ADDR),	    iwmmxt_wldstw),
+ cCE("wstrd",	c400100, 2, (RIWR, ADDR),	    iwmmxt_wldstd),
+ cCE("wsubbss",	e3001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wsubb",	e0001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wsubbus",	e1001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wsubhss",	e7001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wsubh",	e4001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wsubhus",	e5001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wsubwss",	eb001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wsubw",	e8001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wsubwus",	e9001a0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wunpckehub",e0000c0, 2, (RIWR, RIWR),	    rd_rn),
+ cCE("wunpckehuh",e4000c0, 2, (RIWR, RIWR),	    rd_rn),
+ cCE("wunpckehuw",e8000c0, 2, (RIWR, RIWR),	    rd_rn),
+ cCE("wunpckehsb",e2000c0, 2, (RIWR, RIWR),	    rd_rn),
+ cCE("wunpckehsh",e6000c0, 2, (RIWR, RIWR),	    rd_rn),
+ cCE("wunpckehsw",ea000c0, 2, (RIWR, RIWR),	    rd_rn),
+ cCE("wunpckihb", e1000c0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wunpckihh", e5000c0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wunpckihw", e9000c0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wunpckelub",e0000e0, 2, (RIWR, RIWR),	    rd_rn),
+ cCE("wunpckeluh",e4000e0, 2, (RIWR, RIWR),	    rd_rn),
+ cCE("wunpckeluw",e8000e0, 2, (RIWR, RIWR),	    rd_rn),
+ cCE("wunpckelsb",e2000e0, 2, (RIWR, RIWR),	    rd_rn),
+ cCE("wunpckelsh",e6000e0, 2, (RIWR, RIWR),	    rd_rn),
+ cCE("wunpckelsw",ea000e0, 2, (RIWR, RIWR),	    rd_rn),
+ cCE("wunpckilb", e1000e0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wunpckilh", e5000e0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wunpckilw", e9000e0, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wxor",	e100000, 3, (RIWR, RIWR, RIWR),	    rd_rn_rm),
+ cCE("wzero",	e300000, 1, (RIWR),		    iwmmxt_wzero),
+
+#undef  ARM_VARIANT
+#define ARM_VARIANT  & arm_cext_iwmmxt2 /* Intel Wireless MMX technology, version 2.  */
+
+ cCE("torvscb",   e12f190, 1, (RR),		    iwmmxt_tandorc),
+ cCE("torvsch",   e52f190, 1, (RR),		    iwmmxt_tandorc),
+ cCE("torvscw",   e92f190, 1, (RR),		    iwmmxt_tandorc),
+ cCE("wabsb",     e2001c0, 2, (RIWR, RIWR),           rd_rn),
+ cCE("wabsh",     e6001c0, 2, (RIWR, RIWR),           rd_rn),
+ cCE("wabsw",     ea001c0, 2, (RIWR, RIWR),           rd_rn),
+ cCE("wabsdiffb", e1001c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wabsdiffh", e5001c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wabsdiffw", e9001c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("waddbhusl", e2001a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("waddbhusm", e6001a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("waddhc",    e600180, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("waddwc",    ea00180, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("waddsubhx", ea001a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wavg4",	e400000, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wavg4r",    e500000, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wmaddsn",   ee00100, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wmaddsx",   eb00100, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wmaddun",   ec00100, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wmaddux",   e900100, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wmerge",    e000080, 4, (RIWR, RIWR, RIWR, I7), iwmmxt_wmerge),
+ cCE("wmiabb",    e0000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wmiabt",    e1000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wmiatb",    e2000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wmiatt",    e3000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wmiabbn",   e4000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wmiabtn",   e5000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wmiatbn",   e6000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wmiattn",   e7000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wmiawbb",   e800120, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wmiawbt",   e900120, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wmiawtb",   ea00120, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wmiawtt",   eb00120, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wmiawbbn",  ec00120, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wmiawbtn",  ed00120, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wmiawtbn",  ee00120, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wmiawttn",  ef00120, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wmulsmr",   ef00100, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wmulumr",   ed00100, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wmulwumr",  ec000c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wmulwsmr",  ee000c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wmulwum",   ed000c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wmulwsm",   ef000c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wmulwl",    eb000c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wqmiabb",   e8000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wqmiabt",   e9000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wqmiatb",   ea000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wqmiatt",   eb000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wqmiabbn",  ec000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wqmiabtn",  ed000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wqmiatbn",  ee000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wqmiattn",  ef000a0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wqmulm",    e100080, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wqmulmr",   e300080, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wqmulwm",   ec000e0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wqmulwmr",  ee000e0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+ cCE("wsubaddhx", ed001c0, 3, (RIWR, RIWR, RIWR),     rd_rn_rm),
+
+#undef  ARM_VARIANT
+#define ARM_VARIANT  & arm_cext_maverick /* Cirrus Maverick instructions.  */
+
+ cCE("cfldrs",	c100400, 2, (RMF, ADDRGLDC),	      rd_cpaddr),
+ cCE("cfldrd",	c500400, 2, (RMD, ADDRGLDC),	      rd_cpaddr),
+ cCE("cfldr32",	c100500, 2, (RMFX, ADDRGLDC),	      rd_cpaddr),
+ cCE("cfldr64",	c500500, 2, (RMDX, ADDRGLDC),	      rd_cpaddr),
+ cCE("cfstrs",	c000400, 2, (RMF, ADDRGLDC),	      rd_cpaddr),
+ cCE("cfstrd",	c400400, 2, (RMD, ADDRGLDC),	      rd_cpaddr),
+ cCE("cfstr32",	c000500, 2, (RMFX, ADDRGLDC),	      rd_cpaddr),
+ cCE("cfstr64",	c400500, 2, (RMDX, ADDRGLDC),	      rd_cpaddr),
+ cCE("cfmvsr",	e000450, 2, (RMF, RR),		      rn_rd),
+ cCE("cfmvrs",	e100450, 2, (RR, RMF),		      rd_rn),
+ cCE("cfmvdlr",	e000410, 2, (RMD, RR),		      rn_rd),
+ cCE("cfmvrdl",	e100410, 2, (RR, RMD),		      rd_rn),
+ cCE("cfmvdhr",	e000430, 2, (RMD, RR),		      rn_rd),
+ cCE("cfmvrdh",	e100430, 2, (RR, RMD),		      rd_rn),
+ cCE("cfmv64lr",e000510, 2, (RMDX, RR),		      rn_rd),
+ cCE("cfmvr64l",e100510, 2, (RR, RMDX),		      rd_rn),
+ cCE("cfmv64hr",e000530, 2, (RMDX, RR),		      rn_rd),
+ cCE("cfmvr64h",e100530, 2, (RR, RMDX),		      rd_rn),
+ cCE("cfmval32",e200440, 2, (RMAX, RMFX),	      rd_rn),
+ cCE("cfmv32al",e100440, 2, (RMFX, RMAX),	      rd_rn),
+ cCE("cfmvam32",e200460, 2, (RMAX, RMFX),	      rd_rn),
+ cCE("cfmv32am",e100460, 2, (RMFX, RMAX),	      rd_rn),
+ cCE("cfmvah32",e200480, 2, (RMAX, RMFX),	      rd_rn),
+ cCE("cfmv32ah",e100480, 2, (RMFX, RMAX),	      rd_rn),
+ cCE("cfmva32",	e2004a0, 2, (RMAX, RMFX),	      rd_rn),
+ cCE("cfmv32a",	e1004a0, 2, (RMFX, RMAX),	      rd_rn),
+ cCE("cfmva64",	e2004c0, 2, (RMAX, RMDX),	      rd_rn),
+ cCE("cfmv64a",	e1004c0, 2, (RMDX, RMAX),	      rd_rn),
+ cCE("cfmvsc32",e2004e0, 2, (RMDS, RMDX),	      mav_dspsc),
+ cCE("cfmv32sc",e1004e0, 2, (RMDX, RMDS),	      rd),
+ cCE("cfcpys",	e000400, 2, (RMF, RMF),		      rd_rn),
+ cCE("cfcpyd",	e000420, 2, (RMD, RMD),		      rd_rn),
+ cCE("cfcvtsd",	e000460, 2, (RMD, RMF),		      rd_rn),
+ cCE("cfcvtds",	e000440, 2, (RMF, RMD),		      rd_rn),
+ cCE("cfcvt32s",e000480, 2, (RMF, RMFX),	      rd_rn),
+ cCE("cfcvt32d",e0004a0, 2, (RMD, RMFX),	      rd_rn),
+ cCE("cfcvt64s",e0004c0, 2, (RMF, RMDX),	      rd_rn),
+ cCE("cfcvt64d",e0004e0, 2, (RMD, RMDX),	      rd_rn),
+ cCE("cfcvts32",e100580, 2, (RMFX, RMF),	      rd_rn),
+ cCE("cfcvtd32",e1005a0, 2, (RMFX, RMD),	      rd_rn),
+ cCE("cftruncs32",e1005c0, 2, (RMFX, RMF),	      rd_rn),
+ cCE("cftruncd32",e1005e0, 2, (RMFX, RMD),	      rd_rn),
+ cCE("cfrshl32",e000550, 3, (RMFX, RMFX, RR),	      mav_triple),
+ cCE("cfrshl64",e000570, 3, (RMDX, RMDX, RR),	      mav_triple),
+ cCE("cfsh32",	e000500, 3, (RMFX, RMFX, I63s),	      mav_shift),
+ cCE("cfsh64",	e200500, 3, (RMDX, RMDX, I63s),	      mav_shift),
+ cCE("cfcmps",	e100490, 3, (RR, RMF, RMF),	      rd_rn_rm),
+ cCE("cfcmpd",	e1004b0, 3, (RR, RMD, RMD),	      rd_rn_rm),
+ cCE("cfcmp32",	e100590, 3, (RR, RMFX, RMFX),	      rd_rn_rm),
+ cCE("cfcmp64",	e1005b0, 3, (RR, RMDX, RMDX),	      rd_rn_rm),
+ cCE("cfabss",	e300400, 2, (RMF, RMF),		      rd_rn),
+ cCE("cfabsd",	e300420, 2, (RMD, RMD),		      rd_rn),
+ cCE("cfnegs",	e300440, 2, (RMF, RMF),		      rd_rn),
+ cCE("cfnegd",	e300460, 2, (RMD, RMD),		      rd_rn),
+ cCE("cfadds",	e300480, 3, (RMF, RMF, RMF),	      rd_rn_rm),
+ cCE("cfaddd",	e3004a0, 3, (RMD, RMD, RMD),	      rd_rn_rm),
+ cCE("cfsubs",	e3004c0, 3, (RMF, RMF, RMF),	      rd_rn_rm),
+ cCE("cfsubd",	e3004e0, 3, (RMD, RMD, RMD),	      rd_rn_rm),
+ cCE("cfmuls",	e100400, 3, (RMF, RMF, RMF),	      rd_rn_rm),
+ cCE("cfmuld",	e100420, 3, (RMD, RMD, RMD),	      rd_rn_rm),
+ cCE("cfabs32",	e300500, 2, (RMFX, RMFX),	      rd_rn),
+ cCE("cfabs64",	e300520, 2, (RMDX, RMDX),	      rd_rn),
+ cCE("cfneg32",	e300540, 2, (RMFX, RMFX),	      rd_rn),
+ cCE("cfneg64",	e300560, 2, (RMDX, RMDX),	      rd_rn),
+ cCE("cfadd32",	e300580, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
+ cCE("cfadd64",	e3005a0, 3, (RMDX, RMDX, RMDX),	      rd_rn_rm),
+ cCE("cfsub32",	e3005c0, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
+ cCE("cfsub64",	e3005e0, 3, (RMDX, RMDX, RMDX),	      rd_rn_rm),
+ cCE("cfmul32",	e100500, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
+ cCE("cfmul64",	e100520, 3, (RMDX, RMDX, RMDX),	      rd_rn_rm),
+ cCE("cfmac32",	e100540, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
+ cCE("cfmsc32",	e100560, 3, (RMFX, RMFX, RMFX),	      rd_rn_rm),
+ cCE("cfmadd32",e000600, 4, (RMAX, RMFX, RMFX, RMFX), mav_quad),
+ cCE("cfmsub32",e100600, 4, (RMAX, RMFX, RMFX, RMFX), mav_quad),
+ cCE("cfmadda32", e200600, 4, (RMAX, RMAX, RMFX, RMFX), mav_quad),
+ cCE("cfmsuba32", e300600, 4, (RMAX, RMAX, RMFX, RMFX), mav_quad),
+};
+#undef ARM_VARIANT
+#undef THUMB_VARIANT
+#undef TCE
+#undef TUE
+#undef TUF
+#undef TCC
+#undef cCE
+#undef cCL
+#undef C3E
+#undef CE
+#undef CM
+#undef UE
+#undef UF
+#undef UT
+#undef NUF
+#undef nUF
+#undef NCE
+#undef nCE
+#undef OPS0
+#undef OPS1
+#undef OPS2
+#undef OPS3
+#undef OPS4
+#undef OPS5
+#undef OPS6
+#undef do_0
+
+/* MD interface: bits in the object file.  */
+
+/* Turn an integer of n bytes (in val) into a stream of bytes appropriate
+   for use in the a.out file, and stores them in the array pointed to by buf.
+   This knows about the endian-ness of the target machine and does
+   THE RIGHT THING, whatever it is.  Possible values for n are 1 (byte)
+   2 (short) and 4 (long)  Floating numbers are put out as a series of
+   LITTLENUMS (shorts, here at least).	*/
+
+void
+md_number_to_chars (char * buf, valueT val, int n)
+{
+  if (target_big_endian)
+    number_to_chars_bigendian (buf, val, n);
+  else
+    number_to_chars_littleendian (buf, val, n);
+}
+
+static valueT
+md_chars_to_number (char * buf, int n)
+{
+  valueT result = 0;
+  unsigned char * where = (unsigned char *) buf;
+
+  if (target_big_endian)
+    {
+      while (n--)
+	{
+	  result <<= 8;
+	  result |= (*where++ & 255);
+	}
+    }
+  else
+    {
+      while (n--)
+	{
+	  result <<= 8;
+	  result |= (where[n] & 255);
+	}
+    }
+
+  return result;
+}
+
+/* MD interface: Sections.  */
+
+/* Calculate the maximum variable size (i.e., excluding fr_fix)
+   that an rs_machine_dependent frag may reach.  */
+
+unsigned int
+arm_frag_max_var (fragS *fragp)
+{
+  /* We only use rs_machine_dependent for variable-size Thumb instructions,
+     which are either THUMB_SIZE (2) or INSN_SIZE (4).
+
+     Note that we generate relaxable instructions even for cases that don't
+     really need it, like an immediate that's a trivial constant.  So we're
+     overestimating the instruction size for some of those cases.  Rather
+     than putting more intelligence here, it would probably be better to
+     avoid generating a relaxation frag in the first place when it can be
+     determined up front that a short instruction will suffice.  */
+
+  gas_assert (fragp->fr_type == rs_machine_dependent);
+  return INSN_SIZE;
+}
+
+/* Estimate the size of a frag before relaxing.  Assume everything fits in
+   2 bytes.  */
+
+int
+md_estimate_size_before_relax (fragS * fragp,
+			       segT    segtype ATTRIBUTE_UNUSED)
+{
+  fragp->fr_var = 2;
+  return 2;
+}
+
+/* Convert a machine dependent frag.  */
+
+void
+md_convert_frag (bfd *abfd, segT asec ATTRIBUTE_UNUSED, fragS *fragp)
+{
+  unsigned long insn;
+  unsigned long old_op;
+  char *buf;
+  expressionS exp;
+  fixS *fixp;
+  int reloc_type;
+  int pc_rel;
+  int opcode;
+
+  buf = fragp->fr_literal + fragp->fr_fix;
+
+  old_op = bfd_get_16(abfd, buf);
+  if (fragp->fr_symbol)
+    {
+      exp.X_op = O_symbol;
+      exp.X_add_symbol = fragp->fr_symbol;
+    }
+  else
+    {
+      exp.X_op = O_constant;
+    }
+  exp.X_add_number = fragp->fr_offset;
+  opcode = fragp->fr_subtype;
+  switch (opcode)
+    {
+    case T_MNEM_ldr_pc:
+    case T_MNEM_ldr_pc2:
+    case T_MNEM_ldr_sp:
+    case T_MNEM_str_sp:
+    case T_MNEM_ldr:
+    case T_MNEM_ldrb:
+    case T_MNEM_ldrh:
+    case T_MNEM_str:
+    case T_MNEM_strb:
+    case T_MNEM_strh:
+      if (fragp->fr_var == 4)
+	{
+	  insn = THUMB_OP32 (opcode);
+	  if ((old_op >> 12) == 4 || (old_op >> 12) == 9)
+	    {
+	      insn |= (old_op & 0x700) << 4;
+	    }
+	  else
+	    {
+	      insn |= (old_op & 7) << 12;
+	      insn |= (old_op & 0x38) << 13;
+	    }
+	  insn |= 0x00000c00;
+	  put_thumb32_insn (buf, insn);
+	  reloc_type = BFD_RELOC_ARM_T32_OFFSET_IMM;
+	}
+      else
+	{
+	  reloc_type = BFD_RELOC_ARM_THUMB_OFFSET;
+	}
+      pc_rel = (opcode == T_MNEM_ldr_pc2);
+      break;
+    case T_MNEM_adr:
+      if (fragp->fr_var == 4)
+	{
+	  insn = THUMB_OP32 (opcode);
+	  insn |= (old_op & 0xf0) << 4;
+	  put_thumb32_insn (buf, insn);
+	  reloc_type = BFD_RELOC_ARM_T32_ADD_PC12;
+	}
+      else
+	{
+	  reloc_type = BFD_RELOC_ARM_THUMB_ADD;
+	  exp.X_add_number -= 4;
+	}
+      pc_rel = 1;
+      break;
+    case T_MNEM_mov:
+    case T_MNEM_movs:
+    case T_MNEM_cmp:
+    case T_MNEM_cmn:
+      if (fragp->fr_var == 4)
+	{
+	  int r0off = (opcode == T_MNEM_mov
+		       || opcode == T_MNEM_movs) ? 0 : 8;
+	  insn = THUMB_OP32 (opcode);
+	  insn = (insn & 0xe1ffffff) | 0x10000000;
+	  insn |= (old_op & 0x700) << r0off;
+	  put_thumb32_insn (buf, insn);
+	  reloc_type = BFD_RELOC_ARM_T32_IMMEDIATE;
+	}
+      else
+	{
+	  reloc_type = BFD_RELOC_ARM_THUMB_IMM;
+	}
+      pc_rel = 0;
+      break;
+    case T_MNEM_b:
+      if (fragp->fr_var == 4)
+	{
+	  insn = THUMB_OP32(opcode);
+	  put_thumb32_insn (buf, insn);
+	  reloc_type = BFD_RELOC_THUMB_PCREL_BRANCH25;
+	}
+      else
+	reloc_type = BFD_RELOC_THUMB_PCREL_BRANCH12;
+      pc_rel = 1;
+      break;
+    case T_MNEM_bcond:
+      if (fragp->fr_var == 4)
+	{
+	  insn = THUMB_OP32(opcode);
+	  insn |= (old_op & 0xf00) << 14;
+	  put_thumb32_insn (buf, insn);
+	  reloc_type = BFD_RELOC_THUMB_PCREL_BRANCH20;
+	}
+      else
+	reloc_type = BFD_RELOC_THUMB_PCREL_BRANCH9;
+      pc_rel = 1;
+      break;
+    case T_MNEM_add_sp:
+    case T_MNEM_add_pc:
+    case T_MNEM_inc_sp:
+    case T_MNEM_dec_sp:
+      if (fragp->fr_var == 4)
+	{
+	  /* ??? Choose between add and addw.  */
+	  insn = THUMB_OP32 (opcode);
+	  insn |= (old_op & 0xf0) << 4;
+	  put_thumb32_insn (buf, insn);
+	  if (opcode == T_MNEM_add_pc)
+	    reloc_type = BFD_RELOC_ARM_T32_IMM12;
+	  else
+	    reloc_type = BFD_RELOC_ARM_T32_ADD_IMM;
+	}
+      else
+	reloc_type = BFD_RELOC_ARM_THUMB_ADD;
+      pc_rel = 0;
+      break;
+
+    case T_MNEM_addi:
+    case T_MNEM_addis:
+    case T_MNEM_subi:
+    case T_MNEM_subis:
+      if (fragp->fr_var == 4)
+	{
+	  insn = THUMB_OP32 (opcode);
+	  insn |= (old_op & 0xf0) << 4;
+	  insn |= (old_op & 0xf) << 16;
+	  put_thumb32_insn (buf, insn);
+	  if (insn & (1 << 20))
+	    reloc_type = BFD_RELOC_ARM_T32_ADD_IMM;
+	  else
+	    reloc_type = BFD_RELOC_ARM_T32_IMMEDIATE;
+	}
+      else
+	reloc_type = BFD_RELOC_ARM_THUMB_ADD;
+      pc_rel = 0;
+      break;
+    default:
+      abort ();
+    }
+  fixp = fix_new_exp (fragp, fragp->fr_fix, fragp->fr_var, &exp, pc_rel,
+		      (enum bfd_reloc_code_real) reloc_type);
+  fixp->fx_file = fragp->fr_file;
+  fixp->fx_line = fragp->fr_line;
+  fragp->fr_fix += fragp->fr_var;
+
+  /* Set whether we use thumb-2 ISA based on final relaxation results.  */
+  if (thumb_mode && fragp->fr_var == 4 && no_cpu_selected ()
+      && !ARM_CPU_HAS_FEATURE (thumb_arch_used, arm_arch_t2))
+    ARM_MERGE_FEATURE_SETS (arm_arch_used, thumb_arch_used, arm_ext_v6t2);
+}
+
+/* Return the size of a relaxable immediate operand instruction.
+   SHIFT and SIZE specify the form of the allowable immediate.  */
+static int
+relax_immediate (fragS *fragp, int size, int shift)
+{
+  offsetT offset;
+  offsetT mask;
+  offsetT low;
+
+  /* ??? Should be able to do better than this.  */
+  if (fragp->fr_symbol)
+    return 4;
+
+  low = (1 << shift) - 1;
+  mask = (1 << (shift + size)) - (1 << shift);
+  offset = fragp->fr_offset;
+  /* Force misaligned offsets to 32-bit variant.  */
+  if (offset & low)
+    return 4;
+  if (offset & ~mask)
+    return 4;
+  return 2;
+}
+
+/* Get the address of a symbol during relaxation.  */
+static addressT
+relaxed_symbol_addr (fragS *fragp, long stretch)
+{
+  fragS *sym_frag;
+  addressT addr;
+  symbolS *sym;
+
+  sym = fragp->fr_symbol;
+  sym_frag = symbol_get_frag (sym);
+  know (S_GET_SEGMENT (sym) != absolute_section
+	|| sym_frag == &zero_address_frag);
+  addr = S_GET_VALUE (sym) + fragp->fr_offset;
+
+  /* If frag has yet to be reached on this pass, assume it will
+     move by STRETCH just as we did.  If this is not so, it will
+     be because some frag between grows, and that will force
+     another pass.  */
+
+  if (stretch != 0
+      && sym_frag->relax_marker != fragp->relax_marker)
+    {
+      fragS *f;
+
+      /* Adjust stretch for any alignment frag.  Note that if have
+	 been expanding the earlier code, the symbol may be
+	 defined in what appears to be an earlier frag.  FIXME:
+	 This doesn't handle the fr_subtype field, which specifies
+	 a maximum number of bytes to skip when doing an
+	 alignment.  */
+      for (f = fragp; f != NULL && f != sym_frag; f = f->fr_next)
+	{
+	  if (f->fr_type == rs_align || f->fr_type == rs_align_code)
+	    {
+	      if (stretch < 0)
+		stretch = - ((- stretch)
+			     & ~ ((1 << (int) f->fr_offset) - 1));
+	      else
+		stretch &= ~ ((1 << (int) f->fr_offset) - 1);
+	      if (stretch == 0)
+		break;
+	    }
+	}
+      if (f != NULL)
+	addr += stretch;
+    }
+
+  return addr;
+}
+
+/* Return the size of a relaxable adr pseudo-instruction or PC-relative
+   load.  */
+static int
+relax_adr (fragS *fragp, asection *sec, long stretch)
+{
+  addressT addr;
+  offsetT val;
+
+  /* Assume worst case for symbols not known to be in the same section.  */
+  if (fragp->fr_symbol == NULL
+      || !S_IS_DEFINED (fragp->fr_symbol)
+      || sec != S_GET_SEGMENT (fragp->fr_symbol)
+      || S_IS_WEAK (fragp->fr_symbol))
+    return 4;
+
+  val = relaxed_symbol_addr (fragp, stretch);
+  addr = fragp->fr_address + fragp->fr_fix;
+  addr = (addr + 4) & ~3;
+  /* Force misaligned targets to 32-bit variant.  */
+  if (val & 3)
+    return 4;
+  val -= addr;
+  if (val < 0 || val > 1020)
+    return 4;
+  return 2;
+}
+
+/* Return the size of a relaxable add/sub immediate instruction.  */
+static int
+relax_addsub (fragS *fragp, asection *sec)
+{
+  char *buf;
+  int op;
+
+  buf = fragp->fr_literal + fragp->fr_fix;
+  op = bfd_get_16(sec->owner, buf);
+  if ((op & 0xf) == ((op >> 4) & 0xf))
+    return relax_immediate (fragp, 8, 0);
+  else
+    return relax_immediate (fragp, 3, 0);
+}
+
+/* Return TRUE iff the definition of symbol S could be pre-empted
+   (overridden) at link or load time.  */
+static bfd_boolean
+symbol_preemptible (symbolS *s)
+{
+  /* Weak symbols can always be pre-empted.  */
+  if (S_IS_WEAK (s))
+    return TRUE;
+
+  /* Non-global symbols cannot be pre-empted. */
+  if (! S_IS_EXTERNAL (s))
+    return FALSE;
+
+#ifdef OBJ_ELF
+  /* In ELF, a global symbol can be marked protected, or private.  In that
+     case it can't be pre-empted (other definitions in the same link unit
+     would violate the ODR).  */
+  if (ELF_ST_VISIBILITY (S_GET_OTHER (s)) > STV_DEFAULT)
+    return FALSE;
+#endif
+
+  /* Other global symbols might be pre-empted.  */
+  return TRUE;
+}
+
+/* Return the size of a relaxable branch instruction.  BITS is the
+   size of the offset field in the narrow instruction.  */
+
+static int
+relax_branch (fragS *fragp, asection *sec, int bits, long stretch)
+{
+  addressT addr;
+  offsetT val;
+  offsetT limit;
+
+  /* Assume worst case for symbols not known to be in the same section.  */
+  if (!S_IS_DEFINED (fragp->fr_symbol)
+      || sec != S_GET_SEGMENT (fragp->fr_symbol)
+      || S_IS_WEAK (fragp->fr_symbol))
+    return 4;
+
+#ifdef OBJ_ELF
+  /* A branch to a function in ARM state will require interworking.  */
+  if (S_IS_DEFINED (fragp->fr_symbol)
+      && ARM_IS_FUNC (fragp->fr_symbol))
+      return 4;
+#endif
+
+  if (symbol_preemptible (fragp->fr_symbol))
+    return 4;
+
+  val = relaxed_symbol_addr (fragp, stretch);
+  addr = fragp->fr_address + fragp->fr_fix + 4;
+  val -= addr;
+
+  /* Offset is a signed value *2 */
+  limit = 1 << bits;
+  if (val >= limit || val < -limit)
+    return 4;
+  return 2;
+}
+
+
+/* Relax a machine dependent frag.  This returns the amount by which
+   the current size of the frag should change.  */
+
+int
+arm_relax_frag (asection *sec, fragS *fragp, long stretch)
+{
+  int oldsize;
+  int newsize;
+
+  oldsize = fragp->fr_var;
+  switch (fragp->fr_subtype)
+    {
+    case T_MNEM_ldr_pc2:
+      newsize = relax_adr (fragp, sec, stretch);
+      break;
+    case T_MNEM_ldr_pc:
+    case T_MNEM_ldr_sp:
+    case T_MNEM_str_sp:
+      newsize = relax_immediate (fragp, 8, 2);
+      break;
+    case T_MNEM_ldr:
+    case T_MNEM_str:
+      newsize = relax_immediate (fragp, 5, 2);
+      break;
+    case T_MNEM_ldrh:
+    case T_MNEM_strh:
+      newsize = relax_immediate (fragp, 5, 1);
+      break;
+    case T_MNEM_ldrb:
+    case T_MNEM_strb:
+      newsize = relax_immediate (fragp, 5, 0);
+      break;
+    case T_MNEM_adr:
+      newsize = relax_adr (fragp, sec, stretch);
+      break;
+    case T_MNEM_mov:
+    case T_MNEM_movs:
+    case T_MNEM_cmp:
+    case T_MNEM_cmn:
+      newsize = relax_immediate (fragp, 8, 0);
+      break;
+    case T_MNEM_b:
+      newsize = relax_branch (fragp, sec, 11, stretch);
+      break;
+    case T_MNEM_bcond:
+      newsize = relax_branch (fragp, sec, 8, stretch);
+      break;
+    case T_MNEM_add_sp:
+    case T_MNEM_add_pc:
+      newsize = relax_immediate (fragp, 8, 2);
+      break;
+    case T_MNEM_inc_sp:
+    case T_MNEM_dec_sp:
+      newsize = relax_immediate (fragp, 7, 2);
+      break;
+    case T_MNEM_addi:
+    case T_MNEM_addis:
+    case T_MNEM_subi:
+    case T_MNEM_subis:
+      newsize = relax_addsub (fragp, sec);
+      break;
+    default:
+      abort ();
+    }
+
+  fragp->fr_var = newsize;
+  /* Freeze wide instructions that are at or before the same location as
+     in the previous pass.  This avoids infinite loops.
+     Don't freeze them unconditionally because targets may be artificially
+     misaligned by the expansion of preceding frags.  */
+  if (stretch <= 0 && newsize > 2)
+    {
+      md_convert_frag (sec->owner, sec, fragp);
+      frag_wane (fragp);
+    }
+
+  return newsize - oldsize;
+}
+
+/* Round up a section size to the appropriate boundary.	 */
+
+valueT
+md_section_align (segT	 segment ATTRIBUTE_UNUSED,
+		  valueT size)
+{
+#if (defined (OBJ_AOUT) || defined (OBJ_MAYBE_AOUT))
+  if (OUTPUT_FLAVOR == bfd_target_aout_flavour)
+    {
+      /* For a.out, force the section size to be aligned.  If we don't do
+	 this, BFD will align it for us, but it will not write out the
+	 final bytes of the section.  This may be a bug in BFD, but it is
+	 easier to fix it here since that is how the other a.out targets
+	 work.  */
+      int align;
+
+      align = bfd_get_section_alignment (stdoutput, segment);
+      size = ((size + (1 << align) - 1) & (-((valueT) 1 << align)));
+    }
+#endif
+
+  return size;
+}
+
+/* This is called from HANDLE_ALIGN in write.c.	 Fill in the contents
+   of an rs_align_code fragment.  */
+
+void
+arm_handle_align (fragS * fragP)
+{
+  static char const arm_noop[2][2][4] =
+    {
+      {  /* ARMv1 */
+	{0x00, 0x00, 0xa0, 0xe1},  /* LE */
+	{0xe1, 0xa0, 0x00, 0x00},  /* BE */
+      },
+      {  /* ARMv6k */
+	{0x00, 0xf0, 0x20, 0xe3},  /* LE */
+	{0xe3, 0x20, 0xf0, 0x00},  /* BE */
+      },
+    };
+  static char const thumb_noop[2][2][2] =
+    {
+      {  /* Thumb-1 */
+	{0xc0, 0x46},  /* LE */
+	{0x46, 0xc0},  /* BE */
+      },
+      {  /* Thumb-2 */
+	{0x00, 0xbf},  /* LE */
+	{0xbf, 0x00}   /* BE */
+      }
+    };
+  static char const wide_thumb_noop[2][4] =
+    {  /* Wide Thumb-2 */
+      {0xaf, 0xf3, 0x00, 0x80},  /* LE */
+      {0xf3, 0xaf, 0x80, 0x00},  /* BE */
+    };
+
+  unsigned bytes, fix, noop_size;
+  char * p;
+  const char * noop;
+  const char *narrow_noop = NULL;
+#ifdef OBJ_ELF
+  enum mstate state;
+#endif
+
+  if (fragP->fr_type != rs_align_code)
+    return;
+
+  bytes = fragP->fr_next->fr_address - fragP->fr_address - fragP->fr_fix;
+  p = fragP->fr_literal + fragP->fr_fix;
+  fix = 0;
+
+  if (bytes > MAX_MEM_FOR_RS_ALIGN_CODE)
+    bytes &= MAX_MEM_FOR_RS_ALIGN_CODE;
+
+  gas_assert ((fragP->tc_frag_data.thumb_mode & MODE_RECORDED) != 0);
+
+  if (fragP->tc_frag_data.thumb_mode & (~ MODE_RECORDED))
+    {
+      if (ARM_CPU_HAS_FEATURE (selected_cpu_name[0]
+			       ? selected_cpu : arm_arch_none, arm_ext_v6t2))
+	{
+	  narrow_noop = thumb_noop[1][target_big_endian];
+	  noop = wide_thumb_noop[target_big_endian];
+	}
+      else
+	noop = thumb_noop[0][target_big_endian];
+      noop_size = 2;
+#ifdef OBJ_ELF
+      state = MAP_THUMB;
+#endif
+    }
+  else
+    {
+      noop = arm_noop[ARM_CPU_HAS_FEATURE (selected_cpu_name[0]
+					   ? selected_cpu : arm_arch_none,
+					   arm_ext_v6k) != 0]
+		     [target_big_endian];
+      noop_size = 4;
+#ifdef OBJ_ELF
+      state = MAP_ARM;
+#endif
+    }
+
+  fragP->fr_var = noop_size;
+
+  if (bytes & (noop_size - 1))
+    {
+      fix = bytes & (noop_size - 1);
+#ifdef OBJ_ELF
+      insert_data_mapping_symbol (state, fragP->fr_fix, fragP, fix);
+#endif
+      memset (p, 0, fix);
+      p += fix;
+      bytes -= fix;
+    }
+
+  if (narrow_noop)
+    {
+      if (bytes & noop_size)
+	{
+	  /* Insert a narrow noop.  */
+	  memcpy (p, narrow_noop, noop_size);
+	  p += noop_size;
+	  bytes -= noop_size;
+	  fix += noop_size;
+	}
+
+      /* Use wide noops for the remainder */
+      noop_size = 4;
+    }
+
+  while (bytes >= noop_size)
+    {
+      memcpy (p, noop, noop_size);
+      p += noop_size;
+      bytes -= noop_size;
+      fix += noop_size;
+    }
+
+  fragP->fr_fix += fix;
+}
+
+/* Called from md_do_align.  Used to create an alignment
+   frag in a code section.  */
+
+void
+arm_frag_align_code (int n, int max)
+{
+  char * p;
+
+  /* We assume that there will never be a requirement
+     to support alignments greater than MAX_MEM_FOR_RS_ALIGN_CODE bytes.  */
+  if (max > MAX_MEM_FOR_RS_ALIGN_CODE)
+    {
+      char err_msg[128];
+
+      sprintf (err_msg,
+	_("alignments greater than %d bytes not supported in .text sections."),
+	MAX_MEM_FOR_RS_ALIGN_CODE + 1);
+      as_fatal ("%s", err_msg);
+    }
+
+  p = frag_var (rs_align_code,
+		MAX_MEM_FOR_RS_ALIGN_CODE,
+		1,
+		(relax_substateT) max,
+		(symbolS *) NULL,
+		(offsetT) n,
+		(char *) NULL);
+  *p = 0;
+}
+
+/* Perform target specific initialisation of a frag.
+   Note - despite the name this initialisation is not done when the frag
+   is created, but only when its type is assigned.  A frag can be created
+   and used a long time before its type is set, so beware of assuming that
+   this initialisationis performed first.  */
+
+#ifndef OBJ_ELF
+void
+arm_init_frag (fragS * fragP, int max_chars ATTRIBUTE_UNUSED)
+{
+  /* Record whether this frag is in an ARM or a THUMB area.  */
+  fragP->tc_frag_data.thumb_mode = thumb_mode | MODE_RECORDED;
+}
+
+#else /* OBJ_ELF is defined.  */
+void
+arm_init_frag (fragS * fragP, int max_chars)
+{
+  int frag_thumb_mode;
+
+  /* If the current ARM vs THUMB mode has not already
+     been recorded into this frag then do so now.  */
+  if ((fragP->tc_frag_data.thumb_mode & MODE_RECORDED) == 0)
+    fragP->tc_frag_data.thumb_mode = thumb_mode | MODE_RECORDED;
+
+  frag_thumb_mode = fragP->tc_frag_data.thumb_mode ^ MODE_RECORDED;
+
+  /* Record a mapping symbol for alignment frags.  We will delete this
+     later if the alignment ends up empty.  */
+  switch (fragP->fr_type)
+    {
+    case rs_align:
+    case rs_align_test:
+    case rs_fill:
+      mapping_state_2 (MAP_DATA, max_chars);
+      break;
+    case rs_align_code:
+      mapping_state_2 (frag_thumb_mode ? MAP_THUMB : MAP_ARM, max_chars);
+      break;
+    default:
+      break;
+    }
+}
+
+/* When we change sections we need to issue a new mapping symbol.  */
+
+void
+arm_elf_change_section (void)
+{
+  /* Link an unlinked unwind index table section to the .text section.	*/
+  if (elf_section_type (now_seg) == SHT_ARM_EXIDX
+      && elf_linked_to_section (now_seg) == NULL)
+    elf_linked_to_section (now_seg) = text_section;
+}
+
+int
+arm_elf_section_type (const char * str, size_t len)
+{
+  if (len == 5 && strncmp (str, "exidx", 5) == 0)
+    return SHT_ARM_EXIDX;
+
+  return -1;
+}
+
+/* Code to deal with unwinding tables.	*/
+
+static void add_unwind_adjustsp (offsetT);
+
+/* Generate any deferred unwind frame offset.  */
+
+static void
+flush_pending_unwind (void)
+{
+  offsetT offset;
+
+  offset = unwind.pending_offset;
+  unwind.pending_offset = 0;
+  if (offset != 0)
+    add_unwind_adjustsp (offset);
+}
+
+/* Add an opcode to this list for this function.  Two-byte opcodes should
+   be passed as op[0] << 8 | op[1].  The list of opcodes is built in reverse
+   order.  */
+
+static void
+add_unwind_opcode (valueT op, int length)
+{
+  /* Add any deferred stack adjustment.	 */
+  if (unwind.pending_offset)
+    flush_pending_unwind ();
+
+  unwind.sp_restored = 0;
+
+  if (unwind.opcode_count + length > unwind.opcode_alloc)
+    {
+      unwind.opcode_alloc += ARM_OPCODE_CHUNK_SIZE;
+      if (unwind.opcodes)
+	unwind.opcodes = (unsigned char *) xrealloc (unwind.opcodes,
+						     unwind.opcode_alloc);
+      else
+	unwind.opcodes = (unsigned char *) xmalloc (unwind.opcode_alloc);
+    }
+  while (length > 0)
+    {
+      length--;
+      unwind.opcodes[unwind.opcode_count] = op & 0xff;
+      op >>= 8;
+      unwind.opcode_count++;
+    }
+}
+
+/* Add unwind opcodes to adjust the stack pointer.  */
+
+static void
+add_unwind_adjustsp (offsetT offset)
+{
+  valueT op;
+
+  if (offset > 0x200)
+    {
+      /* We need at most 5 bytes to hold a 32-bit value in a uleb128.  */
+      char bytes[5];
+      int n;
+      valueT o;
+
+      /* Long form: 0xb2, uleb128.  */
+      /* This might not fit in a word so add the individual bytes,
+	 remembering the list is built in reverse order.  */
+      o = (valueT) ((offset - 0x204) >> 2);
+      if (o == 0)
+	add_unwind_opcode (0, 1);
+
+      /* Calculate the uleb128 encoding of the offset.	*/
+      n = 0;
+      while (o)
+	{
+	  bytes[n] = o & 0x7f;
+	  o >>= 7;
+	  if (o)
+	    bytes[n] |= 0x80;
+	  n++;
+	}
+      /* Add the insn.	*/
+      for (; n; n--)
+	add_unwind_opcode (bytes[n - 1], 1);
+      add_unwind_opcode (0xb2, 1);
+    }
+  else if (offset > 0x100)
+    {
+      /* Two short opcodes.  */
+      add_unwind_opcode (0x3f, 1);
+      op = (offset - 0x104) >> 2;
+      add_unwind_opcode (op, 1);
+    }
+  else if (offset > 0)
+    {
+      /* Short opcode.	*/
+      op = (offset - 4) >> 2;
+      add_unwind_opcode (op, 1);
+    }
+  else if (offset < 0)
+    {
+      offset = -offset;
+      while (offset > 0x100)
+	{
+	  add_unwind_opcode (0x7f, 1);
+	  offset -= 0x100;
+	}
+      op = ((offset - 4) >> 2) | 0x40;
+      add_unwind_opcode (op, 1);
+    }
+}
+
+/* Finish the list of unwind opcodes for this function.	 */
+static void
+finish_unwind_opcodes (void)
+{
+  valueT op;
+
+  if (unwind.fp_used)
+    {
+      /* Adjust sp as necessary.  */
+      unwind.pending_offset += unwind.fp_offset - unwind.frame_size;
+      flush_pending_unwind ();
+
+      /* After restoring sp from the frame pointer.  */
+      op = 0x90 | unwind.fp_reg;
+      add_unwind_opcode (op, 1);
+    }
+  else
+    flush_pending_unwind ();
+}
+
+
+/* Start an exception table entry.  If idx is nonzero this is an index table
+   entry.  */
+
+static void
+start_unwind_section (const segT text_seg, int idx)
+{
+  const char * text_name;
+  const char * prefix;
+  const char * prefix_once;
+  const char * group_name;
+  size_t prefix_len;
+  size_t text_len;
+  char * sec_name;
+  size_t sec_name_len;
+  int type;
+  int flags;
+  int linkonce;
+
+  if (idx)
+    {
+      prefix = ELF_STRING_ARM_unwind;
+      prefix_once = ELF_STRING_ARM_unwind_once;
+      type = SHT_ARM_EXIDX;
+    }
+  else
+    {
+      prefix = ELF_STRING_ARM_unwind_info;
+      prefix_once = ELF_STRING_ARM_unwind_info_once;
+      type = SHT_PROGBITS;
+    }
+
+  text_name = segment_name (text_seg);
+  if (streq (text_name, ".text"))
+    text_name = "";
+
+  if (strncmp (text_name, ".gnu.linkonce.t.",
+	       strlen (".gnu.linkonce.t.")) == 0)
+    {
+      prefix = prefix_once;
+      text_name += strlen (".gnu.linkonce.t.");
+    }
+
+  prefix_len = strlen (prefix);
+  text_len = strlen (text_name);
+  sec_name_len = prefix_len + text_len;
+  sec_name = (char *) xmalloc (sec_name_len + 1);
+  memcpy (sec_name, prefix, prefix_len);
+  memcpy (sec_name + prefix_len, text_name, text_len);
+  sec_name[prefix_len + text_len] = '\0';
+
+  flags = SHF_ALLOC;
+  linkonce = 0;
+  group_name = 0;
+
+  /* Handle COMDAT group.  */
+  if (prefix != prefix_once && (text_seg->flags & SEC_LINK_ONCE) != 0)
+    {
+      group_name = elf_group_name (text_seg);
+      if (group_name == NULL)
+	{
+	  as_bad (_("Group section `%s' has no group signature"),
+		  segment_name (text_seg));
+	  ignore_rest_of_line ();
+	  return;
+	}
+      flags |= SHF_GROUP;
+      linkonce = 1;
+    }
+
+  obj_elf_change_section (sec_name, type, flags, 0, group_name, linkonce, 0);
+
+  /* Set the section link for index tables.  */
+  if (idx)
+    elf_linked_to_section (now_seg) = text_seg;
+}
+
+
+/* Start an unwind table entry.	 HAVE_DATA is nonzero if we have additional
+   personality routine data.  Returns zero, or the index table value for
+   an inline entry.  */
+
+static valueT
+create_unwind_entry (int have_data)
+{
+  int size;
+  addressT where;
+  char *ptr;
+  /* The current word of data.	*/
+  valueT data;
+  /* The number of bytes left in this word.  */
+  int n;
+
+  finish_unwind_opcodes ();
+
+  /* Remember the current text section.	 */
+  unwind.saved_seg = now_seg;
+  unwind.saved_subseg = now_subseg;
+
+  start_unwind_section (now_seg, 0);
+
+  if (unwind.personality_routine == NULL)
+    {
+      if (unwind.personality_index == -2)
+	{
+	  if (have_data)
+	    as_bad (_("handlerdata in cantunwind frame"));
+	  return 1; /* EXIDX_CANTUNWIND.  */
+	}
+
+      /* Use a default personality routine if none is specified.  */
+      if (unwind.personality_index == -1)
+	{
+	  if (unwind.opcode_count > 3)
+	    unwind.personality_index = 1;
+	  else
+	    unwind.personality_index = 0;
+	}
+
+      /* Space for the personality routine entry.  */
+      if (unwind.personality_index == 0)
+	{
+	  if (unwind.opcode_count > 3)
+	    as_bad (_("too many unwind opcodes for personality routine 0"));
+
+	  if (!have_data)
+	    {
+	      /* All the data is inline in the index table.  */
+	      data = 0x80;
+	      n = 3;
+	      while (unwind.opcode_count > 0)
+		{
+		  unwind.opcode_count--;
+		  data = (data << 8) | unwind.opcodes[unwind.opcode_count];
+		  n--;
+		}
+
+	      /* Pad with "finish" opcodes.  */
+	      while (n--)
+		data = (data << 8) | 0xb0;
+
+	      return data;
+	    }
+	  size = 0;
+	}
+      else
+	/* We get two opcodes "free" in the first word.	 */
+	size = unwind.opcode_count - 2;
+    }
+  else
+    {
+      /* PR 16765: Missing or misplaced unwind directives can trigger this.  */
+      if (unwind.personality_index != -1)
+	{
+	  as_bad (_("attempt to recreate an unwind entry"));
+	  return 1;
+	}
+
+      /* An extra byte is required for the opcode count.	*/
+      size = unwind.opcode_count + 1;
+    }
+
+  size = (size + 3) >> 2;
+  if (size > 0xff)
+    as_bad (_("too many unwind opcodes"));
+
+  frag_align (2, 0, 0);
+  record_alignment (now_seg, 2);
+  unwind.table_entry = expr_build_dot ();
+
+  /* Allocate the table entry.	*/
+  ptr = frag_more ((size << 2) + 4);
+  /* PR 13449: Zero the table entries in case some of them are not used.  */
+  memset (ptr, 0, (size << 2) + 4);
+  where = frag_now_fix () - ((size << 2) + 4);
+
+  switch (unwind.personality_index)
+    {
+    case -1:
+      /* ??? Should this be a PLT generating relocation?  */
+      /* Custom personality routine.  */
+      fix_new (frag_now, where, 4, unwind.personality_routine, 0, 1,
+	       BFD_RELOC_ARM_PREL31);
+
+      where += 4;
+      ptr += 4;
+
+      /* Set the first byte to the number of additional words.	*/
+      data = size > 0 ? size - 1 : 0;
+      n = 3;
+      break;
+
+    /* ABI defined personality routines.  */
+    case 0:
+      /* Three opcodes bytes are packed into the first word.  */
+      data = 0x80;
+      n = 3;
+      break;
+
+    case 1:
+    case 2:
+      /* The size and first two opcode bytes go in the first word.  */
+      data = ((0x80 + unwind.personality_index) << 8) | size;
+      n = 2;
+      break;
+
+    default:
+      /* Should never happen.  */
+      abort ();
+    }
+
+  /* Pack the opcodes into words (MSB first), reversing the list at the same
+     time.  */
+  while (unwind.opcode_count > 0)
+    {
+      if (n == 0)
+	{
+	  md_number_to_chars (ptr, data, 4);
+	  ptr += 4;
+	  n = 4;
+	  data = 0;
+	}
+      unwind.opcode_count--;
+      n--;
+      data = (data << 8) | unwind.opcodes[unwind.opcode_count];
+    }
+
+  /* Finish off the last word.	*/
+  if (n < 4)
+    {
+      /* Pad with "finish" opcodes.  */
+      while (n--)
+	data = (data << 8) | 0xb0;
+
+      md_number_to_chars (ptr, data, 4);
+    }
+
+  if (!have_data)
+    {
+      /* Add an empty descriptor if there is no user-specified data.   */
+      ptr = frag_more (4);
+      md_number_to_chars (ptr, 0, 4);
+    }
+
+  return 0;
+}
+
+
+/* Initialize the DWARF-2 unwind information for this procedure.  */
+
+void
+tc_arm_frame_initial_instructions (void)
+{
+  cfi_add_CFA_def_cfa (REG_SP, 0);
+}
+#endif /* OBJ_ELF */
+
+/* Convert REGNAME to a DWARF-2 register number.  */
+
+int
+tc_arm_regname_to_dw2regnum (char *regname)
+{
+  int reg = arm_reg_parse (&regname, REG_TYPE_RN);
+  if (reg != FAIL)
+    return reg;
+
+  /* PR 16694: Allow VFP registers as well.  */
+  reg = arm_reg_parse (&regname, REG_TYPE_VFS);
+  if (reg != FAIL)
+    return 64 + reg;
+
+  reg = arm_reg_parse (&regname, REG_TYPE_VFD);
+  if (reg != FAIL)
+    return reg + 256;
+
+  return -1;
+}
+
+#ifdef TE_PE
+void
+tc_pe_dwarf2_emit_offset (symbolS *symbol, unsigned int size)
+{
+  expressionS exp;
+
+  exp.X_op = O_secrel;
+  exp.X_add_symbol = symbol;
+  exp.X_add_number = 0;
+  emit_expr (&exp, size);
+}
+#endif
+
+/* MD interface: Symbol and relocation handling.  */
+
+/* Return the address within the segment that a PC-relative fixup is
+   relative to.  For ARM, PC-relative fixups applied to instructions
+   are generally relative to the location of the fixup plus 8 bytes.
+   Thumb branches are offset by 4, and Thumb loads relative to PC
+   require special handling.  */
+
+long
+md_pcrel_from_section (fixS * fixP, segT seg)
+{
+  offsetT base = fixP->fx_where + fixP->fx_frag->fr_address;
+
+  /* If this is pc-relative and we are going to emit a relocation
+     then we just want to put out any pipeline compensation that the linker
+     will need.  Otherwise we want to use the calculated base.
+     For WinCE we skip the bias for externals as well, since this
+     is how the MS ARM-CE assembler behaves and we want to be compatible.  */
+  if (fixP->fx_pcrel
+      && ((fixP->fx_addsy && S_GET_SEGMENT (fixP->fx_addsy) != seg)
+	  || (arm_force_relocation (fixP)
+#ifdef TE_WINCE
+	      && !S_IS_EXTERNAL (fixP->fx_addsy)
+#endif
+	      )))
+    base = 0;
+
+
+  switch (fixP->fx_r_type)
+    {
+      /* PC relative addressing on the Thumb is slightly odd as the
+	 bottom two bits of the PC are forced to zero for the
+	 calculation.  This happens *after* application of the
+	 pipeline offset.  However, Thumb adrl already adjusts for
+	 this, so we need not do it again.  */
+    case BFD_RELOC_ARM_THUMB_ADD:
+      return base & ~3;
+
+    case BFD_RELOC_ARM_THUMB_OFFSET:
+    case BFD_RELOC_ARM_T32_OFFSET_IMM:
+    case BFD_RELOC_ARM_T32_ADD_PC12:
+    case BFD_RELOC_ARM_T32_CP_OFF_IMM:
+      return (base + 4) & ~3;
+
+      /* Thumb branches are simply offset by +4.  */
+    case BFD_RELOC_THUMB_PCREL_BRANCH7:
+    case BFD_RELOC_THUMB_PCREL_BRANCH9:
+    case BFD_RELOC_THUMB_PCREL_BRANCH12:
+    case BFD_RELOC_THUMB_PCREL_BRANCH20:
+    case BFD_RELOC_THUMB_PCREL_BRANCH25:
+      return base + 4;
+
+    case BFD_RELOC_THUMB_PCREL_BRANCH23:
+      if (fixP->fx_addsy
+	  && (S_GET_SEGMENT (fixP->fx_addsy) == seg)
+	  && !S_FORCE_RELOC (fixP->fx_addsy, TRUE)
+	  && ARM_IS_FUNC (fixP->fx_addsy)
+	  && ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v5t))
+	base = fixP->fx_where + fixP->fx_frag->fr_address;
+       return base + 4;
+
+      /* BLX is like branches above, but forces the low two bits of PC to
+	 zero.  */
+    case BFD_RELOC_THUMB_PCREL_BLX:
+      if (fixP->fx_addsy
+	  && (S_GET_SEGMENT (fixP->fx_addsy) == seg)
+	  && !S_FORCE_RELOC (fixP->fx_addsy, TRUE)
+	  && THUMB_IS_FUNC (fixP->fx_addsy)
+	  && ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v5t))
+	base = fixP->fx_where + fixP->fx_frag->fr_address;
+      return (base + 4) & ~3;
+
+      /* ARM mode branches are offset by +8.  However, the Windows CE
+	 loader expects the relocation not to take this into account.  */
+    case BFD_RELOC_ARM_PCREL_BLX:
+      if (fixP->fx_addsy
+	  && (S_GET_SEGMENT (fixP->fx_addsy) == seg)
+	  && !S_FORCE_RELOC (fixP->fx_addsy, TRUE)
+	  && ARM_IS_FUNC (fixP->fx_addsy)
+	  && ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v5t))
+	base = fixP->fx_where + fixP->fx_frag->fr_address;
+      return base + 8;
+
+    case BFD_RELOC_ARM_PCREL_CALL:
+      if (fixP->fx_addsy
+	  && (S_GET_SEGMENT (fixP->fx_addsy) == seg)
+	  && !S_FORCE_RELOC (fixP->fx_addsy, TRUE)
+	  && THUMB_IS_FUNC (fixP->fx_addsy)
+	  && ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v5t))
+	base = fixP->fx_where + fixP->fx_frag->fr_address;
+      return base + 8;
+
+    case BFD_RELOC_ARM_PCREL_BRANCH:
+    case BFD_RELOC_ARM_PCREL_JUMP:
+    case BFD_RELOC_ARM_PLT32:
+#ifdef TE_WINCE
+      /* When handling fixups immediately, because we have already
+	 discovered the value of a symbol, or the address of the frag involved
+	 we must account for the offset by +8, as the OS loader will never see the reloc.
+	 see fixup_segment() in write.c
+	 The S_IS_EXTERNAL test handles the case of global symbols.
+	 Those need the calculated base, not just the pipe compensation the linker will need.  */
+      if (fixP->fx_pcrel
+	  && fixP->fx_addsy != NULL
+	  && (S_GET_SEGMENT (fixP->fx_addsy) == seg)
+	  && (S_IS_EXTERNAL (fixP->fx_addsy) || !arm_force_relocation (fixP)))
+	return base + 8;
+      return base;
+#else
+      return base + 8;
+#endif
+
+
+      /* ARM mode loads relative to PC are also offset by +8.  Unlike
+	 branches, the Windows CE loader *does* expect the relocation
+	 to take this into account.  */
+    case BFD_RELOC_ARM_OFFSET_IMM:
+    case BFD_RELOC_ARM_OFFSET_IMM8:
+    case BFD_RELOC_ARM_HWLITERAL:
+    case BFD_RELOC_ARM_LITERAL:
+    case BFD_RELOC_ARM_CP_OFF_IMM:
+      return base + 8;
+
+
+      /* Other PC-relative relocations are un-offset.  */
+    default:
+      return base;
+    }
+}
+
+static bfd_boolean flag_warn_syms = TRUE;
+
+bfd_boolean
+arm_tc_equal_in_insn (int c ATTRIBUTE_UNUSED, char * name)
+{
+  /* PR 18347 - Warn if the user attempts to create a symbol with the same
+     name as an ARM instruction.  Whilst strictly speaking it is allowed, it
+     does mean that the resulting code might be very confusing to the reader.
+     Also this warning can be triggered if the user omits an operand before
+     an immediate address, eg:
+
+       LDR =foo
+
+     GAS treats this as an assignment of the value of the symbol foo to a
+     symbol LDR, and so (without this code) it will not issue any kind of
+     warning or error message.
+
+     Note - ARM instructions are case-insensitive but the strings in the hash
+     table are all stored in lower case, so we must first ensure that name is
+     lower case too.  */
+  if (flag_warn_syms && arm_ops_hsh)
+    {
+      char * nbuf = strdup (name);
+      char * p;
+
+      for (p = nbuf; *p; p++)
+	*p = TOLOWER (*p);
+      if (hash_find (arm_ops_hsh, nbuf) != NULL)
+	{
+	  static struct hash_control * already_warned = NULL;
+
+	  if (already_warned == NULL)
+	    already_warned = hash_new ();
+	  /* Only warn about the symbol once.  To keep the code
+	     simple we let hash_insert do the lookup for us.  */
+	  if (hash_insert (already_warned, name, NULL) == NULL)
+	    as_warn (_("[-mwarn-syms]: Assignment makes a symbol match an ARM instruction: %s"), name);
+	}
+      else
+	free (nbuf);
+    }
+
+  return FALSE;
+}
+
+/* Under ELF we need to default _GLOBAL_OFFSET_TABLE.
+   Otherwise we have no need to default values of symbols.  */
+
+symbolS *
+md_undefined_symbol (char * name ATTRIBUTE_UNUSED)
+{
+#ifdef OBJ_ELF
+  if (name[0] == '_' && name[1] == 'G'
+      && streq (name, GLOBAL_OFFSET_TABLE_NAME))
+    {
+      if (!GOT_symbol)
+	{
+	  if (symbol_find (name))
+	    as_bad (_("GOT already in the symbol table"));
+
+	  GOT_symbol = symbol_new (name, undefined_section,
+				   (valueT) 0, & zero_address_frag);
+	}
+
+      return GOT_symbol;
+    }
+#endif
+
+  return NULL;
+}
+
+/* Subroutine of md_apply_fix.	 Check to see if an immediate can be
+   computed as two separate immediate values, added together.  We
+   already know that this value cannot be computed by just one ARM
+   instruction.	 */
+
+static unsigned int
+validate_immediate_twopart (unsigned int   val,
+			    unsigned int * highpart)
+{
+  unsigned int a;
+  unsigned int i;
+
+  for (i = 0; i < 32; i += 2)
+    if (((a = rotate_left (val, i)) & 0xff) != 0)
+      {
+	if (a & 0xff00)
+	  {
+	    if (a & ~ 0xffff)
+	      continue;
+	    * highpart = (a  >> 8) | ((i + 24) << 7);
+	  }
+	else if (a & 0xff0000)
+	  {
+	    if (a & 0xff000000)
+	      continue;
+	    * highpart = (a >> 16) | ((i + 16) << 7);
+	  }
+	else
+	  {
+	    gas_assert (a & 0xff000000);
+	    * highpart = (a >> 24) | ((i + 8) << 7);
+	  }
+
+	return (a & 0xff) | (i << 7);
+      }
+
+  return FAIL;
+}
+
+static int
+validate_offset_imm (unsigned int val, int hwse)
+{
+  if ((hwse && val > 255) || val > 4095)
+    return FAIL;
+  return val;
+}
+
+/* Subroutine of md_apply_fix.	 Do those data_ops which can take a
+   negative immediate constant by altering the instruction.  A bit of
+   a hack really.
+	MOV <-> MVN
+	AND <-> BIC
+	ADC <-> SBC
+	by inverting the second operand, and
+	ADD <-> SUB
+	CMP <-> CMN
+	by negating the second operand.	 */
+
+static int
+negate_data_op (unsigned long * instruction,
+		unsigned long	value)
+{
+  int op, new_inst;
+  unsigned long negated, inverted;
+
+  negated = encode_arm_immediate (-value);
+  inverted = encode_arm_immediate (~value);
+
+  op = (*instruction >> DATA_OP_SHIFT) & 0xf;
+  switch (op)
+    {
+      /* First negates.	 */
+    case OPCODE_SUB:		 /* ADD <-> SUB	 */
+      new_inst = OPCODE_ADD;
+      value = negated;
+      break;
+
+    case OPCODE_ADD:
+      new_inst = OPCODE_SUB;
+      value = negated;
+      break;
+
+    case OPCODE_CMP:		 /* CMP <-> CMN	 */
+      new_inst = OPCODE_CMN;
+      value = negated;
+      break;
+
+    case OPCODE_CMN:
+      new_inst = OPCODE_CMP;
+      value = negated;
+      break;
+
+      /* Now Inverted ops.  */
+    case OPCODE_MOV:		 /* MOV <-> MVN	 */
+      new_inst = OPCODE_MVN;
+      value = inverted;
+      break;
+
+    case OPCODE_MVN:
+      new_inst = OPCODE_MOV;
+      value = inverted;
+      break;
+
+    case OPCODE_AND:		 /* AND <-> BIC	 */
+      new_inst = OPCODE_BIC;
+      value = inverted;
+      break;
+
+    case OPCODE_BIC:
+      new_inst = OPCODE_AND;
+      value = inverted;
+      break;
+
+    case OPCODE_ADC:		  /* ADC <-> SBC  */
+      new_inst = OPCODE_SBC;
+      value = inverted;
+      break;
+
+    case OPCODE_SBC:
+      new_inst = OPCODE_ADC;
+      value = inverted;
+      break;
+
+      /* We cannot do anything.	 */
+    default:
+      return FAIL;
+    }
+
+  if (value == (unsigned) FAIL)
+    return FAIL;
+
+  *instruction &= OPCODE_MASK;
+  *instruction |= new_inst << DATA_OP_SHIFT;
+  return value;
+}
+
+/* Like negate_data_op, but for Thumb-2.   */
+
+static unsigned int
+thumb32_negate_data_op (offsetT *instruction, unsigned int value)
+{
+  int op, new_inst;
+  int rd;
+  unsigned int negated, inverted;
+
+  negated = encode_thumb32_immediate (-value);
+  inverted = encode_thumb32_immediate (~value);
+
+  rd = (*instruction >> 8) & 0xf;
+  op = (*instruction >> T2_DATA_OP_SHIFT) & 0xf;
+  switch (op)
+    {
+      /* ADD <-> SUB.  Includes CMP <-> CMN.  */
+    case T2_OPCODE_SUB:
+      new_inst = T2_OPCODE_ADD;
+      value = negated;
+      break;
+
+    case T2_OPCODE_ADD:
+      new_inst = T2_OPCODE_SUB;
+      value = negated;
+      break;
+
+      /* ORR <-> ORN.  Includes MOV <-> MVN.  */
+    case T2_OPCODE_ORR:
+      new_inst = T2_OPCODE_ORN;
+      value = inverted;
+      break;
+
+    case T2_OPCODE_ORN:
+      new_inst = T2_OPCODE_ORR;
+      value = inverted;
+      break;
+
+      /* AND <-> BIC.  TST has no inverted equivalent.  */
+    case T2_OPCODE_AND:
+      new_inst = T2_OPCODE_BIC;
+      if (rd == 15)
+	value = FAIL;
+      else
+	value = inverted;
+      break;
+
+    case T2_OPCODE_BIC:
+      new_inst = T2_OPCODE_AND;
+      value = inverted;
+      break;
+
+      /* ADC <-> SBC  */
+    case T2_OPCODE_ADC:
+      new_inst = T2_OPCODE_SBC;
+      value = inverted;
+      break;
+
+    case T2_OPCODE_SBC:
+      new_inst = T2_OPCODE_ADC;
+      value = inverted;
+      break;
+
+      /* We cannot do anything.	 */
+    default:
+      return FAIL;
+    }
+
+  if (value == (unsigned int)FAIL)
+    return FAIL;
+
+  *instruction &= T2_OPCODE_MASK;
+  *instruction |= new_inst << T2_DATA_OP_SHIFT;
+  return value;
+}
+
+/* Read a 32-bit thumb instruction from buf.  */
+static unsigned long
+get_thumb32_insn (char * buf)
+{
+  unsigned long insn;
+  insn = md_chars_to_number (buf, THUMB_SIZE) << 16;
+  insn |= md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);
+
+  return insn;
+}
+
+
+/* We usually want to set the low bit on the address of thumb function
+   symbols.  In particular .word foo - . should have the low bit set.
+   Generic code tries to fold the difference of two symbols to
+   a constant.  Prevent this and force a relocation when the first symbols
+   is a thumb function.  */
+
+bfd_boolean
+arm_optimize_expr (expressionS *l, operatorT op, expressionS *r)
+{
+  if (op == O_subtract
+      && l->X_op == O_symbol
+      && r->X_op == O_symbol
+      && THUMB_IS_FUNC (l->X_add_symbol))
+    {
+      l->X_op = O_subtract;
+      l->X_op_symbol = r->X_add_symbol;
+      l->X_add_number -= r->X_add_number;
+      return TRUE;
+    }
+
+  /* Process as normal.  */
+  return FALSE;
+}
+
+/* Encode Thumb2 unconditional branches and calls. The encoding
+   for the 2 are identical for the immediate values.  */
+
+static void
+encode_thumb2_b_bl_offset (char * buf, offsetT value)
+{
+#define T2I1I2MASK  ((1 << 13) | (1 << 11))
+  offsetT newval;
+  offsetT newval2;
+  addressT S, I1, I2, lo, hi;
+
+  S = (value >> 24) & 0x01;
+  I1 = (value >> 23) & 0x01;
+  I2 = (value >> 22) & 0x01;
+  hi = (value >> 12) & 0x3ff;
+  lo = (value >> 1) & 0x7ff;
+  newval   = md_chars_to_number (buf, THUMB_SIZE);
+  newval2  = md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);
+  newval  |= (S << 10) | hi;
+  newval2 &=  ~T2I1I2MASK;
+  newval2 |= (((I1 ^ S) << 13) | ((I2 ^ S) << 11) | lo) ^ T2I1I2MASK;
+  md_number_to_chars (buf, newval, THUMB_SIZE);
+  md_number_to_chars (buf + THUMB_SIZE, newval2, THUMB_SIZE);
+}
+
+void
+md_apply_fix (fixS *	fixP,
+	       valueT * valP,
+	       segT	seg)
+{
+  offsetT	 value = * valP;
+  offsetT	 newval;
+  unsigned int	 newimm;
+  unsigned long	 temp;
+  int		 sign;
+  char *	 buf = fixP->fx_where + fixP->fx_frag->fr_literal;
+
+  gas_assert (fixP->fx_r_type <= BFD_RELOC_UNUSED);
+
+  /* Note whether this will delete the relocation.  */
+
+  if (fixP->fx_addsy == 0 && !fixP->fx_pcrel)
+    fixP->fx_done = 1;
+
+  /* On a 64-bit host, silently truncate 'value' to 32 bits for
+     consistency with the behaviour on 32-bit hosts.  Remember value
+     for emit_reloc.  */
+  value &= 0xffffffff;
+  value ^= 0x80000000;
+  value -= 0x80000000;
+
+  *valP = value;
+  fixP->fx_addnumber = value;
+
+  /* Same treatment for fixP->fx_offset.  */
+  fixP->fx_offset &= 0xffffffff;
+  fixP->fx_offset ^= 0x80000000;
+  fixP->fx_offset -= 0x80000000;
+
+  switch (fixP->fx_r_type)
+    {
+    case BFD_RELOC_NONE:
+      /* This will need to go in the object file.  */
+      fixP->fx_done = 0;
+      break;
+
+    case BFD_RELOC_ARM_IMMEDIATE:
+      /* We claim that this fixup has been processed here,
+	 even if in fact we generate an error because we do
+	 not have a reloc for it, so tc_gen_reloc will reject it.  */
+      fixP->fx_done = 1;
+
+      if (fixP->fx_addsy)
+	{
+	  const char *msg = 0;
+
+	  if (! S_IS_DEFINED (fixP->fx_addsy))
+	    msg = _("undefined symbol %s used as an immediate value");
+	  else if (S_GET_SEGMENT (fixP->fx_addsy) != seg)
+	    msg = _("symbol %s is in a different section");
+	  else if (S_IS_WEAK (fixP->fx_addsy))
+	    msg = _("symbol %s is weak and may be overridden later");
+
+	  if (msg)
+	    {
+	      as_bad_where (fixP->fx_file, fixP->fx_line,
+			    msg, S_GET_NAME (fixP->fx_addsy));
+	      break;
+	    }
+	}
+
+      temp = md_chars_to_number (buf, INSN_SIZE);
+
+      /* If the offset is negative, we should use encoding A2 for ADR.  */
+      if ((temp & 0xfff0000) == 0x28f0000 && value < 0)
+	newimm = negate_data_op (&temp, value);
+      else
+	{
+	  newimm = encode_arm_immediate (value);
+
+	  /* If the instruction will fail, see if we can fix things up by
+	     changing the opcode.  */
+	  if (newimm == (unsigned int) FAIL)
+	    newimm = negate_data_op (&temp, value);
+	}
+
+      if (newimm == (unsigned int) FAIL)
+	{
+	  as_bad_where (fixP->fx_file, fixP->fx_line,
+			_("invalid constant (%lx) after fixup"),
+			(unsigned long) value);
+	  break;
+	}
+
+      newimm |= (temp & 0xfffff000);
+      md_number_to_chars (buf, (valueT) newimm, INSN_SIZE);
+      break;
+
+    case BFD_RELOC_ARM_ADRL_IMMEDIATE:
+      {
+	unsigned int highpart = 0;
+	unsigned int newinsn  = 0xe1a00000; /* nop.  */
+
+	if (fixP->fx_addsy)
+	  {
+	    const char *msg = 0;
+
+	    if (! S_IS_DEFINED (fixP->fx_addsy))
+	      msg = _("undefined symbol %s used as an immediate value");
+	    else if (S_GET_SEGMENT (fixP->fx_addsy) != seg)
+	      msg = _("symbol %s is in a different section");
+	    else if (S_IS_WEAK (fixP->fx_addsy))
+	      msg = _("symbol %s is weak and may be overridden later");
+
+	    if (msg)
+	      {
+		as_bad_where (fixP->fx_file, fixP->fx_line,
+			      msg, S_GET_NAME (fixP->fx_addsy));
+		break;
+	      }
+	  }
+
+	newimm = encode_arm_immediate (value);
+	temp = md_chars_to_number (buf, INSN_SIZE);
+
+	/* If the instruction will fail, see if we can fix things up by
+	   changing the opcode.	 */
+	if (newimm == (unsigned int) FAIL
+	    && (newimm = negate_data_op (& temp, value)) == (unsigned int) FAIL)
+	  {
+	    /* No ?  OK - try using two ADD instructions to generate
+	       the value.  */
+	    newimm = validate_immediate_twopart (value, & highpart);
+
+	    /* Yes - then make sure that the second instruction is
+	       also an add.  */
+	    if (newimm != (unsigned int) FAIL)
+	      newinsn = temp;
+	    /* Still No ?  Try using a negated value.  */
+	    else if ((newimm = validate_immediate_twopart (- value, & highpart)) != (unsigned int) FAIL)
+	      temp = newinsn = (temp & OPCODE_MASK) | OPCODE_SUB << DATA_OP_SHIFT;
+	    /* Otherwise - give up.  */
+	    else
+	      {
+		as_bad_where (fixP->fx_file, fixP->fx_line,
+			      _("unable to compute ADRL instructions for PC offset of 0x%lx"),
+			      (long) value);
+		break;
+	      }
+
+	    /* Replace the first operand in the 2nd instruction (which
+	       is the PC) with the destination register.  We have
+	       already added in the PC in the first instruction and we
+	       do not want to do it again.  */
+	    newinsn &= ~ 0xf0000;
+	    newinsn |= ((newinsn & 0x0f000) << 4);
+	  }
+
+	newimm |= (temp & 0xfffff000);
+	md_number_to_chars (buf, (valueT) newimm, INSN_SIZE);
+
+	highpart |= (newinsn & 0xfffff000);
+	md_number_to_chars (buf + INSN_SIZE, (valueT) highpart, INSN_SIZE);
+      }
+      break;
+
+    case BFD_RELOC_ARM_OFFSET_IMM:
+      if (!fixP->fx_done && seg->use_rela_p)
+	value = 0;
+
+    case BFD_RELOC_ARM_LITERAL:
+      sign = value > 0;
+
+      if (value < 0)
+	value = - value;
+
+      if (validate_offset_imm (value, 0) == FAIL)
+	{
+	  if (fixP->fx_r_type == BFD_RELOC_ARM_LITERAL)
+	    as_bad_where (fixP->fx_file, fixP->fx_line,
+			  _("invalid literal constant: pool needs to be closer"));
+	  else
+	    as_bad_where (fixP->fx_file, fixP->fx_line,
+			  _("bad immediate value for offset (%ld)"),
+			  (long) value);
+	  break;
+	}
+
+      newval = md_chars_to_number (buf, INSN_SIZE);
+      if (value == 0)
+	newval &= 0xfffff000;
+      else
+	{
+	  newval &= 0xff7ff000;
+	  newval |= value | (sign ? INDEX_UP : 0);
+	}
+      md_number_to_chars (buf, newval, INSN_SIZE);
+      break;
+
+    case BFD_RELOC_ARM_OFFSET_IMM8:
+    case BFD_RELOC_ARM_HWLITERAL:
+      sign = value > 0;
+
+      if (value < 0)
+	value = - value;
+
+      if (validate_offset_imm (value, 1) == FAIL)
+	{
+	  if (fixP->fx_r_type == BFD_RELOC_ARM_HWLITERAL)
+	    as_bad_where (fixP->fx_file, fixP->fx_line,
+			  _("invalid literal constant: pool needs to be closer"));
+	  else
+	    as_bad_where (fixP->fx_file, fixP->fx_line,
+			  _("bad immediate value for 8-bit offset (%ld)"),
+			  (long) value);
+	  break;
+	}
+
+      newval = md_chars_to_number (buf, INSN_SIZE);
+      if (value == 0)
+	newval &= 0xfffff0f0;
+      else
+	{
+	  newval &= 0xff7ff0f0;
+	  newval |= ((value >> 4) << 8) | (value & 0xf) | (sign ? INDEX_UP : 0);
+	}
+      md_number_to_chars (buf, newval, INSN_SIZE);
+      break;
+
+    case BFD_RELOC_ARM_T32_OFFSET_U8:
+      if (value < 0 || value > 1020 || value % 4 != 0)
+	as_bad_where (fixP->fx_file, fixP->fx_line,
+		      _("bad immediate value for offset (%ld)"), (long) value);
+      value /= 4;
+
+      newval = md_chars_to_number (buf+2, THUMB_SIZE);
+      newval |= value;
+      md_number_to_chars (buf+2, newval, THUMB_SIZE);
+      break;
+
+    case BFD_RELOC_ARM_T32_OFFSET_IMM:
+      /* This is a complicated relocation used for all varieties of Thumb32
+	 load/store instruction with immediate offset:
+
+	 1110 100P u1WL NNNN XXXX YYYY iiii iiii - +/-(U) pre/post(P) 8-bit,
+						   *4, optional writeback(W)
+						   (doubleword load/store)
+
+	 1111 100S uTTL 1111 XXXX iiii iiii iiii - +/-(U) 12-bit PC-rel
+	 1111 100S 0TTL NNNN XXXX 1Pu1 iiii iiii - +/-(U) pre/post(P) 8-bit
+	 1111 100S 0TTL NNNN XXXX 1110 iiii iiii - positive 8-bit (T instruction)
+	 1111 100S 1TTL NNNN XXXX iiii iiii iiii - positive 12-bit
+	 1111 100S 0TTL NNNN XXXX 1100 iiii iiii - negative 8-bit
+
+	 Uppercase letters indicate bits that are already encoded at
+	 this point.  Lowercase letters are our problem.  For the
+	 second block of instructions, the secondary opcode nybble
+	 (bits 8..11) is present, and bit 23 is zero, even if this is
+	 a PC-relative operation.  */
+      newval = md_chars_to_number (buf, THUMB_SIZE);
+      newval <<= 16;
+      newval |= md_chars_to_number (buf+THUMB_SIZE, THUMB_SIZE);
+
+      if ((newval & 0xf0000000) == 0xe0000000)
+	{
+	  /* Doubleword load/store: 8-bit offset, scaled by 4.  */
+	  if (value >= 0)
+	    newval |= (1 << 23);
+	  else
+	    value = -value;
+	  if (value % 4 != 0)
+	    {
+	      as_bad_where (fixP->fx_file, fixP->fx_line,
+			    _("offset not a multiple of 4"));
+	      break;
+	    }
+	  value /= 4;
+	  if (value > 0xff)
+	    {
+	      as_bad_where (fixP->fx_file, fixP->fx_line,
+			    _("offset out of range"));
+	      break;
+	    }
+	  newval &= ~0xff;
+	}
+      else if ((newval & 0x000f0000) == 0x000f0000)
+	{
+	  /* PC-relative, 12-bit offset.  */
+	  if (value >= 0)
+	    newval |= (1 << 23);
+	  else
+	    value = -value;
+	  if (value > 0xfff)
+	    {
+	      as_bad_where (fixP->fx_file, fixP->fx_line,
+			    _("offset out of range"));
+	      break;
+	    }
+	  newval &= ~0xfff;
+	}
+      else if ((newval & 0x00000100) == 0x00000100)
+	{
+	  /* Writeback: 8-bit, +/- offset.  */
+	  if (value >= 0)
+	    newval |= (1 << 9);
+	  else
+	    value = -value;
+	  if (value > 0xff)
+	    {
+	      as_bad_where (fixP->fx_file, fixP->fx_line,
+			    _("offset out of range"));
+	      break;
+	    }
+	  newval &= ~0xff;
+	}
+      else if ((newval & 0x00000f00) == 0x00000e00)
+	{
+	  /* T-instruction: positive 8-bit offset.  */
+	  if (value < 0 || value > 0xff)
+	    {
+	      as_bad_where (fixP->fx_file, fixP->fx_line,
+			    _("offset out of range"));
+	      break;
+	    }
+	  newval &= ~0xff;
+	  newval |= value;
+	}
+      else
+	{
+	  /* Positive 12-bit or negative 8-bit offset.  */
+	  int limit;
+	  if (value >= 0)
+	    {
+	      newval |= (1 << 23);
+	      limit = 0xfff;
+	    }
+	  else
+	    {
+	      value = -value;
+	      limit = 0xff;
+	    }
+	  if (value > limit)
+	    {
+	      as_bad_where (fixP->fx_file, fixP->fx_line,
+			    _("offset out of range"));
+	      break;
+	    }
+	  newval &= ~limit;
+	}
+
+      newval |= value;
+      md_number_to_chars (buf, (newval >> 16) & 0xffff, THUMB_SIZE);
+      md_number_to_chars (buf + THUMB_SIZE, newval & 0xffff, THUMB_SIZE);
+      break;
+
+    case BFD_RELOC_ARM_SHIFT_IMM:
+      newval = md_chars_to_number (buf, INSN_SIZE);
+      if (((unsigned long) value) > 32
+	  || (value == 32
+	      && (((newval & 0x60) == 0) || (newval & 0x60) == 0x60)))
+	{
+	  as_bad_where (fixP->fx_file, fixP->fx_line,
+			_("shift expression is too large"));
+	  break;
+	}
+
+      if (value == 0)
+	/* Shifts of zero must be done as lsl.	*/
+	newval &= ~0x60;
+      else if (value == 32)
+	value = 0;
+      newval &= 0xfffff07f;
+      newval |= (value & 0x1f) << 7;
+      md_number_to_chars (buf, newval, INSN_SIZE);
+      break;
+
+    case BFD_RELOC_ARM_T32_IMMEDIATE:
+    case BFD_RELOC_ARM_T32_ADD_IMM:
+    case BFD_RELOC_ARM_T32_IMM12:
+    case BFD_RELOC_ARM_T32_ADD_PC12:
+      /* We claim that this fixup has been processed here,
+	 even if in fact we generate an error because we do
+	 not have a reloc for it, so tc_gen_reloc will reject it.  */
+      fixP->fx_done = 1;
+
+      if (fixP->fx_addsy
+	  && ! S_IS_DEFINED (fixP->fx_addsy))
+	{
+	  as_bad_where (fixP->fx_file, fixP->fx_line,
+			_("undefined symbol %s used as an immediate value"),
+			S_GET_NAME (fixP->fx_addsy));
+	  break;
+	}
+
+      newval = md_chars_to_number (buf, THUMB_SIZE);
+      newval <<= 16;
+      newval |= md_chars_to_number (buf+2, THUMB_SIZE);
+
+      newimm = FAIL;
+      if (fixP->fx_r_type == BFD_RELOC_ARM_T32_IMMEDIATE
+	  || fixP->fx_r_type == BFD_RELOC_ARM_T32_ADD_IMM)
+	{
+	  newimm = encode_thumb32_immediate (value);
+	  if (newimm == (unsigned int) FAIL)
+	    newimm = thumb32_negate_data_op (&newval, value);
+	}
+      if (fixP->fx_r_type != BFD_RELOC_ARM_T32_IMMEDIATE
+	  && newimm == (unsigned int) FAIL)
+	{
+	  /* Turn add/sum into addw/subw.  */
+	  if (fixP->fx_r_type == BFD_RELOC_ARM_T32_ADD_IMM)
+	    newval = (newval & 0xfeffffff) | 0x02000000;
+	  /* No flat 12-bit imm encoding for addsw/subsw.  */
+	  if ((newval & 0x00100000) == 0)
+	    {
+	      /* 12 bit immediate for addw/subw.  */
+	      if (value < 0)
+		{
+		  value = -value;
+		  newval ^= 0x00a00000;
+		}
+	      if (value > 0xfff)
+		newimm = (unsigned int) FAIL;
+	      else
+		newimm = value;
+	    }
+	}
+
+      if (newimm == (unsigned int)FAIL)
+	{
+	  as_bad_where (fixP->fx_file, fixP->fx_line,
+			_("invalid constant (%lx) after fixup"),
+			(unsigned long) value);
+	  break;
+	}
+
+      newval |= (newimm & 0x800) << 15;
+      newval |= (newimm & 0x700) << 4;
+      newval |= (newimm & 0x0ff);
+
+      md_number_to_chars (buf,   (valueT) ((newval >> 16) & 0xffff), THUMB_SIZE);
+      md_number_to_chars (buf+2, (valueT) (newval & 0xffff), THUMB_SIZE);
+      break;
+
+    case BFD_RELOC_ARM_SMC:
+      if (((unsigned long) value) > 0xffff)
+	as_bad_where (fixP->fx_file, fixP->fx_line,
+		      _("invalid smc expression"));
+      newval = md_chars_to_number (buf, INSN_SIZE);
+      newval |= (value & 0xf) | ((value & 0xfff0) << 4);
+      md_number_to_chars (buf, newval, INSN_SIZE);
+      break;
+
+    case BFD_RELOC_ARM_HVC:
+      if (((unsigned long) value) > 0xffff)
+	as_bad_where (fixP->fx_file, fixP->fx_line,
+		      _("invalid hvc expression"));
+      newval = md_chars_to_number (buf, INSN_SIZE);
+      newval |= (value & 0xf) | ((value & 0xfff0) << 4);
+      md_number_to_chars (buf, newval, INSN_SIZE);
+      break;
+
+    case BFD_RELOC_ARM_SWI:
+      if (fixP->tc_fix_data != 0)
+	{
+	  if (((unsigned long) value) > 0xff)
+	    as_bad_where (fixP->fx_file, fixP->fx_line,
+			  _("invalid swi expression"));
+	  newval = md_chars_to_number (buf, THUMB_SIZE);
+	  newval |= value;
+	  md_number_to_chars (buf, newval, THUMB_SIZE);
+	}
+      else
+	{
+	  if (((unsigned long) value) > 0x00ffffff)
+	    as_bad_where (fixP->fx_file, fixP->fx_line,
+			  _("invalid swi expression"));
+	  newval = md_chars_to_number (buf, INSN_SIZE);
+	  newval |= value;
+	  md_number_to_chars (buf, newval, INSN_SIZE);
+	}
+      break;
+
+    case BFD_RELOC_ARM_MULTI:
+      if (((unsigned long) value) > 0xffff)
+	as_bad_where (fixP->fx_file, fixP->fx_line,
+		      _("invalid expression in load/store multiple"));
+      newval = value | md_chars_to_number (buf, INSN_SIZE);
+      md_number_to_chars (buf, newval, INSN_SIZE);
+      break;
+
+#ifdef OBJ_ELF
+    case BFD_RELOC_ARM_PCREL_CALL:
+
+      if (ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v5t)
+	  && fixP->fx_addsy
+	  && !S_FORCE_RELOC (fixP->fx_addsy, TRUE)
+	  && (S_GET_SEGMENT (fixP->fx_addsy) == seg)
+	  && THUMB_IS_FUNC (fixP->fx_addsy))
+	/* Flip the bl to blx. This is a simple flip
+	   bit here because we generate PCREL_CALL for
+	   unconditional bls.  */
+	{
+	  newval = md_chars_to_number (buf, INSN_SIZE);
+	  newval = newval | 0x10000000;
+	  md_number_to_chars (buf, newval, INSN_SIZE);
+	  temp = 1;
+	  fixP->fx_done = 1;
+	}
+      else
+	temp = 3;
+      goto arm_branch_common;
+
+    case BFD_RELOC_ARM_PCREL_JUMP:
+      if (ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v5t)
+	  && fixP->fx_addsy
+	  && !S_FORCE_RELOC (fixP->fx_addsy, TRUE)
+	  && (S_GET_SEGMENT (fixP->fx_addsy) == seg)
+	  && THUMB_IS_FUNC (fixP->fx_addsy))
+	{
+	  /* This would map to a bl<cond>, b<cond>,
+	     b<always> to a Thumb function. We
+	     need to force a relocation for this particular
+	     case.  */
+	  newval = md_chars_to_number (buf, INSN_SIZE);
+	  fixP->fx_done = 0;
+	}
+
+    case BFD_RELOC_ARM_PLT32:
+#endif
+    case BFD_RELOC_ARM_PCREL_BRANCH:
+      temp = 3;
+      goto arm_branch_common;
+
+    case BFD_RELOC_ARM_PCREL_BLX:
+
+      temp = 1;
+      if (ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v5t)
+	  && fixP->fx_addsy
+	  && !S_FORCE_RELOC (fixP->fx_addsy, TRUE)
+	  && (S_GET_SEGMENT (fixP->fx_addsy) == seg)
+	  && ARM_IS_FUNC (fixP->fx_addsy))
+	{
+	  /* Flip the blx to a bl and warn.  */
+	  const char *name = S_GET_NAME (fixP->fx_addsy);
+	  newval = 0xeb000000;
+	  as_warn_where (fixP->fx_file, fixP->fx_line,
+			 _("blx to '%s' an ARM ISA state function changed to bl"),
+			  name);
+	  md_number_to_chars (buf, newval, INSN_SIZE);
+	  temp = 3;
+	  fixP->fx_done = 1;
+	}
+
+#ifdef OBJ_ELF
+       if (EF_ARM_EABI_VERSION (meabi_flags) >= EF_ARM_EABI_VER4)
+	 fixP->fx_r_type = BFD_RELOC_ARM_PCREL_CALL;
+#endif
+
+    arm_branch_common:
+      /* We are going to store value (shifted right by two) in the
+	 instruction, in a 24 bit, signed field.  Bits 26 through 32 either
+	 all clear or all set and bit 0 must be clear.  For B/BL bit 1 must
+	 also be be clear.  */
+      if (value & temp)
+	as_bad_where (fixP->fx_file, fixP->fx_line,
+		      _("misaligned branch destination"));
+      if ((value & (offsetT)0xfe000000) != (offsetT)0
+	  && (value & (offsetT)0xfe000000) != (offsetT)0xfe000000)
+	as_bad_where (fixP->fx_file, fixP->fx_line, BAD_RANGE);
+
+      if (fixP->fx_done || !seg->use_rela_p)
+	{
+	  newval = md_chars_to_number (buf, INSN_SIZE);
+	  newval |= (value >> 2) & 0x00ffffff;
+	  /* Set the H bit on BLX instructions.  */
+	  if (temp == 1)
+	    {
+	      if (value & 2)
+		newval |= 0x01000000;
+	      else
+		newval &= ~0x01000000;
+	    }
+	  md_number_to_chars (buf, newval, INSN_SIZE);
+	}
+      break;
+
+    case BFD_RELOC_THUMB_PCREL_BRANCH7: /* CBZ */
+      /* CBZ can only branch forward.  */
+
+      /* Attempts to use CBZ to branch to the next instruction
+	 (which, strictly speaking, are prohibited) will be turned into
+	 no-ops.
+
+	 FIXME: It may be better to remove the instruction completely and
+	 perform relaxation.  */
+      if (value == -2)
+	{
+	  newval = md_chars_to_number (buf, THUMB_SIZE);
+	  newval = 0xbf00; /* NOP encoding T1 */
+	  md_number_to_chars (buf, newval, THUMB_SIZE);
+	}
+      else
+	{
+	  if (value & ~0x7e)
+	    as_bad_where (fixP->fx_file, fixP->fx_line, BAD_RANGE);
+
+	  if (fixP->fx_done || !seg->use_rela_p)
+	    {
+	      newval = md_chars_to_number (buf, THUMB_SIZE);
+	      newval |= ((value & 0x3e) << 2) | ((value & 0x40) << 3);
+	      md_number_to_chars (buf, newval, THUMB_SIZE);
+	    }
+	}
+      break;
+
+    case BFD_RELOC_THUMB_PCREL_BRANCH9: /* Conditional branch.	*/
+      if ((value & ~0xff) && ((value & ~0xff) != ~0xff))
+	as_bad_where (fixP->fx_file, fixP->fx_line, BAD_RANGE);
+
+      if (fixP->fx_done || !seg->use_rela_p)
+	{
+	  newval = md_chars_to_number (buf, THUMB_SIZE);
+	  newval |= (value & 0x1ff) >> 1;
+	  md_number_to_chars (buf, newval, THUMB_SIZE);
+	}
+      break;
+
+    case BFD_RELOC_THUMB_PCREL_BRANCH12: /* Unconditional branch.  */
+      if ((value & ~0x7ff) && ((value & ~0x7ff) != ~0x7ff))
+	as_bad_where (fixP->fx_file, fixP->fx_line, BAD_RANGE);
+
+      if (fixP->fx_done || !seg->use_rela_p)
+	{
+	  newval = md_chars_to_number (buf, THUMB_SIZE);
+	  newval |= (value & 0xfff) >> 1;
+	  md_number_to_chars (buf, newval, THUMB_SIZE);
+	}
+      break;
+
+    case BFD_RELOC_THUMB_PCREL_BRANCH20:
+      if (fixP->fx_addsy
+	  && (S_GET_SEGMENT (fixP->fx_addsy) == seg)
+	  && !S_FORCE_RELOC (fixP->fx_addsy, TRUE)
+	  && ARM_IS_FUNC (fixP->fx_addsy)
+	  && ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v5t))
+	{
+	  /* Force a relocation for a branch 20 bits wide.  */
+	  fixP->fx_done = 0;
+	}
+      if ((value & ~0x1fffff) && ((value & ~0x0fffff) != ~0x0fffff))
+	as_bad_where (fixP->fx_file, fixP->fx_line,
+		      _("conditional branch out of range"));
+
+      if (fixP->fx_done || !seg->use_rela_p)
+	{
+	  offsetT newval2;
+	  addressT S, J1, J2, lo, hi;
+
+	  S  = (value & 0x00100000) >> 20;
+	  J2 = (value & 0x00080000) >> 19;
+	  J1 = (value & 0x00040000) >> 18;
+	  hi = (value & 0x0003f000) >> 12;
+	  lo = (value & 0x00000ffe) >> 1;
+
+	  newval   = md_chars_to_number (buf, THUMB_SIZE);
+	  newval2  = md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);
+	  newval  |= (S << 10) | hi;
+	  newval2 |= (J1 << 13) | (J2 << 11) | lo;
+	  md_number_to_chars (buf, newval, THUMB_SIZE);
+	  md_number_to_chars (buf + THUMB_SIZE, newval2, THUMB_SIZE);
+	}
+      break;
+
+    case BFD_RELOC_THUMB_PCREL_BLX:
+      /* If there is a blx from a thumb state function to
+	 another thumb function flip this to a bl and warn
+	 about it.  */
+
+      if (fixP->fx_addsy
+	  && !S_FORCE_RELOC (fixP->fx_addsy, TRUE)
+	  && (S_GET_SEGMENT (fixP->fx_addsy) == seg)
+	  && THUMB_IS_FUNC (fixP->fx_addsy))
+	{
+	  const char *name = S_GET_NAME (fixP->fx_addsy);
+	  as_warn_where (fixP->fx_file, fixP->fx_line,
+			 _("blx to Thumb func '%s' from Thumb ISA state changed to bl"),
+			 name);
+	  newval = md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);
+	  newval = newval | 0x1000;
+	  md_number_to_chars (buf+THUMB_SIZE, newval, THUMB_SIZE);
+	  fixP->fx_r_type = BFD_RELOC_THUMB_PCREL_BRANCH23;
+	  fixP->fx_done = 1;
+	}
+
+
+      goto thumb_bl_common;
+
+    case BFD_RELOC_THUMB_PCREL_BRANCH23:
+      /* A bl from Thumb state ISA to an internal ARM state function
+	 is converted to a blx.  */
+      if (fixP->fx_addsy
+	  && (S_GET_SEGMENT (fixP->fx_addsy) == seg)
+	  && !S_FORCE_RELOC (fixP->fx_addsy, TRUE)
+	  && ARM_IS_FUNC (fixP->fx_addsy)
+	  && ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v5t))
+	{
+	  newval = md_chars_to_number (buf + THUMB_SIZE, THUMB_SIZE);
+	  newval = newval & ~0x1000;
+	  md_number_to_chars (buf+THUMB_SIZE, newval, THUMB_SIZE);
+	  fixP->fx_r_type = BFD_RELOC_THUMB_PCREL_BLX;
+	  fixP->fx_done = 1;
+	}
+
+    thumb_bl_common:
+
+      if (fixP->fx_r_type == BFD_RELOC_THUMB_PCREL_BLX)
+	/* For a BLX instruction, make sure that the relocation is rounded up
+	   to a word boundary.  This follows the semantics of the instruction
+	   which specifies that bit 1 of the target address will come from bit
+	   1 of the base address.  */
+	value = (value + 3) & ~ 3;
+
+#ifdef OBJ_ELF
+       if (EF_ARM_EABI_VERSION (meabi_flags) >= EF_ARM_EABI_VER4
+	   && fixP->fx_r_type == BFD_RELOC_THUMB_PCREL_BLX)
+	 fixP->fx_r_type = BFD_RELOC_THUMB_PCREL_BRANCH23;
+#endif
+
+      if ((value & ~0x3fffff) && ((value & ~0x3fffff) != ~0x3fffff))
+	{
+	  if (!(ARM_CPU_HAS_FEATURE (cpu_variant, arm_arch_t2)))
+	    as_bad_where (fixP->fx_file, fixP->fx_line, BAD_RANGE);
+	  else if ((value & ~0x1ffffff)
+		   && ((value & ~0x1ffffff) != ~0x1ffffff))
+	    as_bad_where (fixP->fx_file, fixP->fx_line,
+			  _("Thumb2 branch out of range"));
+	}
+
+      if (fixP->fx_done || !seg->use_rela_p)
+	encode_thumb2_b_bl_offset (buf, value);
+
+      break;
+
+    case BFD_RELOC_THUMB_PCREL_BRANCH25:
+      if ((value & ~0x0ffffff) && ((value & ~0x0ffffff) != ~0x0ffffff))
+	as_bad_where (fixP->fx_file, fixP->fx_line, BAD_RANGE);
+
+      if (fixP->fx_done || !seg->use_rela_p)
+	  encode_thumb2_b_bl_offset (buf, value);
+
+      break;
+
+    case BFD_RELOC_8:
+      if (fixP->fx_done || !seg->use_rela_p)
+	*buf = value;
+      break;
+
+    case BFD_RELOC_16:
+      if (fixP->fx_done || !seg->use_rela_p)
+	md_number_to_chars (buf, value, 2);
+      break;
+
+#ifdef OBJ_ELF
+    case BFD_RELOC_ARM_TLS_CALL:
+    case BFD_RELOC_ARM_THM_TLS_CALL:
+    case BFD_RELOC_ARM_TLS_DESCSEQ:
+    case BFD_RELOC_ARM_THM_TLS_DESCSEQ:
+    case BFD_RELOC_ARM_TLS_GOTDESC:
+    case BFD_RELOC_ARM_TLS_GD32:
+    case BFD_RELOC_ARM_TLS_LE32:
+    case BFD_RELOC_ARM_TLS_IE32:
+    case BFD_RELOC_ARM_TLS_LDM32:
+    case BFD_RELOC_ARM_TLS_LDO32:
+      S_SET_THREAD_LOCAL (fixP->fx_addsy);
+      break;
+
+    case BFD_RELOC_ARM_GOT32:
+    case BFD_RELOC_ARM_GOTOFF:
+      break;
+
+    case BFD_RELOC_ARM_GOT_PREL:
+      if (fixP->fx_done || !seg->use_rela_p)
+	md_number_to_chars (buf, value, 4);
+      break;
+
+    case BFD_RELOC_ARM_TARGET2:
+      /* TARGET2 is not partial-inplace, so we need to write the
+	 addend here for REL targets, because it won't be written out
+	 during reloc processing later.  */
+      if (fixP->fx_done || !seg->use_rela_p)
+	md_number_to_chars (buf, fixP->fx_offset, 4);
+      break;
+#endif
+
+    case BFD_RELOC_RVA:
+    case BFD_RELOC_32:
+    case BFD_RELOC_ARM_TARGET1:
+    case BFD_RELOC_ARM_ROSEGREL32:
+    case BFD_RELOC_ARM_SBREL32:
+    case BFD_RELOC_32_PCREL:
+#ifdef TE_PE
+    case BFD_RELOC_32_SECREL:
+#endif
+      if (fixP->fx_done || !seg->use_rela_p)
+#ifdef TE_WINCE
+	/* For WinCE we only do this for pcrel fixups.  */
+	if (fixP->fx_done || fixP->fx_pcrel)
+#endif
+	  md_number_to_chars (buf, value, 4);
+      break;
+
+#ifdef OBJ_ELF
+    case BFD_RELOC_ARM_PREL31:
+      if (fixP->fx_done || !seg->use_rela_p)
+	{
+	  newval = md_chars_to_number (buf, 4) & 0x80000000;
+	  if ((value ^ (value >> 1)) & 0x40000000)
+	    {
+	      as_bad_where (fixP->fx_file, fixP->fx_line,
+			    _("rel31 relocation overflow"));
+	    }
+	  newval |= value & 0x7fffffff;
+	  md_number_to_chars (buf, newval, 4);
+	}
+      break;
+#endif
+
+    case BFD_RELOC_ARM_CP_OFF_IMM:
+    case BFD_RELOC_ARM_T32_CP_OFF_IMM:
+      if (value < -1023 || value > 1023 || (value & 3))
+	as_bad_where (fixP->fx_file, fixP->fx_line,
+		      _("co-processor offset out of range"));
+    cp_off_common:
+      sign = value > 0;
+      if (value < 0)
+	value = -value;
+      if (fixP->fx_r_type == BFD_RELOC_ARM_CP_OFF_IMM
+	  || fixP->fx_r_type == BFD_RELOC_ARM_CP_OFF_IMM_S2)
+	newval = md_chars_to_number (buf, INSN_SIZE);
+      else
+	newval = get_thumb32_insn (buf);
+      if (value == 0)
+	newval &= 0xffffff00;
+      else
+	{
+	  newval &= 0xff7fff00;
+	  newval |= (value >> 2) | (sign ? INDEX_UP : 0);
+	}
+      if (fixP->fx_r_type == BFD_RELOC_ARM_CP_OFF_IMM
+	  || fixP->fx_r_type == BFD_RELOC_ARM_CP_OFF_IMM_S2)
+	md_number_to_chars (buf, newval, INSN_SIZE);
+      else
+	put_thumb32_insn (buf, newval);
+      break;
+
+    case BFD_RELOC_ARM_CP_OFF_IMM_S2:
+    case BFD_RELOC_ARM_T32_CP_OFF_IMM_S2:
+      if (value < -255 || value > 255)
+	as_bad_where (fixP->fx_file, fixP->fx_line,
+		      _("co-processor offset out of range"));
+      value *= 4;
+      goto cp_off_common;
+
+    case BFD_RELOC_ARM_THUMB_OFFSET:
+      newval = md_chars_to_number (buf, THUMB_SIZE);
+      /* Exactly what ranges, and where the offset is inserted depends
+	 on the type of instruction, we can establish this from the
+	 top 4 bits.  */
+      switch (newval >> 12)
+	{
+	case 4: /* PC load.  */
+	  /* Thumb PC loads are somewhat odd, bit 1 of the PC is
+	     forced to zero for these loads; md_pcrel_from has already
+	     compensated for this.  */
+	  if (value & 3)
+	    as_bad_where (fixP->fx_file, fixP->fx_line,
+			  _("invalid offset, target not word aligned (0x%08lX)"),
+			  (((unsigned long) fixP->fx_frag->fr_address
+			    + (unsigned long) fixP->fx_where) & ~3)
+			  + (unsigned long) value);
+
+	  if (value & ~0x3fc)
+	    as_bad_where (fixP->fx_file, fixP->fx_line,
+			  _("invalid offset, value too big (0x%08lX)"),
+			  (long) value);
+
+	  newval |= value >> 2;
+	  break;
+
+	case 9: /* SP load/store.  */
+	  if (value & ~0x3fc)
+	    as_bad_where (fixP->fx_file, fixP->fx_line,
+			  _("invalid offset, value too big (0x%08lX)"),
+			  (long) value);
+	  newval |= value >> 2;
+	  break;
+
+	case 6: /* Word load/store.  */
+	  if (value & ~0x7c)
+	    as_bad_where (fixP->fx_file, fixP->fx_line,
+			  _("invalid offset, value too big (0x%08lX)"),
+			  (long) value);
+	  newval |= value << 4; /* 6 - 2.  */
+	  break;
+
+	case 7: /* Byte load/store.  */
+	  if (value & ~0x1f)
+	    as_bad_where (fixP->fx_file, fixP->fx_line,
+			  _("invalid offset, value too big (0x%08lX)"),
+			  (long) value);
+	  newval |= value << 6;
+	  break;
+
+	case 8: /* Halfword load/store.	 */
+	  if (value & ~0x3e)
+	    as_bad_where (fixP->fx_file, fixP->fx_line,
+			  _("invalid offset, value too big (0x%08lX)"),
+			  (long) value);
+	  newval |= value << 5; /* 6 - 1.  */
+	  break;
+
+	default:
+	  as_bad_where (fixP->fx_file, fixP->fx_line,
+			"Unable to process relocation for thumb opcode: %lx",
+			(unsigned long) newval);
+	  break;
+	}
+      md_number_to_chars (buf, newval, THUMB_SIZE);
+      break;
+
+    case BFD_RELOC_ARM_THUMB_ADD:
+      /* This is a complicated relocation, since we use it for all of
+	 the following immediate relocations:
+
+	    3bit ADD/SUB
+	    8bit ADD/SUB
+	    9bit ADD/SUB SP word-aligned
+	   10bit ADD PC/SP word-aligned
+
+	 The type of instruction being processed is encoded in the
+	 instruction field:
+
+	   0x8000  SUB
+	   0x00F0  Rd
+	   0x000F  Rs
+      */
+      newval = md_chars_to_number (buf, THUMB_SIZE);
+      {
+	int rd = (newval >> 4) & 0xf;
+	int rs = newval & 0xf;
+	int subtract = !!(newval & 0x8000);
+
+	/* Check for HI regs, only very restricted cases allowed:
+	   Adjusting SP, and using PC or SP to get an address.	*/
+	if ((rd > 7 && (rd != REG_SP || rs != REG_SP))
+	    || (rs > 7 && rs != REG_SP && rs != REG_PC))
+	  as_bad_where (fixP->fx_file, fixP->fx_line,
+			_("invalid Hi register with immediate"));
+
+	/* If value is negative, choose the opposite instruction.  */
+	if (value < 0)
+	  {
+	    value = -value;
+	    subtract = !subtract;
+	    if (value < 0)
+	      as_bad_where (fixP->fx_file, fixP->fx_line,
+			    _("immediate value out of range"));
+	  }
+
+	if (rd == REG_SP)
+	  {
+ 	    if (value & ~0x1fc)
+	      as_bad_where (fixP->fx_file, fixP->fx_line,
+			    _("invalid immediate for stack address calculation"));
+	    newval = subtract ? T_OPCODE_SUB_ST : T_OPCODE_ADD_ST;
+	    newval |= value >> 2;
+	  }
+	else if (rs == REG_PC || rs == REG_SP)
+	  {
+	    /* PR gas/18541.  If the addition is for a defined symbol
+	       within range of an ADR instruction then accept it.  */
+	    if (subtract
+		&& value == 4
+		&& fixP->fx_addsy != NULL)
+	      {
+		subtract = 0;
+
+		if (! S_IS_DEFINED (fixP->fx_addsy)
+		    || S_GET_SEGMENT (fixP->fx_addsy) != seg
+		    || S_IS_WEAK (fixP->fx_addsy))
+		  {
+		    as_bad_where (fixP->fx_file, fixP->fx_line,
+				  _("address calculation needs a strongly defined nearby symbol"));
+		  }
+		else
+		  {
+		    offsetT v = fixP->fx_where + fixP->fx_frag->fr_address;
+
+		    /* Round up to the next 4-byte boundary.  */
+		    if (v & 3)
+		      v = (v + 3) & ~ 3;
+		    else
+		      v += 4;
+		    v = S_GET_VALUE (fixP->fx_addsy) - v;
+
+		    if (v & ~0x3fc)
+		      {
+			as_bad_where (fixP->fx_file, fixP->fx_line,
+				      _("symbol too far away"));
+		      }
+		    else
+		      {
+			fixP->fx_done = 1;
+			value = v;
+		      }
+		  }
+	      }
+
+	    if (subtract || value & ~0x3fc)
+	      as_bad_where (fixP->fx_file, fixP->fx_line,
+			    _("invalid immediate for address calculation (value = 0x%08lX)"),
+			    (unsigned long) (subtract ? - value : value));
+	    newval = (rs == REG_PC ? T_OPCODE_ADD_PC : T_OPCODE_ADD_SP);
+	    newval |= rd << 8;
+	    newval |= value >> 2;
+	  }
+	else if (rs == rd)
+	  {
+	    if (value & ~0xff)
+	      as_bad_where (fixP->fx_file, fixP->fx_line,
+			    _("immediate value out of range"));
+	    newval = subtract ? T_OPCODE_SUB_I8 : T_OPCODE_ADD_I8;
+	    newval |= (rd << 8) | value;
+	  }
+	else
+	  {
+	    if (value & ~0x7)
+	      as_bad_where (fixP->fx_file, fixP->fx_line,
+			    _("immediate value out of range"));
+	    newval = subtract ? T_OPCODE_SUB_I3 : T_OPCODE_ADD_I3;
+	    newval |= rd | (rs << 3) | (value << 6);
+	  }
+      }
+      md_number_to_chars (buf, newval, THUMB_SIZE);
+      break;
+
+    case BFD_RELOC_ARM_THUMB_IMM:
+      newval = md_chars_to_number (buf, THUMB_SIZE);
+      if (value < 0 || value > 255)
+	as_bad_where (fixP->fx_file, fixP->fx_line,
+		      _("invalid immediate: %ld is out of range"),
+		      (long) value);
+      newval |= value;
+      md_number_to_chars (buf, newval, THUMB_SIZE);
+      break;
+
+    case BFD_RELOC_ARM_THUMB_SHIFT:
+      /* 5bit shift value (0..32).  LSL cannot take 32.	 */
+      newval = md_chars_to_number (buf, THUMB_SIZE) & 0xf83f;
+      temp = newval & 0xf800;
+      if (value < 0 || value > 32 || (value == 32 && temp == T_OPCODE_LSL_I))
+	as_bad_where (fixP->fx_file, fixP->fx_line,
+		      _("invalid shift value: %ld"), (long) value);
+      /* Shifts of zero must be encoded as LSL.	 */
+      if (value == 0)
+	newval = (newval & 0x003f) | T_OPCODE_LSL_I;
+      /* Shifts of 32 are encoded as zero.  */
+      else if (value == 32)
+	value = 0;
+      newval |= value << 6;
+      md_number_to_chars (buf, newval, THUMB_SIZE);
+      break;
+
+    case BFD_RELOC_VTABLE_INHERIT:
+    case BFD_RELOC_VTABLE_ENTRY:
+      fixP->fx_done = 0;
+      return;
+
+    case BFD_RELOC_ARM_MOVW:
+    case BFD_RELOC_ARM_MOVT:
+    case BFD_RELOC_ARM_THUMB_MOVW:
+    case BFD_RELOC_ARM_THUMB_MOVT:
+      if (fixP->fx_done || !seg->use_rela_p)
+	{
+	  /* REL format relocations are limited to a 16-bit addend.  */
+	  if (!fixP->fx_done)
+	    {
+	      if (value < -0x8000 || value > 0x7fff)
+		  as_bad_where (fixP->fx_file, fixP->fx_line,
+				_("offset out of range"));
+	    }
+	  else if (fixP->fx_r_type == BFD_RELOC_ARM_MOVT
+		   || fixP->fx_r_type == BFD_RELOC_ARM_THUMB_MOVT)
+	    {
+	      value >>= 16;
+	    }
+
+	  if (fixP->fx_r_type == BFD_RELOC_ARM_THUMB_MOVW
+	      || fixP->fx_r_type == BFD_RELOC_ARM_THUMB_MOVT)
+	    {
+	      newval = get_thumb32_insn (buf);
+	      newval &= 0xfbf08f00;
+	      newval |= (value & 0xf000) << 4;
+	      newval |= (value & 0x0800) << 15;
+	      newval |= (value & 0x0700) << 4;
+	      newval |= (value & 0x00ff);
+	      put_thumb32_insn (buf, newval);
+	    }
+	  else
+	    {
+	      newval = md_chars_to_number (buf, 4);
+	      newval &= 0xfff0f000;
+	      newval |= value & 0x0fff;
+	      newval |= (value & 0xf000) << 4;
+	      md_number_to_chars (buf, newval, 4);
+	    }
+	}
+      return;
+
+   case BFD_RELOC_ARM_ALU_PC_G0_NC:
+   case BFD_RELOC_ARM_ALU_PC_G0:
+   case BFD_RELOC_ARM_ALU_PC_G1_NC:
+   case BFD_RELOC_ARM_ALU_PC_G1:
+   case BFD_RELOC_ARM_ALU_PC_G2:
+   case BFD_RELOC_ARM_ALU_SB_G0_NC:
+   case BFD_RELOC_ARM_ALU_SB_G0:
+   case BFD_RELOC_ARM_ALU_SB_G1_NC:
+   case BFD_RELOC_ARM_ALU_SB_G1:
+   case BFD_RELOC_ARM_ALU_SB_G2:
+     gas_assert (!fixP->fx_done);
+     if (!seg->use_rela_p)
+       {
+	 bfd_vma insn;
+	 bfd_vma encoded_addend;
+	 bfd_vma addend_abs = abs (value);
+
+	 /* Check that the absolute value of the addend can be
+	    expressed as an 8-bit constant plus a rotation.  */
+	 encoded_addend = encode_arm_immediate (addend_abs);
+	 if (encoded_addend == (unsigned int) FAIL)
+	   as_bad_where (fixP->fx_file, fixP->fx_line,
+			 _("the offset 0x%08lX is not representable"),
+			 (unsigned long) addend_abs);
+
+	 /* Extract the instruction.  */
+	 insn = md_chars_to_number (buf, INSN_SIZE);
+
+	 /* If the addend is positive, use an ADD instruction.
+	    Otherwise use a SUB.  Take care not to destroy the S bit.  */
+	 insn &= 0xff1fffff;
+	 if (value < 0)
+	   insn |= 1 << 22;
+	 else
+	   insn |= 1 << 23;
+
+	 /* Place the encoded addend into the first 12 bits of the
+	    instruction.  */
+	 insn &= 0xfffff000;
+	 insn |= encoded_addend;
+
+	 /* Update the instruction.  */
+	 md_number_to_chars (buf, insn, INSN_SIZE);
+       }
+     break;
+
+    case BFD_RELOC_ARM_LDR_PC_G0:
+    case BFD_RELOC_ARM_LDR_PC_G1:
+    case BFD_RELOC_ARM_LDR_PC_G2:
+    case BFD_RELOC_ARM_LDR_SB_G0:
+    case BFD_RELOC_ARM_LDR_SB_G1:
+    case BFD_RELOC_ARM_LDR_SB_G2:
+      gas_assert (!fixP->fx_done);
+      if (!seg->use_rela_p)
+	{
+	  bfd_vma insn;
+	  bfd_vma addend_abs = abs (value);
+
+	  /* Check that the absolute value of the addend can be
+	     encoded in 12 bits.  */
+	  if (addend_abs >= 0x1000)
+	    as_bad_where (fixP->fx_file, fixP->fx_line,
+			  _("bad offset 0x%08lX (only 12 bits available for the magnitude)"),
+			  (unsigned long) addend_abs);
+
+	  /* Extract the instruction.  */
+	  insn = md_chars_to_number (buf, INSN_SIZE);
+
+	  /* If the addend is negative, clear bit 23 of the instruction.
+	     Otherwise set it.  */
+	  if (value < 0)
+	    insn &= ~(1 << 23);
+	  else
+	    insn |= 1 << 23;
+
+	  /* Place the absolute value of the addend into the first 12 bits
+	     of the instruction.  */
+	  insn &= 0xfffff000;
+	  insn |= addend_abs;
+
+	  /* Update the instruction.  */
+	  md_number_to_chars (buf, insn, INSN_SIZE);
+	}
+      break;
+
+    case BFD_RELOC_ARM_LDRS_PC_G0:
+    case BFD_RELOC_ARM_LDRS_PC_G1:
+    case BFD_RELOC_ARM_LDRS_PC_G2:
+    case BFD_RELOC_ARM_LDRS_SB_G0:
+    case BFD_RELOC_ARM_LDRS_SB_G1:
+    case BFD_RELOC_ARM_LDRS_SB_G2:
+      gas_assert (!fixP->fx_done);
+      if (!seg->use_rela_p)
+	{
+	  bfd_vma insn;
+	  bfd_vma addend_abs = abs (value);
+
+	  /* Check that the absolute value of the addend can be
+	     encoded in 8 bits.  */
+	  if (addend_abs >= 0x100)
+	    as_bad_where (fixP->fx_file, fixP->fx_line,
+			  _("bad offset 0x%08lX (only 8 bits available for the magnitude)"),
+			  (unsigned long) addend_abs);
+
+	  /* Extract the instruction.  */
+	  insn = md_chars_to_number (buf, INSN_SIZE);
+
+	  /* If the addend is negative, clear bit 23 of the instruction.
+	     Otherwise set it.  */
+	  if (value < 0)
+	    insn &= ~(1 << 23);
+	  else
+	    insn |= 1 << 23;
+
+	  /* Place the first four bits of the absolute value of the addend
+	     into the first 4 bits of the instruction, and the remaining
+	     four into bits 8 .. 11.  */
+	  insn &= 0xfffff0f0;
+	  insn |= (addend_abs & 0xf) | ((addend_abs & 0xf0) << 4);
+
+	  /* Update the instruction.  */
+	  md_number_to_chars (buf, insn, INSN_SIZE);
+	}
+      break;
+
+    case BFD_RELOC_ARM_LDC_PC_G0:
+    case BFD_RELOC_ARM_LDC_PC_G1:
+    case BFD_RELOC_ARM_LDC_PC_G2:
+    case BFD_RELOC_ARM_LDC_SB_G0:
+    case BFD_RELOC_ARM_LDC_SB_G1:
+    case BFD_RELOC_ARM_LDC_SB_G2:
+      gas_assert (!fixP->fx_done);
+      if (!seg->use_rela_p)
+	{
+	  bfd_vma insn;
+	  bfd_vma addend_abs = abs (value);
+
+	  /* Check that the absolute value of the addend is a multiple of
+	     four and, when divided by four, fits in 8 bits.  */
+	  if (addend_abs & 0x3)
+	    as_bad_where (fixP->fx_file, fixP->fx_line,
+			  _("bad offset 0x%08lX (must be word-aligned)"),
+			  (unsigned long) addend_abs);
+
+	  if ((addend_abs >> 2) > 0xff)
+	    as_bad_where (fixP->fx_file, fixP->fx_line,
+			  _("bad offset 0x%08lX (must be an 8-bit number of words)"),
+			  (unsigned long) addend_abs);
+
+	  /* Extract the instruction.  */
+	  insn = md_chars_to_number (buf, INSN_SIZE);
+
+	  /* If the addend is negative, clear bit 23 of the instruction.
+	     Otherwise set it.  */
+	  if (value < 0)
+	    insn &= ~(1 << 23);
+	  else
+	    insn |= 1 << 23;
+
+	  /* Place the addend (divided by four) into the first eight
+	     bits of the instruction.  */
+	  insn &= 0xfffffff0;
+	  insn |= addend_abs >> 2;
+
+	  /* Update the instruction.  */
+	  md_number_to_chars (buf, insn, INSN_SIZE);
+	}
+      break;
+
+    case BFD_RELOC_ARM_V4BX:
+      /* This will need to go in the object file.  */
+      fixP->fx_done = 0;
+      break;
+
+    case BFD_RELOC_UNUSED:
+    default:
+      as_bad_where (fixP->fx_file, fixP->fx_line,
+		    _("bad relocation fixup type (%d)"), fixP->fx_r_type);
+    }
+}
+
+/* Translate internal representation of relocation info to BFD target
+   format.  */
+
+arelent *
+tc_gen_reloc (asection *section, fixS *fixp)
+{
+  arelent * reloc;
+  bfd_reloc_code_real_type code;
+
+  reloc = (arelent *) xmalloc (sizeof (arelent));
+
+  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
+  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
+  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
+
+  if (fixp->fx_pcrel)
+    {
+      if (section->use_rela_p)
+	fixp->fx_offset -= md_pcrel_from_section (fixp, section);
+      else
+	fixp->fx_offset = reloc->address;
+    }
+  reloc->addend = fixp->fx_offset;
+
+  switch (fixp->fx_r_type)
+    {
+    case BFD_RELOC_8:
+      if (fixp->fx_pcrel)
+	{
+	  code = BFD_RELOC_8_PCREL;
+	  break;
+	}
+
+    case BFD_RELOC_16:
+      if (fixp->fx_pcrel)
+	{
+	  code = BFD_RELOC_16_PCREL;
+	  break;
+	}
+
+    case BFD_RELOC_32:
+      if (fixp->fx_pcrel)
+	{
+	  code = BFD_RELOC_32_PCREL;
+	  break;
+	}
+
+    case BFD_RELOC_ARM_MOVW:
+      if (fixp->fx_pcrel)
+	{
+	  code = BFD_RELOC_ARM_MOVW_PCREL;
+	  break;
+	}
+
+    case BFD_RELOC_ARM_MOVT:
+      if (fixp->fx_pcrel)
+	{
+	  code = BFD_RELOC_ARM_MOVT_PCREL;
+	  break;
+	}
+
+    case BFD_RELOC_ARM_THUMB_MOVW:
+      if (fixp->fx_pcrel)
+	{
+	  code = BFD_RELOC_ARM_THUMB_MOVW_PCREL;
+	  break;
+	}
+
+    case BFD_RELOC_ARM_THUMB_MOVT:
+      if (fixp->fx_pcrel)
+	{
+	  code = BFD_RELOC_ARM_THUMB_MOVT_PCREL;
+	  break;
+	}
+
+    case BFD_RELOC_NONE:
+    case BFD_RELOC_ARM_PCREL_BRANCH:
+    case BFD_RELOC_ARM_PCREL_BLX:
+    case BFD_RELOC_RVA:
+    case BFD_RELOC_THUMB_PCREL_BRANCH7:
+    case BFD_RELOC_THUMB_PCREL_BRANCH9:
+    case BFD_RELOC_THUMB_PCREL_BRANCH12:
+    case BFD_RELOC_THUMB_PCREL_BRANCH20:
+    case BFD_RELOC_THUMB_PCREL_BRANCH23:
+    case BFD_RELOC_THUMB_PCREL_BRANCH25:
+    case BFD_RELOC_VTABLE_ENTRY:
+    case BFD_RELOC_VTABLE_INHERIT:
+#ifdef TE_PE
+    case BFD_RELOC_32_SECREL:
+#endif
+      code = fixp->fx_r_type;
+      break;
+
+    case BFD_RELOC_THUMB_PCREL_BLX:
+#ifdef OBJ_ELF
+      if (EF_ARM_EABI_VERSION (meabi_flags) >= EF_ARM_EABI_VER4)
+	code = BFD_RELOC_THUMB_PCREL_BRANCH23;
+      else
+#endif
+	code = BFD_RELOC_THUMB_PCREL_BLX;
+      break;
+
+    case BFD_RELOC_ARM_LITERAL:
+    case BFD_RELOC_ARM_HWLITERAL:
+      /* If this is called then the a literal has
+	 been referenced across a section boundary.  */
+      as_bad_where (fixp->fx_file, fixp->fx_line,
+		    _("literal referenced across section boundary"));
+      return NULL;
+
+#ifdef OBJ_ELF
+    case BFD_RELOC_ARM_TLS_CALL:
+    case BFD_RELOC_ARM_THM_TLS_CALL:
+    case BFD_RELOC_ARM_TLS_DESCSEQ:
+    case BFD_RELOC_ARM_THM_TLS_DESCSEQ:
+    case BFD_RELOC_ARM_GOT32:
+    case BFD_RELOC_ARM_GOTOFF:
+    case BFD_RELOC_ARM_GOT_PREL:
+    case BFD_RELOC_ARM_PLT32:
+    case BFD_RELOC_ARM_TARGET1:
+    case BFD_RELOC_ARM_ROSEGREL32:
+    case BFD_RELOC_ARM_SBREL32:
+    case BFD_RELOC_ARM_PREL31:
+    case BFD_RELOC_ARM_TARGET2:
+    case BFD_RELOC_ARM_TLS_LDO32:
+    case BFD_RELOC_ARM_PCREL_CALL:
+    case BFD_RELOC_ARM_PCREL_JUMP:
+    case BFD_RELOC_ARM_ALU_PC_G0_NC:
+    case BFD_RELOC_ARM_ALU_PC_G0:
+    case BFD_RELOC_ARM_ALU_PC_G1_NC:
+    case BFD_RELOC_ARM_ALU_PC_G1:
+    case BFD_RELOC_ARM_ALU_PC_G2:
+    case BFD_RELOC_ARM_LDR_PC_G0:
+    case BFD_RELOC_ARM_LDR_PC_G1:
+    case BFD_RELOC_ARM_LDR_PC_G2:
+    case BFD_RELOC_ARM_LDRS_PC_G0:
+    case BFD_RELOC_ARM_LDRS_PC_G1:
+    case BFD_RELOC_ARM_LDRS_PC_G2:
+    case BFD_RELOC_ARM_LDC_PC_G0:
+    case BFD_RELOC_ARM_LDC_PC_G1:
+    case BFD_RELOC_ARM_LDC_PC_G2:
+    case BFD_RELOC_ARM_ALU_SB_G0_NC:
+    case BFD_RELOC_ARM_ALU_SB_G0:
+    case BFD_RELOC_ARM_ALU_SB_G1_NC:
+    case BFD_RELOC_ARM_ALU_SB_G1:
+    case BFD_RELOC_ARM_ALU_SB_G2:
+    case BFD_RELOC_ARM_LDR_SB_G0:
+    case BFD_RELOC_ARM_LDR_SB_G1:
+    case BFD_RELOC_ARM_LDR_SB_G2:
+    case BFD_RELOC_ARM_LDRS_SB_G0:
+    case BFD_RELOC_ARM_LDRS_SB_G1:
+    case BFD_RELOC_ARM_LDRS_SB_G2:
+    case BFD_RELOC_ARM_LDC_SB_G0:
+    case BFD_RELOC_ARM_LDC_SB_G1:
+    case BFD_RELOC_ARM_LDC_SB_G2:
+    case BFD_RELOC_ARM_V4BX:
+      code = fixp->fx_r_type;
+      break;
+
+    case BFD_RELOC_ARM_TLS_GOTDESC:
+    case BFD_RELOC_ARM_TLS_GD32:
+    case BFD_RELOC_ARM_TLS_LE32:
+    case BFD_RELOC_ARM_TLS_IE32:
+    case BFD_RELOC_ARM_TLS_LDM32:
+      /* BFD will include the symbol's address in the addend.
+	 But we don't want that, so subtract it out again here.  */
+      if (!S_IS_COMMON (fixp->fx_addsy))
+	reloc->addend -= (*reloc->sym_ptr_ptr)->value;
+      code = fixp->fx_r_type;
+      break;
+#endif
+
+    case BFD_RELOC_ARM_IMMEDIATE:
+      as_bad_where (fixp->fx_file, fixp->fx_line,
+		    _("internal relocation (type: IMMEDIATE) not fixed up"));
+      return NULL;
+
+    case BFD_RELOC_ARM_ADRL_IMMEDIATE:
+      as_bad_where (fixp->fx_file, fixp->fx_line,
+		    _("ADRL used for a symbol not defined in the same file"));
+      return NULL;
+
+    case BFD_RELOC_ARM_OFFSET_IMM:
+      if (section->use_rela_p)
+	{
+	  code = fixp->fx_r_type;
+	  break;
+	}
+
+      if (fixp->fx_addsy != NULL
+	  && !S_IS_DEFINED (fixp->fx_addsy)
+	  && S_IS_LOCAL (fixp->fx_addsy))
+	{
+	  as_bad_where (fixp->fx_file, fixp->fx_line,
+			_("undefined local label `%s'"),
+			S_GET_NAME (fixp->fx_addsy));
+	  return NULL;
+	}
+
+      as_bad_where (fixp->fx_file, fixp->fx_line,
+		    _("internal_relocation (type: OFFSET_IMM) not fixed up"));
+      return NULL;
+
+    default:
+      {
+	char * type;
+
+	switch (fixp->fx_r_type)
+	  {
+	  case BFD_RELOC_NONE:		   type = "NONE";	  break;
+	  case BFD_RELOC_ARM_OFFSET_IMM8:  type = "OFFSET_IMM8";  break;
+	  case BFD_RELOC_ARM_SHIFT_IMM:	   type = "SHIFT_IMM";	  break;
+	  case BFD_RELOC_ARM_SMC:	   type = "SMC";	  break;
+	  case BFD_RELOC_ARM_SWI:	   type = "SWI";	  break;
+	  case BFD_RELOC_ARM_MULTI:	   type = "MULTI";	  break;
+	  case BFD_RELOC_ARM_CP_OFF_IMM:   type = "CP_OFF_IMM";	  break;
+	  case BFD_RELOC_ARM_T32_OFFSET_IMM: type = "T32_OFFSET_IMM"; break;
+	  case BFD_RELOC_ARM_T32_CP_OFF_IMM: type = "T32_CP_OFF_IMM"; break;
+	  case BFD_RELOC_ARM_THUMB_ADD:	   type = "THUMB_ADD";	  break;
+	  case BFD_RELOC_ARM_THUMB_SHIFT:  type = "THUMB_SHIFT";  break;
+	  case BFD_RELOC_ARM_THUMB_IMM:	   type = "THUMB_IMM";	  break;
+	  case BFD_RELOC_ARM_THUMB_OFFSET: type = "THUMB_OFFSET"; break;
+	  default:			   type = _("<unknown>"); break;
+	  }
+	as_bad_where (fixp->fx_file, fixp->fx_line,
+		      _("cannot represent %s relocation in this object file format"),
+		      type);
+	return NULL;
+      }
+    }
+
+#ifdef OBJ_ELF
+  if ((code == BFD_RELOC_32_PCREL || code == BFD_RELOC_32)
+      && GOT_symbol
+      && fixp->fx_addsy == GOT_symbol)
+    {
+      code = BFD_RELOC_ARM_GOTPC;
+      reloc->addend = fixp->fx_offset = reloc->address;
+    }
+#endif
+
+  reloc->howto = bfd_reloc_type_lookup (stdoutput, code);
+
+  if (reloc->howto == NULL)
+    {
+      as_bad_where (fixp->fx_file, fixp->fx_line,
+		    _("cannot represent %s relocation in this object file format"),
+		    bfd_get_reloc_code_name (code));
+      return NULL;
+    }
+
+  /* HACK: Since arm ELF uses Rel instead of Rela, encode the
+     vtable entry to be used in the relocation's section offset.  */
+  if (fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
+    reloc->address = fixp->fx_offset;
+
+  return reloc;
+}
+
+/* This fix_new is called by cons via TC_CONS_FIX_NEW.	*/
+
+void
+cons_fix_new_arm (fragS *	frag,
+		  int		where,
+		  int		size,
+		  expressionS * exp,
+		  bfd_reloc_code_real_type reloc)
+{
+  int pcrel = 0;
+
+  /* Pick a reloc.
+     FIXME: @@ Should look at CPU word size.  */
+  switch (size)
+    {
+    case 1:
+      reloc = BFD_RELOC_8;
+      break;
+    case 2:
+      reloc = BFD_RELOC_16;
+      break;
+    case 4:
+    default:
+      reloc = BFD_RELOC_32;
+      break;
+    case 8:
+      reloc = BFD_RELOC_64;
+      break;
+    }
+
+#ifdef TE_PE
+  if (exp->X_op == O_secrel)
+  {
+    exp->X_op = O_symbol;
+    reloc = BFD_RELOC_32_SECREL;
+  }
+#endif
+
+  fix_new_exp (frag, where, size, exp, pcrel, reloc);
+}
+
+#if defined (OBJ_COFF)
+void
+arm_validate_fix (fixS * fixP)
+{
+  /* If the destination of the branch is a defined symbol which does not have
+     the THUMB_FUNC attribute, then we must be calling a function which has
+     the (interfacearm) attribute.  We look for the Thumb entry point to that
+     function and change the branch to refer to that function instead.	*/
+  if (fixP->fx_r_type == BFD_RELOC_THUMB_PCREL_BRANCH23
+      && fixP->fx_addsy != NULL
+      && S_IS_DEFINED (fixP->fx_addsy)
+      && ! THUMB_IS_FUNC (fixP->fx_addsy))
+    {
+      fixP->fx_addsy = find_real_start (fixP->fx_addsy);
+    }
+}
+#endif
+
+
+int
+arm_force_relocation (struct fix * fixp)
+{
+#if defined (OBJ_COFF) && defined (TE_PE)
+  if (fixp->fx_r_type == BFD_RELOC_RVA)
+    return 1;
+#endif
+
+  /* In case we have a call or a branch to a function in ARM ISA mode from
+     a thumb function or vice-versa force the relocation. These relocations
+     are cleared off for some cores that might have blx and simple transformations
+     are possible.  */
+
+#ifdef OBJ_ELF
+  switch (fixp->fx_r_type)
+    {
+    case BFD_RELOC_ARM_PCREL_JUMP:
+    case BFD_RELOC_ARM_PCREL_CALL:
+    case BFD_RELOC_THUMB_PCREL_BLX:
+      if (THUMB_IS_FUNC (fixp->fx_addsy))
+	return 1;
+      break;
+
+    case BFD_RELOC_ARM_PCREL_BLX:
+    case BFD_RELOC_THUMB_PCREL_BRANCH25:
+    case BFD_RELOC_THUMB_PCREL_BRANCH20:
+    case BFD_RELOC_THUMB_PCREL_BRANCH23:
+      if (ARM_IS_FUNC (fixp->fx_addsy))
+	return 1;
+      break;
+
+    default:
+      break;
+    }
+#endif
+
+  /* Resolve these relocations even if the symbol is extern or weak.
+     Technically this is probably wrong due to symbol preemption.
+     In practice these relocations do not have enough range to be useful
+     at dynamic link time, and some code (e.g. in the Linux kernel)
+     expects these references to be resolved.  */
+  if (fixp->fx_r_type == BFD_RELOC_ARM_IMMEDIATE
+      || fixp->fx_r_type == BFD_RELOC_ARM_OFFSET_IMM
+      || fixp->fx_r_type == BFD_RELOC_ARM_OFFSET_IMM8
+      || fixp->fx_r_type == BFD_RELOC_ARM_ADRL_IMMEDIATE
+      || fixp->fx_r_type == BFD_RELOC_ARM_CP_OFF_IMM
+      || fixp->fx_r_type == BFD_RELOC_ARM_CP_OFF_IMM_S2
+      || fixp->fx_r_type == BFD_RELOC_ARM_THUMB_OFFSET
+      || fixp->fx_r_type == BFD_RELOC_ARM_T32_ADD_IMM
+      || fixp->fx_r_type == BFD_RELOC_ARM_T32_IMMEDIATE
+      || fixp->fx_r_type == BFD_RELOC_ARM_T32_IMM12
+      || fixp->fx_r_type == BFD_RELOC_ARM_T32_OFFSET_IMM
+      || fixp->fx_r_type == BFD_RELOC_ARM_T32_ADD_PC12
+      || fixp->fx_r_type == BFD_RELOC_ARM_T32_CP_OFF_IMM
+      || fixp->fx_r_type == BFD_RELOC_ARM_T32_CP_OFF_IMM_S2)
+    return 0;
+
+  /* Always leave these relocations for the linker.  */
+  if ((fixp->fx_r_type >= BFD_RELOC_ARM_ALU_PC_G0_NC
+       && fixp->fx_r_type <= BFD_RELOC_ARM_LDC_SB_G2)
+      || fixp->fx_r_type == BFD_RELOC_ARM_LDR_PC_G0)
+    return 1;
+
+  /* Always generate relocations against function symbols.  */
+  if (fixp->fx_r_type == BFD_RELOC_32
+      && fixp->fx_addsy
+      && (symbol_get_bfdsym (fixp->fx_addsy)->flags & BSF_FUNCTION))
+    return 1;
+
+  return generic_force_reloc (fixp);
+}
+
+#if defined (OBJ_ELF) || defined (OBJ_COFF)
+/* Relocations against function names must be left unadjusted,
+   so that the linker can use this information to generate interworking
+   stubs.  The MIPS version of this function
+   also prevents relocations that are mips-16 specific, but I do not
+   know why it does this.
+
+   FIXME:
+   There is one other problem that ought to be addressed here, but
+   which currently is not:  Taking the address of a label (rather
+   than a function) and then later jumping to that address.  Such
+   addresses also ought to have their bottom bit set (assuming that
+   they reside in Thumb code), but at the moment they will not.	 */
+
+bfd_boolean
+arm_fix_adjustable (fixS * fixP)
+{
+  if (fixP->fx_addsy == NULL)
+    return 1;
+
+  /* Preserve relocations against symbols with function type.  */
+  if (symbol_get_bfdsym (fixP->fx_addsy)->flags & BSF_FUNCTION)
+    return FALSE;
+
+  if (THUMB_IS_FUNC (fixP->fx_addsy)
+      && fixP->fx_subsy == NULL)
+    return FALSE;
+
+  /* We need the symbol name for the VTABLE entries.  */
+  if (	 fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
+      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
+    return FALSE;
+
+  /* Don't allow symbols to be discarded on GOT related relocs.	 */
+  if (fixP->fx_r_type == BFD_RELOC_ARM_PLT32
+      || fixP->fx_r_type == BFD_RELOC_ARM_GOT32
+      || fixP->fx_r_type == BFD_RELOC_ARM_GOTOFF
+      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_GD32
+      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_LE32
+      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_IE32
+      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_LDM32
+      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_LDO32
+      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_GOTDESC
+      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_CALL
+      || fixP->fx_r_type == BFD_RELOC_ARM_THM_TLS_CALL
+      || fixP->fx_r_type == BFD_RELOC_ARM_TLS_DESCSEQ
+      || fixP->fx_r_type == BFD_RELOC_ARM_THM_TLS_DESCSEQ
+      || fixP->fx_r_type == BFD_RELOC_ARM_TARGET2)
+    return FALSE;
+
+  /* Similarly for group relocations.  */
+  if ((fixP->fx_r_type >= BFD_RELOC_ARM_ALU_PC_G0_NC
+       && fixP->fx_r_type <= BFD_RELOC_ARM_LDC_SB_G2)
+      || fixP->fx_r_type == BFD_RELOC_ARM_LDR_PC_G0)
+    return FALSE;
+
+  /* MOVW/MOVT REL relocations have limited offsets, so keep the symbols.  */
+  if (fixP->fx_r_type == BFD_RELOC_ARM_MOVW
+      || fixP->fx_r_type == BFD_RELOC_ARM_MOVT
+      || fixP->fx_r_type == BFD_RELOC_ARM_MOVW_PCREL
+      || fixP->fx_r_type == BFD_RELOC_ARM_MOVT_PCREL
+      || fixP->fx_r_type == BFD_RELOC_ARM_THUMB_MOVW
+      || fixP->fx_r_type == BFD_RELOC_ARM_THUMB_MOVT
+      || fixP->fx_r_type == BFD_RELOC_ARM_THUMB_MOVW_PCREL
+      || fixP->fx_r_type == BFD_RELOC_ARM_THUMB_MOVT_PCREL)
+    return FALSE;
+
+  return TRUE;
+}
+#endif /* defined (OBJ_ELF) || defined (OBJ_COFF) */
+
+#ifdef OBJ_ELF
+
+const char *
+elf32_arm_target_format (void)
+{
+#ifdef TE_SYMBIAN
+  return (target_big_endian
+	  ? "elf32-bigarm-symbian"
+	  : "elf32-littlearm-symbian");
+#elif defined (TE_VXWORKS)
+  return (target_big_endian
+	  ? "elf32-bigarm-vxworks"
+	  : "elf32-littlearm-vxworks");
+#elif defined (TE_NACL)
+  return (target_big_endian
+	  ? "elf32-bigarm-nacl"
+	  : "elf32-littlearm-nacl");
+#else
+  if (target_big_endian)
+    return "elf32-bigarm";
+  else
+    return "elf32-littlearm";
+#endif
+}
+
+void
+armelf_frob_symbol (symbolS * symp,
+		    int *     puntp)
+{
+  elf_frob_symbol (symp, puntp);
+}
+#endif
+
+/* MD interface: Finalization.	*/
+
+void
+arm_cleanup (void)
+{
+  literal_pool * pool;
+
+  /* Ensure that all the IT blocks are properly closed.  */
+  check_it_blocks_finished ();
+
+  for (pool = list_of_pools; pool; pool = pool->next)
+    {
+      /* Put it at the end of the relevant section.  */
+      subseg_set (pool->section, pool->sub_section);
+#ifdef OBJ_ELF
+      arm_elf_change_section ();
+#endif
+      s_ltorg (0);
+    }
+}
+
+#ifdef OBJ_ELF
+/* Remove any excess mapping symbols generated for alignment frags in
+   SEC.  We may have created a mapping symbol before a zero byte
+   alignment; remove it if there's a mapping symbol after the
+   alignment.  */
+static void
+check_mapping_symbols (bfd *abfd ATTRIBUTE_UNUSED, asection *sec,
+		       void *dummy ATTRIBUTE_UNUSED)
+{
+  segment_info_type *seginfo = seg_info (sec);
+  fragS *fragp;
+
+  if (seginfo == NULL || seginfo->frchainP == NULL)
+    return;
+
+  for (fragp = seginfo->frchainP->frch_root;
+       fragp != NULL;
+       fragp = fragp->fr_next)
+    {
+      symbolS *sym = fragp->tc_frag_data.last_map;
+      fragS *next = fragp->fr_next;
+
+      /* Variable-sized frags have been converted to fixed size by
+	 this point.  But if this was variable-sized to start with,
+	 there will be a fixed-size frag after it.  So don't handle
+	 next == NULL.  */
+      if (sym == NULL || next == NULL)
+	continue;
+
+      if (S_GET_VALUE (sym) < next->fr_address)
+	/* Not at the end of this frag.  */
+	continue;
+      know (S_GET_VALUE (sym) == next->fr_address);
+
+      do
+	{
+	  if (next->tc_frag_data.first_map != NULL)
+	    {
+	      /* Next frag starts with a mapping symbol.  Discard this
+		 one.  */
+	      symbol_remove (sym, &symbol_rootP, &symbol_lastP);
+	      break;
+	    }
+
+	  if (next->fr_next == NULL)
+	    {
+	      /* This mapping symbol is at the end of the section.  Discard
+		 it.  */
+	      know (next->fr_fix == 0 && next->fr_var == 0);
+	      symbol_remove (sym, &symbol_rootP, &symbol_lastP);
+	      break;
+	    }
+
+	  /* As long as we have empty frags without any mapping symbols,
+	     keep looking.  */
+	  /* If the next frag is non-empty and does not start with a
+	     mapping symbol, then this mapping symbol is required.  */
+	  if (next->fr_address != next->fr_next->fr_address)
+	    break;
+
+	  next = next->fr_next;
+	}
+      while (next != NULL);
+    }
+}
+#endif
+
+/* Adjust the symbol table.  This marks Thumb symbols as distinct from
+   ARM ones.  */
+
+void
+arm_adjust_symtab (void)
+{
+#ifdef OBJ_COFF
+  symbolS * sym;
+
+  for (sym = symbol_rootP; sym != NULL; sym = symbol_next (sym))
+    {
+      if (ARM_IS_THUMB (sym))
+	{
+	  if (THUMB_IS_FUNC (sym))
+	    {
+	      /* Mark the symbol as a Thumb function.  */
+	      if (   S_GET_STORAGE_CLASS (sym) == C_STAT
+		  || S_GET_STORAGE_CLASS (sym) == C_LABEL)  /* This can happen!	 */
+		S_SET_STORAGE_CLASS (sym, C_THUMBSTATFUNC);
+
+	      else if (S_GET_STORAGE_CLASS (sym) == C_EXT)
+		S_SET_STORAGE_CLASS (sym, C_THUMBEXTFUNC);
+	      else
+		as_bad (_("%s: unexpected function type: %d"),
+			S_GET_NAME (sym), S_GET_STORAGE_CLASS (sym));
+	    }
+	  else switch (S_GET_STORAGE_CLASS (sym))
+	    {
+	    case C_EXT:
+	      S_SET_STORAGE_CLASS (sym, C_THUMBEXT);
+	      break;
+	    case C_STAT:
+	      S_SET_STORAGE_CLASS (sym, C_THUMBSTAT);
+	      break;
+	    case C_LABEL:
+	      S_SET_STORAGE_CLASS (sym, C_THUMBLABEL);
+	      break;
+	    default:
+	      /* Do nothing.  */
+	      break;
+	    }
+	}
+
+      if (ARM_IS_INTERWORK (sym))
+	coffsymbol (symbol_get_bfdsym (sym))->native->u.syment.n_flags = 0xFF;
+    }
+#endif
+#ifdef OBJ_ELF
+  symbolS * sym;
+  char	    bind;
+
+  for (sym = symbol_rootP; sym != NULL; sym = symbol_next (sym))
+    {
+      if (ARM_IS_THUMB (sym))
+	{
+	  elf_symbol_type * elf_sym;
+
+	  elf_sym = elf_symbol (symbol_get_bfdsym (sym));
+	  bind = ELF_ST_BIND (elf_sym->internal_elf_sym.st_info);
+
+	  if (! bfd_is_arm_special_symbol_name (elf_sym->symbol.name,
+		BFD_ARM_SPECIAL_SYM_TYPE_ANY))
+	    {
+	      /* If it's a .thumb_func, declare it as so,
+		 otherwise tag label as .code 16.  */
+	      if (THUMB_IS_FUNC (sym))
+		elf_sym->internal_elf_sym.st_target_internal
+		  = ST_BRANCH_TO_THUMB;
+	      else if (EF_ARM_EABI_VERSION (meabi_flags) < EF_ARM_EABI_VER4)
+		elf_sym->internal_elf_sym.st_info =
+		  ELF_ST_INFO (bind, STT_ARM_16BIT);
+	    }
+	}
+    }
+
+  /* Remove any overlapping mapping symbols generated by alignment frags.  */
+  bfd_map_over_sections (stdoutput, check_mapping_symbols, (char *) 0);
+  /* Now do generic ELF adjustments.  */
+  elf_adjust_symtab ();
+#endif
+}
+
+/* MD interface: Initialization.  */
+
+static void
+set_constant_flonums (void)
+{
+  int i;
+
+  for (i = 0; i < NUM_FLOAT_VALS; i++)
+    if (atof_ieee ((char *) fp_const[i], 'x', fp_values[i]) == NULL)
+      abort ();
+}
+
+/* Auto-select Thumb mode if it's the only available instruction set for the
+   given architecture.  */
+
+static void
+autoselect_thumb_from_cpu_variant (void)
+{
+  if (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v1))
+    opcode_select (16);
+}
+
+void
+md_begin (void)
+{
+  unsigned mach;
+  unsigned int i;
+
+  if (	 (arm_ops_hsh = hash_new ()) == NULL
+      || (arm_cond_hsh = hash_new ()) == NULL
+      || (arm_shift_hsh = hash_new ()) == NULL
+      || (arm_psr_hsh = hash_new ()) == NULL
+      || (arm_v7m_psr_hsh = hash_new ()) == NULL
+      || (arm_reg_hsh = hash_new ()) == NULL
+      || (arm_reloc_hsh = hash_new ()) == NULL
+      || (arm_barrier_opt_hsh = hash_new ()) == NULL)
+    as_fatal (_("virtual memory exhausted"));
+
+  for (i = 0; i < sizeof (insns) / sizeof (struct asm_opcode); i++)
+    hash_insert (arm_ops_hsh, insns[i].template_name, (void *) (insns + i));
+  for (i = 0; i < sizeof (conds) / sizeof (struct asm_cond); i++)
+    hash_insert (arm_cond_hsh, conds[i].template_name, (void *) (conds + i));
+  for (i = 0; i < sizeof (shift_names) / sizeof (struct asm_shift_name); i++)
+    hash_insert (arm_shift_hsh, shift_names[i].name, (void *) (shift_names + i));
+  for (i = 0; i < sizeof (psrs) / sizeof (struct asm_psr); i++)
+    hash_insert (arm_psr_hsh, psrs[i].template_name, (void *) (psrs + i));
+  for (i = 0; i < sizeof (v7m_psrs) / sizeof (struct asm_psr); i++)
+    hash_insert (arm_v7m_psr_hsh, v7m_psrs[i].template_name,
+		 (void *) (v7m_psrs + i));
+  for (i = 0; i < sizeof (reg_names) / sizeof (struct reg_entry); i++)
+    hash_insert (arm_reg_hsh, reg_names[i].name, (void *) (reg_names + i));
+  for (i = 0;
+       i < sizeof (barrier_opt_names) / sizeof (struct asm_barrier_opt);
+       i++)
+    hash_insert (arm_barrier_opt_hsh, barrier_opt_names[i].template_name,
+		 (void *) (barrier_opt_names + i));
+#ifdef OBJ_ELF
+  for (i = 0; i < ARRAY_SIZE (reloc_names); i++)
+    {
+      struct reloc_entry * entry = reloc_names + i;
+
+      if (arm_is_eabi() && entry->reloc == BFD_RELOC_ARM_PLT32)
+	/* This makes encode_branch() use the EABI versions of this relocation.  */
+	entry->reloc = BFD_RELOC_UNUSED;
+
+      hash_insert (arm_reloc_hsh, entry->name, (void *) entry);
+    }
+#endif
+
+  set_constant_flonums ();
+
+  /* Set the cpu variant based on the command-line options.  We prefer
+     -mcpu= over -march= if both are set (as for GCC); and we prefer
+     -mfpu= over any other way of setting the floating point unit.
+     Use of legacy options with new options are faulted.  */
+  if (legacy_cpu)
+    {
+      if (mcpu_cpu_opt || march_cpu_opt)
+	as_bad (_("use of old and new-style options to set CPU type"));
+
+      mcpu_cpu_opt = legacy_cpu;
+    }
+  else if (!mcpu_cpu_opt)
+    mcpu_cpu_opt = march_cpu_opt;
+
+  if (legacy_fpu)
+    {
+      if (mfpu_opt)
+	as_bad (_("use of old and new-style options to set FPU type"));
+
+      mfpu_opt = legacy_fpu;
+    }
+  else if (!mfpu_opt)
+    {
+#if !(defined (EABI_DEFAULT) || defined (TE_LINUX) \
+	|| defined (TE_NetBSD) || defined (TE_VXWORKS))
+      /* Some environments specify a default FPU.  If they don't, infer it
+	 from the processor.  */
+      if (mcpu_fpu_opt)
+	mfpu_opt = mcpu_fpu_opt;
+      else
+	mfpu_opt = march_fpu_opt;
+#else
+      mfpu_opt = &fpu_default;
+#endif
+    }
+
+  if (!mfpu_opt)
+    {
+      if (mcpu_cpu_opt != NULL)
+	mfpu_opt = &fpu_default;
+      else if (mcpu_fpu_opt != NULL && ARM_CPU_HAS_FEATURE (*mcpu_fpu_opt, arm_ext_v5))
+	mfpu_opt = &fpu_arch_vfp_v2;
+      else
+	mfpu_opt = &fpu_arch_fpa;
+    }
+
+#ifdef CPU_DEFAULT
+  if (!mcpu_cpu_opt)
+    {
+      mcpu_cpu_opt = &cpu_default;
+      selected_cpu = cpu_default;
+    }
+  else if (no_cpu_selected ())
+    selected_cpu = cpu_default;
+#else
+  if (mcpu_cpu_opt)
+    selected_cpu = *mcpu_cpu_opt;
+  else
+    mcpu_cpu_opt = &arm_arch_any;
+#endif
+
+  ARM_MERGE_FEATURE_SETS (cpu_variant, *mcpu_cpu_opt, *mfpu_opt);
+
+  autoselect_thumb_from_cpu_variant ();
+
+  arm_arch_used = thumb_arch_used = arm_arch_none;
+
+#if defined OBJ_COFF || defined OBJ_ELF
+  {
+    unsigned int flags = 0;
+
+#if defined OBJ_ELF
+    flags = meabi_flags;
+
+    switch (meabi_flags)
+      {
+      case EF_ARM_EABI_UNKNOWN:
+#endif
+	/* Set the flags in the private structure.  */
+	if (uses_apcs_26)      flags |= F_APCS26;
+	if (support_interwork) flags |= F_INTERWORK;
+	if (uses_apcs_float)   flags |= F_APCS_FLOAT;
+	if (pic_code)	       flags |= F_PIC;
+	if (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_any_hard))
+	  flags |= F_SOFT_FLOAT;
+
+	switch (mfloat_abi_opt)
+	  {
+	  case ARM_FLOAT_ABI_SOFT:
+	  case ARM_FLOAT_ABI_SOFTFP:
+	    flags |= F_SOFT_FLOAT;
+	    break;
+
+	  case ARM_FLOAT_ABI_HARD:
+	    if (flags & F_SOFT_FLOAT)
+	      as_bad (_("hard-float conflicts with specified fpu"));
+	    break;
+	  }
+
+	/* Using pure-endian doubles (even if soft-float).	*/
+	if (ARM_CPU_HAS_FEATURE (cpu_variant, fpu_endian_pure))
+	  flags |= F_VFP_FLOAT;
+
+#if defined OBJ_ELF
+	if (ARM_CPU_HAS_FEATURE (cpu_variant, fpu_arch_maverick))
+	    flags |= EF_ARM_MAVERICK_FLOAT;
+	break;
+
+      case EF_ARM_EABI_VER4:
+      case EF_ARM_EABI_VER5:
+	/* No additional flags to set.	*/
+	break;
+
+      default:
+	abort ();
+      }
+#endif
+    bfd_set_private_flags (stdoutput, flags);
+
+    /* We have run out flags in the COFF header to encode the
+       status of ATPCS support, so instead we create a dummy,
+       empty, debug section called .arm.atpcs.	*/
+    if (atpcs)
+      {
+	asection * sec;
+
+	sec = bfd_make_section (stdoutput, ".arm.atpcs");
+
+	if (sec != NULL)
+	  {
+	    bfd_set_section_flags
+	      (stdoutput, sec, SEC_READONLY | SEC_DEBUGGING /* | SEC_HAS_CONTENTS */);
+	    bfd_set_section_size (stdoutput, sec, 0);
+	    bfd_set_section_contents (stdoutput, sec, NULL, 0, 0);
+	  }
+      }
+  }
+#endif
+
+  /* Record the CPU type as well.  */
+  if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_cext_iwmmxt2))
+    mach = bfd_mach_arm_iWMMXt2;
+  else if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_cext_iwmmxt))
+    mach = bfd_mach_arm_iWMMXt;
+  else if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_cext_xscale))
+    mach = bfd_mach_arm_XScale;
+  else if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_cext_maverick))
+    mach = bfd_mach_arm_ep9312;
+  else if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v5e))
+    mach = bfd_mach_arm_5TE;
+  else if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v5))
+    {
+      if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v4t))
+	mach = bfd_mach_arm_5T;
+      else
+	mach = bfd_mach_arm_5;
+    }
+  else if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v4))
+    {
+      if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v4t))
+	mach = bfd_mach_arm_4T;
+      else
+	mach = bfd_mach_arm_4;
+    }
+  else if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v3m))
+    mach = bfd_mach_arm_3M;
+  else if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v3))
+    mach = bfd_mach_arm_3;
+  else if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v2s))
+    mach = bfd_mach_arm_2a;
+  else if (ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v2))
+    mach = bfd_mach_arm_2;
+  else
+    mach = bfd_mach_arm_unknown;
+
+  bfd_set_arch_mach (stdoutput, TARGET_ARCH, mach);
+}
+
+/* Command line processing.  */
+
+/* md_parse_option
+      Invocation line includes a switch not recognized by the base assembler.
+      See if it's a processor-specific option.
+
+      This routine is somewhat complicated by the need for backwards
+      compatibility (since older releases of gcc can't be changed).
+      The new options try to make the interface as compatible as
+      possible with GCC.
+
+      New options (supported) are:
+
+	      -mcpu=<cpu name>		 Assemble for selected processor
+	      -march=<architecture name> Assemble for selected architecture
+	      -mfpu=<fpu architecture>	 Assemble for selected FPU.
+	      -EB/-mbig-endian		 Big-endian
+	      -EL/-mlittle-endian	 Little-endian
+	      -k			 Generate PIC code
+	      -mthumb			 Start in Thumb mode
+	      -mthumb-interwork		 Code supports ARM/Thumb interworking
+
+	      -m[no-]warn-deprecated     Warn about deprecated features
+	      -m[no-]warn-syms		 Warn when symbols match instructions
+
+      For now we will also provide support for:
+
+	      -mapcs-32			 32-bit Program counter
+	      -mapcs-26			 26-bit Program counter
+	      -macps-float		 Floats passed in FP registers
+	      -mapcs-reentrant		 Reentrant code
+	      -matpcs
+      (sometime these will probably be replaced with -mapcs=<list of options>
+      and -matpcs=<list of options>)
+
+      The remaining options are only supported for back-wards compatibility.
+      Cpu variants, the arm part is optional:
+	      -m[arm]1		      Currently not supported.
+	      -m[arm]2, -m[arm]250    Arm 2 and Arm 250 processor
+	      -m[arm]3		      Arm 3 processor
+	      -m[arm]6[xx],	      Arm 6 processors
+	      -m[arm]7[xx][t][[d]m]   Arm 7 processors
+	      -m[arm]8[10]	      Arm 8 processors
+	      -m[arm]9[20][tdmi]      Arm 9 processors
+	      -mstrongarm[110[0]]     StrongARM processors
+	      -mxscale		      XScale processors
+	      -m[arm]v[2345[t[e]]]    Arm architectures
+	      -mall		      All (except the ARM1)
+      FP variants:
+	      -mfpa10, -mfpa11	      FPA10 and 11 co-processor instructions
+	      -mfpe-old		      (No float load/store multiples)
+	      -mvfpxd		      VFP Single precision
+	      -mvfp		      All VFP
+	      -mno-fpu		      Disable all floating point instructions
+
+      The following CPU names are recognized:
+	      arm1, arm2, arm250, arm3, arm6, arm600, arm610, arm620,
+	      arm7, arm7m, arm7d, arm7dm, arm7di, arm7dmi, arm70, arm700,
+	      arm700i, arm710 arm710t, arm720, arm720t, arm740t, arm710c,
+	      arm7100, arm7500, arm7500fe, arm7tdmi, arm8, arm810, arm9,
+	      arm920, arm920t, arm940t, arm946, arm966, arm9tdmi, arm9e,
+	      arm10t arm10e, arm1020t, arm1020e, arm10200e,
+	      strongarm, strongarm110, strongarm1100, strongarm1110, xscale.
+
+      */
+
+const char * md_shortopts = "m:k";
+
+#ifdef ARM_BI_ENDIAN
+#define OPTION_EB (OPTION_MD_BASE + 0)
+#define OPTION_EL (OPTION_MD_BASE + 1)
+#else
+#if TARGET_BYTES_BIG_ENDIAN
+#define OPTION_EB (OPTION_MD_BASE + 0)
+#else
+#define OPTION_EL (OPTION_MD_BASE + 1)
+#endif
+#endif
+#define OPTION_FIX_V4BX (OPTION_MD_BASE + 2)
+
+struct option md_longopts[] =
+{
+#ifdef OPTION_EB
+  {"EB", no_argument, NULL, OPTION_EB},
+#endif
+#ifdef OPTION_EL
+  {"EL", no_argument, NULL, OPTION_EL},
+#endif
+  {"fix-v4bx", no_argument, NULL, OPTION_FIX_V4BX},
+  {NULL, no_argument, NULL, 0}
+};
+
+
+size_t md_longopts_size = sizeof (md_longopts);
+
+struct arm_option_table
+{
+  char *option;		/* Option name to match.  */
+  char *help;		/* Help information.  */
+  int  *var;		/* Variable to change.	*/
+  int	value;		/* What to change it to.  */
+  char *deprecated;	/* If non-null, print this message.  */
+};
+
+struct arm_option_table arm_opts[] =
+{
+  {"k",	     N_("generate PIC code"),	   &pic_code,	 1, NULL},
+  {"mthumb", N_("assemble Thumb code"),	   &thumb_mode,	 1, NULL},
+  {"mthumb-interwork", N_("support ARM/Thumb interworking"),
+   &support_interwork, 1, NULL},
+  {"mapcs-32", N_("code uses 32-bit program counter"), &uses_apcs_26, 0, NULL},
+  {"mapcs-26", N_("code uses 26-bit program counter"), &uses_apcs_26, 1, NULL},
+  {"mapcs-float", N_("floating point args are in fp regs"), &uses_apcs_float,
+   1, NULL},
+  {"mapcs-reentrant", N_("re-entrant code"), &pic_code, 1, NULL},
+  {"matpcs", N_("code is ATPCS conformant"), &atpcs, 1, NULL},
+  {"mbig-endian", N_("assemble for big-endian"), &target_big_endian, 1, NULL},
+  {"mlittle-endian", N_("assemble for little-endian"), &target_big_endian, 0,
+   NULL},
+
+  /* These are recognized by the assembler, but have no affect on code.	 */
+  {"mapcs-frame", N_("use frame pointer"), NULL, 0, NULL},
+  {"mapcs-stack-check", N_("use stack size checking"), NULL, 0, NULL},
+
+  {"mwarn-deprecated", NULL, &warn_on_deprecated, 1, NULL},
+  {"mno-warn-deprecated", N_("do not warn on use of deprecated feature"),
+   &warn_on_deprecated, 0, NULL},
+  {"mwarn-syms", N_("warn about symbols that match instruction names [default]"), (int *) (& flag_warn_syms), TRUE, NULL},
+  {"mno-warn-syms", N_("disable warnings about symobls that match instructions"), (int *) (& flag_warn_syms), FALSE, NULL},
+  {NULL, NULL, NULL, 0, NULL}
+};
+
+struct arm_legacy_option_table
+{
+  char *option;				/* Option name to match.  */
+  const arm_feature_set	**var;		/* Variable to change.	*/
+  const arm_feature_set	value;		/* What to change it to.  */
+  char *deprecated;			/* If non-null, print this message.  */
+};
+
+const struct arm_legacy_option_table arm_legacy_opts[] =
+{
+  /* DON'T add any new processors to this list -- we want the whole list
+     to go away...  Add them to the processors table instead.  */
+  {"marm1",	 &legacy_cpu, ARM_ARCH_V1,  N_("use -mcpu=arm1")},
+  {"m1",	 &legacy_cpu, ARM_ARCH_V1,  N_("use -mcpu=arm1")},
+  {"marm2",	 &legacy_cpu, ARM_ARCH_V2,  N_("use -mcpu=arm2")},
+  {"m2",	 &legacy_cpu, ARM_ARCH_V2,  N_("use -mcpu=arm2")},
+  {"marm250",	 &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm250")},
+  {"m250",	 &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm250")},
+  {"marm3",	 &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm3")},
+  {"m3",	 &legacy_cpu, ARM_ARCH_V2S, N_("use -mcpu=arm3")},
+  {"marm6",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm6")},
+  {"m6",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm6")},
+  {"marm600",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm600")},
+  {"m600",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm600")},
+  {"marm610",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm610")},
+  {"m610",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm610")},
+  {"marm620",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm620")},
+  {"m620",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm620")},
+  {"marm7",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7")},
+  {"m7",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7")},
+  {"marm70",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm70")},
+  {"m70",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm70")},
+  {"marm700",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700")},
+  {"m700",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700")},
+  {"marm700i",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700i")},
+  {"m700i",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm700i")},
+  {"marm710",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710")},
+  {"m710",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710")},
+  {"marm710c",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710c")},
+  {"m710c",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm710c")},
+  {"marm720",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm720")},
+  {"m720",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm720")},
+  {"marm7d",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7d")},
+  {"m7d",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7d")},
+  {"marm7di",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7di")},
+  {"m7di",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7di")},
+  {"marm7m",	 &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7m")},
+  {"m7m",	 &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7m")},
+  {"marm7dm",	 &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dm")},
+  {"m7dm",	 &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dm")},
+  {"marm7dmi",	 &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dmi")},
+  {"m7dmi",	 &legacy_cpu, ARM_ARCH_V3M, N_("use -mcpu=arm7dmi")},
+  {"marm7100",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7100")},
+  {"m7100",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7100")},
+  {"marm7500",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500")},
+  {"m7500",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500")},
+  {"marm7500fe", &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500fe")},
+  {"m7500fe",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -mcpu=arm7500fe")},
+  {"marm7t",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
+  {"m7t",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
+  {"marm7tdmi",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
+  {"m7tdmi",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm7tdmi")},
+  {"marm710t",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm710t")},
+  {"m710t",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm710t")},
+  {"marm720t",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm720t")},
+  {"m720t",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm720t")},
+  {"marm740t",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm740t")},
+  {"m740t",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm740t")},
+  {"marm8",	 &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm8")},
+  {"m8",	 &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm8")},
+  {"marm810",	 &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm810")},
+  {"m810",	 &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=arm810")},
+  {"marm9",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9")},
+  {"m9",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9")},
+  {"marm9tdmi",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9tdmi")},
+  {"m9tdmi",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm9tdmi")},
+  {"marm920",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm920")},
+  {"m920",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm920")},
+  {"marm940",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm940")},
+  {"m940",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -mcpu=arm940")},
+  {"mstrongarm", &legacy_cpu, ARM_ARCH_V4,  N_("use -mcpu=strongarm")},
+  {"mstrongarm110", &legacy_cpu, ARM_ARCH_V4,
+   N_("use -mcpu=strongarm110")},
+  {"mstrongarm1100", &legacy_cpu, ARM_ARCH_V4,
+   N_("use -mcpu=strongarm1100")},
+  {"mstrongarm1110", &legacy_cpu, ARM_ARCH_V4,
+   N_("use -mcpu=strongarm1110")},
+  {"mxscale",	 &legacy_cpu, ARM_ARCH_XSCALE, N_("use -mcpu=xscale")},
+  {"miwmmxt",	 &legacy_cpu, ARM_ARCH_IWMMXT, N_("use -mcpu=iwmmxt")},
+  {"mall",	 &legacy_cpu, ARM_ANY,	       N_("use -mcpu=all")},
+
+  /* Architecture variants -- don't add any more to this list either.  */
+  {"mv2",	 &legacy_cpu, ARM_ARCH_V2,  N_("use -march=armv2")},
+  {"marmv2",	 &legacy_cpu, ARM_ARCH_V2,  N_("use -march=armv2")},
+  {"mv2a",	 &legacy_cpu, ARM_ARCH_V2S, N_("use -march=armv2a")},
+  {"marmv2a",	 &legacy_cpu, ARM_ARCH_V2S, N_("use -march=armv2a")},
+  {"mv3",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -march=armv3")},
+  {"marmv3",	 &legacy_cpu, ARM_ARCH_V3,  N_("use -march=armv3")},
+  {"mv3m",	 &legacy_cpu, ARM_ARCH_V3M, N_("use -march=armv3m")},
+  {"marmv3m",	 &legacy_cpu, ARM_ARCH_V3M, N_("use -march=armv3m")},
+  {"mv4",	 &legacy_cpu, ARM_ARCH_V4,  N_("use -march=armv4")},
+  {"marmv4",	 &legacy_cpu, ARM_ARCH_V4,  N_("use -march=armv4")},
+  {"mv4t",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -march=armv4t")},
+  {"marmv4t",	 &legacy_cpu, ARM_ARCH_V4T, N_("use -march=armv4t")},
+  {"mv5",	 &legacy_cpu, ARM_ARCH_V5,  N_("use -march=armv5")},
+  {"marmv5",	 &legacy_cpu, ARM_ARCH_V5,  N_("use -march=armv5")},
+  {"mv5t",	 &legacy_cpu, ARM_ARCH_V5T, N_("use -march=armv5t")},
+  {"marmv5t",	 &legacy_cpu, ARM_ARCH_V5T, N_("use -march=armv5t")},
+  {"mv5e",	 &legacy_cpu, ARM_ARCH_V5TE, N_("use -march=armv5te")},
+  {"marmv5e",	 &legacy_cpu, ARM_ARCH_V5TE, N_("use -march=armv5te")},
+
+  /* Floating point variants -- don't add any more to this list either.	 */
+  {"mfpe-old", &legacy_fpu, FPU_ARCH_FPE, N_("use -mfpu=fpe")},
+  {"mfpa10",   &legacy_fpu, FPU_ARCH_FPA, N_("use -mfpu=fpa10")},
+  {"mfpa11",   &legacy_fpu, FPU_ARCH_FPA, N_("use -mfpu=fpa11")},
+  {"mno-fpu",  &legacy_fpu, ARM_ARCH_NONE,
+   N_("use either -mfpu=softfpa or -mfpu=softvfp")},
+
+  {NULL, NULL, ARM_ARCH_NONE, NULL}
+};
+
+struct arm_cpu_option_table
+{
+  char *name;
+  size_t name_len;
+  const arm_feature_set	value;
+  /* For some CPUs we assume an FPU unless the user explicitly sets
+     -mfpu=...	*/
+  const arm_feature_set	default_fpu;
+  /* The canonical name of the CPU, or NULL to use NAME converted to upper
+     case.  */
+  const char *canonical_name;
+};
+
+/* This list should, at a minimum, contain all the cpu names
+   recognized by GCC.  */
+#define ARM_CPU_OPT(N, V, DF, CN) { N, sizeof (N) - 1, V, DF, CN }
+static const struct arm_cpu_option_table arm_cpus[] =
+{
+  ARM_CPU_OPT ("all",		ARM_ANY,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm1",		ARM_ARCH_V1,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm2",		ARM_ARCH_V2,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm250",	ARM_ARCH_V2S,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm3",		ARM_ARCH_V2S,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm6",		ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm60",		ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm600",	ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm610",	ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm620",	ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm7",		ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm7m",		ARM_ARCH_V3M,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm7d",		ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm7dm",	ARM_ARCH_V3M,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm7di",	ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm7dmi",	ARM_ARCH_V3M,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm70",		ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm700",	ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm700i",	ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm710",	ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm710t",	ARM_ARCH_V4T,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm720",	ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm720t",	ARM_ARCH_V4T,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm740t",	ARM_ARCH_V4T,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm710c",	ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm7100",	ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm7500",	ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm7500fe",	ARM_ARCH_V3,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm7t",		ARM_ARCH_V4T,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm7tdmi",	ARM_ARCH_V4T,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm7tdmi-s",	ARM_ARCH_V4T,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm8",		ARM_ARCH_V4,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm810",	ARM_ARCH_V4,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("strongarm",	ARM_ARCH_V4,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("strongarm1",	ARM_ARCH_V4,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("strongarm110",	ARM_ARCH_V4,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("strongarm1100",	ARM_ARCH_V4,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("strongarm1110",	ARM_ARCH_V4,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm9",		ARM_ARCH_V4T,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm920",	ARM_ARCH_V4T,	 FPU_ARCH_FPA,    "ARM920T"),
+  ARM_CPU_OPT ("arm920t",	ARM_ARCH_V4T,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm922t",	ARM_ARCH_V4T,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm940t",	ARM_ARCH_V4T,	 FPU_ARCH_FPA,    NULL),
+  ARM_CPU_OPT ("arm9tdmi",	ARM_ARCH_V4T,	 FPU_ARCH_FPA,	  NULL),
+  ARM_CPU_OPT ("fa526",		ARM_ARCH_V4,	 FPU_ARCH_FPA,	  NULL),
+  ARM_CPU_OPT ("fa626",		ARM_ARCH_V4,	 FPU_ARCH_FPA,	  NULL),
+  /* For V5 or later processors we default to using VFP; but the user
+     should really set the FPU type explicitly.	 */
+  ARM_CPU_OPT ("arm9e-r0",	ARM_ARCH_V5TExP, FPU_ARCH_VFP_V2, NULL),
+  ARM_CPU_OPT ("arm9e",		ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, NULL),
+  ARM_CPU_OPT ("arm926ej",	ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2, "ARM926EJ-S"),
+  ARM_CPU_OPT ("arm926ejs",	ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2, "ARM926EJ-S"),
+  ARM_CPU_OPT ("arm926ej-s",	ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2, NULL),
+  ARM_CPU_OPT ("arm946e-r0",	ARM_ARCH_V5TExP, FPU_ARCH_VFP_V2, NULL),
+  ARM_CPU_OPT ("arm946e",	ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, "ARM946E-S"),
+  ARM_CPU_OPT ("arm946e-s",	ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, NULL),
+  ARM_CPU_OPT ("arm966e-r0",	ARM_ARCH_V5TExP, FPU_ARCH_VFP_V2, NULL),
+  ARM_CPU_OPT ("arm966e",	ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, "ARM966E-S"),
+  ARM_CPU_OPT ("arm966e-s",	ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, NULL),
+  ARM_CPU_OPT ("arm968e-s",	ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, NULL),
+  ARM_CPU_OPT ("arm10t",	ARM_ARCH_V5T,	 FPU_ARCH_VFP_V1, NULL),
+  ARM_CPU_OPT ("arm10tdmi",	ARM_ARCH_V5T,	 FPU_ARCH_VFP_V1, NULL),
+  ARM_CPU_OPT ("arm10e",	ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, NULL),
+  ARM_CPU_OPT ("arm1020",	ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, "ARM1020E"),
+  ARM_CPU_OPT ("arm1020t",	ARM_ARCH_V5T,	 FPU_ARCH_VFP_V1, NULL),
+  ARM_CPU_OPT ("arm1020e",	ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, NULL),
+  ARM_CPU_OPT ("arm1022e",	ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, NULL),
+  ARM_CPU_OPT ("arm1026ejs",	ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2,
+								 "ARM1026EJ-S"),
+  ARM_CPU_OPT ("arm1026ej-s",	ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP_V2, NULL),
+  ARM_CPU_OPT ("fa606te",	ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, NULL),
+  ARM_CPU_OPT ("fa616te",	ARM_ARCH_V5TE,   FPU_ARCH_VFP_V2, NULL),
+  ARM_CPU_OPT ("fa626te",	ARM_ARCH_V5TE,   FPU_ARCH_VFP_V2, NULL),
+  ARM_CPU_OPT ("fmp626",	ARM_ARCH_V5TE,   FPU_ARCH_VFP_V2, NULL),
+  ARM_CPU_OPT ("fa726te",	ARM_ARCH_V5TE,	 FPU_ARCH_VFP_V2, NULL),
+  ARM_CPU_OPT ("arm1136js",	ARM_ARCH_V6,	 FPU_NONE,	  "ARM1136J-S"),
+  ARM_CPU_OPT ("arm1136j-s",	ARM_ARCH_V6,	 FPU_NONE,	  NULL),
+  ARM_CPU_OPT ("arm1136jfs",	ARM_ARCH_V6,	 FPU_ARCH_VFP_V2,
+								 "ARM1136JF-S"),
+  ARM_CPU_OPT ("arm1136jf-s",	ARM_ARCH_V6,	 FPU_ARCH_VFP_V2, NULL),
+  ARM_CPU_OPT ("mpcore",	ARM_ARCH_V6K,	 FPU_ARCH_VFP_V2, "MPCore"),
+  ARM_CPU_OPT ("mpcorenovfp",	ARM_ARCH_V6K,	 FPU_NONE,	  "MPCore"),
+  ARM_CPU_OPT ("arm1156t2-s",	ARM_ARCH_V6T2,	 FPU_NONE,	  NULL),
+  ARM_CPU_OPT ("arm1156t2f-s",	ARM_ARCH_V6T2,	 FPU_ARCH_VFP_V2, NULL),
+  ARM_CPU_OPT ("arm1176jz-s",	ARM_ARCH_V6KZ,	 FPU_NONE,	  NULL),
+  ARM_CPU_OPT ("arm1176jzf-s",	ARM_ARCH_V6KZ,	 FPU_ARCH_VFP_V2, NULL),
+  ARM_CPU_OPT ("cortex-a5",	ARM_ARCH_V7A_MP_SEC,
+						 FPU_NONE,	  "Cortex-A5"),
+  ARM_CPU_OPT ("cortex-a7",	ARM_ARCH_V7VE,   FPU_ARCH_NEON_VFP_V4,
+								  "Cortex-A7"),
+  ARM_CPU_OPT ("cortex-a8",	ARM_ARCH_V7A_SEC,
+						 ARM_FEATURE_COPROC (FPU_VFP_V3
+							| FPU_NEON_EXT_V1),
+								  "Cortex-A8"),
+  ARM_CPU_OPT ("cortex-a9",	ARM_ARCH_V7A_MP_SEC,
+						 ARM_FEATURE_COPROC (FPU_VFP_V3
+							| FPU_NEON_EXT_V1),
+								  "Cortex-A9"),
+  ARM_CPU_OPT ("cortex-a12",	ARM_ARCH_V7VE,   FPU_ARCH_NEON_VFP_V4,
+								  "Cortex-A12"),
+  ARM_CPU_OPT ("cortex-a15",	ARM_ARCH_V7VE,   FPU_ARCH_NEON_VFP_V4,
+								  "Cortex-A15"),
+  ARM_CPU_OPT ("cortex-a17",	ARM_ARCH_V7VE,   FPU_ARCH_NEON_VFP_V4,
+								  "Cortex-A17"),
+  ARM_CPU_OPT ("cortex-a35",    ARM_ARCH_V8A,    FPU_ARCH_CRYPTO_NEON_VFP_ARMV8,
+								  "Cortex-A35"),
+  ARM_CPU_OPT ("cortex-a53",    ARM_ARCH_V8A,    FPU_ARCH_CRYPTO_NEON_VFP_ARMV8,
+								  "Cortex-A53"),
+  ARM_CPU_OPT ("cortex-a57",    ARM_ARCH_V8A,    FPU_ARCH_CRYPTO_NEON_VFP_ARMV8,
+								  "Cortex-A57"),
+  ARM_CPU_OPT ("cortex-a72",    ARM_ARCH_V8A,    FPU_ARCH_CRYPTO_NEON_VFP_ARMV8,
+								  "Cortex-A72"),
+  ARM_CPU_OPT ("cortex-r4",	ARM_ARCH_V7R,	 FPU_NONE,	  "Cortex-R4"),
+  ARM_CPU_OPT ("cortex-r4f",	ARM_ARCH_V7R,	 FPU_ARCH_VFP_V3D16,
+								  "Cortex-R4F"),
+  ARM_CPU_OPT ("cortex-r5",	ARM_ARCH_V7R_IDIV,
+						 FPU_NONE,	  "Cortex-R5"),
+  ARM_CPU_OPT ("cortex-r7",	ARM_ARCH_V7R_IDIV,
+						 FPU_ARCH_VFP_V3D16,
+								  "Cortex-R7"),
+  ARM_CPU_OPT ("cortex-m7",	ARM_ARCH_V7EM,	 FPU_NONE,	  "Cortex-M7"),
+  ARM_CPU_OPT ("cortex-m4",	ARM_ARCH_V7EM,	 FPU_NONE,	  "Cortex-M4"),
+  ARM_CPU_OPT ("cortex-m3",	ARM_ARCH_V7M,	 FPU_NONE,	  "Cortex-M3"),
+  ARM_CPU_OPT ("cortex-m1",	ARM_ARCH_V6SM,	 FPU_NONE,	  "Cortex-M1"),
+  ARM_CPU_OPT ("cortex-m0",	ARM_ARCH_V6SM,	 FPU_NONE,	  "Cortex-M0"),
+  ARM_CPU_OPT ("cortex-m0plus",	ARM_ARCH_V6SM,	 FPU_NONE,	  "Cortex-M0+"),
+  ARM_CPU_OPT ("exynos-m1",	ARM_ARCH_V8A,	 FPU_ARCH_CRYPTO_NEON_VFP_ARMV8,
+								  "Samsung " \
+								  "Exynos M1"),
+  ARM_CPU_OPT ("qdf24xx",	ARM_ARCH_V8A,	 FPU_ARCH_CRYPTO_NEON_VFP_ARMV8,
+								  "Qualcomm "
+								  "QDF24XX"),
+
+  /* ??? XSCALE is really an architecture.  */
+  ARM_CPU_OPT ("xscale",	ARM_ARCH_XSCALE, FPU_ARCH_VFP_V2, NULL),
+  /* ??? iwmmxt is not a processor.  */
+  ARM_CPU_OPT ("iwmmxt",	ARM_ARCH_IWMMXT, FPU_ARCH_VFP_V2, NULL),
+  ARM_CPU_OPT ("iwmmxt2",	ARM_ARCH_IWMMXT2,FPU_ARCH_VFP_V2, NULL),
+  ARM_CPU_OPT ("i80200",	ARM_ARCH_XSCALE, FPU_ARCH_VFP_V2, NULL),
+  /* Maverick */
+  ARM_CPU_OPT ("ep9312",	ARM_FEATURE_LOW (ARM_AEXT_V4T, ARM_CEXT_MAVERICK),
+						 FPU_ARCH_MAVERICK, "ARM920T"),
+  /* Marvell processors.  */
+  ARM_CPU_OPT ("marvell-pj4",   ARM_FEATURE_CORE_LOW (ARM_AEXT_V7A | ARM_EXT_MP
+						      | ARM_EXT_SEC),
+						FPU_ARCH_VFP_V3D16, NULL),
+  ARM_CPU_OPT ("marvell-whitney", ARM_FEATURE_CORE_LOW (ARM_AEXT_V7A | ARM_EXT_MP
+							| ARM_EXT_SEC),
+					       FPU_ARCH_NEON_VFP_V4, NULL),
+  /* APM X-Gene family.  */
+  ARM_CPU_OPT ("xgene1",        ARM_ARCH_V8A,    FPU_ARCH_CRYPTO_NEON_VFP_ARMV8,
+	                                                          "APM X-Gene 1"),
+  ARM_CPU_OPT ("xgene2",        ARM_ARCH_V8A,    FPU_ARCH_CRYPTO_NEON_VFP_ARMV8,
+	                                                          "APM X-Gene 2"),
+
+  { NULL, 0, ARM_ARCH_NONE, ARM_ARCH_NONE, NULL }
+};
+#undef ARM_CPU_OPT
+
+struct arm_arch_option_table
+{
+  char *name;
+  size_t name_len;
+  const arm_feature_set	value;
+  const arm_feature_set	default_fpu;
+};
+
+/* This list should, at a minimum, contain all the architecture names
+   recognized by GCC.  */
+#define ARM_ARCH_OPT(N, V, DF) { N, sizeof (N) - 1, V, DF }
+static const struct arm_arch_option_table arm_archs[] =
+{
+  ARM_ARCH_OPT ("all",		ARM_ANY,	 FPU_ARCH_FPA),
+  ARM_ARCH_OPT ("armv1",	ARM_ARCH_V1,	 FPU_ARCH_FPA),
+  ARM_ARCH_OPT ("armv2",	ARM_ARCH_V2,	 FPU_ARCH_FPA),
+  ARM_ARCH_OPT ("armv2a",	ARM_ARCH_V2S,	 FPU_ARCH_FPA),
+  ARM_ARCH_OPT ("armv2s",	ARM_ARCH_V2S,	 FPU_ARCH_FPA),
+  ARM_ARCH_OPT ("armv3",	ARM_ARCH_V3,	 FPU_ARCH_FPA),
+  ARM_ARCH_OPT ("armv3m",	ARM_ARCH_V3M,	 FPU_ARCH_FPA),
+  ARM_ARCH_OPT ("armv4",	ARM_ARCH_V4,	 FPU_ARCH_FPA),
+  ARM_ARCH_OPT ("armv4xm",	ARM_ARCH_V4xM,	 FPU_ARCH_FPA),
+  ARM_ARCH_OPT ("armv4t",	ARM_ARCH_V4T,	 FPU_ARCH_FPA),
+  ARM_ARCH_OPT ("armv4txm",	ARM_ARCH_V4TxM,	 FPU_ARCH_FPA),
+  ARM_ARCH_OPT ("armv5",	ARM_ARCH_V5,	 FPU_ARCH_VFP),
+  ARM_ARCH_OPT ("armv5t",	ARM_ARCH_V5T,	 FPU_ARCH_VFP),
+  ARM_ARCH_OPT ("armv5txm",	ARM_ARCH_V5TxM,	 FPU_ARCH_VFP),
+  ARM_ARCH_OPT ("armv5te",	ARM_ARCH_V5TE,	 FPU_ARCH_VFP),
+  ARM_ARCH_OPT ("armv5texp",	ARM_ARCH_V5TExP, FPU_ARCH_VFP),
+  ARM_ARCH_OPT ("armv5tej",	ARM_ARCH_V5TEJ,	 FPU_ARCH_VFP),
+  ARM_ARCH_OPT ("armv6",	ARM_ARCH_V6,	 FPU_ARCH_VFP),
+  ARM_ARCH_OPT ("armv6j",	ARM_ARCH_V6,	 FPU_ARCH_VFP),
+  ARM_ARCH_OPT ("armv6k",	ARM_ARCH_V6K,	 FPU_ARCH_VFP),
+  ARM_ARCH_OPT ("armv6z",	ARM_ARCH_V6Z,	 FPU_ARCH_VFP),
+  /* The official spelling of this variant is ARMv6KZ, the name "armv6zk" is
+     kept to preserve existing behaviour.  */
+  ARM_ARCH_OPT ("armv6kz",	ARM_ARCH_V6KZ,	 FPU_ARCH_VFP),
+  ARM_ARCH_OPT ("armv6zk",	ARM_ARCH_V6KZ,	 FPU_ARCH_VFP),
+  ARM_ARCH_OPT ("armv6t2",	ARM_ARCH_V6T2,	 FPU_ARCH_VFP),
+  ARM_ARCH_OPT ("armv6kt2",	ARM_ARCH_V6KT2,	 FPU_ARCH_VFP),
+  ARM_ARCH_OPT ("armv6zt2",	ARM_ARCH_V6ZT2,	 FPU_ARCH_VFP),
+  /* The official spelling of this variant is ARMv6KZ, the name "armv6zkt2" is
+     kept to preserve existing behaviour.  */
+  ARM_ARCH_OPT ("armv6kzt2",	ARM_ARCH_V6KZT2, FPU_ARCH_VFP),
+  ARM_ARCH_OPT ("armv6zkt2",	ARM_ARCH_V6KZT2, FPU_ARCH_VFP),
+  ARM_ARCH_OPT ("armv6-m",	ARM_ARCH_V6M,	 FPU_ARCH_VFP),
+  ARM_ARCH_OPT ("armv6s-m",	ARM_ARCH_V6SM,	 FPU_ARCH_VFP),
+  ARM_ARCH_OPT ("armv7",	ARM_ARCH_V7,	 FPU_ARCH_VFP),
+  /* The official spelling of the ARMv7 profile variants is the dashed form.
+     Accept the non-dashed form for compatibility with old toolchains.  */
+  ARM_ARCH_OPT ("armv7a",	ARM_ARCH_V7A,	 FPU_ARCH_VFP),
+  ARM_ARCH_OPT ("armv7ve",	ARM_ARCH_V7VE,	 FPU_ARCH_VFP),
+  ARM_ARCH_OPT ("armv7r",	ARM_ARCH_V7R,	 FPU_ARCH_VFP),
+  ARM_ARCH_OPT ("armv7m",	ARM_ARCH_V7M,	 FPU_ARCH_VFP),
+  ARM_ARCH_OPT ("armv7-a",	ARM_ARCH_V7A,	 FPU_ARCH_VFP),
+  ARM_ARCH_OPT ("armv7-r",	ARM_ARCH_V7R,	 FPU_ARCH_VFP),
+  ARM_ARCH_OPT ("armv7-m",	ARM_ARCH_V7M,	 FPU_ARCH_VFP),
+  ARM_ARCH_OPT ("armv7e-m",	ARM_ARCH_V7EM,	 FPU_ARCH_VFP),
+  ARM_ARCH_OPT ("armv8-a",	ARM_ARCH_V8A,	 FPU_ARCH_VFP),
+  ARM_ARCH_OPT ("armv8.1-a",	ARM_ARCH_V8_1A,	 FPU_ARCH_VFP),
+  ARM_ARCH_OPT ("xscale",	ARM_ARCH_XSCALE, FPU_ARCH_VFP),
+  ARM_ARCH_OPT ("iwmmxt",	ARM_ARCH_IWMMXT, FPU_ARCH_VFP),
+  ARM_ARCH_OPT ("iwmmxt2",	ARM_ARCH_IWMMXT2,FPU_ARCH_VFP),
+  { NULL, 0, ARM_ARCH_NONE, ARM_ARCH_NONE }
+};
+#undef ARM_ARCH_OPT
+
+/* ISA extensions in the co-processor and main instruction set space.  */
+struct arm_option_extension_value_table
+{
+  char *name;
+  size_t name_len;
+  const arm_feature_set merge_value;
+  const arm_feature_set clear_value;
+  const arm_feature_set allowed_archs;
+};
+
+/* The following table must be in alphabetical order with a NULL last entry.
+   */
+#define ARM_EXT_OPT(N, M, C, AA) { N, sizeof (N) - 1, M, C, AA }
+static const struct arm_option_extension_value_table arm_extensions[] =
+{
+  ARM_EXT_OPT ("crc",  ARCH_CRC_ARMV8, ARM_FEATURE_COPROC (CRC_EXT_ARMV8),
+			 ARM_FEATURE_CORE_LOW (ARM_EXT_V8)),
+  ARM_EXT_OPT ("crypto", FPU_ARCH_CRYPTO_NEON_VFP_ARMV8,
+			 ARM_FEATURE_COPROC (FPU_CRYPTO_ARMV8),
+				   ARM_FEATURE_CORE_LOW (ARM_EXT_V8)),
+  ARM_EXT_OPT ("fp",     FPU_ARCH_VFP_ARMV8, ARM_FEATURE_COPROC (FPU_VFP_ARMV8),
+				   ARM_FEATURE_CORE_LOW (ARM_EXT_V8)),
+  ARM_EXT_OPT ("idiv",	ARM_FEATURE_CORE_LOW (ARM_EXT_ADIV | ARM_EXT_DIV),
+			ARM_FEATURE_CORE_LOW (ARM_EXT_ADIV | ARM_EXT_DIV),
+				   ARM_FEATURE_CORE_LOW (ARM_EXT_V7A | ARM_EXT_V7R)),
+  ARM_EXT_OPT ("iwmmxt",ARM_FEATURE_COPROC (ARM_CEXT_IWMMXT),
+			ARM_FEATURE_COPROC (ARM_CEXT_IWMMXT), ARM_ANY),
+  ARM_EXT_OPT ("iwmmxt2", ARM_FEATURE_COPROC (ARM_CEXT_IWMMXT2),
+			ARM_FEATURE_COPROC (ARM_CEXT_IWMMXT2), ARM_ANY),
+  ARM_EXT_OPT ("maverick", ARM_FEATURE_COPROC (ARM_CEXT_MAVERICK),
+			ARM_FEATURE_COPROC (ARM_CEXT_MAVERICK), ARM_ANY),
+  ARM_EXT_OPT ("mp",	ARM_FEATURE_CORE_LOW (ARM_EXT_MP),
+			ARM_FEATURE_CORE_LOW (ARM_EXT_MP),
+				   ARM_FEATURE_CORE_LOW (ARM_EXT_V7A | ARM_EXT_V7R)),
+  ARM_EXT_OPT ("simd",   FPU_ARCH_NEON_VFP_ARMV8,
+			ARM_FEATURE_COPROC (FPU_NEON_ARMV8),
+				   ARM_FEATURE_CORE_LOW (ARM_EXT_V8)),
+  ARM_EXT_OPT ("os",	ARM_FEATURE_CORE_LOW (ARM_EXT_OS),
+			ARM_FEATURE_CORE_LOW (ARM_EXT_OS),
+				   ARM_FEATURE_CORE_LOW (ARM_EXT_V6M)),
+  ARM_EXT_OPT ("pan",	ARM_FEATURE_CORE_HIGH (ARM_EXT2_PAN),
+			ARM_FEATURE (ARM_EXT_V8, ARM_EXT2_PAN, 0),
+			ARM_FEATURE_CORE_LOW (ARM_EXT_V8)),
+  ARM_EXT_OPT ("sec",	ARM_FEATURE_CORE_LOW (ARM_EXT_SEC),
+			ARM_FEATURE_CORE_LOW (ARM_EXT_SEC),
+				   ARM_FEATURE_CORE_LOW (ARM_EXT_V6K | ARM_EXT_V7A)),
+  ARM_EXT_OPT ("virt",	ARM_FEATURE_CORE_LOW (ARM_EXT_VIRT | ARM_EXT_ADIV
+				     | ARM_EXT_DIV),
+			ARM_FEATURE_CORE_LOW (ARM_EXT_VIRT),
+				   ARM_FEATURE_CORE_LOW (ARM_EXT_V7A)),
+  ARM_EXT_OPT ("rdma",  FPU_ARCH_NEON_VFP_ARMV8,
+			ARM_FEATURE_COPROC (FPU_NEON_ARMV8 | FPU_NEON_EXT_RDMA),
+				   ARM_FEATURE_CORE_LOW (ARM_EXT_V8)),
+  ARM_EXT_OPT ("xscale",ARM_FEATURE_COPROC (ARM_CEXT_XSCALE),
+			ARM_FEATURE_COPROC (ARM_CEXT_XSCALE), ARM_ANY),
+  { NULL, 0, ARM_ARCH_NONE, ARM_ARCH_NONE, ARM_ARCH_NONE }
+};
+#undef ARM_EXT_OPT
+
+/* ISA floating-point and Advanced SIMD extensions.  */
+struct arm_option_fpu_value_table
+{
+  char *name;
+  const arm_feature_set value;
+};
+
+/* This list should, at a minimum, contain all the fpu names
+   recognized by GCC.  */
+static const struct arm_option_fpu_value_table arm_fpus[] =
+{
+  {"softfpa",		FPU_NONE},
+  {"fpe",		FPU_ARCH_FPE},
+  {"fpe2",		FPU_ARCH_FPE},
+  {"fpe3",		FPU_ARCH_FPA},	/* Third release supports LFM/SFM.  */
+  {"fpa",		FPU_ARCH_FPA},
+  {"fpa10",		FPU_ARCH_FPA},
+  {"fpa11",		FPU_ARCH_FPA},
+  {"arm7500fe",		FPU_ARCH_FPA},
+  {"softvfp",		FPU_ARCH_VFP},
+  {"softvfp+vfp",	FPU_ARCH_VFP_V2},
+  {"vfp",		FPU_ARCH_VFP_V2},
+  {"vfp9",		FPU_ARCH_VFP_V2},
+  {"vfp3",              FPU_ARCH_VFP_V3}, /* For backwards compatbility.  */
+  {"vfp10",		FPU_ARCH_VFP_V2},
+  {"vfp10-r0",		FPU_ARCH_VFP_V1},
+  {"vfpxd",		FPU_ARCH_VFP_V1xD},
+  {"vfpv2",		FPU_ARCH_VFP_V2},
+  {"vfpv3",		FPU_ARCH_VFP_V3},
+  {"vfpv3-fp16",	FPU_ARCH_VFP_V3_FP16},
+  {"vfpv3-d16",		FPU_ARCH_VFP_V3D16},
+  {"vfpv3-d16-fp16",	FPU_ARCH_VFP_V3D16_FP16},
+  {"vfpv3xd",		FPU_ARCH_VFP_V3xD},
+  {"vfpv3xd-fp16",	FPU_ARCH_VFP_V3xD_FP16},
+  {"arm1020t",		FPU_ARCH_VFP_V1},
+  {"arm1020e",		FPU_ARCH_VFP_V2},
+  {"arm1136jfs",	FPU_ARCH_VFP_V2},
+  {"arm1136jf-s",	FPU_ARCH_VFP_V2},
+  {"maverick",		FPU_ARCH_MAVERICK},
+  {"neon",              FPU_ARCH_VFP_V3_PLUS_NEON_V1},
+  {"neon-fp16",		FPU_ARCH_NEON_FP16},
+  {"vfpv4",		FPU_ARCH_VFP_V4},
+  {"vfpv4-d16",		FPU_ARCH_VFP_V4D16},
+  {"fpv4-sp-d16",	FPU_ARCH_VFP_V4_SP_D16},
+  {"fpv5-d16",		FPU_ARCH_VFP_V5D16},
+  {"fpv5-sp-d16",	FPU_ARCH_VFP_V5_SP_D16},
+  {"neon-vfpv4",	FPU_ARCH_NEON_VFP_V4},
+  {"fp-armv8",		FPU_ARCH_VFP_ARMV8},
+  {"neon-fp-armv8",	FPU_ARCH_NEON_VFP_ARMV8},
+  {"crypto-neon-fp-armv8",
+			FPU_ARCH_CRYPTO_NEON_VFP_ARMV8},
+  {"neon-fp-armv8.1",	FPU_ARCH_NEON_VFP_ARMV8_1},
+  {"crypto-neon-fp-armv8.1",
+			FPU_ARCH_CRYPTO_NEON_VFP_ARMV8_1},
+  {NULL,		ARM_ARCH_NONE}
+};
+
+struct arm_option_value_table
+{
+  char *name;
+  long value;
+};
+
+static const struct arm_option_value_table arm_float_abis[] =
+{
+  {"hard",	ARM_FLOAT_ABI_HARD},
+  {"softfp",	ARM_FLOAT_ABI_SOFTFP},
+  {"soft",	ARM_FLOAT_ABI_SOFT},
+  {NULL,	0}
+};
+
+#ifdef OBJ_ELF
+/* We only know how to output GNU and ver 4/5 (AAELF) formats.  */
+static const struct arm_option_value_table arm_eabis[] =
+{
+  {"gnu",	EF_ARM_EABI_UNKNOWN},
+  {"4",		EF_ARM_EABI_VER4},
+  {"5",		EF_ARM_EABI_VER5},
+  {NULL,	0}
+};
+#endif
+
+struct arm_long_option_table
+{
+  char * option;		/* Substring to match.	*/
+  char * help;			/* Help information.  */
+  int (* func) (char * subopt);	/* Function to decode sub-option.  */
+  char * deprecated;		/* If non-null, print this message.  */
+};
+
+static bfd_boolean
+arm_parse_extension (char *str, const arm_feature_set **opt_p)
+{
+  arm_feature_set *ext_set = (arm_feature_set *)
+      xmalloc (sizeof (arm_feature_set));
+
+  /* We insist on extensions being specified in alphabetical order, and with
+     extensions being added before being removed.  We achieve this by having
+     the global ARM_EXTENSIONS table in alphabetical order, and using the
+     ADDING_VALUE variable to indicate whether we are adding an extension (1)
+     or removing it (0) and only allowing it to change in the order
+     -1 -> 1 -> 0.  */
+  const struct arm_option_extension_value_table * opt = NULL;
+  int adding_value = -1;
+
+  /* Copy the feature set, so that we can modify it.  */
+  *ext_set = **opt_p;
+  *opt_p = ext_set;
+
+  while (str != NULL && *str != 0)
+    {
+      char *ext;
+      size_t len;
+
+      if (*str != '+')
+	{
+	  as_bad (_("invalid architectural extension"));
+	  return FALSE;
+	}
+
+      str++;
+      ext = strchr (str, '+');
+
+      if (ext != NULL)
+	len = ext - str;
+      else
+	len = strlen (str);
+
+      if (len >= 2 && strncmp (str, "no", 2) == 0)
+	{
+	  if (adding_value != 0)
+	    {
+	      adding_value = 0;
+	      opt = arm_extensions;
+	    }
+
+	  len -= 2;
+	  str += 2;
+	}
+      else if (len > 0)
+	{
+	  if (adding_value == -1)
+	    {
+	      adding_value = 1;
+	      opt = arm_extensions;
+	    }
+	  else if (adding_value != 1)
+	    {
+	      as_bad (_("must specify extensions to add before specifying "
+			"those to remove"));
+	      return FALSE;
+	    }
+	}
+
+      if (len == 0)
+	{
+	  as_bad (_("missing architectural extension"));
+	  return FALSE;
+	}
+
+      gas_assert (adding_value != -1);
+      gas_assert (opt != NULL);
+
+      /* Scan over the options table trying to find an exact match. */
+      for (; opt->name != NULL; opt++)
+	if (opt->name_len == len && strncmp (opt->name, str, len) == 0)
+	  {
+	    /* Check we can apply the extension to this architecture.  */
+	    if (!ARM_CPU_HAS_FEATURE (*ext_set, opt->allowed_archs))
+	      {
+		as_bad (_("extension does not apply to the base architecture"));
+		return FALSE;
+	      }
+
+	    /* Add or remove the extension.  */
+	    if (adding_value)
+	      ARM_MERGE_FEATURE_SETS (*ext_set, *ext_set, opt->merge_value);
+	    else
+	      ARM_CLEAR_FEATURE (*ext_set, *ext_set, opt->clear_value);
+
+	    break;
+	  }
+
+      if (opt->name == NULL)
+	{
+	  /* Did we fail to find an extension because it wasn't specified in
+	     alphabetical order, or because it does not exist?  */
+
+	  for (opt = arm_extensions; opt->name != NULL; opt++)
+	    if (opt->name_len == len && strncmp (opt->name, str, len) == 0)
+	      break;
+
+	  if (opt->name == NULL)
+	    as_bad (_("unknown architectural extension `%s'"), str);
+	  else
+	    as_bad (_("architectural extensions must be specified in "
+		      "alphabetical order"));
+
+	  return FALSE;
+	}
+      else
+	{
+	  /* We should skip the extension we've just matched the next time
+	     round.  */
+	  opt++;
+	}
+
+      str = ext;
+    };
+
+  return TRUE;
+}
+
+static bfd_boolean
+arm_parse_cpu (char *str)
+{
+  const struct arm_cpu_option_table *opt;
+  char *ext = strchr (str, '+');
+  size_t len;
+
+  if (ext != NULL)
+    len = ext - str;
+  else
+    len = strlen (str);
+
+  if (len == 0)
+    {
+      as_bad (_("missing cpu name `%s'"), str);
+      return FALSE;
+    }
+
+  for (opt = arm_cpus; opt->name != NULL; opt++)
+    if (opt->name_len == len && strncmp (opt->name, str, len) == 0)
+      {
+	mcpu_cpu_opt = &opt->value;
+	mcpu_fpu_opt = &opt->default_fpu;
+	if (opt->canonical_name)
+	  {
+	    gas_assert (sizeof selected_cpu_name > strlen (opt->canonical_name));
+	    strcpy (selected_cpu_name, opt->canonical_name);
+	  }
+	else
+	  {
+	    size_t i;
+
+	    if (len >= sizeof selected_cpu_name)
+	      len = (sizeof selected_cpu_name) - 1;
+
+	    for (i = 0; i < len; i++)
+	      selected_cpu_name[i] = TOUPPER (opt->name[i]);
+	    selected_cpu_name[i] = 0;
+	  }
+
+	if (ext != NULL)
+	  return arm_parse_extension (ext, &mcpu_cpu_opt);
+
+	return TRUE;
+      }
+
+  as_bad (_("unknown cpu `%s'"), str);
+  return FALSE;
+}
+
+static bfd_boolean
+arm_parse_arch (char *str)
+{
+  const struct arm_arch_option_table *opt;
+  char *ext = strchr (str, '+');
+  size_t len;
+
+  if (ext != NULL)
+    len = ext - str;
+  else
+    len = strlen (str);
+
+  if (len == 0)
+    {
+      as_bad (_("missing architecture name `%s'"), str);
+      return FALSE;
+    }
+
+  for (opt = arm_archs; opt->name != NULL; opt++)
+    if (opt->name_len == len && strncmp (opt->name, str, len) == 0)
+      {
+	march_cpu_opt = &opt->value;
+	march_fpu_opt = &opt->default_fpu;
+	strcpy (selected_cpu_name, opt->name);
+
+	if (ext != NULL)
+	  return arm_parse_extension (ext, &march_cpu_opt);
+
+	return TRUE;
+      }
+
+  as_bad (_("unknown architecture `%s'\n"), str);
+  return FALSE;
+}
+
+static bfd_boolean
+arm_parse_fpu (char * str)
+{
+  const struct arm_option_fpu_value_table * opt;
+
+  for (opt = arm_fpus; opt->name != NULL; opt++)
+    if (streq (opt->name, str))
+      {
+	mfpu_opt = &opt->value;
+	return TRUE;
+      }
+
+  as_bad (_("unknown floating point format `%s'\n"), str);
+  return FALSE;
+}
+
+static bfd_boolean
+arm_parse_float_abi (char * str)
+{
+  const struct arm_option_value_table * opt;
+
+  for (opt = arm_float_abis; opt->name != NULL; opt++)
+    if (streq (opt->name, str))
+      {
+	mfloat_abi_opt = opt->value;
+	return TRUE;
+      }
+
+  as_bad (_("unknown floating point abi `%s'\n"), str);
+  return FALSE;
+}
+
+#ifdef OBJ_ELF
+static bfd_boolean
+arm_parse_eabi (char * str)
+{
+  const struct arm_option_value_table *opt;
+
+  for (opt = arm_eabis; opt->name != NULL; opt++)
+    if (streq (opt->name, str))
+      {
+	meabi_flags = opt->value;
+	return TRUE;
+      }
+  as_bad (_("unknown EABI `%s'\n"), str);
+  return FALSE;
+}
+#endif
+
+static bfd_boolean
+arm_parse_it_mode (char * str)
+{
+  bfd_boolean ret = TRUE;
+
+  if (streq ("arm", str))
+    implicit_it_mode = IMPLICIT_IT_MODE_ARM;
+  else if (streq ("thumb", str))
+    implicit_it_mode = IMPLICIT_IT_MODE_THUMB;
+  else if (streq ("always", str))
+    implicit_it_mode = IMPLICIT_IT_MODE_ALWAYS;
+  else if (streq ("never", str))
+    implicit_it_mode = IMPLICIT_IT_MODE_NEVER;
+  else
+    {
+      as_bad (_("unknown implicit IT mode `%s', should be "\
+		"arm, thumb, always, or never."), str);
+      ret = FALSE;
+    }
+
+  return ret;
+}
+
+static bfd_boolean
+arm_ccs_mode (char * unused ATTRIBUTE_UNUSED)
+{
+  codecomposer_syntax = TRUE;
+  arm_comment_chars[0] = ';';
+  arm_line_separator_chars[0] = 0;
+  return TRUE;
+}
+
+struct arm_long_option_table arm_long_opts[] =
+{
+  {"mcpu=", N_("<cpu name>\t  assemble for CPU <cpu name>"),
+   arm_parse_cpu, NULL},
+  {"march=", N_("<arch name>\t  assemble for architecture <arch name>"),
+   arm_parse_arch, NULL},
+  {"mfpu=", N_("<fpu name>\t  assemble for FPU architecture <fpu name>"),
+   arm_parse_fpu, NULL},
+  {"mfloat-abi=", N_("<abi>\t  assemble for floating point ABI <abi>"),
+   arm_parse_float_abi, NULL},
+#ifdef OBJ_ELF
+  {"meabi=", N_("<ver>\t\t  assemble for eabi version <ver>"),
+   arm_parse_eabi, NULL},
+#endif
+  {"mimplicit-it=", N_("<mode>\t  controls implicit insertion of IT instructions"),
+   arm_parse_it_mode, NULL},
+  {"mccs", N_("\t\t\t  TI CodeComposer Studio syntax compatibility mode"),
+   arm_ccs_mode, NULL},
+  {NULL, NULL, 0, NULL}
+};
+
+int
+md_parse_option (int c, char * arg)
+{
+  struct arm_option_table *opt;
+  const struct arm_legacy_option_table *fopt;
+  struct arm_long_option_table *lopt;
+
+  switch (c)
+    {
+#ifdef OPTION_EB
+    case OPTION_EB:
+      target_big_endian = 1;
+      break;
+#endif
+
+#ifdef OPTION_EL
+    case OPTION_EL:
+      target_big_endian = 0;
+      break;
+#endif
+
+    case OPTION_FIX_V4BX:
+      fix_v4bx = TRUE;
+      break;
+
+    case 'a':
+      /* Listing option.  Just ignore these, we don't support additional
+	 ones.	*/
+      return 0;
+
+    default:
+      for (opt = arm_opts; opt->option != NULL; opt++)
+	{
+	  if (c == opt->option[0]
+	      && ((arg == NULL && opt->option[1] == 0)
+		  || streq (arg, opt->option + 1)))
+	    {
+	      /* If the option is deprecated, tell the user.  */
+	      if (warn_on_deprecated && opt->deprecated != NULL)
+		as_tsktsk (_("option `-%c%s' is deprecated: %s"), c,
+			   arg ? arg : "", _(opt->deprecated));
+
+	      if (opt->var != NULL)
+		*opt->var = opt->value;
+
+	      return 1;
+	    }
+	}
+
+      for (fopt = arm_legacy_opts; fopt->option != NULL; fopt++)
+	{
+	  if (c == fopt->option[0]
+	      && ((arg == NULL && fopt->option[1] == 0)
+		  || streq (arg, fopt->option + 1)))
+	    {
+	      /* If the option is deprecated, tell the user.  */
+	      if (warn_on_deprecated && fopt->deprecated != NULL)
+		as_tsktsk (_("option `-%c%s' is deprecated: %s"), c,
+			   arg ? arg : "", _(fopt->deprecated));
+
+	      if (fopt->var != NULL)
+		*fopt->var = &fopt->value;
+
+	      return 1;
+	    }
+	}
+
+      for (lopt = arm_long_opts; lopt->option != NULL; lopt++)
+	{
+	  /* These options are expected to have an argument.  */
+	  if (c == lopt->option[0]
+	      && arg != NULL
+	      && strncmp (arg, lopt->option + 1,
+			  strlen (lopt->option + 1)) == 0)
+	    {
+	      /* If the option is deprecated, tell the user.  */
+	      if (warn_on_deprecated && lopt->deprecated != NULL)
+		as_tsktsk (_("option `-%c%s' is deprecated: %s"), c, arg,
+			   _(lopt->deprecated));
+
+	      /* Call the sup-option parser.  */
+	      return lopt->func (arg + strlen (lopt->option) - 1);
+	    }
+	}
+
+      return 0;
+    }
+
+  return 1;
+}
+
+void
+md_show_usage (FILE * fp)
+{
+  struct arm_option_table *opt;
+  struct arm_long_option_table *lopt;
+
+  fprintf (fp, _(" ARM-specific assembler options:\n"));
+
+  for (opt = arm_opts; opt->option != NULL; opt++)
+    if (opt->help != NULL)
+      fprintf (fp, "  -%-23s%s\n", opt->option, _(opt->help));
+
+  for (lopt = arm_long_opts; lopt->option != NULL; lopt++)
+    if (lopt->help != NULL)
+      fprintf (fp, "  -%s%s\n", lopt->option, _(lopt->help));
+
+#ifdef OPTION_EB
+  fprintf (fp, _("\
+  -EB                     assemble code for a big-endian cpu\n"));
+#endif
+
+#ifdef OPTION_EL
+  fprintf (fp, _("\
+  -EL                     assemble code for a little-endian cpu\n"));
+#endif
+
+  fprintf (fp, _("\
+  --fix-v4bx              Allow BX in ARMv4 code\n"));
+}
+
+
+#ifdef OBJ_ELF
+typedef struct
+{
+  int val;
+  arm_feature_set flags;
+} cpu_arch_ver_table;
+
+/* Mapping from CPU features to EABI CPU arch values.  Table must be sorted
+   least features first.  */
+static const cpu_arch_ver_table cpu_arch_ver[] =
+{
+    {1, ARM_ARCH_V4},
+    {2, ARM_ARCH_V4T},
+    {3, ARM_ARCH_V5},
+    {3, ARM_ARCH_V5T},
+    {4, ARM_ARCH_V5TE},
+    {5, ARM_ARCH_V5TEJ},
+    {6, ARM_ARCH_V6},
+    {9, ARM_ARCH_V6K},
+    {7, ARM_ARCH_V6Z},
+    {11, ARM_ARCH_V6M},
+    {12, ARM_ARCH_V6SM},
+    {8, ARM_ARCH_V6T2},
+    {10, ARM_ARCH_V7VE},
+    {10, ARM_ARCH_V7R},
+    {10, ARM_ARCH_V7M},
+    {14, ARM_ARCH_V8A},
+    {0, ARM_ARCH_NONE}
+};
+
+/* Set an attribute if it has not already been set by the user.  */
+static void
+aeabi_set_attribute_int (int tag, int value)
+{
+  if (tag < 1
+      || tag >= NUM_KNOWN_OBJ_ATTRIBUTES
+      || !attributes_set_explicitly[tag])
+    bfd_elf_add_proc_attr_int (stdoutput, tag, value);
+}
+
+static void
+aeabi_set_attribute_string (int tag, const char *value)
+{
+  if (tag < 1
+      || tag >= NUM_KNOWN_OBJ_ATTRIBUTES
+      || !attributes_set_explicitly[tag])
+    bfd_elf_add_proc_attr_string (stdoutput, tag, value);
+}
+
+/* Set the public EABI object attributes.  */
+void
+aeabi_set_public_attributes (void)
+{
+  int arch;
+  char profile;
+  int virt_sec = 0;
+  int fp16_optional = 0;
+  arm_feature_set flags;
+  arm_feature_set tmp;
+  const cpu_arch_ver_table *p;
+
+  /* Choose the architecture based on the capabilities of the requested cpu
+     (if any) and/or the instructions actually used.  */
+  ARM_MERGE_FEATURE_SETS (flags, arm_arch_used, thumb_arch_used);
+  ARM_MERGE_FEATURE_SETS (flags, flags, *mfpu_opt);
+  ARM_MERGE_FEATURE_SETS (flags, flags, selected_cpu);
+
+  if (ARM_CPU_HAS_FEATURE (arm_arch_used, arm_arch_any))
+    ARM_MERGE_FEATURE_SETS (flags, flags, arm_ext_v1);
+
+  if (ARM_CPU_HAS_FEATURE (thumb_arch_used, arm_arch_any))
+    ARM_MERGE_FEATURE_SETS (flags, flags, arm_ext_v4t);
+
+  selected_cpu = flags;
+
+  /* Allow the user to override the reported architecture.  */
+  if (object_arch)
+    {
+      ARM_CLEAR_FEATURE (flags, flags, arm_arch_any);
+      ARM_MERGE_FEATURE_SETS (flags, flags, *object_arch);
+    }
+
+  /* We need to make sure that the attributes do not identify us as v6S-M
+     when the only v6S-M feature in use is the Operating System Extensions.  */
+  if (ARM_CPU_HAS_FEATURE (flags, arm_ext_os))
+      if (!ARM_CPU_HAS_FEATURE (flags, arm_arch_v6m_only))
+	ARM_CLEAR_FEATURE (flags, flags, arm_ext_os);
+
+  tmp = flags;
+  arch = 0;
+  for (p = cpu_arch_ver; p->val; p++)
+    {
+      if (ARM_CPU_HAS_FEATURE (tmp, p->flags))
+	{
+	  arch = p->val;
+	  ARM_CLEAR_FEATURE (tmp, tmp, p->flags);
+	}
+    }
+
+  /* The table lookup above finds the last architecture to contribute
+     a new feature.  Unfortunately, Tag13 is a subset of the union of
+     v6T2 and v7-M, so it is never seen as contributing a new feature.
+     We can not search for the last entry which is entirely used,
+     because if no CPU is specified we build up only those flags
+     actually used.  Perhaps we should separate out the specified
+     and implicit cases.  Avoid taking this path for -march=all by
+     checking for contradictory v7-A / v7-M features.  */
+  if (arch == 10
+      && !ARM_CPU_HAS_FEATURE (flags, arm_ext_v7a)
+      && ARM_CPU_HAS_FEATURE (flags, arm_ext_v7m)
+      && ARM_CPU_HAS_FEATURE (flags, arm_ext_v6_dsp))
+    arch = 13;
+
+  /* Tag_CPU_name.  */
+  if (selected_cpu_name[0])
+    {
+      char *q;
+
+      q = selected_cpu_name;
+      if (strncmp (q, "armv", 4) == 0)
+	{
+	  int i;
+
+	  q += 4;
+	  for (i = 0; q[i]; i++)
+	    q[i] = TOUPPER (q[i]);
+	}
+      aeabi_set_attribute_string (Tag_CPU_name, q);
+    }
+
+  /* Tag_CPU_arch.  */
+  aeabi_set_attribute_int (Tag_CPU_arch, arch);
+
+  /* Tag_CPU_arch_profile.  */
+  if (ARM_CPU_HAS_FEATURE (flags, arm_ext_v7a)
+      || ARM_CPU_HAS_FEATURE (flags, arm_ext_v8))
+    profile = 'A';
+  else if (ARM_CPU_HAS_FEATURE (flags, arm_ext_v7r))
+    profile = 'R';
+  else if (ARM_CPU_HAS_FEATURE (flags, arm_ext_m))
+    profile = 'M';
+  else
+    profile = '\0';
+
+  if (profile != '\0')
+    aeabi_set_attribute_int (Tag_CPU_arch_profile, profile);
+
+  /* Tag_ARM_ISA_use.  */
+  if (ARM_CPU_HAS_FEATURE (flags, arm_ext_v1)
+      || arch == 0)
+    aeabi_set_attribute_int (Tag_ARM_ISA_use, 1);
+
+  /* Tag_THUMB_ISA_use.  */
+  if (ARM_CPU_HAS_FEATURE (flags, arm_ext_v4t)
+      || arch == 0)
+    aeabi_set_attribute_int (Tag_THUMB_ISA_use,
+	ARM_CPU_HAS_FEATURE (flags, arm_arch_t2) ? 2 : 1);
+
+  /* Tag_VFP_arch.  */
+  if (ARM_CPU_HAS_FEATURE (flags, fpu_vfp_ext_armv8xd))
+    aeabi_set_attribute_int (Tag_VFP_arch,
+			     ARM_CPU_HAS_FEATURE (flags, fpu_vfp_ext_d32)
+			     ? 7 : 8);
+  else if (ARM_CPU_HAS_FEATURE (flags, fpu_vfp_ext_fma))
+    aeabi_set_attribute_int (Tag_VFP_arch,
+			     ARM_CPU_HAS_FEATURE (flags, fpu_vfp_ext_d32)
+			     ? 5 : 6);
+  else if (ARM_CPU_HAS_FEATURE (flags, fpu_vfp_ext_d32))
+    {
+      fp16_optional = 1;
+      aeabi_set_attribute_int (Tag_VFP_arch, 3);
+    }
+  else if (ARM_CPU_HAS_FEATURE (flags, fpu_vfp_ext_v3xd))
+    {
+      aeabi_set_attribute_int (Tag_VFP_arch, 4);
+      fp16_optional = 1;
+    }
+  else if (ARM_CPU_HAS_FEATURE (flags, fpu_vfp_ext_v2))
+    aeabi_set_attribute_int (Tag_VFP_arch, 2);
+  else if (ARM_CPU_HAS_FEATURE (flags, fpu_vfp_ext_v1)
+	   || ARM_CPU_HAS_FEATURE (flags, fpu_vfp_ext_v1xd))
+    aeabi_set_attribute_int (Tag_VFP_arch, 1);
+
+  /* Tag_ABI_HardFP_use.  */
+  if (ARM_CPU_HAS_FEATURE (flags, fpu_vfp_ext_v1xd)
+      && !ARM_CPU_HAS_FEATURE (flags, fpu_vfp_ext_v1))
+    aeabi_set_attribute_int (Tag_ABI_HardFP_use, 1);
+
+  /* Tag_WMMX_arch.  */
+  if (ARM_CPU_HAS_FEATURE (flags, arm_cext_iwmmxt2))
+    aeabi_set_attribute_int (Tag_WMMX_arch, 2);
+  else if (ARM_CPU_HAS_FEATURE (flags, arm_cext_iwmmxt))
+    aeabi_set_attribute_int (Tag_WMMX_arch, 1);
+
+  /* Tag_Advanced_SIMD_arch (formerly Tag_NEON_arch).  */
+  if (ARM_CPU_HAS_FEATURE (flags, fpu_neon_ext_armv8))
+    aeabi_set_attribute_int (Tag_Advanced_SIMD_arch, 3);
+  else if (ARM_CPU_HAS_FEATURE (flags, fpu_neon_ext_v1))
+    {
+      if (ARM_CPU_HAS_FEATURE (flags, fpu_neon_ext_fma))
+	{
+	  aeabi_set_attribute_int (Tag_Advanced_SIMD_arch, 2);
+	}
+      else
+	{
+	  aeabi_set_attribute_int (Tag_Advanced_SIMD_arch, 1);
+	  fp16_optional = 1;
+	}
+    }
+
+  /* Tag_VFP_HP_extension (formerly Tag_NEON_FP16_arch).  */
+  if (ARM_CPU_HAS_FEATURE (flags, fpu_vfp_fp16) && fp16_optional)
+    aeabi_set_attribute_int (Tag_VFP_HP_extension, 1);
+
+  /* Tag_DIV_use.
+
+     We set Tag_DIV_use to two when integer divide instructions have been used
+     in ARM state, or when Thumb integer divide instructions have been used,
+     but we have no architecture profile set, nor have we any ARM instructions.
+
+     For ARMv8 we set the tag to 0 as integer divide is implied by the base
+     architecture.
+
+     For new architectures we will have to check these tests.  */
+  gas_assert (arch <= TAG_CPU_ARCH_V8);
+  if (ARM_CPU_HAS_FEATURE (flags, arm_ext_v8))
+    aeabi_set_attribute_int (Tag_DIV_use, 0);
+  else if (ARM_CPU_HAS_FEATURE (flags, arm_ext_adiv)
+	   || (profile == '\0'
+	       && ARM_CPU_HAS_FEATURE (flags, arm_ext_div)
+	       && !ARM_CPU_HAS_FEATURE (arm_arch_used, arm_arch_any)))
+    aeabi_set_attribute_int (Tag_DIV_use, 2);
+
+  /* Tag_MP_extension_use.  */
+  if (ARM_CPU_HAS_FEATURE (flags, arm_ext_mp))
+    aeabi_set_attribute_int (Tag_MPextension_use, 1);
+
+  /* Tag Virtualization_use.  */
+  if (ARM_CPU_HAS_FEATURE (flags, arm_ext_sec))
+    virt_sec |= 1;
+  if (ARM_CPU_HAS_FEATURE (flags, arm_ext_virt))
+    virt_sec |= 2;
+  if (virt_sec != 0)
+    aeabi_set_attribute_int (Tag_Virtualization_use, virt_sec);
+}
+
+/* Add the default contents for the .ARM.attributes section.  */
+void
+arm_md_end (void)
+{
+  if (EF_ARM_EABI_VERSION (meabi_flags) < EF_ARM_EABI_VER4)
+    return;
+
+  aeabi_set_public_attributes ();
+}
+#endif /* OBJ_ELF */
+
+
+/* Parse a .cpu directive.  */
+
+static void
+s_arm_cpu (int ignored ATTRIBUTE_UNUSED)
+{
+  const struct arm_cpu_option_table *opt;
+  char *name;
+  char saved_char;
+
+  name = input_line_pointer;
+  while (*input_line_pointer && !ISSPACE (*input_line_pointer))
+    input_line_pointer++;
+  saved_char = *input_line_pointer;
+  *input_line_pointer = 0;
+
+  /* Skip the first "all" entry.  */
+  for (opt = arm_cpus + 1; opt->name != NULL; opt++)
+    if (streq (opt->name, name))
+      {
+	mcpu_cpu_opt = &opt->value;
+	selected_cpu = opt->value;
+	if (opt->canonical_name)
+	  strcpy (selected_cpu_name, opt->canonical_name);
+	else
+	  {
+	    int i;
+	    for (i = 0; opt->name[i]; i++)
+	      selected_cpu_name[i] = TOUPPER (opt->name[i]);
+
+	    selected_cpu_name[i] = 0;
+	  }
+	ARM_MERGE_FEATURE_SETS (cpu_variant, *mcpu_cpu_opt, *mfpu_opt);
+	*input_line_pointer = saved_char;
+	demand_empty_rest_of_line ();
+	return;
+      }
+  as_bad (_("unknown cpu `%s'"), name);
+  *input_line_pointer = saved_char;
+  ignore_rest_of_line ();
+}
+
+
+/* Parse a .arch directive.  */
+
+static void
+s_arm_arch (int ignored ATTRIBUTE_UNUSED)
+{
+  const struct arm_arch_option_table *opt;
+  char saved_char;
+  char *name;
+
+  name = input_line_pointer;
+  while (*input_line_pointer && !ISSPACE (*input_line_pointer))
+    input_line_pointer++;
+  saved_char = *input_line_pointer;
+  *input_line_pointer = 0;
+
+  /* Skip the first "all" entry.  */
+  for (opt = arm_archs + 1; opt->name != NULL; opt++)
+    if (streq (opt->name, name))
+      {
+	mcpu_cpu_opt = &opt->value;
+	selected_cpu = opt->value;
+	strcpy (selected_cpu_name, opt->name);
+	ARM_MERGE_FEATURE_SETS (cpu_variant, *mcpu_cpu_opt, *mfpu_opt);
+	*input_line_pointer = saved_char;
+	demand_empty_rest_of_line ();
+	return;
+      }
+
+  as_bad (_("unknown architecture `%s'\n"), name);
+  *input_line_pointer = saved_char;
+  ignore_rest_of_line ();
+}
+
+
+/* Parse a .object_arch directive.  */
+
+static void
+s_arm_object_arch (int ignored ATTRIBUTE_UNUSED)
+{
+  const struct arm_arch_option_table *opt;
+  char saved_char;
+  char *name;
+
+  name = input_line_pointer;
+  while (*input_line_pointer && !ISSPACE (*input_line_pointer))
+    input_line_pointer++;
+  saved_char = *input_line_pointer;
+  *input_line_pointer = 0;
+
+  /* Skip the first "all" entry.  */
+  for (opt = arm_archs + 1; opt->name != NULL; opt++)
+    if (streq (opt->name, name))
+      {
+	object_arch = &opt->value;
+	*input_line_pointer = saved_char;
+	demand_empty_rest_of_line ();
+	return;
+      }
+
+  as_bad (_("unknown architecture `%s'\n"), name);
+  *input_line_pointer = saved_char;
+  ignore_rest_of_line ();
+}
+
+/* Parse a .arch_extension directive.  */
+
+static void
+s_arm_arch_extension (int ignored ATTRIBUTE_UNUSED)
+{
+  const struct arm_option_extension_value_table *opt;
+  char saved_char;
+  char *name;
+  int adding_value = 1;
+
+  name = input_line_pointer;
+  while (*input_line_pointer && !ISSPACE (*input_line_pointer))
+    input_line_pointer++;
+  saved_char = *input_line_pointer;
+  *input_line_pointer = 0;
+
+  if (strlen (name) >= 2
+      && strncmp (name, "no", 2) == 0)
+    {
+      adding_value = 0;
+      name += 2;
+    }
+
+  for (opt = arm_extensions; opt->name != NULL; opt++)
+    if (streq (opt->name, name))
+      {
+	if (!ARM_CPU_HAS_FEATURE (*mcpu_cpu_opt, opt->allowed_archs))
+	  {
+	    as_bad (_("architectural extension `%s' is not allowed for the "
+		      "current base architecture"), name);
+	    break;
+	  }
+
+	if (adding_value)
+	  ARM_MERGE_FEATURE_SETS (selected_cpu, selected_cpu,
+				  opt->merge_value);
+	else
+	  ARM_CLEAR_FEATURE (selected_cpu, selected_cpu, opt->clear_value);
+
+	mcpu_cpu_opt = &selected_cpu;
+	ARM_MERGE_FEATURE_SETS (cpu_variant, *mcpu_cpu_opt, *mfpu_opt);
+	*input_line_pointer = saved_char;
+	demand_empty_rest_of_line ();
+	return;
+      }
+
+  if (opt->name == NULL)
+    as_bad (_("unknown architecture extension `%s'\n"), name);
+
+  *input_line_pointer = saved_char;
+  ignore_rest_of_line ();
+}
+
+/* Parse a .fpu directive.  */
+
+static void
+s_arm_fpu (int ignored ATTRIBUTE_UNUSED)
+{
+  const struct arm_option_fpu_value_table *opt;
+  char saved_char;
+  char *name;
+
+  name = input_line_pointer;
+  while (*input_line_pointer && !ISSPACE (*input_line_pointer))
+    input_line_pointer++;
+  saved_char = *input_line_pointer;
+  *input_line_pointer = 0;
+
+  for (opt = arm_fpus; opt->name != NULL; opt++)
+    if (streq (opt->name, name))
+      {
+	mfpu_opt = &opt->value;
+	ARM_MERGE_FEATURE_SETS (cpu_variant, *mcpu_cpu_opt, *mfpu_opt);
+	*input_line_pointer = saved_char;
+	demand_empty_rest_of_line ();
+	return;
+      }
+
+  as_bad (_("unknown floating point format `%s'\n"), name);
+  *input_line_pointer = saved_char;
+  ignore_rest_of_line ();
+}
+
+/* Copy symbol information.  */
+
+void
+arm_copy_symbol_attributes (symbolS *dest, symbolS *src)
+{
+  ARM_GET_FLAG (dest) = ARM_GET_FLAG (src);
+}
+
+#ifdef OBJ_ELF
+/* Given a symbolic attribute NAME, return the proper integer value.
+   Returns -1 if the attribute is not known.  */
+
+int
+arm_convert_symbolic_attribute (const char *name)
+{
+  static const struct
+  {
+    const char * name;
+    const int    tag;
+  }
+  attribute_table[] =
+    {
+      /* When you modify this table you should
+	 also modify the list in doc/c-arm.texi.  */
+#define T(tag) {#tag, tag}
+      T (Tag_CPU_raw_name),
+      T (Tag_CPU_name),
+      T (Tag_CPU_arch),
+      T (Tag_CPU_arch_profile),
+      T (Tag_ARM_ISA_use),
+      T (Tag_THUMB_ISA_use),
+      T (Tag_FP_arch),
+      T (Tag_VFP_arch),
+      T (Tag_WMMX_arch),
+      T (Tag_Advanced_SIMD_arch),
+      T (Tag_PCS_config),
+      T (Tag_ABI_PCS_R9_use),
+      T (Tag_ABI_PCS_RW_data),
+      T (Tag_ABI_PCS_RO_data),
+      T (Tag_ABI_PCS_GOT_use),
+      T (Tag_ABI_PCS_wchar_t),
+      T (Tag_ABI_FP_rounding),
+      T (Tag_ABI_FP_denormal),
+      T (Tag_ABI_FP_exceptions),
+      T (Tag_ABI_FP_user_exceptions),
+      T (Tag_ABI_FP_number_model),
+      T (Tag_ABI_align_needed),
+      T (Tag_ABI_align8_needed),
+      T (Tag_ABI_align_preserved),
+      T (Tag_ABI_align8_preserved),
+      T (Tag_ABI_enum_size),
+      T (Tag_ABI_HardFP_use),
+      T (Tag_ABI_VFP_args),
+      T (Tag_ABI_WMMX_args),
+      T (Tag_ABI_optimization_goals),
+      T (Tag_ABI_FP_optimization_goals),
+      T (Tag_compatibility),
+      T (Tag_CPU_unaligned_access),
+      T (Tag_FP_HP_extension),
+      T (Tag_VFP_HP_extension),
+      T (Tag_ABI_FP_16bit_format),
+      T (Tag_MPextension_use),
+      T (Tag_DIV_use),
+      T (Tag_nodefaults),
+      T (Tag_also_compatible_with),
+      T (Tag_conformance),
+      T (Tag_T2EE_use),
+      T (Tag_Virtualization_use),
+      /* We deliberately do not include Tag_MPextension_use_legacy.  */
+#undef T
+    };
+  unsigned int i;
+
+  if (name == NULL)
+    return -1;
+
+  for (i = 0; i < ARRAY_SIZE (attribute_table); i++)
+    if (streq (name, attribute_table[i].name))
+      return attribute_table[i].tag;
+
+  return -1;
+}
+
+
+/* Apply sym value for relocations only in the case that they are for
+   local symbols in the same segment as the fixup and you have the
+   respective architectural feature for blx and simple switches.  */
+int
+arm_apply_sym_value (struct fix * fixP, segT this_seg)
+{
+  if (fixP->fx_addsy
+      && ARM_CPU_HAS_FEATURE (selected_cpu, arm_ext_v5t)
+      /* PR 17444: If the local symbol is in a different section then a reloc
+	 will always be generated for it, so applying the symbol value now
+	 will result in a double offset being stored in the relocation.  */
+      && (S_GET_SEGMENT (fixP->fx_addsy) == this_seg)
+      && !S_FORCE_RELOC (fixP->fx_addsy, TRUE))
+    {
+      switch (fixP->fx_r_type)
+	{
+	case BFD_RELOC_ARM_PCREL_BLX:
+	case BFD_RELOC_THUMB_PCREL_BRANCH23:
+	  if (ARM_IS_FUNC (fixP->fx_addsy))
+	    return 1;
+	  break;
+
+	case BFD_RELOC_ARM_PCREL_CALL:
+	case BFD_RELOC_THUMB_PCREL_BLX:
+	  if (THUMB_IS_FUNC (fixP->fx_addsy))
+	    return 1;
+	  break;
+
+	default:
+	  break;
+	}
+
+    }
+  return 0;
+}
+#endif /* OBJ_ELF */
diff -Naur binutils-2.26/gas/config/tc-arm.h binutils-2.26.0007/gas/config/tc-arm.h
--- binutils-2.26/gas/config/tc-arm.h	2015-11-13 09:27:41.000000000 +0100
+++ binutils-2.26.0007/gas/config/tc-arm.h	2016-03-10 17:02:24.300717372 +0100
@@ -65,6 +65,8 @@
 # if defined TE_PE
 #  if defined TE_EPOC
 #   define TARGET_FORMAT (target_big_endian ? "epoc-pe-arm-big" : "epoc-pe-arm-little")
+#  elif defined TE_WINNT
+#   define TARGET_FORMAT (target_big_endian ? "pe-arm-winnt-big" : "pe-arm-winnt-little")
 #  elif defined TE_WINCE
 #   define TARGET_FORMAT (target_big_endian ? "pe-arm-wince-big" : "pe-arm-wince-little")
 #  else
diff -Naur binutils-2.26/gas/config/te-winnt-pe.h binutils-2.26.0007/gas/config/te-winnt-pe.h
--- binutils-2.26/gas/config/te-winnt-pe.h	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.26.0007/gas/config/te-winnt-pe.h	2016-03-10 17:02:24.300717372 +0100
@@ -0,0 +1,21 @@
+/* Copyright (C) 2007-2014 Free Software Foundation, Inc.
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 3,
+   or (at your option) any later version.
+
+   GAS is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+   the GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#define TE_WINNT
+#include "te-pe.h"
diff -Naur binutils-2.26/gas/configure.tgt binutils-2.26.0007/gas/configure.tgt
--- binutils-2.26/gas/configure.tgt	2015-11-13 09:27:41.000000000 +0100
+++ binutils-2.26.0007/gas/configure.tgt	2016-03-10 17:02:24.304050632 +0100
@@ -157,6 +157,8 @@
   arm-epoc-pe)				fmt=coff em=epoc-pe ;;
   arm-wince-pe | arm-*-wince | arm*-*-mingw32ce* | arm*-*-cegcc*)
 					fmt=coff em=wince-pe ;;
+  arm*-*-mingw* | arm*-*-cygwin*)
+          fmt=coff em=winnt-pe ;;
   arm-*-pe)				fmt=coff em=pe ;;
   arm-*-riscix*)			fmt=aout em=riscix ;;
 
diff -Naur binutils-2.26/gas/configure.tgt.orig binutils-2.26.0007/gas/configure.tgt.orig
--- binutils-2.26/gas/configure.tgt.orig	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.26.0007/gas/configure.tgt.orig	2016-03-10 17:01:36.995090855 +0100
@@ -0,0 +1,504 @@
+# gas target specific configuration file.  This is a -*- sh -*- file.
+#
+#   Copyright (C) 2012-2015 Free Software Foundation, Inc.
+#
+# This file is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+#
+
+# This is invoked by configure.  Putting it in a separate shell file
+# lets us skip running autoconf when modifying target specific
+# information.
+
+# Input shell variables:
+#   targ	a configuration target name, such as i686-pc-linux-gnu.
+
+# Output shell variables:
+#   cpu_type	canonical gas cpu type; identifies the config/tc-* files
+#   fmt		output format; identifies the config/obj-* files
+#   em		emulation; identifies the config/te-* files
+
+# Optional output shell variables; these are not always set:
+#   arch	the default architecture; sets DEFAULT_ARCH on some systems
+#   endian	"big" or "little"; used on bi-endian systems
+
+cpu_type=
+fmt=
+em=generic
+bfd_gas=no
+arch=
+endian=
+
+eval `echo $targ | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/cpu=\1 vendor=\2 os=\3/'`
+
+# Check for architecture variants.  Set cpu_type and, optionally,
+# endian and arch.
+# Note: This table is alpha-sorted, please try to keep it that way.
+case ${cpu} in
+  aarch64)		cpu_type=aarch64 endian=little ;;
+  aarch64_be)		cpu_type=aarch64 endian=big ;;
+  alpha*)		cpu_type=alpha ;;
+  am33_2.0)		cpu_type=mn10300 endian=little ;;
+  arc*eb)		cpu_type=arc endian=big ;;
+  arm*be|arm*b)		cpu_type=arm endian=big ;;
+  arm*)			cpu_type=arm endian=little ;;
+  bfin*)		cpu_type=bfin endian=little ;;
+  c4x*)			cpu_type=tic4x ;;
+  cr16*)		cpu_type=cr16 endian=little ;;
+  crisv32)		cpu_type=cris arch=crisv32 ;;
+  crx*)			cpu_type=crx endian=little ;;
+  epiphany*)		cpu_type=epiphany endian=little ;;
+  fido)			cpu_type=m68k ;;
+  hppa*)		cpu_type=hppa ;;
+  i[3-7]86)		cpu_type=i386 arch=i386;;
+  ia64)			cpu_type=ia64 ;;
+  ip2k)			cpu_type=ip2k endian=big ;;
+  iq2000)		cpu_type=iq2000 endian=big ;;
+  lm32)			cpu_type=lm32 ;;
+  m32c)			cpu_type=m32c endian=little ;;
+  m32r)			cpu_type=m32r endian=big ;;
+  m32rle)		cpu_type=m32r endian=little ;;
+  m5200)		cpu_type=m68k ;;
+  m68008)		cpu_type=m68k ;;
+  m680[012346]0)	cpu_type=m68k ;;
+  m6811|m6812|m68hc12)	cpu_type=m68hc11 ;;
+  m683??)		cpu_type=m68k ;;
+  mep)			cpu_type=mep endian=little ;;
+  microblazeel*)	cpu_type=microblaze endian=little;;
+  microblaze*)		cpu_type=microblaze endian=big;;
+  mips*el)		cpu_type=mips endian=little ;;
+  mips*)		cpu_type=mips endian=big ;;
+  mt)			cpu_type=mt endian=big ;;
+  nds32be)		cpu_type=nds32 endian=big ;;
+  nds32le)		cpu_type=nds32 endian=little ;;
+  or1k* | or1knd*)	cpu_type=or1k endian=big ;;
+  pjl*)			cpu_type=pj endian=little ;;
+  pj*)			cpu_type=pj endian=big ;;
+  powerpc*le*)		cpu_type=ppc endian=little ;;
+  powerpc*)		cpu_type=ppc endian=big ;;
+  rs6000*)		cpu_type=ppc ;;
+  rl78*)		cpu_type=rl78 ;;
+  rx)			cpu_type=rx ;;
+  s390x*)		cpu_type=s390 arch=s390x ;;
+  s390*)		cpu_type=s390 arch=s390 ;;
+  score*l)		cpu_type=score endian=little ;;
+  score*)		cpu_type=score endian=big ;;
+  sh5le*)		cpu_type=sh64 endian=little ;;
+  sh5*)			cpu_type=sh64 endian=big ;;
+  sh64le*)		cpu_type=sh64 endian=little ;;
+  sh64*)		cpu_type=sh64 endian=big ;;
+  sh*le)		cpu_type=sh endian=little ;;
+  sh*)			cpu_type=sh endian=big ;;
+  sparc64*)		cpu_type=sparc arch=v9-64 ;;
+  sparc86x*)		cpu_type=sparc arch=sparc86x  ;;
+  sparclet*)		cpu_type=sparc arch=sparclet ;;
+  sparclite*)		cpu_type=sparc arch=sparclite ;;
+  sparc*)		cpu_type=sparc arch=sparclite ;; # ??? See tc-sparc.c.
+  tilegx*be)		cpu_type=tilegx endian=big ;;
+  tilegx*)		cpu_type=tilegx endian=little ;;
+  v850*)		cpu_type=v850 ;;
+  visium)		cpu_type=visium endian=big ;;
+  x86_64*)		cpu_type=i386 arch=x86_64;;
+  xgate)		cpu_type=xgate ;;
+  xtensa*)		cpu_type=xtensa arch=xtensa ;;
+  *)			cpu_type=${cpu} ;;
+esac
+
+
+# Assign object format.  Set fmt, em, and bfd_gas.
+generic_target=${cpu_type}-$vendor-$os
+# Note: This table is alpha-sorted, please try to keep it that way.
+case ${generic_target} in
+  aarch64*-*-elf)			fmt=elf;;
+  aarch64*-*-linux*)			fmt=elf em=linux ;;
+
+  alpha-*-*vms*)			fmt=evax ;;
+  alpha-*-osf*)				fmt=ecoff ;;
+  alpha-*-linux*ecoff*)			fmt=ecoff ;;
+  alpha-*-linux-*)			fmt=elf em=linux ;;
+  alpha-*-netbsd*)			fmt=elf em=nbsd ;;
+  alpha-*-openbsd*)			fmt=elf em=obsd ;;
+
+  arc-*-elf*)				fmt=elf ;;
+  arc*-*-linux-uclibc*)			fmt=elf bfd_gas=yes ;;
+
+  arm-*-aout)				fmt=aout ;;
+  arm-*-coff)				fmt=coff ;;
+  arm-*-rtems*)				fmt=elf ;;
+  arm-*-elf)				fmt=elf ;;
+  arm-*-eabi*)				fmt=elf em=armeabi ;;
+  arm-*-symbianelf*)			fmt=elf em=symbian ;;
+  arm-*-kaos*)				fmt=elf ;;
+  arm-*-conix*)				fmt=elf ;;
+  arm-*-freebsd[89].* | armeb-*-freebsd[89].*)
+					fmt=elf  em=freebsd ;;
+  arm-*-freebsd* | armeb-*-freebsd*)	fmt=elf  em=armfbsdeabi ;;
+  arm*-*-freebsd*)			fmt=elf  em=armfbsdvfp ;;
+  arm-*-linux*aout*)			fmt=aout em=linux ;;
+  arm-*-linux-*eabi*)			fmt=elf  em=armlinuxeabi ;;
+  arm-*-linux-*)			fmt=elf  em=linux ;;
+  arm-*-uclinux*eabi*)			fmt=elf  em=armlinuxeabi ;;
+  arm-*-uclinux*)			fmt=elf  em=linux ;;
+  arm-*-nacl*)				fmt=elf  em=nacl ;;
+  arm-*-netbsdelf*)			fmt=elf  em=nbsd ;;
+  arm-*-*n*bsd*)			fmt=aout em=nbsd ;;
+  arm-*-nto*)				fmt=elf ;;
+  arm-epoc-pe)				fmt=coff em=epoc-pe ;;
+  arm-wince-pe | arm-*-wince | arm*-*-mingw32ce* | arm*-*-cegcc*)
+					fmt=coff em=wince-pe ;;
+  arm-*-pe)				fmt=coff em=pe ;;
+  arm-*-riscix*)			fmt=aout em=riscix ;;
+
+  avr-*-*)				fmt=elf bfd_gas=yes ;;
+
+  bfin-*-linux-uclibc)			fmt=fdpicelf em=linux ;;
+  bfin-*-uclinux*)			fmt=elf em=linux ;;
+  bfin-*-rtems*)			fmt=elf ;;
+  bfin-*elf)				fmt=elf ;;
+
+  cr16-*-elf*)				fmt=elf ;;
+
+  cris-*-linux-* | crisv32-*-linux-*)
+					fmt=multi em=linux ;;
+  cris-*-* | crisv32-*-*)		fmt=multi ;;
+
+  crx-*-elf*)				fmt=elf ;;
+
+  d10v-*-*)				fmt=elf ;;
+  d30v-*-*)				fmt=elf ;;
+  dlx-*-*)				fmt=elf ;;
+
+  epiphany-*-*)				fmt=elf ;;
+
+  fr30-*-*)				fmt=elf ;;
+  frv-*-*linux*)			fmt=elf em=linux;;
+  frv-*-*)				fmt=elf ;;
+
+  ft32-*-*)				fmt=elf ;;
+
+  hppa-*-linux*)
+    case ${cpu} in
+      hppa*64*)				fmt=elf em=hppalinux64 ;;
+      hppa*)				fmt=elf em=linux ;;
+    esac ;;
+  hppa-*-*elf*)				fmt=elf em=hppa ;;
+  hppa-*-lites*)			fmt=elf em=hppa ;;
+  hppa-*-netbsd*)			fmt=elf em=nbsd ;;
+  hppa-*-openbsd*)			fmt=elf em=hppa ;;
+  hppa-*-osf*)				fmt=som em=hppa ;;
+  hppa-*-hpux11*)
+    case ${cpu} in
+      hppa*64*)				fmt=elf em=hppa64 ;;
+      hppa*)				fmt=som em=hppa ;;
+    esac ;;
+  hppa-*-hpux*)				fmt=som em=hppa ;;
+  hppa-*-mpeix*)			fmt=som em=hppa ;;
+  hppa-*-bsd*)				fmt=som em=hppa ;;
+  hppa-*-hiux*)				fmt=som em=hppa ;;
+
+  h8300-*-elf | h8300-*-rtems*)		fmt=elf ;;
+  h8300-*-linux*)			fmt=elf em=linux ;;
+
+  i370-*-elf* | i370-*-linux*)		fmt=elf ;;
+
+  i386-ibm-aix*)			fmt=coff em=i386aix ;;
+  i386-sequent-bsd*)			fmt=aout em=dynix ;;
+  i386-*-beospe*)			fmt=coff em=pe ;;
+  i386-*-beos*)				fmt=elf ;;
+  i386-*-coff)				fmt=coff ;;
+  i386-*-elfiamcu)			fmt=elf arch=iamcu ;;
+  i386-*-elf*)				fmt=elf ;;
+  i386-*-kaos*)				fmt=elf ;;
+  i386-*-bsd*)				fmt=aout em=386bsd ;;
+  i386-*-nacl*)				fmt=elf em=nacl
+    case ${cpu} in
+      x86_64*)				arch=x86_64:32 ;;
+    esac ;;
+  i386-*-netbsd0.8)			fmt=aout em=386bsd ;;
+  i386-*-netbsdpe*)			fmt=coff em=pe ;;
+  i386-*-netbsd*-gnu* | \
+  i386-*-knetbsd*-gnu | \
+  i386-*-netbsdelf*)			fmt=elf em=nbsd ;;
+  i386-*-netbsd*)
+    case ${cpu} in
+      x86_64)				fmt=elf em=nbsd ;;
+      *)				fmt=aout em=nbsd ;;
+    esac ;;
+  i386-*-openbsd[0-2].* | \
+  i386-*-openbsd3.[0-2])		fmt=aout em=nbsd ;;
+  i386-*-openbsd*)			fmt=elf em=nbsd ;;
+  i386-*-linux*aout*)			fmt=aout em=linux ;;
+  i386-*-linux*oldld)			fmt=aout em=linux ;;
+  i386-*-linux*coff*)			fmt=coff em=linux ;;
+  i386-*-linux-*)			fmt=elf em=linux
+    case ${cpu}-${os} in
+      x86_64*-linux-gnux32)		arch=x86_64:32 ;;
+    esac ;;
+  i386-*-lynxos*)			fmt=elf em=lynx ;;
+  i386-*-sysv[45]*)			fmt=elf ;;
+  i386-*-solaris*)			fmt=elf em=solaris ;;
+  i386-*-freebsdaout*)			fmt=aout em=386bsd ;;
+  i386-*-freebsd[12].*)			fmt=aout em=386bsd ;;
+  i386-*-freebsd[12])			fmt=aout em=386bsd ;;
+  i386-*-freebsd* \
+  | i386-*-kfreebsd*-gnu)		fmt=elf em=freebsd ;;
+  i386-*-sysv*)				fmt=coff ;;
+  i386-*-sco3.2v5*coff)			fmt=coff ;;
+  i386-*-isc*)				fmt=coff ;;
+  i386-*-sco3.2v5*)			fmt=elf ;;
+  i386-*-sco3.2*)			fmt=coff ;;
+  i386-*-vsta)				fmt=aout ;;
+  i386-*-msdosdjgpp* \
+  | i386-*-go32*)			fmt=coff em=go32 ;;
+  i386-*-rtems*)			fmt=elf ;;
+  i386-*-gnu*)				fmt=elf em=gnu ;;
+  i386-*-mach*)				fmt=aout em=mach ;;
+  i386-*-msdos*)			fmt=aout ;;
+  i386-*-moss*)				fmt=elf ;;
+  i386-*-pe)				fmt=coff em=pe ;;
+  i386-*-cygwin*)
+   case ${cpu} in
+     x86_64*)				fmt=coff em=pep ;;
+     i*)				fmt=coff em=pe ;;
+   esac ;;
+  i386-*-interix*)			fmt=coff em=interix ;;
+  i386-*-mingw*)
+    case ${cpu} in
+      x86_64*)				fmt=coff em=pep ;;
+      i*)				fmt=coff em=pe ;;
+    esac ;;
+  i386-*-nto-qnx*)			fmt=elf ;;
+  i386-*-*nt*)				fmt=coff em=pe ;;
+  i386-*-chaos)				fmt=elf ;;
+  i386-*-rdos*)				fmt=elf ;;
+  i386-*-darwin*)			fmt=macho ;;
+
+  i860-*-*)				fmt=elf endian=little ;;
+
+  i960-*-elf*)				fmt=elf ;;
+
+  ia64-*-elf*)				fmt=elf ;;
+  ia64-*-*vms*)				fmt=elf em=vms ;;
+  ia64-*-aix*)				fmt=elf em=ia64aix ;;
+  ia64-*-linux-*)			fmt=elf em=linux ;;
+  ia64-*-hpux*)				fmt=elf em=hpux ;;
+  ia64-*-netbsd*)			fmt=elf em=nbsd ;;
+
+  ip2k-*-*)				fmt=elf ;;
+
+  iq2000-*-elf)				fmt=elf ;;
+
+  lm32-*-*)				fmt=elf ;;
+
+  m32c-*-elf | m32c-*-rtems*)		fmt=elf ;;
+
+  m32r-*-elf* | m32r-*-rtems*)		fmt=elf ;;
+  m32r-*-linux*)			fmt=elf em=linux;;
+
+  m68hc11-*-* | m6811-*-*)		fmt=elf ;;
+  m68hc12-*-* | m6812-*-*)		fmt=elf ;;
+
+  m68k-*-aout)				fmt=aout bfd_gas=yes ;;
+  m68k-*-elf*)				fmt=elf ;;
+  m68k-*-sysv4*)			fmt=elf em=svr4 ;;
+  m68k-*-rtems*)			fmt=elf ;;
+  m68k-*-linux-*)			fmt=elf em=linux ;;
+  m68k-*-uclinux*)			fmt=elf em=uclinux ;;
+  m68k-*-gnu*)				fmt=elf ;;
+  m68k-*-netbsdelf*)			fmt=elf em=nbsd ;;
+  m68k-*-netbsd*)			fmt=aout em=nbsd bfd_gas=yes ;;
+  m68k-*-openbsd*)			fmt=aout em=nbsd bfd_gas=yes ;;
+  m68k-*-psos*)				fmt=elf em=psos;;
+
+  mep-*-elf)				fmt=elf ;;
+
+  metag-*-elf)				fmt=elf ;;
+  metag-*-linux*)			fmt=elf em=linux ;;
+
+  mcore-*-elf)				fmt=elf ;;
+  mcore-*-pe)				fmt=coff em=pe bfd_gas=yes ;;
+
+  microblaze-*-*)			fmt=elf ;;
+
+  mips-*-irix6*)			fmt=elf em=irix ;;
+  mips-*-irix5*)			fmt=elf em=irix ;;
+  mips*-*-linux*)			fmt=elf em=tmips ;;
+  mips*-*-freebsd* | mips*-*-kfreebsd*-gnu)
+					fmt=elf em=freebsd ;;
+  mips-*-sysv4*MP* | mips-*-gnu*)	fmt=elf em=tmips ;;
+  mips*-sde-elf* | mips*-mti-elf* | mips*-img-elf*)
+					fmt=elf em=tmips ;;
+  mips-*-elf* | mips-*-rtems*)		fmt=elf ;;
+  mips-*-netbsd*)			fmt=elf em=tmips ;;
+  mips-*-openbsd*)			fmt=elf em=tmips ;;
+
+  mmix-*-*)				fmt=elf ;;
+
+  mn10200-*-*)				fmt=elf ;;
+
+  # cpu_type for am33_2.0 is set to mn10300
+  mn10300-*-linux*)			fmt=elf em=linux ;;
+  mn10300-*-*)				fmt=elf ;;
+
+  moxie-*-uclinux)			fmt=elf em=linux ;;
+  moxie-*-moxiebox*)                    fmt=elf endian=little ;;
+  moxie-*-*)				fmt=elf ;;
+    
+  mt-*-elf)				fmt=elf bfd_gas=yes ;;
+
+  msp430-*-*)				fmt=elf ;;
+
+  nds32-*-elf*)				fmt=elf ;;
+  nds32-*-linux*)			fmt=elf em=linux ;;
+
+  nios2-*-rtems*)			fmt=elf ;;
+  nios2*-linux*)			fmt=elf em=linux ;;
+
+  ns32k-pc532-mach*)			fmt=aout em=pc532mach ;;
+  ns32k-pc532-ux*)			fmt=aout em=pc532mach ;;
+  ns32k-pc532-lites*)			fmt=aout em=nbsd532 ;;
+  ns32k-*-*n*bsd*)			fmt=aout em=nbsd532 ;;
+
+  or1k*-*-elf | or1k*-*-rtems*) 	fmt=elf endian=big ;;
+  or1k*-*-linux*)			fmt=elf em=linux endian=big ;;
+
+  pj*)					fmt=elf ;;
+
+  ppc-*-pe | ppc-*-cygwin*)		fmt=coff em=pe ;;
+  ppc-*-winnt*)				fmt=coff em=pe ;;
+  ppc-*-aix5.[01])			fmt=coff em=aix5 ;;
+  ppc-*-aix[5-9].*)			fmt=coff em=aix5 ;;
+  ppc-*-aix*)				fmt=coff em=aix ;;
+  ppc-*-beos*)				fmt=coff ;;
+  ppc-*-*n*bsd* | ppc-*-elf*)		fmt=elf ;;
+  ppc-*-eabi* | ppc-*-sysv4*)		fmt=elf ;;
+  ppc-*-linux-*)			fmt=elf em=linux ;;
+  ppc-*-solaris*)			fmt=elf em=solaris ;;
+  ppc-*-rtems*)				fmt=elf ;;
+  ppc-*-macos*)				fmt=coff em=macos ;;
+  ppc-*-nto*)				fmt=elf ;;
+  ppc-*-kaos*)				fmt=elf ;;
+  ppc-*-lynxos*)			fmt=elf em=lynx ;;
+
+  s390-*-linux-*)			fmt=elf em=linux ;;
+  s390-*-tpf*)				fmt=elf ;;
+
+  score-*-elf)				fmt=elf ;;
+
+  sh*-*-linux*)				fmt=elf em=linux
+    case ${cpu} in
+      sh*eb)	endian=big ;;
+      *)	endian=little ;;
+    esac ;;
+  sh5*-*-netbsd*)			fmt=elf em=nbsd ;;
+  sh64*-*-netbsd*)			fmt=elf em=nbsd ;;
+  sh*-*-netbsdelf*)			fmt=elf em=nbsd
+    case ${cpu} in
+      sh*l*)	endian=little ;;
+      *)	endian=big ;;
+    esac ;;
+  sh*-*-symbianelf*)			fmt=elf endian=little ;;
+  sh-*-elf*)				fmt=elf ;;
+  sh-*-uclinux* | sh[12]-*-uclinux*)	fmt=elf em=uclinux ;;
+  sh-*-coff*)				fmt=coff ;;
+  sh-*-nto*)				fmt=elf ;;
+  sh-*-pe*)				fmt=coff em=pe bfd_gas=yes endian=little ;;
+  sh-*-rtemscoff*)			fmt=coff ;;
+  sh-*-rtems*)				fmt=elf ;;
+  sh-*-kaos*)				fmt=elf ;;
+  shle*-*-kaos*)			fmt=elf ;;
+  sh64-*-elf*)				fmt=elf ;;
+
+  sparc64-*-rtems*)			fmt=elf ;;
+  sparc-*-rtems*)			fmt=elf ;;
+  sparc-*-sunos4*)			fmt=aout em=sun3 ;;
+  sparc-*-aout)				fmt=aout em=sparcaout ;;
+  sparc-*-coff)				fmt=coff ;;
+  sparc-*-linux*aout*)			fmt=aout em=linux ;;
+  sparc-*-linux-*)			fmt=elf em=linux ;;
+  sparc-fujitsu-none)			fmt=aout ;;
+  sparc-*-elf)				fmt=elf ;;
+  sparc-*-sysv4*)			fmt=elf ;;
+  sparc-*-solaris*)			fmt=elf em=solaris ;;
+  sparc-*-netbsdelf*)			fmt=elf em=nbsd ;;
+  sparc-*-netbsd*)
+    case ${cpu} in
+      sparc64)				fmt=elf em=nbsd ;;
+      *)				fmt=aout em=nbsd ;;
+    esac ;;
+  sparc-*-openbsd[0-2].* | \
+  sparc-*-openbsd3.[0-1])
+    case ${cpu} in
+      sparc64)				fmt=elf em=nbsd ;;
+      *)				fmt=aout em=nbsd ;;
+    esac ;;
+  sparc-*-openbsd*)			fmt=elf em=nbsd ;;
+
+  spu-*-elf)				fmt=elf ;;
+
+  tic30-*-*aout*)			fmt=aout bfd_gas=yes ;;
+  tic30-*-*coff*)			fmt=coff bfd_gas=yes ;;
+  tic4x-*-* | c4x-*-*)			fmt=coff bfd_gas=yes ;;
+  tic54x-*-* | c54x*-*-*)		fmt=coff bfd_gas=yes need_libm=yes;;
+  tic6x-*-*)				fmt=elf ;;
+
+  tilepro-*-* | tilegx*-*-*)		fmt=elf ;;
+
+  v850*-*-*)				fmt=elf ;;
+
+  vax-*-netbsdelf*)			fmt=elf em=nbsd ;;
+  vax-*-linux-*)			fmt=elf em=linux ;;
+
+  visium-*-elf)				fmt=elf ;;
+
+  xstormy16-*-*)			fmt=elf ;;
+  
+  xgate-*-*)    			fmt=elf ;;
+
+  xtensa*-*-*)				fmt=elf ;;
+
+  z80-*-coff)				fmt=coff ;;
+
+  z8k-*-coff | z8k-*-sim)		fmt=coff ;;
+
+  *-*-aout | *-*-scout)			fmt=aout ;;
+  *-*-cloudabi*)			fmt=elf ;;
+  *-*-dragonfly*)			fmt=elf em=dragonfly ;;
+  *-*-freebsd* | *-*-kfreebsd*-gnu)	fmt=elf em=freebsd ;;
+  *-*-bsd*)				fmt=aout em=sun3 ;;
+  *-*-generic)				fmt=generic ;;
+  *-*-xray | *-*-hms)			fmt=coff ;;
+  *-*-sim)				fmt=coff ;;
+  *-*-elf | *-*-sysv4*)			fmt=elf ;;
+  *-*-solaris*)				fmt=elf em=solaris ;;
+  *-*-aros*)				fmt=elf em=linux ;;
+  *-*-vxworks* | *-*-windiss)		fmt=elf em=vxworks ;;
+  *-*-netware)				fmt=elf em=netware ;;
+esac
+
+case ${cpu_type} in
+  aarch64 | alpha | arm | i386 | ia64 | microblaze | mips | ns32k | or1k | or1knd | pdp11 | ppc | sparc | z80 | z8k)
+    bfd_gas=yes
+    ;;
+esac
+case ${fmt} in
+  elf | ecoff | fdpicelf | multi | som)
+    bfd_gas=yes
+    ;;
+esac
+
+if test $bfd_gas != yes; then
+  echo This target is no longer supported in gas
+  exit 1
+fi
diff -Naur binutils-2.26/include/coff/arm.h binutils-2.26.0007/include/coff/arm.h
--- binutils-2.26/include/coff/arm.h	2015-11-13 09:27:42.000000000 +0100
+++ binutils-2.26.0007/include/coff/arm.h	2016-03-10 17:02:24.304050632 +0100
@@ -81,10 +81,10 @@
 
 #define	ARMPEMAGIC	0x1c0
 #define	THUMBPEMAGIC	0x1c2
-#define	ARMV7PEMAGIC	0x1c4
+#define	ARMNTPEMAGIC	0x1c4
 
 #undef  ARMBADMAG
-#define ARMBADMAG(x) (((x).f_magic != ARMMAGIC) && ((x).f_magic != ARMPEMAGIC) && ((x).f_magic != THUMBPEMAGIC) && ((x).f_magic != ARMV7PEMAGIC))
+#define ARMBADMAG(x) (((x).f_magic != ARMMAGIC) && ((x).f_magic != ARMPEMAGIC) && ((x).f_magic != THUMBPEMAGIC) && ((x).f_magic != ARMNTPEMAGIC))
 
 #define OMAGIC          0404    /* object files, eg as output */
 #define ZMAGIC          0413    /* demand load format, eg normal ld output */
@@ -102,7 +102,7 @@
 #define _LIT	".rdata"
 
 /********************** RELOCATION DIRECTIVES **********************/
-#ifdef ARM_WINCE
+#if defined (ARM_WINCE) || defined (ARM_WINNT)
 struct external_reloc
 {
   char r_vaddr[4];
diff -Naur binutils-2.26/include/coff/pe.h binutils-2.26.0007/include/coff/pe.h
--- binutils-2.26/include/coff/pe.h	2015-11-13 09:27:42.000000000 +0100
+++ binutils-2.26.0007/include/coff/pe.h	2016-03-10 17:02:24.307383892 +0100
@@ -149,6 +149,7 @@
 #define IMAGE_FILE_MACHINE_SH4               0x01a6
 #define IMAGE_FILE_MACHINE_SH5               0x01a8
 #define IMAGE_FILE_MACHINE_THUMB             0x01c2
+#define IMAGE_FILE_MACHINE_ARMNT             0x01c4
 #define IMAGE_FILE_MACHINE_TRICORE           0x0520
 #define IMAGE_FILE_MACHINE_WCEMIPSV2         0x0169
 #define IMAGE_FILE_MACHINE_AMD64             0x8664
diff -Naur binutils-2.26/ld/Makefile.am binutils-2.26.0007/ld/Makefile.am
--- binutils-2.26/ld/Makefile.am	2015-11-13 09:27:42.000000000 +0100
+++ binutils-2.26.0007/ld/Makefile.am	2016-03-10 17:02:24.380715607 +0100
@@ -164,6 +164,7 @@
 	earclinux_prof.c \
 	earm_epoc_pe.c \
 	earm_wince_pe.c \
+	ethumb2pe.c \
 	earmaoutb.c \
 	earmaoutl.c \
 	earmcoff.c \
@@ -726,6 +727,9 @@
 earm_wince_pe.c: $(srcdir)/emulparams/arm_wince_pe.sh \
   $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
 
+ethumb2pe.c: $(srcdir)/emulparams/thumb2pe.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
+
 earmaoutb.c:	$(srcdir)/emulparams/armaoutb.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/armaout.sc ${GEN_DEPENDS}
 
diff -Naur binutils-2.26/ld/Makefile.am.orig binutils-2.26.0007/ld/Makefile.am.orig
--- binutils-2.26/ld/Makefile.am.orig	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.26.0007/ld/Makefile.am.orig	2016-03-10 17:01:12.848951971 +0100
@@ -0,0 +1,2223 @@
+## Process this file with automake to generate Makefile.in
+#
+#   Copyright (C) 2012-2015 Free Software Foundation, Inc.
+#
+# This file is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+#
+
+AUTOMAKE_OPTIONS = dejagnu no-texinfo.tex no-dist foreign
+ACLOCAL_AMFLAGS = -I .. -I ../config -I ../bfd
+TEXINFO_TEX = ../texinfo/texinfo.tex
+
+SUBDIRS = po
+
+tooldir = $(exec_prefix)/$(target_alias)
+
+YACC = `if [ -f ../bison/bison ]; then echo ../bison/bison -y -L$(srcdir)/../bison/; else echo @YACC@; fi`
+YFLAGS = -d
+LEX = `if [ -f ../flex/flex ]; then echo ../flex/flex; else echo @LEX@; fi`
+
+# Automake 1.10+ disables lex and yacc output file regeneration if
+# maintainer mode is disabled.  Avoid this.
+am__skiplex =
+am__skipyacc =
+
+ELF_CLFAGS=-DELF_LIST_OPTIONS=@elf_list_options@ \
+	   -DELF_SHLIB_LIST_OPTIONS=@elf_shlib_list_options@ \
+	   -DELF_PLT_UNWIND_LIST_OPTIONS=@elf_plt_unwind_list_options@
+WARN_CFLAGS = @WARN_CFLAGS@
+NO_WERROR = @NO_WERROR@
+AM_CFLAGS = $(WARN_CFLAGS) $(ELF_CLFAGS)
+
+# Conditionally enable the plugin interface.
+if ENABLE_PLUGINS
+PLUGIN_C = plugin.c
+PLUGIN_H = plugin.h
+PLUGIN_OBJECT = plugin.@OBJEXT@
+PLUGIN_CFLAGS = -DENABLE_PLUGINS
+else
+PLUGIN_C =
+PLUGIN_H =
+PLUGIN_OBJECT =
+PLUGIN_CFLAGS =
+endif
+
+# We put the scripts in the directory $(scriptdir)/ldscripts.
+# We can't put the scripts in $(datadir) because the SEARCH_DIR
+# directives need to be different for native and cross linkers.
+scriptdir = $(tooldir)/lib
+
+EMUL = @EMUL@
+EMULATION_OFILES = @EMULATION_OFILES@
+EMUL_EXTRA_OFILES = @EMUL_EXTRA_OFILES@
+
+
+# Search path to override the default search path for -lfoo libraries.
+# If LIB_PATH is empty, the ones in the script (if any) are left alone.
+# (The default is usually /lib:/usr/lib:/usr/local/lib, unless building
+# a cross-linker, in which case the default is empty.  See genscripts.sh.)
+# Otherwise, they are replaced with the ones given in LIB_PATH,
+# which may have the form: LIB_PATH=/lib:/usr/local/lib.  This can be set
+# when the linker is configured via the --with-lib-path configure switch.
+LIB_PATH = @LIB_PATH@
+
+BASEDIR = $(srcdir)/..
+BFDDIR = $(BASEDIR)/bfd
+INCDIR	= $(BASEDIR)/include
+
+# What version of the manual to build
+DOCVER = gen
+
+# Options to extract the man page from ld.texinfo
+MANCONF = -Dman
+
+TEXI2POD = perl $(BASEDIR)/etc/texi2pod.pl $(AM_MAKEINFOFLAGS)
+
+POD2MAN = pod2man --center="GNU Development Tools" \
+	--release="binutils-$(VERSION)" --section=1
+
+#stuff for self hosting (can be overridden in config file).
+HOSTING_CRT0 = @HOSTING_CRT0@
+HOSTING_SCRT0 = @HOSTING_SCRT0@
+HOSTING_LIBS = @HOSTING_LIBS@
+HOSTING_SLIBS = @HOSTING_SLIBS@
+HOSTING_EMU = -m $(EMUL)
+
+# Setup the testing framework, if you have one
+EXPECT = expect
+RUNTEST = runtest
+RUNTESTFLAGS =
+
+CC_FOR_TARGET = ` \
+  if [ -f $$r/../gcc/xgcc ] ; then \
+    if [ -f $$r/../newlib/Makefile ] ; then \
+      echo $$r/../gcc/xgcc -B$$r/../gcc/ -idirafter $$r/../newlib/targ-include -idirafter $${srcroot}/../newlib/libc/include -nostdinc; \
+    else \
+      echo $$r/../gcc/xgcc -B$$r/../gcc/; \
+    fi; \
+  else \
+    if [ "@host@" = "@target@" ] ; then \
+      echo $(CC); \
+    else \
+      echo gcc | sed '$(transform)'; \
+    fi; \
+  fi`
+
+CXX_FOR_TARGET = ` \
+  if [ -f $$r/../gcc/g++ ] ; then \
+    if [ -f $$r/../newlib/Makefile ] ; then \
+      echo $$r/../gcc/g++ -B$$r/../gcc/ -idirafter $$r/../newlib/targ-include -idirafter $${srcroot}/../newlib/libc/include -nostdinc; \
+    else \
+      echo $$r/../gcc/g++ -B$$r/../gcc/; \
+    fi; \
+  else \
+    if [ "@host@" = "@target@" ] ; then \
+      echo $(CXX); \
+    else \
+      echo g++ | sed '$(transform)'; \
+    fi; \
+  fi`
+
+transform = s/^ld-new$$/$(installed_linker)/;@program_transform_name@
+bin_PROGRAMS = ld-new
+info_TEXINFOS = ld.texinfo
+ld_TEXINFOS = configdoc.texi
+noinst_TEXINFOS = ldint.texinfo
+man_MANS = ld.1
+
+AM_MAKEINFOFLAGS = -I $(srcdir) -I $(BFDDIR)/doc -I ../bfd/doc \
+		   -I $(top_srcdir)/../libiberty
+TEXI2DVI = texi2dvi -I $(srcdir) -I $(BFDDIR)/doc -I ../bfd/doc \
+		    -I $(top_srcdir)/../libiberty
+
+AM_CPPFLAGS = -I. -I$(srcdir) -I../bfd -I$(BFDDIR) -I$(INCDIR) \
+	@INCINTL@ $(HDEFINES) $(CFLAGS) $(PLUGIN_CFLAGS) \
+	-DLOCALEDIR="\"$(datadir)/locale\""
+
+BFDLIB = ../bfd/libbfd.la
+LIBIBERTY = ../libiberty/libiberty.a
+
+ALL_EMULATION_SOURCES = \
+	eaix5ppc.c \
+	eaix5rs6.c \
+	eaixppc.c \
+	eaixrs6.c \
+	ealpha.c \
+	ealphavms.c \
+	earcv2elf.c \
+	earcv2elfx.c \
+	earcelf.c \
+	earcelf_prof.c \
+	earclinux.c \
+	earclinux_prof.c \
+	earm_epoc_pe.c \
+	earm_wince_pe.c \
+	earmaoutb.c \
+	earmaoutl.c \
+	earmcoff.c \
+	earmelf.c \
+	earmelf_fbsd.c \
+	earmelf_linux.c \
+	earmelf_linux_eabi.c \
+	earmelf_nacl.c \
+	earmelf_nbsd.c \
+	earmelf_vxworks.c \
+	earmelfb.c \
+	earmelfb_fbsd.c \
+	earmelfb_linux.c \
+	earmelfb_linux_eabi.c \
+	earmelfb_nacl.c \
+	earmelfb_nbsd.c \
+	earmnbsd.c \
+	earmnto.c \
+	earmpe.c \
+	earmsymbian.c \
+	eavr1.c \
+	eavr2.c \
+	eavr25.c \
+	eavr3.c \
+	eavr31.c \
+	eavr35.c \
+	eavr4.c \
+	eavr5.c \
+	eavr51.c \
+	eavr6.c \
+	eavrxmega1.c \
+	eavrxmega2.c \
+	eavrxmega3.c \
+	eavrxmega4.c \
+	eavrxmega5.c \
+	eavrxmega6.c \
+	eavrxmega7.c \
+	eavrtiny.c   \
+	ecoff_i860.c \
+	ecoff_sparc.c \
+	ecrisaout.c \
+	ecriself.c \
+	ecrislinux.c \
+	ed10velf.c \
+	ed30v_e.c \
+	ed30v_o.c \
+	ed30velf.c \
+	edelta68.c \
+	eelf32_dlx.c \
+	eelf32_i860.c \
+	eelf32_i960.c \
+	eelf32_sparc.c \
+	eelf32_sparc_sol2.c \
+	eelf32_sparc_vxworks.c \
+	eelf32_spu.c \
+	eelf32_tic6x_be.c \
+	eelf32_tic6x_le.c \
+	eelf32_tic6x_linux_be.c \
+	eelf32_tic6x_linux_le.c \
+	eelf32_tic6x_elf_be.c \
+	eelf32_tic6x_elf_le.c \
+	eelf32am33lin.c \
+	eelf32bfin.c \
+	eelf32bfinfd.c \
+	eelf32cr16.c \
+	eelf32cr16c.c \
+	eelf32crx.c \
+	eelf32epiphany.c \
+	eelf32epiphany_4x4.c \
+	eelf32fr30.c \
+	eelf32frv.c \
+	eelf32frvfd.c \
+	eelf32ft32.c \
+	eelf32i370.c \
+	eelf32ip2k.c \
+	eelf32iq10.c \
+	eelf32iq2000.c \
+	eelf32lm32.c \
+	eelf32lm32fd.c \
+	eelf32lppc.c \
+	eelf32lppclinux.c \
+	eelf32lppcnto.c \
+	eelf32lppcsim.c \
+	eelf32m32c.c \
+	eelf32mb_linux.c \
+	eelf32mbel_linux.c \
+	eelf32mcore.c \
+	eelf32mep.c \
+	eelf32metag.c \
+	eelf32microblazeel.c \
+	eelf32microblaze.c \
+	eelf32moxie.c \
+	emoxiebox.c \
+	eelf32mt.c \
+	eelf32or1k.c \
+	eelf32or1k_linux.c \
+	eelf32ppc.c \
+	eelf32ppc_fbsd.c \
+	eelf32ppclinux.c \
+	eelf32ppcnto.c \
+	eelf32ppcsim.c \
+	eelf32ppcvxworks.c \
+	eelf32ppcwindiss.c \
+	eelf32rl78.c \
+	eelf32rx.c \
+	eelf32tilegx.c \
+	eelf32tilegx_be.c \
+	eelf32tilepro.c \
+	eelf32vax.c \
+	eelf32visium.c \
+	eelf32xc16x.c \
+	eelf32xc16xl.c \
+	eelf32xc16xs.c \
+	eelf32xstormy16.c \
+	eelf32xtensa.c \
+	eelf_i386.c \
+	eelf_i386_be.c \
+	eelf_i386_chaos.c \
+	eelf_i386_fbsd.c \
+	eelf_i386_ldso.c \
+	eelf_i386_nacl.c \
+	eelf_i386_sol2.c \
+	eelf_i386_vxworks.c \
+	eelf_iamcu.c \
+	eelf_s390.c \
+	egld960.c \
+	egld960coff.c \
+	eh8300.c \
+	eh8300elf.c \
+	eh8300elf_linux.c \
+	eh8300h.c \
+	eh8300helf.c \
+	eh8300helf_linux.c \
+	eh8300hn.c \
+	eh8300hnelf.c \
+	eh8300s.c \
+	eh8300self.c \
+	eh8300self_linux.c \
+	eh8300sn.c \
+	eh8300snelf.c \
+	eh8300sx.c \
+	eh8300sxelf.c \
+	eh8300sxelf_linux.c \
+	eh8300sxn.c \
+	eh8300sxnelf.c \
+	eh8500.c \
+	eh8500b.c \
+	eh8500c.c \
+	eh8500m.c \
+	eh8500s.c \
+	ehp300bsd.c \
+	ehp3hpux.c \
+	ehppaelf.c \
+	ehppalinux.c \
+	ehppanbsd.c \
+	ehppaobsd.c \
+	ei386aout.c \
+	ei386beos.c \
+	ei386bsd.c \
+	ei386coff.c \
+	ei386go32.c \
+	ei386linux.c \
+	ei386lynx.c \
+	ei386mach.c \
+	ei386moss.c \
+	ei386msdos.c \
+	ei386nbsd.c \
+	ei386nto.c \
+	ei386nw.c \
+	ei386pe.c \
+	ei386pe_posix.c \
+	elnk960.c \
+	em32relf.c \
+	em32relf_linux.c \
+	em32rlelf.c \
+	em32rlelf_linux.c \
+	em68hc11elf.c \
+	em68hc11elfb.c \
+	em68hc12elf.c \
+	em68hc12elfb.c \
+	em68k4knbsd.c \
+	em68kaout.c \
+	em68kaux.c \
+	em68kcoff.c \
+	em68kelf.c \
+	em68kelfnbsd.c \
+	em68klinux.c \
+	em68knbsd.c \
+	em68kpsos.c \
+	em88kbcs.c \
+	emcorepe.c \
+	emn10200.c \
+	emn10300.c \
+	emsp430elf.c \
+	emsp430X.c \
+	ends32elf.c \
+	ends32elf16m.c \
+	ends32elf_linux.c \
+	ends32belf.c \
+	ends32belf16m.c \
+	ends32belf_linux.c \
+	enews.c \
+	ens32knbsd.c \
+	enios2elf.c \
+	enios2linux.c \
+	epc532macha.c \
+	epdp11.c \
+	epjelf.c \
+	epjlelf.c \
+	eppclynx.c \
+	eppcmacos.c \
+	eppcnw.c \
+	eppcpe.c \
+	eriscix.c \
+	escore3_elf.c \
+	escore7_elf.c \
+	esh.c \
+	eshelf.c \
+	eshelf32.c \
+	eshelf32_linux.c \
+	eshelf32_nbsd.c \
+	eshelf_fd.c \
+	eshelf_linux.c \
+	eshelf_nbsd.c \
+	eshelf_nto.c \
+	eshelf_uclinux.c \
+	eshelf_vxworks.c \
+	eshl.c \
+	eshlelf.c \
+	eshlelf32.c \
+	eshlelf32_linux.c \
+	eshlelf32_nbsd.c \
+	eshlelf_fd.c \
+	eshlelf_linux.c \
+	eshlelf_nbsd.c \
+	eshlelf_nto.c \
+	eshlelf_vxworks.c \
+	eshlsymbian.c \
+	eshpe.c \
+	esparcaout.c \
+	esparclinux.c \
+	esparcnbsd.c \
+	est2000.c \
+	esun3.c \
+	esun4.c \
+	etic30aout.c \
+	etic30coff.c \
+	etic3xcoff.c \
+	etic3xcoff_onchip.c \
+	etic4xcoff.c \
+	etic54xcoff.c \
+	etic80coff.c \
+	ev850.c \
+	ev850_rh850.c \
+	evanilla.c \
+	evax.c \
+	evaxnbsd.c \
+	evsta.c \
+	ew65.c \
+	exgateelf.c \
+	ez80.c \
+	ez8001.c \
+	ez8002.c
+
+ALL_EMULATIONS = $(ALL_EMULATION_SOURCES:.c=.@OBJEXT@)
+
+ALL_64_EMULATION_SOURCES = \
+	eaarch64elf.c \
+	eaarch64elf32.c \
+	eaarch64elfb.c \
+	eaarch64elf32b.c \
+	eaarch64cloudabi.c \
+	eaarch64cloudabib.c \
+	eaarch64fbsd.c \
+	eaarch64fbsdb.c \
+	eaarch64linux.c \
+	eaarch64linuxb.c \
+	eaarch64linux32.c \
+	eaarch64linux32b.c \
+	eelf32_x86_64.c \
+	eelf32_x86_64_nacl.c \
+	eelf32b4300.c \
+	eelf32bmip.c \
+	eelf32bmipn32.c \
+	eelf32bsmip.c \
+	eelf32btsmip.c \
+	eelf32btsmip_fbsd.c \
+	eelf32btsmipn32.c \
+	eelf32btsmipn32_fbsd.c \
+	eelf32ebmip.c \
+	eelf32ebmipvxworks.c \
+	eelf32elmip.c \
+	eelf32elmipvxworks.c \
+	eelf32l4300.c \
+	eelf32lmip.c \
+	eelf32lr5900.c \
+	eelf32lr5900n32.c \
+	eelf32lsmip.c \
+	eelf32ltsmip.c \
+	eelf32ltsmip_fbsd.c \
+	eelf32ltsmipn32.c \
+	eelf32ltsmipn32_fbsd.c \
+	eelf32mipswindiss.c \
+	eelf64_aix.c \
+	eelf64_ia64.c \
+	eelf64_ia64_fbsd.c \
+	eelf64_ia64_vms.c \
+	eelf64_s390.c \
+	eelf64_sparc.c \
+	eelf64_sparc_fbsd.c \
+	eelf64_sparc_sol2.c \
+	eelf64alpha.c \
+	eelf64alpha_fbsd.c \
+	eelf64alpha_nbsd.c \
+	eelf64bmip.c \
+	eelf64btsmip.c \
+	eelf64btsmip_fbsd.c \
+	eelf64hppa.c \
+	eelf64lppc.c \
+	eelf64ltsmip.c \
+	eelf64ltsmip_fbsd.c \
+	eelf64mmix.c \
+	eelf64ppc.c \
+	eelf64ppc_fbsd.c \
+	eelf64rdos.c \
+	eelf64tilegx.c \
+	eelf64tilegx_be.c \
+	eelf_l1om.c \
+	eelf_l1om_fbsd.c \
+	eelf_k1om.c \
+	eelf_k1om_fbsd.c \
+	eelf_x86_64.c \
+	eelf_x86_64_cloudabi.c \
+	eelf_x86_64_fbsd.c \
+	eelf_x86_64_nacl.c \
+	eelf_x86_64_sol2.c \
+	ehppa64linux.c \
+	ei386pep.c \
+	emmo.c \
+	eshelf64.c \
+	eshelf64_nbsd.c \
+	eshlelf64.c \
+	eshlelf64_nbsd.c
+
+ALL_64_EMULATIONS = $(ALL_64_EMULATION_SOURCES:.c=.@OBJEXT@)
+
+ALL_EMUL_EXTRA_OFILES = \
+	deffilep.@OBJEXT@ \
+	pe-dll.@OBJEXT@
+
+ALL_64_EMUL_EXTRA_OFILES = \
+	pep-dll.@OBJEXT@
+
+CFILES = ldctor.c ldemul.c ldexp.c ldfile.c ldlang.c \
+	ldmain.c ldmisc.c ldver.c ldwrite.c lexsup.c \
+	mri.c ldcref.c pe-dll.c pep-dll.c ldlex-wrapper.c \
+	$(PLUGIN_C) ldbuildid.c
+
+HFILES = ld.h ldctor.h ldemul.h ldexp.h ldfile.h \
+	ldlang.h ldlex.h ldmain.h ldmisc.h ldver.h \
+	ldwrite.h mri.h deffile.h pe-dll.h pep-dll.h \
+	elf-hints-local.h $(PLUGIN_H) ldbuildid.h
+
+GENERATED_CFILES = ldgram.c ldlex.c deffilep.c
+GENERATED_HFILES = ldgram.h ldemul-list.h deffilep.h
+
+# Require an early dependency on the generated headers, as the dependency
+# tracking will not cause them to be built beforehand.
+BUILT_SOURCES = $(GENERATED_HFILES)
+
+OFILES = ldgram.@OBJEXT@ ldlex-wrapper.@OBJEXT@ lexsup.@OBJEXT@ ldlang.@OBJEXT@ \
+	mri.@OBJEXT@ ldctor.@OBJEXT@ ldmain.@OBJEXT@ $(PLUGIN_OBJECT) \
+	ldwrite.@OBJEXT@ ldexp.@OBJEXT@  ldemul.@OBJEXT@ ldver.@OBJEXT@ ldmisc.@OBJEXT@ \
+	ldfile.@OBJEXT@ ldcref.@OBJEXT@ ${EMULATION_OFILES} ${EMUL_EXTRA_OFILES} \
+	ldbuildid.@OBJEXT@
+
+STAGESTUFF = *.@OBJEXT@ ldscripts/* e*.c
+
+# Disable -Werror, if it has been enabled, since old versions of bison/
+# yacc will produce working code which contain compile time warnings.
+ldgram.@OBJEXT@: ldgram.c
+if am__fastdepCC
+	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `test -f ldgram.c || echo $(srcdir)/`ldgram.c $(NO_WERROR)
+	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+else
+if AMDEP
+	source='ldgram.c' object='$@' libtool=no @AMDEPBACKSLASH@
+	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+endif
+	$(COMPILE) -c `test -f ldgram.c || echo $(srcdir)/`ldgram.c $(NO_WERROR)
+endif
+
+ldlex-wrapper.@OBJEXT@: ldlex-wrapper.c ldlex.c
+if am__fastdepCC
+	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $(srcdir)/ldlex-wrapper.c $(NO_WERROR)
+	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+else
+if AMDEP
+	source='ldlex-wrapper.c' object='$@' libtool=no @AMDEPBACKSLASH@
+	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+endif
+	$(COMPILE) -c $(srcdir)/ldlex-wrapper.c $(NO_WERROR)
+endif
+
+deffilep.@OBJEXT@: deffilep.c
+if am__fastdepCC
+	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `test -f deffilep.c || echo $(srcdir)/`deffilep.c $(NO_WERROR)
+	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+else
+if AMDEP
+	source='deffilep.c' object='$@' libtool=no @AMDEPBACKSLASH@
+	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+endif
+	$(COMPILE) -c `test -f deffilep.c || echo $(srcdir)/`deffilep.c $(NO_WERROR)
+endif
+
+# At the moment this is just a list of those emulation template files
+# that contain internationalised strings.
+EMULATION_FILES = emultempl/pe.em emultempl/armcoff.em
+
+POTFILES = $(CFILES) $(HFILES) $(EMULATION_FILES)
+
+po/POTFILES.in: @MAINT@ Makefile
+	for f in $(POTFILES); do echo $$f; done | LC_ALL=C sort > tmp \
+	  && mv tmp $(srcdir)/po/POTFILES.in
+
+ldmain.@OBJEXT@: ldmain.c config.status
+if am__fastdepCC
+	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ \
+	  -DDEFAULT_EMULATION='"$(EMUL)"' \
+	  -DBINDIR='"$(bindir)"' -DTOOLBINDIR='"$(tooldir)/bin"' \
+	  -DTARGET='"@target@"' @TARGET_SYSTEM_ROOT_DEFINE@ \
+	  $(srcdir)/ldmain.c
+	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+else
+if AMDEP
+	source='ldmain.c' object='$@' libtool=no @AMDEPBACKSLASH@
+	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+endif
+	$(COMPILE) -c -DDEFAULT_EMULATION='"$(EMUL)"' \
+	  -DBINDIR='"$(bindir)"' -DTOOLBINDIR='"$(tooldir)/bin"' \
+	  -DTARGET='"@target@"' @TARGET_SYSTEM_ROOT_DEFINE@ \
+	  $(srcdir)/ldmain.c
+endif
+
+ldfile.@OBJEXT@: ldfile.c config.status
+if am__fastdepCC
+	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ \
+	-DSCRIPTDIR='"$(scriptdir)"' -DBINDIR='"$(bindir)"' -DTOOLBINDIR='"$(tooldir)/bin"' \
+	 $(srcdir)/ldfile.c
+	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+else
+if AMDEP
+	source='ldfile.c' object='$@' libtool=no @AMDEPBACKSLASH@
+	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+endif
+	$(COMPILE) -c -DSCRIPTDIR='"$(scriptdir)"' -DBINDIR='"$(bindir)"' \
+	  -DTOOLBINDIR='"$(tooldir)/bin"' \
+	  $(srcdir)/ldfile.c
+endif
+
+eelf32_spu.@OBJEXT@: eelf32_spu.c
+if am__fastdepCC
+	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ \
+	  -DEMBEDSPU="\"`echo embedspu | sed '$(transform)'`\"" eelf32_spu.c
+	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+else
+if AMDEP
+	source='eelf32_spu.c' object='$@' libtool=no @AMDEPBACKSLASH@
+	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+endif
+	$(COMPILE) -c -DEMBEDSPU="\"`echo embedspu | sed '$(transform)'`\"" \
+	  eelf32_spu.c
+endif
+
+ldemul-list.h: Makefile
+	(echo "/* This file is automatically generated.  DO NOT EDIT! */";\
+	for f in `echo " " ${EMULATION_OFILES} "" \
+	 | sed -e 's/ e/ ld/g' -e 's/ ld/ /g' -e 's/[.]o//g'`; do \
+	    echo "extern ld_emulation_xfer_type ld_$${f}_emulation;"; \
+	done;\
+	echo "";\
+	echo "#define EMULATION_LIST \\";\
+	for f in `echo " " ${EMULATION_OFILES} "" \
+	 | sed -e 's/ e/ ld/g' -e 's/ ld/ /g' -e 's/[.]o//g'`; do \
+	    echo "  &ld_$${f}_emulation, \\"; \
+	done;\
+	echo "  0") >ldemul-tmp.h
+	mv ldemul-tmp.h ldemul-list.h
+
+stringify.sed: ${srcdir}/emultempl/$(STRINGIFY)
+	  cp ${srcdir}/emultempl/$(STRINGIFY) stringify.sed
+
+# These all start with e so 'make clean' can find them.
+
+GENSCRIPTS = LIB_PATH='${LIB_PATH}' $(SHELL) $(srcdir)/genscripts.sh "${srcdir}" "${libdir}" "${prefix}" "${exec_prefix}" @host@ @target@ @target_alias@ "@EMULATION_LIBPATH@" "@NATIVE_LIB_DIRS@" @use_sysroot@ @enable_initfini_array@
+GEN_DEPENDS = $(srcdir)/genscripts.sh stringify.sed
+ELF_DEPS = $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/elf-generic.em $(srcdir)/scripttempl/DWARF.sc
+ELF_GEN_DEPS = $(srcdir)/emultempl/generic.em $(srcdir)/emultempl/elf-generic.em $(srcdir)/emultempl/genelf.em $(srcdir)/scripttempl/DWARF.sc
+
+@TDIRS@
+
+# We can't use pattern rules as we don't want to depend on GNU
+# make, or else these rules could have been expressed in one
+# two-liner: 'e%.c:' and '	${GENSCRIPTS} $* "$(tdir_$*)"'.
+# (The recursive variable expansion is portable.)
+
+run-genscripts:
+	${GENSCRIPTS} $(script_target) "$($(script_tdirname))"
+
+.PHONY: run-genscripts
+
+$(ALL_EMULATION_SOURCES) $(ALL_64_EMULATION_SOURCES):
+	base=`echo $@ | sed -e 's,e\(.*\).c,\1,'`; \
+	$(MAKE) run-genscripts "script_target=$$base" "script_tdirname=tdir_$$base"
+
+eaix5ppc.c: $(srcdir)/emulparams/aix5ppc.sh \
+  $(srcdir)/emultempl/aix.em $(srcdir)/scripttempl/aix.sc ${GEN_DEPENDS}
+
+eaix5rs6.c: $(srcdir)/emulparams/aix5rs6.sh \
+  $(srcdir)/emultempl/aix.em $(srcdir)/scripttempl/aix.sc ${GEN_DEPENDS}
+
+eaixppc.c: $(srcdir)/emulparams/aixppc.sh \
+  $(srcdir)/emultempl/aix.em $(srcdir)/scripttempl/aix.sc ${GEN_DEPENDS}
+
+eaixrs6.c: $(srcdir)/emulparams/aixrs6.sh \
+  $(srcdir)/emultempl/aix.em $(srcdir)/scripttempl/aix.sc ${GEN_DEPENDS}
+
+ealpha.c: $(srcdir)/emulparams/alpha.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/alpha.sc ${GEN_DEPENDS}
+
+ealphavms.c: $(srcdir)/emulparams/alphavms.sh \
+  $(srcdir)/emultempl/vms.em $(srcdir)/scripttempl/alphavms.sc \
+  ${GEN_DEPENDS}
+
+earcv2elf.c: $(srcdir)/emulparams/arcv2elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elfarcv2.sc ${GEN_DEPENDS}
+
+earcv2elfx.c: $(srcdir)/emulparams/arcv2elfx.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elfarcv2.sc ${GEN_DEPENDS}
+
+earcelf.c: $(srcdir)/emulparams/arcelf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elfarc.sc ${GEN_DEPENDS}
+
+earcelf_prof.c: $(srcdir)/emulparams/arcelf_prof.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elfarc.sc ${GEN_DEPENDS}
+
+#for linux on arc
+earclinux.c: $(srcdir)/emulparams/arclinux.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/arclinux.em \
+  $(srcdir)/scripttempl/arclinux.sc ${GEN_DEPENDS}
+
+earclinux_prof.c: $(srcdir)/emulparams/arclinux_prof.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/arclinux.em \
+  $(srcdir)/scripttempl/arclinux.sc ${GEN_DEPENDS}
+
+earm_epoc_pe.c: $(srcdir)/emulparams/arm_epoc_pe.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/epocpe.sc ${GEN_DEPENDS}
+
+earm_wince_pe.c: $(srcdir)/emulparams/arm_wince_pe.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
+
+earmaoutb.c:	$(srcdir)/emulparams/armaoutb.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/armaout.sc ${GEN_DEPENDS}
+
+earmaoutl.c:	$(srcdir)/emulparams/armaoutl.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/armaout.sc ${GEN_DEPENDS}
+
+earmcoff.c:	$(srcdir)/emulparams/armcoff.sh \
+  $(srcdir)/emultempl/armcoff.em $(srcdir)/scripttempl/armcoff.sc ${GEN_DEPENDS}
+
+earmelf.c: $(srcdir)/emulparams/armelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+earmelf_fbsd.c: $(srcdir)/emulparams/armelf_fbsd.sh \
+  $(srcdir)/emulparams/armelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+earmelf_linux.c: $(srcdir)/emulparams/armelf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+earmelf_linux_eabi.c: $(srcdir)/emulparams/armelf_linux_eabi.sh \
+  $(srcdir)/emulparams/armelf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+earmelf_nacl.c: $(srcdir)/emulparams/armelf_nacl.sh \
+  $(srcdir)/emulparams/armelf_linux_eabi.sh \
+  $(srcdir)/emulparams/armelf_linux.sh \
+  $(srcdir)/emulparams/elf_nacl.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+earmelf_nbsd.c: $(srcdir)/emulparams/armelf_nbsd.sh \
+  $(srcdir)/emulparams/armelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+earmelf_vxworks.c: $(srcdir)/emulparams/armelf_vxworks.sh \
+  $(srcdir)/emulparams/vxworks.sh $(srcdir)/emulparams/armelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/vxworks.em \
+  $(srcdir)/emultempl/armelf.em $(srcdir)/scripttempl/elf.sc \
+  ${GEN_DEPENDS}
+
+earmelfb.c: $(srcdir)/emulparams/armelfb.sh $(srcdir)/emulparams/armelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+earmelfb_fbsd.c: $(srcdir)/emulparams/armelfb_fbsd.sh \
+  $(srcdir)/emulparams/armelf_fbsd.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+earmelfb_linux.c: $(srcdir)/emulparams/armelfb_linux.sh \
+  $(srcdir)/emulparams/armelf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+earmelfb_linux_eabi.c: $(srcdir)/emulparams/armelfb_linux_eabi.sh \
+  $(srcdir)/emulparams/armelf_linux_eabi.sh \
+  $(srcdir)/emulparams/armelf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+earmelfb_nacl.c: $(srcdir)/emulparams/armelfb_nacl.sh \
+  $(srcdir)/emulparams/armelf_nacl.sh \
+  $(srcdir)/emulparams/armelf_linux_eabi.sh \
+  $(srcdir)/emulparams/armelf_linux.sh \
+  $(srcdir)/emulparams/elf_nacl.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+earmelfb_nbsd.c: $(srcdir)/emulparams/armelfb_nbsd.sh \
+  $(srcdir)/emulparams/armelf_nbsd.sh \
+  $(srcdir)/emulparams/armelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+earmnbsd.c:	$(srcdir)/emulparams/armnbsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+earmnto.c: $(srcdir)/emulparams/armnto.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+earmpe.c: $(srcdir)/emulparams/armpe.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
+
+earmsymbian.c: $(srcdir)/emulparams/armsymbian.sh \
+  $(srcdir)/emulparams/armelf.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/armelf.em $(srcdir)/scripttempl/armbpabi.sc \
+  ${GEN_DEPENDS}
+
+eavr1.c: $(srcdir)/emulparams/avr1.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavr2.c: $(srcdir)/emulparams/avr2.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavr25.c: $(srcdir)/emulparams/avr25.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavr3.c: $(srcdir)/emulparams/avr3.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavr31.c: $(srcdir)/emulparams/avr31.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavr35.c: $(srcdir)/emulparams/avr35.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavr4.c: $(srcdir)/emulparams/avr4.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavr5.c: $(srcdir)/emulparams/avr5.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavr51.c: $(srcdir)/emulparams/avr51.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavr6.c: $(srcdir)/emulparams/avr6.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavrxmega1.c: $(srcdir)/emulparams/avrxmega1.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavrxmega2.c: $(srcdir)/emulparams/avrxmega2.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavrxmega3.c: $(srcdir)/emulparams/avrxmega3.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavrxmega4.c: $(srcdir)/emulparams/avrxmega4.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavrxmega5.c: $(srcdir)/emulparams/avrxmega5.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavrxmega6.c: $(srcdir)/emulparams/avrxmega6.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavrxmega7.c: $(srcdir)/emulparams/avrxmega7.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavrtiny.c: $(srcdir)/emulparams/avrtiny.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avrtiny.sc \
+  ${GEN_DEPENDS}
+
+ecoff_i860.c: $(srcdir)/emulparams/coff_i860.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/i860coff.sc ${GEN_DEPENDS}
+
+ecoff_sparc.c: $(srcdir)/emulparams/coff_sparc.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/sparccoff.sc ${GEN_DEPENDS}
+
+ecrisaout.c: $(srcdir)/emulparams/crisaout.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/crisaout.sc ${GEN_DEPENDS}
+
+ecriself.c: $(srcdir)/emulparams/criself.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+ecrislinux.c: $(srcdir)/emulparams/crislinux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+ed10velf.c: $(srcdir)/emulparams/d10velf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elfd10v.sc ${GEN_DEPENDS}
+
+ed30v_e.c: $(srcdir)/emulparams/d30v_e.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elfd30v.sc ${GEN_DEPENDS}
+
+ed30v_o.c: $(srcdir)/emulparams/d30v_o.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elfd30v.sc ${GEN_DEPENDS}
+
+ed30velf.c: $(srcdir)/emulparams/d30velf.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elfd30v.sc ${GEN_DEPENDS}
+
+edelta68.c: $(srcdir)/emulparams/delta68.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/delta68.sc ${GEN_DEPENDS}
+
+eelf32_dlx.c: $(srcdir)/emulparams/elf32_dlx.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/dlx.sc ${GEN_DEPENDS}
+
+eelf32_i860.c: $(srcdir)/emulparams/elf32_i860.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32_i960.c: $(srcdir)/emulparams/elf32_i960.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32_sparc.c: $(srcdir)/emulparams/elf32_sparc.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32_sparc_sol2.c: $(srcdir)/emulparams/elf32_sparc_sol2.sh \
+  $(srcdir)/emulparams/elf32_sparc.sh \
+  $(srcdir)/emulparams/solaris2.sh \
+  $(srcdir)/emultempl/solaris2.em $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32_sparc_vxworks.c: $(srcdir)/emulparams/elf32_sparc_vxworks.sh \
+  $(srcdir)/emulparams/vxworks.sh $(srcdir)/emulparams/elf32_sparc.sh \
+  $(srcdir)/emultempl/vxworks.em $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32_spu.c: $(srcdir)/emulparams/elf32_spu.sh $(srcdir)/emultempl/spuelf.em \
+  $(srcdir)/emultempl/spu_ovl.@OBJEXT@_c $(srcdir)/emultempl/spu_icache.@OBJEXT@_c \
+  ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+$(srcdir)/emultempl/spu_ovl.@OBJEXT@_c: @MAINT@ $(srcdir)/emultempl/spu_ovl.S
+	if ../gas/as-new --version \
+		| grep 'target.*spu' >/dev/null 2>/dev/null; then \
+	  cpp -DOVLY_IRQ_SAVE $(srcdir)/emultempl/spu_ovl.S spu_ovl.s; \
+	  ../gas/as-new -o spu_ovl.@OBJEXT@ spu_ovl.s; \
+	  ../binutils/bin2c <spu_ovl.@OBJEXT@ >$@; \
+	fi
+$(srcdir)/emultempl/spu_icache.@OBJEXT@_c: @MAINT@ $(srcdir)/emultempl/spu_icache.S
+	if ../gas/as-new --version \
+		| grep 'target.*spu' >/dev/null 2>/dev/null; then \
+	  cpp -DOVLY_IRQ_SAVE $(srcdir)/emultempl/spu_icache.S spu_icache.s; \
+	  ../gas/as-new -o spu_icache.@OBJEXT@ spu_icache.s; \
+	  ../binutils/bin2c <spu_icache.@OBJEXT@ >$@; \
+	fi
+eelf32_tic6x_be.c: $(srcdir)/emulparams/elf32_tic6x_be.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc $(srcdir)/emultempl/tic6xdsbt.em \
+  ${GEN_DEPENDS}
+
+eelf32_tic6x_elf_be.c: $(srcdir)/emulparams/elf32_tic6x_elf_be.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc  $(srcdir)/emultempl/tic6xdsbt.em \
+  ${GEN_DEPENDS}
+
+eelf32_tic6x_elf_le.c: $(srcdir)/emulparams/elf32_tic6x_elf_le.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc  $(srcdir)/emultempl/tic6xdsbt.em \
+  ${GEN_DEPENDS}
+
+eelf32_tic6x_le.c: $(srcdir)/emulparams/elf32_tic6x_le.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc $(srcdir)/emultempl/tic6xdsbt.em \
+  ${GEN_DEPENDS}
+
+eelf32_tic6x_linux_be.c: $(srcdir)/emulparams/elf32_tic6x_linux_be.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc  $(srcdir)/emultempl/tic6xdsbt.em \
+  ${GEN_DEPENDS}
+
+eelf32_tic6x_linux_le.c: $(srcdir)/emulparams/elf32_tic6x_linux_le.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc  $(srcdir)/emultempl/tic6xdsbt.em \
+  ${GEN_DEPENDS}
+
+eelf32am33lin.c: $(srcdir)/emulparams/elf32am33lin.sh \
+  $(srcdir)/emulparams/elf32am33lin.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32b4300.c: $(srcdir)/emulparams/elf32b4300.sh \
+  $(srcdir)/emulparams/elf32bmip.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32bfin.c: $(srcdir)/emulparams/elf32bfin.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/bfin.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32bfinfd.c: $(srcdir)/emulparams/elf32bfinfd.sh \
+  $(srcdir)/emulparams/elf32bfin.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/bfin.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32bmip.c: $(srcdir)/emulparams/elf32bmip.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32bmipn32.c: $(srcdir)/emulparams/elf32bmipn32.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/irix.em $(srcdir)/emultempl/mipself.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32bsmip.c: $(srcdir)/emulparams/elf32bsmip.sh \
+  $(srcdir)/emulparams/elf32bmip.sh $(ELF_DEPS) $(srcdir)/emultempl/irix.em \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32btsmip.c: $(srcdir)/emulparams/elf32btsmip.sh \
+  $(srcdir)/emulparams/elf32bmip.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32btsmip_fbsd.c: $(srcdir)/emulparams/elf32btsmip_fbsd.sh \
+  $(srcdir)/emulparams/elf32bmip.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32btsmipn32.c: $(srcdir)/emulparams/elf32btsmipn32.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32btsmipn32_fbsd.c: $(srcdir)/emulparams/elf32btsmipn32_fbsd.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32cr16.c: $(srcdir)/emulparams/elf32cr16.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/cr16elf.em \
+  $(srcdir)/scripttempl/elf32cr16.sc ${GEN_DEPENDS}
+
+eelf32cr16c.c: $(srcdir)/emulparams/elf32cr16c.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf32cr16c.sc ${GEN_DEPENDS}
+
+eelf32crx.c: $(srcdir)/emulparams/elf32crx.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/crxelf.em \
+  $(srcdir)/scripttempl/elf32crx.sc ${GEN_DEPENDS}
+
+eelf32ebmip.c: $(srcdir)/emulparams/elf32ebmip.sh \
+  $(srcdir)/emulparams/elf32bmip.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32ebmipvxworks.c: $(srcdir)/emulparams/elf32ebmipvxworks.sh \
+  $(srcdir)/emulparams/elf32bmip.sh $(srcdir)/emulparams/vxworks.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/generic.em $(srcdir)/emultempl/mipself.em \
+  $(srcdir)/emultempl/vxworks.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32elmip.c: $(srcdir)/emulparams/elf32elmip.sh \
+  $(srcdir)/emulparams/elf32lmip.sh $(srcdir)/emulparams/elf32bmip.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc \
+  ${GEN_DEPENDS}
+
+eelf32elmipvxworks.c: $(srcdir)/emulparams/elf32elmipvxworks.sh \
+  $(srcdir)/emulparams/elf32bmip.sh $(srcdir)/emulparams/vxworks.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/generic.em $(srcdir)/emultempl/mipself.em \
+  $(srcdir)/emultempl/vxworks.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32lr5900.c: $(srcdir)/emulparams/elf32lr5900.sh \
+  $(srcdir)/emulparams/elf32bmip.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc \
+  ${GEN_DEPENDS}
+
+eelf32lr5900n32.c: $(srcdir)/emulparams/elf32lr5900n32.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc \
+  ${GEN_DEPENDS}
+
+eelf32epiphany.c: $(srcdir)/emulparams/elf32epiphany.sh \
+  $(ELF_DEPS) ${GEN_DEPENDS}
+
+eelf32epiphany_4x4.c: $(srcdir)/emulparams/elf32epiphany_4x4.sh \
+  $(srcdir)/emultempl/elf32.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/epiphany_4x4.sc ${GEN_DEPENDS}
+
+eelf32fr30.c: $(srcdir)/emulparams/elf32fr30.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32frv.c: $(srcdir)/emulparams/elf32frv.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32frvfd.c: $(srcdir)/emulparams/elf32frvfd.sh \
+  $(srcdir)/emulparams/elf32frv.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32ft32.c: $(srcdir)/emulparams/elf32ft32.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32i370.c: $(srcdir)/emulparams/elf32i370.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elfi370.sc ${GEN_DEPENDS}
+
+eelf32ip2k.c: $(srcdir)/emulparams/elf32ip2k.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32iq10.c: $(srcdir)/emulparams/elf32iq10.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/iq2000.sc ${GEN_DEPENDS}
+
+eelf32iq2000.c: $(srcdir)/emulparams/elf32iq2000.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/iq2000.sc ${GEN_DEPENDS}
+
+eelf32l4300.c: $(srcdir)/emulparams/elf32l4300.sh \
+  $(srcdir)/emulparams/elf32b4300.sh $(srcdir)/emulparams/elf32bmip.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc \
+  ${GEN_DEPENDS}
+
+eelf32lm32.c: $(srcdir)/emulparams/elf32lm32.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32lm32fd.c: $(srcdir)/emulparams/elf32lm32fd.sh \
+  $(srcdir)/emulparams/elf32lm32.sh $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32lmip.c: $(srcdir)/emulparams/elf32lmip.sh \
+  $(srcdir)/emulparams/elf32bmip.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32lppc.c: $(srcdir)/emulparams/elf32lppc.sh \
+  $(srcdir)/emulparams/elf32ppccommon.sh \
+  $(srcdir)/emulparams/elf32ppc.sh \
+  $(srcdir)/emultempl/ppc32elf.em ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32lppclinux.c: $(srcdir)/emulparams/elf32lppclinux.sh \
+  $(srcdir)/emulparams/elf32lppc.sh $(srcdir)/emulparams/elf32ppc.sh \
+  $(srcdir)/emulparams/elf32ppccommon.sh \
+  $(srcdir)/emultempl/ppc32elf.em ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32lppcnto.c: $(srcdir)/emulparams/elf32lppcnto.sh \
+  $(srcdir)/emulparams/elf32ppc.sh $(srcdir)/emulparams/elf32ppccommon.sh \
+  $(srcdir)/emultempl/ppc32elf.em ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32lppcsim.c: $(srcdir)/emulparams/elf32lppcsim.sh \
+  $(srcdir)/emulparams/elf32lppc.sh $(srcdir)/emulparams/elf32ppc.sh \
+  $(srcdir)/emulparams/elf32ppccommon.sh \
+  $(srcdir)/emultempl/ppc32elf.em ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32lsmip.c: $(srcdir)/emulparams/elf32lsmip.sh \
+  $(srcdir)/emulparams/elf32lmip.sh $(srcdir)/emulparams/elf32bmip.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc \
+  ${GEN_DEPENDS}
+
+eelf32ltsmip.c: $(srcdir)/emulparams/elf32ltsmip.sh \
+  $(srcdir)/emulparams/elf32btsmip.sh $(srcdir)/emulparams/elf32bmip.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc \
+  ${GEN_DEPENDS}
+
+eelf32ltsmip_fbsd.c: $(srcdir)/emulparams/elf32ltsmip_fbsd.sh \
+  $(srcdir)/emulparams/elf32btsmip.sh $(srcdir)/emulparams/elf32bmip.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc \
+  ${GEN_DEPENDS}
+
+eelf32ltsmipn32.c: $(srcdir)/emulparams/elf32ltsmipn32.sh \
+  $(srcdir)/emulparams/elf32btsmipn32.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32ltsmipn32_fbsd.c: $(srcdir)/emulparams/elf32ltsmipn32_fbsd.sh \
+  $(srcdir)/emulparams/elf32btsmipn32.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32m32c.c: $(srcdir)/emulparams/elf32m32c.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32mbel_linux.c: $(srcdir)/emulparams/elf32mbel_linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32mb_linux.c: $(srcdir)/emulparams/elf32mb_linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32mcore.c: $(srcdir)/emulparams/elf32mcore.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32mep.c: $(srcdir)/emulparams/elf32mep.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/mep.sc ${GEN_DEPENDS}
+
+eelf32metag.c: $(srcdir)/emulparams/elf32metag.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/metagelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32microblazeel.c: $(srcdir)/emulparams/elf32microblazeel.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elfmicroblaze.sc ${GEN_DEPENDS}
+
+eelf32microblaze.c: $(srcdir)/emulparams/elf32microblaze.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elfmicroblaze.sc ${GEN_DEPENDS}
+
+eelf32mipswindiss.c: $(srcdir)/emulparams/elf32mipswindiss.sh $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32moxie.c: $(srcdir)/emulparams/elf32moxie.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+emoxiebox.c: $(srcdir)/emulparams/moxiebox.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32mt.c: $(srcdir)/emulparams/elf32mt.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32or1k.c: $(srcdir)/emulparams/elf32or1k.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32or1k_linux.c: $(srcdir)/emulparams/elf32or1k_linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32ppc.c: $(srcdir)/emulparams/elf32ppc.sh \
+  $(srcdir)/emulparams/elf32ppccommon.sh \
+  $(srcdir)/emultempl/ppc32elf.em ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32ppc_fbsd.c: $(srcdir)/emulparams/elf32ppc_fbsd.sh \
+  $(srcdir)/emulparams/elf32ppc.sh $(srcdir)/emulparams/elf32ppccommon.sh \
+  $(srcdir)/emultempl/ppc32elf.em ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32ppclinux.c: $(srcdir)/emulparams/elf32ppclinux.sh \
+  $(srcdir)/emulparams/elf32ppc.sh $(srcdir)/emulparams/elf32ppccommon.sh \
+  $(srcdir)/emultempl/ppc32elf.em ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32ppcnto.c: $(srcdir)/emulparams/elf32ppcnto.sh \
+  $(srcdir)/emulparams/elf32ppc.sh $(srcdir)/emulparams/elf32ppccommon.sh \
+  $(srcdir)/emultempl/ppc32elf.em ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32ppcsim.c: $(srcdir)/emulparams/elf32ppcsim.sh \
+  $(srcdir)/emulparams/elf32ppc.sh $(srcdir)/emulparams/elf32ppccommon.sh \
+  $(srcdir)/emultempl/ppc32elf.em ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32ppcvxworks.c: $(srcdir)/emulparams/elf32ppcvxworks.sh \
+  $(srcdir)/emulparams/elf32ppccommon.sh $(srcdir)/emulparams/vxworks.sh \
+  $(srcdir)/emultempl/ppc32elf.em ldemul-list.h \
+  $(srcdir)/emultempl/vxworks.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32ppcwindiss.c: $(srcdir)/emulparams/elf32ppcwindiss.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32rl78.c: $(srcdir)/emulparams/elf32rl78.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32rx.c: $(srcdir)/emulparams/elf32rx.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32tilegx.c: $(srcdir)/emulparams/elf32tilegx.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32tilegx_be.c: $(srcdir)/emulparams/elf32tilegx_be.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32tilepro.c: $(srcdir)/emulparams/elf32tilepro.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32vax.c: $(srcdir)/emulparams/elf32vax.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32visium.c: $(srcdir)/emulparams/elf32visium.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/visium.sc ${GEN_DEPENDS}
+
+eelf32xc16x.c: $(srcdir)/emulparams/elf32xc16x.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32xc16xl.c: $(srcdir)/emulparams/elf32xc16xl.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32xc16xs.c: $(srcdir)/emulparams/elf32xc16xs.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32xstormy16.c: $(srcdir)/emulparams/elf32xstormy16.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/xstormy16.sc ${GEN_DEPENDS}
+
+eelf32xtensa.c: $(srcdir)/emulparams/elf32xtensa.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/xtensaelf.em $(INCDIR)/xtensa-config.h \
+  $(BFDDIR)/elf-bfd.h $(BFDDIR)/libbfd.h $(INCDIR)/elf/xtensa.h \
+  $(srcdir)/scripttempl/elfxtensa.sc ${GEN_DEPENDS}
+
+eelf_i386.c: $(srcdir)/emulparams/elf_i386.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_i386_be.c: $(srcdir)/emulparams/elf_i386_be.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_i386_chaos.c: $(srcdir)/emulparams/elf_i386_chaos.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf_chaos.sc ${GEN_DEPENDS}
+
+eelf_i386_fbsd.c: $(srcdir)/emulparams/elf_i386_fbsd.sh \
+  $(srcdir)/emulparams/elf_i386.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_i386_ldso.c: $(srcdir)/emulparams/elf_i386_ldso.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_i386_nacl.c: $(srcdir)/emulparams/elf_i386_nacl.sh \
+  $(srcdir)/emulparams/elf_i386.sh \
+  $(srcdir)/emulparams/elf_nacl.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_i386_sol2.c: $(srcdir)/emulparams/elf_i386_sol2.sh \
+  $(srcdir)/emulparams/solaris2.sh \
+  $(srcdir)/emultempl/solaris2.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_i386_vxworks.c: $(srcdir)/emulparams/elf_i386_vxworks.sh \
+  $(srcdir)/emulparams/vxworks.sh $(srcdir)/emultempl/vxworks.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_iamcu.c: $(srcdir)/emulparams/elf_iamcu.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_s390.c: $(srcdir)/emulparams/elf_s390.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+egld960.c: $(srcdir)/emulparams/gld960.sh \
+  $(srcdir)/emultempl/gld960.em $(srcdir)/scripttempl/i960.sc ${GEN_DEPENDS}
+
+egld960coff.c: $(srcdir)/emulparams/gld960coff.sh \
+  $(srcdir)/emultempl/gld960c.em $(srcdir)/scripttempl/i960.sc ${GEN_DEPENDS}
+
+eh8300.c: $(srcdir)/emulparams/h8300.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8300.sc ${GEN_DEPENDS}
+
+eh8300elf.c: $(srcdir)/emulparams/h8300elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eh8300elf_linux.c: $(srcdir)/emulparams/h8300elf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eh8300h.c: $(srcdir)/emulparams/h8300h.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8300h.sc ${GEN_DEPENDS}
+
+eh8300helf.c: $(srcdir)/emulparams/h8300helf.sh \
+  $(srcdir)/emulparams/h8300elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eh8300helf_linux.c: $(srcdir)/emulparams/h8300helf_linux.sh \
+  $(srcdir)/emulparams/h8300elf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eh8300hn.c: $(srcdir)/emulparams/h8300hn.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8300hn.sc ${GEN_DEPENDS}
+
+eh8300hnelf.c: $(srcdir)/emulparams/h8300hnelf.sh \
+  $(srcdir)/emulparams/h8300elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eh8300s.c: $(srcdir)/emulparams/h8300s.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8300s.sc ${GEN_DEPENDS}
+
+eh8300self.c: $(srcdir)/emulparams/h8300self.sh \
+  $(srcdir)/emulparams/h8300elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eh8300self_linux.c: $(srcdir)/emulparams/h8300self_linux.sh \
+  $(srcdir)/emulparams/h8300elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eh8300sn.c: $(srcdir)/emulparams/h8300sn.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8300sn.sc ${GEN_DEPENDS}
+
+eh8300snelf.c: $(srcdir)/emulparams/h8300snelf.sh \
+  $(srcdir)/emulparams/h8300elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eh8300sx.c: $(srcdir)/emulparams/h8300sx.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8300sx.sc ${GEN_DEPENDS}
+
+eh8300sxelf.c: $(srcdir)/emulparams/h8300sxelf.sh \
+  $(srcdir)/emulparams/h8300elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eh8300sxelf_linux.c: $(srcdir)/emulparams/h8300sxelf_linux.sh \
+  $(srcdir)/emulparams/h8300elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eh8300sxn.c: $(srcdir)/emulparams/h8300sxn.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8300sxn.sc ${GEN_DEPENDS}
+
+eh8300sxnelf.c: $(srcdir)/emulparams/h8300sxnelf.sh \
+  $(srcdir)/emulparams/h8300elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eh8500.c: $(srcdir)/emulparams/h8500.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8500.sc ${GEN_DEPENDS}
+
+eh8500b.c: $(srcdir)/emulparams/h8500b.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8500b.sc ${GEN_DEPENDS}
+
+eh8500c.c: $(srcdir)/emulparams/h8500c.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8500c.sc ${GEN_DEPENDS}
+
+eh8500m.c: $(srcdir)/emulparams/h8500m.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8500m.sc ${GEN_DEPENDS}
+
+eh8500s.c: $(srcdir)/emulparams/h8500s.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8500s.sc ${GEN_DEPENDS}
+
+ehp300bsd.c: $(srcdir)/emulparams/hp300bsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+ehp3hpux.c: $(srcdir)/emulparams/hp3hpux.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+ehppaelf.c: $(srcdir)/emulparams/hppaelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/hppaelf.em \
+  $(srcdir)/scripttempl/hppaelf.sc ${GEN_DEPENDS}
+
+ehppalinux.c: $(srcdir)/emulparams/hppalinux.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/hppaelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+ehppanbsd.c: $(srcdir)/emulparams/hppanbsd.sh \
+  $(srcdir)/emulparams/hppaelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/hppaelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+ehppaobsd.c: $(srcdir)/emulparams/hppaobsd.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/hppaelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+ei386aout.c: $(srcdir)/emulparams/i386aout.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+ei386beos.c: $(srcdir)/emulparams/i386beos.sh \
+  $(srcdir)/emultempl/beos.em $(srcdir)/scripttempl/i386beos.sc ${GEN_DEPENDS}
+
+ei386bsd.c: $(srcdir)/emulparams/i386bsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+ei386coff.c: $(srcdir)/emulparams/i386coff.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/i386coff.sc ${GEN_DEPENDS}
+
+ei386go32.c: $(srcdir)/emulparams/i386go32.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/i386go32.sc ${GEN_DEPENDS}
+
+ei386linux.c: $(srcdir)/emulparams/i386linux.sh \
+  $(srcdir)/emultempl/linux.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+ei386lynx.c: $(srcdir)/emulparams/i386lynx.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+ei386mach.c: $(srcdir)/emulparams/i386mach.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+ei386moss.c: $(srcdir)/emulparams/i386moss.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+ei386msdos.c: $(srcdir)/emulparams/i386msdos.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/i386msdos.sc ${GEN_DEPENDS}
+
+ei386nbsd.c:	$(srcdir)/emulparams/i386nbsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+ei386nto.c:	$(srcdir)/emulparams/i386nto.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+ei386nw.c:	$(srcdir)/emulparams/i386nw.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/nw.sc ${GEN_DEPENDS}
+
+ei386pe.c: $(srcdir)/emulparams/i386pe.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
+
+ei386pe_posix.c: $(srcdir)/emulparams/i386pe_posix.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
+
+ei386pep.c: $(srcdir)/emulparams/i386pep.sh \
+  $(srcdir)/emultempl/pep.em $(srcdir)/scripttempl/pep.sc ${GEN_DEPENDS}
+
+elnk960.c: $(srcdir)/emulparams/lnk960.sh \
+  $(srcdir)/emultempl/lnk960.em $(srcdir)/scripttempl/i960.sc ${GEN_DEPENDS}
+
+em32relf.c: $(srcdir)/emulparams/m32relf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+em32relf_linux.c: $(srcdir)/emulparams/m32relf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+em32rlelf.c: $(srcdir)/emulparams/m32rlelf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+em32rlelf_linux.c: $(srcdir)/emulparams/m32rlelf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+em68hc11elf.c: $(srcdir)/emulparams/m68hc11elf.sh \
+  $(srcdir)/emultempl/m68hc1xelf.em $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elfm68hc11.sc ${GEN_DEPENDS}
+
+em68hc11elfb.c: $(srcdir)/emulparams/m68hc11elfb.sh \
+  $(srcdir)/emultempl/m68hc1xelf.em $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elfm68hc11.sc ${GEN_DEPENDS}
+
+em68hc12elf.c: $(srcdir)/emulparams/m68hc12elf.sh \
+  $(srcdir)/emultempl/m68hc1xelf.em $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elfm68hc12.sc ${GEN_DEPENDS}
+
+em68hc12elfb.c: $(srcdir)/emulparams/m68hc12elfb.sh \
+  $(srcdir)/emultempl/m68hc1xelf.em $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elfm68hc12.sc ${GEN_DEPENDS}
+
+em68k4knbsd.c:	$(srcdir)/emulparams/m68k4knbsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+em68kaout.c: $(srcdir)/emulparams/m68kaout.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+em68kaux.c: $(srcdir)/emulparams/m68kaux.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/m68kaux.sc ${GEN_DEPENDS}
+
+em68kcoff.c: $(srcdir)/emulparams/m68kcoff.sh \
+  $(srcdir)/emultempl/m68kcoff.em $(srcdir)/scripttempl/m68kcoff.sc ${GEN_DEPENDS}
+
+em68kelf.c: $(srcdir)/emulparams/m68kelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/m68kelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+em68kelfnbsd.c: $(srcdir)/emulparams/m68kelfnbsd.sh \
+  $(srcdir)/emulparams/m68kelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/m68kelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+em68klinux.c: $(srcdir)/emulparams/m68klinux.sh \
+  $(srcdir)/emultempl/linux.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+em68knbsd.c:	$(srcdir)/emulparams/m68knbsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+em68kpsos.c:	$(srcdir)/emulparams/m68kpsos.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/psos.sc ${GEN_DEPENDS}
+
+em88kbcs.c: $(srcdir)/emulparams/m88kbcs.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/m88kbcs.sc ${GEN_DEPENDS}
+
+emcorepe.c: $(srcdir)/emulparams/mcorepe.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
+
+emn10200.c: $(srcdir)/emulparams/mn10200.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+emn10300.c: $(srcdir)/emulparams/mn10300.sh \
+  $(srcdir)/emulparams/mn10200.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+emsp430elf.c: $(srcdir)/emulparams/msp430elf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/msp430.em \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc ${GEN_DEPENDS}
+
+emsp430X.c: $(srcdir)/emulparams/msp430elf.sh $(srcdir)/emulparams/msp430X.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/msp430.em \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc ${GEN_DEPENDS}
+
+ends32elf.c: $(srcdir)/emulparams/nds32elf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/nds32elf.em \
+  $(srcdir)/scripttempl/nds32elf.sc ${GEN_DEPENDS}
+
+ends32elf16m.c: $(srcdir)/emulparams/nds32elf16m.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/nds32elf.em \
+  $(srcdir)/scripttempl/nds32elf.sc ${GEN_DEPENDS}
+
+ends32belf.c: $(srcdir)/emulparams/nds32belf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/nds32elf.em \
+  $(srcdir)/scripttempl/nds32elf.sc ${GEN_DEPENDS}
+
+ends32belf16m.c: $(srcdir)/emulparams/nds32belf16m.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/nds32elf.em \
+  $(srcdir)/scripttempl/nds32elf.sc ${GEN_DEPENDS}
+
+ends32elf_linux.c: $(srcdir)/emulparams/nds32elf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/nds32elf.em \
+  $(srcdir)/scripttempl/nds32elf.sc ${GEN_DEPENDS}
+
+ends32belf_linux.c: $(srcdir)/emulparams/nds32belf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/nds32elf.em \
+  $(srcdir)/scripttempl/nds32elf.sc ${GEN_DEPENDS}
+
+enews.c: $(srcdir)/emulparams/news.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+enios2elf.c: $(srcdir)/emulparams/nios2elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/nios2elf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+enios2linux.c: $(srcdir)/emulparams/nios2linux.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/nios2elf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+ens32knbsd.c:	$(srcdir)/emulparams/ns32knbsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/emultempl/netbsd.em \
+  $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+eaarch64elf.c: $(srcdir)/emulparams/aarch64elf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/aarch64elf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eaarch64elf32.c: $(srcdir)/emulparams/aarch64elf32.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/aarch64elf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eaarch64elfb.c: $(srcdir)/emulparams/aarch64elfb.sh $(srcdir)/emulparams/aarch64elf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/aarch64elf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eaarch64elf32b.c: $(srcdir)/emulparams/aarch64elf32b.sh $(srcdir)/emulparams/aarch64elf32.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/aarch64elf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eaarch64cloudabi.c: $(srcdir)/emulparams/aarch64cloudabi.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/aarch64elf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eaarch64cloudabib.c: $(srcdir)/emulparams/aarch64cloudabib.sh $(srcdir)/emulparams/aarch64cloudabi.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/aarch64elf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eaarch64fbsd.c: $(srcdir)/emulparams/aarch64fbsd.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/aarch64elf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eaarch64fbsdb.c: $(srcdir)/emulparams/aarch64fbsdb.sh $(srcdir)/emulparams/aarch64fbsd.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/aarch64elf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eaarch64linux.c: $(srcdir)/emulparams/aarch64linux.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/aarch64elf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eaarch64linuxb.c: $(srcdir)/emulparams/aarch64linuxb.sh $(srcdir)/emulparams/aarch64linux.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/aarch64elf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eaarch64linux32.c: $(srcdir)/emulparams/aarch64linux32.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/aarch64elf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eaarch64linux32b.c: $(srcdir)/emulparams/aarch64linux32b.sh $(srcdir)/emulparams/aarch64linux32.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/aarch64elf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+epc532macha.c: $(srcdir)/emulparams/pc532macha.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+epdp11.c: $(srcdir)/emulparams/pdp11.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+epjelf.c: $(srcdir)/emulparams/pjelf.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+epjlelf.c: $(srcdir)/emulparams/pjlelf.sh $(srcdir)/emulparams/pjelf.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eppclynx.c: $(srcdir)/emulparams/ppclynx.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eppcmacos.c:	$(srcdir)/emulparams/ppcmacos.sh \
+  $(srcdir)/emultempl/aix.em $(srcdir)/scripttempl/aix.sc ${GEN_DEPENDS}
+
+eppcnw.c:	$(srcdir)/emulparams/ppcnw.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/nw.sc ${GEN_DEPENDS}
+
+eppcpe.c: $(srcdir)/emulparams/ppcpe.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/ppcpe.sc ${GEN_DEPENDS}
+
+eriscix.c: $(srcdir)/emulparams/riscix.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+escore3_elf.c: $(srcdir)/emulparams/score3_elf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/scoreelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+escore7_elf.c: $(srcdir)/emulparams/score3_elf.sh \
+  $(srcdir)/emulparams/score7_elf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/scoreelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+esh.c: $(srcdir)/emulparams/sh.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/sh.sc ${GEN_DEPENDS}
+
+eshelf.c: $(srcdir)/emulparams/shelf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshelf32.c: $(srcdir)/emulparams/shelf32.sh \
+  $(BFDDIR)/libbfd.h $(INCDIR)/libiberty.h \
+  $(srcdir)/emultempl/sh64elf.em $(INCDIR)/elf/sh.h $(BFDDIR)/elf-bfd.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshelf32_linux.c: $(srcdir)/emulparams/shelf32_linux.sh \
+  $(srcdir)/emulparams/shelf32.sh \
+  $(BFDDIR)/libbfd.h $(INCDIR)/libiberty.h \
+  $(srcdir)/emultempl/sh64elf.em $(INCDIR)/elf/sh.h $(BFDDIR)/elf-bfd.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshelf32_nbsd.c: $(srcdir)/emulparams/shelf32_nbsd.sh \
+  $(srcdir)/emulparams/shelf32.sh \
+  $(BFDDIR)/libbfd.h $(INCDIR)/libiberty.h \
+  $(srcdir)/emultempl/sh64elf.em $(INCDIR)/elf/sh.h $(BFDDIR)/elf-bfd.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshelf_fd.c: $(srcdir)/emulparams/shelf_fd.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshelf_linux.c: $(srcdir)/emulparams/shelf_linux.sh \
+  $(srcdir)/emulparams/shlelf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshelf_nbsd.c: $(srcdir)/emulparams/shelf_nbsd.sh \
+  $(srcdir)/emulparams/shelf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshelf_nto.c: $(srcdir)/emulparams/shelf_nto.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshelf_uclinux.c: $(srcdir)/emulparams/shelf_uclinux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshelf_vxworks.c: $(srcdir)/emulparams/shelf_vxworks.sh \
+  $(srcdir)/emulparams/vxworks.sh $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc \
+  $(srcdir)/emultempl/vxworks.em ${GEN_DEPENDS}
+
+eshl.c: $(srcdir)/emulparams/shl.sh \
+  $(srcdir)/emulparams/sh.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/sh.sc ${GEN_DEPENDS}
+
+eshlelf.c: $(srcdir)/emulparams/shlelf.sh \
+  $(srcdir)/emulparams/shelf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshlelf32.c: $(srcdir)/emulparams/shlelf32.sh \
+  $(BFDDIR)/libbfd.h $(INCDIR)/libiberty.h $(srcdir)/emulparams/shelf32.sh \
+  $(srcdir)/emultempl/sh64elf.em $(INCDIR)/elf/sh.h $(BFDDIR)/elf-bfd.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshlelf32_linux.c: $(srcdir)/emulparams/shlelf32_linux.sh \
+  $(srcdir)/emulparams/shelf32_linux.sh $(srcdir)/emulparams/shelf32.sh \
+  $(BFDDIR)/libbfd.h $(INCDIR)/libiberty.h \
+  $(srcdir)/emultempl/sh64elf.em $(INCDIR)/elf/sh.h $(BFDDIR)/elf-bfd.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshlelf32_nbsd.c: $(srcdir)/emulparams/shlelf32_nbsd.sh \
+  $(srcdir)/emulparams/shelf32_nbsd.sh $(srcdir)/emulparams/shelf32.sh \
+  $(BFDDIR)/libbfd.h $(INCDIR)/libiberty.h \
+  $(srcdir)/emultempl/sh64elf.em $(INCDIR)/elf/sh.h $(BFDDIR)/elf-bfd.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshlelf_fd.c: $(srcdir)/emulparams/shlelf_fd.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshlelf_linux.c: $(srcdir)/emulparams/shlelf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshlelf_nbsd.c: $(srcdir)/emulparams/shlelf_nbsd.sh \
+  $(srcdir)/emulparams/shelf_nbsd.sh \
+  $(srcdir)/emulparams/shelf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshlelf_nto.c: $(srcdir)/emulparams/shlelf_nto.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshlelf_vxworks.c: $(srcdir)/emulparams/shlelf_vxworks.sh \
+  $(srcdir)/emulparams/shelf_vxworks.sh $(srcdir)/emulparams/vxworks.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc $(srcdir)/emultempl/vxworks.em \
+  ${GEN_DEPENDS}
+
+eshlsymbian.c: $(srcdir)/emulparams/shlsymbian.sh \
+  $(srcdir)/emulparams/shelf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf32sh-symbian.sc ${GEN_DEPENDS}
+
+eshpe.c: $(srcdir)/emulparams/shpe.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
+
+esparcaout.c: $(srcdir)/emulparams/sparcaout.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+esparclinux.c: $(srcdir)/emulparams/sparclinux.sh \
+  $(srcdir)/emultempl/linux.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+esparcnbsd.c:	$(srcdir)/emulparams/sparcnbsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+est2000.c: $(srcdir)/emulparams/st2000.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/st2000.sc ${GEN_DEPENDS}
+
+esun3.c: $(srcdir)/emulparams/sun3.sh \
+  $(srcdir)/emultempl/sunos.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+esun4.c: $(srcdir)/emulparams/sun4.sh \
+  $(srcdir)/emultempl/sunos.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+etic30aout.c: $(srcdir)/emulparams/tic30aout.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/tic30aout.sc ${GEN_DEPENDS}
+
+etic30coff.c: $(srcdir)/emulparams/tic30coff.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/tic30coff.sc ${GEN_DEPENDS}
+
+etic3xcoff.c: $(srcdir)/emulparams/tic3xcoff.sh \
+  $(srcdir)/emultempl/ticoff.em $(srcdir)/scripttempl/tic4xcoff.sc ${GEN_DEPENDS}
+
+etic3xcoff_onchip.c: $(srcdir)/emulparams/tic3xcoff_onchip.sh \
+  $(srcdir)/emultempl/ticoff.em $(srcdir)/scripttempl/tic4xcoff.sc ${GEN_DEPENDS}
+
+etic4xcoff.c: $(srcdir)/emulparams/tic4xcoff.sh \
+  $(srcdir)/emultempl/ticoff.em $(srcdir)/scripttempl/tic4xcoff.sc ${GEN_DEPENDS}
+
+etic54xcoff.c: $(srcdir)/emulparams/tic54xcoff.sh \
+  $(srcdir)/emultempl/ticoff.em $(srcdir)/scripttempl/tic54xcoff.sc ${GEN_DEPENDS}
+
+etic80coff.c: $(srcdir)/emulparams/tic80coff.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/tic80coff.sc ${GEN_DEPENDS}
+
+ev850.c: $(srcdir)/emulparams/v850.sh $(srcdir)/emultempl/v850elf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/v850.sc ${GEN_DEPENDS}
+
+ev850_rh850.c: $(srcdir)/emulparams/v850_rh850.sh $(srcdir)/emultempl/v850elf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/v850_rh850.sc ${GEN_DEPENDS}
+
+evanilla.c: $(srcdir)/emulparams/vanilla.sh \
+  $(srcdir)/emultempl/vanilla.em $(srcdir)/scripttempl/vanilla.sc ${GEN_DEPENDS}
+
+evax.c: $(srcdir)/emulparams/vax.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+evaxnbsd.c: $(srcdir)/emulparams/vaxnbsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+evsta.c: $(srcdir)/emulparams/vsta.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+ew65.c: $(srcdir)/emulparams/w65.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/w65.sc ${GEN_DEPENDS}
+
+exgateelf.c: $(srcdir)/emulparams/xgateelf.sh \
+  $(srcdir)/emultempl/generic.em $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elfxgate.sc ${GEN_DEPENDS}
+
+ez80.c: $(srcdir)/emulparams/z80.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/emultempl/z80.em \
+  $(srcdir)/scripttempl/z80.sc ${GEN_DEPENDS}
+
+ez8001.c: $(srcdir)/emulparams/z8001.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/z8000.sc ${GEN_DEPENDS}
+
+ez8002.c: $(srcdir)/emulparams/z8002.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/z8000.sc ${GEN_DEPENDS}
+
+eelf32_x86_64.c: $(srcdir)/emulparams/elf32_x86_64.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32_x86_64_nacl.c: $(srcdir)/emulparams/elf32_x86_64_nacl.sh \
+  $(srcdir)/emulparams/elf32_x86_64.sh \
+  $(srcdir)/emulparams/elf_nacl.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64_aix.c: $(srcdir)/emulparams/elf64_aix.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64_ia64.c: $(srcdir)/emulparams/elf64_ia64.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/ia64elf.em \
+  $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64_ia64_fbsd.c: $(srcdir)/emulparams/elf64_ia64_fbsd.sh \
+  $(srcdir)/emulparams/elf64_ia64.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/ia64elf.em \
+  $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64_ia64_vms.c: $(srcdir)/emulparams/elf64_ia64_vms.sh \
+  $(srcdir)/emultempl/vms.em $(srcdir)/emultempl/elf-generic.em \
+  $(srcdir)/scripttempl/ia64vms.sc ${GEN_DEPENDS}
+
+eelf64_s390.c: $(srcdir)/emulparams/elf64_s390.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64_sparc.c: $(srcdir)/emulparams/elf64_sparc.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64_sparc_fbsd.c: $(srcdir)/emulparams/elf64_sparc_fbsd.sh \
+  $(srcdir)/emulparams/elf64_sparc.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64_sparc_sol2.c: $(srcdir)/emulparams/elf64_sparc_sol2.sh \
+  $(srcdir)/emulparams/elf64_sparc.sh \
+  $(srcdir)/emulparams/solaris2.sh \
+  $(srcdir)/emultempl/solaris2.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64alpha.c: $(srcdir)/emulparams/elf64alpha.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/alphaelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64alpha_fbsd.c: $(srcdir)/emulparams/elf64alpha_fbsd.sh \
+  $(srcdir)/emulparams/elf64alpha.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/alphaelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64alpha_nbsd.c: $(srcdir)/emulparams/elf64alpha_nbsd.sh \
+  $(srcdir)/emulparams/elf64alpha.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/alphaelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64bmip.c: $(srcdir)/emulparams/elf64bmip.sh \
+  $(srcdir)/emulparams/elf64bmip-defs.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/irix.em $(srcdir)/emultempl/mipself.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64btsmip.c: $(srcdir)/emulparams/elf64btsmip.sh \
+  $(srcdir)/emulparams/elf64bmip-defs.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64btsmip_fbsd.c: $(srcdir)/emulparams/elf64btsmip_fbsd.sh \
+  $(srcdir)/emulparams/elf64bmip-defs.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64hppa.c: $(srcdir)/emulparams/elf64hppa.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf64hppa.sc ${GEN_DEPENDS}
+
+eelf64lppc.c: $(srcdir)/emulparams/elf64lppc.sh \
+  $(srcdir)/emulparams/elf64ppc.sh $(srcdir)/emultempl/ppc64elf.em \
+  ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64ltsmip.c: $(srcdir)/emulparams/elf64ltsmip.sh \
+  $(srcdir)/emulparams/elf64btsmip.sh $(srcdir)/emulparams/elf64bmip-defs.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64ltsmip_fbsd.c: $(srcdir)/emulparams/elf64ltsmip_fbsd.sh \
+  $(srcdir)/emulparams/elf64btsmip_fbsd.sh $(srcdir)/emulparams/elf64bmip-defs.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64mmix.c: $(srcdir)/emulparams/elf64mmix.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/mmix-elfnmmo.em \
+  $(srcdir)/emultempl/mmixelf.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64ppc.c: $(srcdir)/emulparams/elf64ppc.sh $(srcdir)/emultempl/ppc64elf.em \
+  ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64ppc_fbsd.c: $(srcdir)/emulparams/elf64ppc_fbsd.sh \
+  $(srcdir)/emultempl/ppc64elf.em ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64rdos.c: $(srcdir)/emulparams/elf64rdos.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64tilegx.c: $(srcdir)/emulparams/elf64tilegx.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64tilegx_be.c: $(srcdir)/emulparams/elf64tilegx_be.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_l1om.c: $(srcdir)/emulparams/elf_l1om.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_l1om_fbsd.c: $(srcdir)/emulparams/elf_l1om_fbsd.sh \
+  $(srcdir)/emulparams/elf_l1om.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_k1om.c: $(srcdir)/emulparams/elf_k1om.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_k1om_fbsd.c: $(srcdir)/emulparams/elf_k1om_fbsd.sh \
+  $(srcdir)/emulparams/elf_k1om.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_x86_64.c: $(srcdir)/emulparams/elf_x86_64.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_x86_64_cloudabi.c: $(srcdir)/emulparams/elf_x86_64_cloudabi.sh \
+  $(srcdir)/emulparams/elf_x86_64.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_x86_64_fbsd.c: $(srcdir)/emulparams/elf_x86_64_fbsd.sh \
+  $(srcdir)/emulparams/elf_x86_64.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_x86_64_nacl.c: $(srcdir)/emulparams/elf_x86_64_nacl.sh \
+  $(srcdir)/emulparams/elf_x86_64.sh \
+  $(srcdir)/emulparams/elf_nacl.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_x86_64_sol2.c: $(srcdir)/emulparams/elf_x86_64_sol2.sh \
+  $(srcdir)/emulparams/elf_x86_64.sh \
+  $(srcdir)/emulparams/solaris2.sh \
+  $(srcdir)/emultempl/solaris2.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+ehppa64linux.c: $(srcdir)/emulparams/hppa64linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+emmo.c: $(srcdir)/emulparams/mmo.sh $(srcdir)/emultempl/mmix-elfnmmo.em \
+  $(srcdir)/emultempl/generic.em $(srcdir)/emultempl/elf-generic.em \
+  $(srcdir)/emultempl/mmo.em $(srcdir)/scripttempl/DWARF.sc \
+  $(srcdir)/scripttempl/mmo.sc ${GEN_DEPENDS}
+
+eshelf64.c: $(srcdir)/emulparams/shelf64.sh $(srcdir)/emulparams/shelf32.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshelf64_nbsd.c: $(srcdir)/emulparams/shelf64_nbsd.sh \
+  $(srcdir)/emulparams/shelf32_nbsd.sh $(srcdir)/emulparams/shelf32.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshlelf64.c: $(srcdir)/emulparams/shlelf64.sh \
+  $(srcdir)/emulparams/shelf64.sh $(srcdir)/emulparams/shelf32.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshlelf64_nbsd.c: $(srcdir)/emulparams/shlelf64_nbsd.sh \
+  $(srcdir)/emulparams/shelf64_nbsd.sh \
+  $(srcdir)/emulparams/shelf32_nbsd.sh $(srcdir)/emulparams/shelf32.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+
+# We need this for automake to use YLWRAP.
+EXTRA_ld_new_SOURCES = deffilep.y ldlex.l
+# Allow dependency tracking to work for these files, too.
+EXTRA_ld_new_SOURCES += pep-dll.c pe-dll.c
+
+ld_new_SOURCES = ldgram.y ldlex-wrapper.c lexsup.c ldlang.c mri.c ldctor.c ldmain.c \
+	ldwrite.c ldexp.c ldemul.c ldver.c ldmisc.c ldfile.c ldcref.c $(PLUGIN_C) \
+	ldbuildid.c
+ld_new_DEPENDENCIES = $(EMULATION_OFILES) $(EMUL_EXTRA_OFILES) \
+		      $(BFDLIB) $(LIBIBERTY) $(LIBINTL_DEP)
+ld_new_LDADD = $(EMULATION_OFILES) $(EMUL_EXTRA_OFILES) $(BFDLIB) $(LIBIBERTY) $(LIBINTL)
+
+# Dependency tracking for the generated emulation files.
+EXTRA_ld_new_SOURCES += $(ALL_EMULATION_SOURCES) $(ALL_64_EMULATION_SOURCES)
+
+# This is the real libbfd.a created by libtool.
+TESTBFDLIB = @TESTBFDLIB@
+
+check-DEJAGNU: site.exp
+	srcroot=`cd $(srcdir) && pwd`; export srcroot; \
+	r=`pwd`; export r; \
+	LC_ALL=C; export LC_ALL; \
+	EXPECT=$(EXPECT); export EXPECT; \
+	runtest=$(RUNTEST); \
+	if $(SHELL) -c "$$runtest --version" > /dev/null 2>&1; then \
+	  $$runtest --tool $(DEJATOOL) --srcdir $${srcroot}/testsuite \
+		CC="$(CC_FOR_TARGET)" CFLAGS="$(CFLAGS)" \
+		CXX="$(CXX_FOR_TARGET)" CXXFLAGS="$(CXXFLAGS)" \
+		CC_FOR_HOST="$(CC)" CFLAGS_FOR_HOST="$(CFLAGS)" \
+		OFILES="$(OFILES)" BFDLIB="$(TESTBFDLIB)" \
+		LIBIBERTY="$(LIBIBERTY) $(LIBINTL)" LIBS="$(LIBS)" \
+		DO_COMPARE="`echo '$(do_compare)' | sed -e 's,\\$$,,g'`" \
+		$(RUNTESTFLAGS); \
+	else echo "WARNING: could not find \`runtest'" 1>&2; :;\
+	fi
+
+# Rules for testing by relinking ld itself.
+# A similar test is in the testsuite.  This target is for ease of use
+# when porting ld.
+
+ld-partial.@OBJEXT@: ld-new$(EXEEXT)
+	./ld-new$(EXEEXT) $(HOSTING_EMU) -o ld-partial.@OBJEXT@ -r $(OFILES)
+ld1$(EXEEXT): ld-partial.@OBJEXT@
+	./ld-new$(EXEEXT) $(HOSTING_EMU) -o ld1$(EXEEXT) $(HOSTING_CRT0) ld-partial.@OBJEXT@ $(TESTBFDLIB) $(LIBIBERTY) $(HOSTING_LIBS) $(LIBS)
+
+ld1-full$(EXEEXT): ld-new
+	./ld-new$(EXEEXT) $(HOSTING_EMU) -o ld1-full$(EXEEXT) $(HOSTING_CRT0) $(OFILES) $(TESTBFDLIB) $(LIBIBERTY) $(HOSTING_LIBS) $(LIBS)
+
+ld2$(EXEEXT): ld1$(EXEEXT)
+	./ld1$(EXEEXT) $(HOSTING_EMU) -o ld2$(EXEEXT) $(HOSTING_CRT0) $(OFILES) $(TESTBFDLIB) $(LIBIBERTY) $(HOSTING_LIBS) $(LIBS)
+
+ld3$(EXEEXT): ld2$(EXEEXT)
+	./ld2$(EXEEXT) $(HOSTING_EMU) -o ld3$(EXEEXT) $(HOSTING_CRT0) $(OFILES) $(TESTBFDLIB) $(LIBIBERTY) $(HOSTING_LIBS) $(LIBS)
+
+bootstrap: ld3$(EXEEXT)
+	cmp ld2$(EXEEXT) ld3$(EXEEXT)
+
+.PHONY: bootstrap
+
+# A test program for C++ constructors and destructors.
+# This test is now in the testsuite.
+#
+#cdtest: cdtest-main.@OBJEXT@ cdtest-bar.@OBJEXT@ cdtest-foo.@OBJEXT@ ld.new
+#	./ld.new $(HOSTING_EMU) -o cdtest $(HOSTING_CRT0) \
+#	  cdtest-main.@OBJEXT@ cdtest-bar.@OBJEXT@ cdtest-foo.@OBJEXT@ $(HOSTING_LIBS)
+#
+#cdtest.out: cdtest
+#	./cdtest > cdtest.tmp
+#	mv cdtest.tmp cdtest.out
+#
+#cdtest-ur.@OBJEXT@: cdtest-main.@OBJEXT@ cdtest-bar.@OBJEXT@ cdtest-foo.@OBJEXT@ ld.new
+#	./ld.new $(HOSTING_EMU) -o cdtest-ur.@OBJEXT@ -Ur cdtest-main.@OBJEXT@ \
+#	  cdtest-bar.@OBJEXT@ cdtest-foo.@OBJEXT@
+#
+#cdtest-ur: cdtest-ur.@OBJEXT@
+#	./ld.new $(HOSTING_EMU) -o cdtest-ur $(HOSTING_CRT0) cdtest-ur.@OBJEXT@ \
+#	  $(HOSTING_LIBS)
+#
+#cdtest-ur.out: cdtest-ur
+#	./cdtest-ur > cdtest-ur.tmp
+#	mv cdtest-ur.tmp cdtest-ur.out
+#
+#check-cdtest: cdtest.out cdtest-ur.out $(srcdir)/cdtest.exp
+#	diff $(srcdir)/cdtest.exp cdtest.out
+#	diff $(srcdir)/cdtest.exp cdtest-ur.out
+#
+#.PHONY: check-cdtest
+
+# END OF CHECK TARGETS
+
+#
+# Build a dummy plugin using libtool.
+#
+if ENABLE_PLUGINS
+noinst_LTLIBRARIES = libldtestplug.la libldtestplug2.la libldtestplug3.la
+libldtestplug_la_SOURCES = testplug.c
+libldtestplug_la_CFLAGS= -g -O2
+libldtestplug_la_LDFLAGS = -no-undefined -rpath /nowhere
+libldtestplug2_la_SOURCES = testplug2.c
+libldtestplug2_la_CFLAGS= -g -O2
+libldtestplug2_la_LDFLAGS = -no-undefined -rpath /nowhere
+libldtestplug3_la_SOURCES = testplug3.c
+libldtestplug3_la_CFLAGS= -g -O2
+libldtestplug3_la_LDFLAGS = -no-undefined -rpath /nowhere
+endif
+
+# DOCUMENTATION TARGETS
+# Manual configuration file; not usually attached to normal configuration,
+# because almost all configs use "gen" version of manual.
+#  Set DOCVER above to change.
+configdoc.texi:	${DOCVER}-doc.texi
+	cp ${srcdir}/${DOCVER}-doc.texi ./configdoc.texi
+	chmod u+w ./configdoc.texi
+
+# Build the man page from the texinfo file
+# The sed command removes the no-adjust Nroff command so that
+# the man output looks standard.
+ld.1: $(srcdir)/ld.texinfo configdoc.texi
+	touch $@
+	-$(TEXI2POD) $(MANCONF) < $(srcdir)/ld.texinfo > ld.pod
+	-($(POD2MAN) ld.pod | \
+		sed -e '/^.if n .na/d' > $@.T$$$$ && \
+		mv -f $@.T$$$$ $@) || \
+		(rm -f $@.T$$$$ && exit 1)
+	rm -f ld.pod
+
+MAINTAINERCLEANFILES = configdoc.texi ld.1
+
+# We want to reconfigure if configure.host or configure.tgt changes.
+# development.sh is used to determine -Werror default.
+CONFIG_STATUS_DEPENDENCIES = $(srcdir)/configure.host $(srcdir)/configure.tgt \
+	$(BFDDIR)/development.sh
+
+MOSTLYCLEANFILES = $(STAGESTUFF) ld1$(EXEEXT) ld2$(EXEEXT) ld3$(EXEEXT) \
+	ldemul-list.h crtbegin.@OBJEXT@ crtend.@OBJEXT@ ld.log ld.sum
+mostlyclean-local:
+	-rm -rf tmpdir
+CLEANFILES = dep.sed DEP DEPA DEP1 DEP2 spu_ovl.s spu_ovl.@OBJEXT@ spu_icache.s spu_icache.@OBJEXT@
+
+.PHONY: install-exec-local install-data-local
+
+install-exec-local: ld-new$(EXEEXT) install-binPROGRAMS
+	$(mkinstalldirs) $(DESTDIR)$(tooldir)/bin
+	n=`echo $(installed_linker) | sed '$(transform)'`; \
+	if test "$(bindir)" != "$(tooldir)/bin"; then \
+	  rm -f $(DESTDIR)$(tooldir)/bin/$(installed_linker)$(EXEEXT); \
+	  ln $(DESTDIR)$(bindir)/$$n$(EXEEXT) $(DESTDIR)$(tooldir)/bin/$(installed_linker)$(EXEEXT) >/dev/null 2>/dev/null \
+	  || $(INSTALL_PROGRAM_ENV) $(LIBTOOL) --mode=install $(INSTALL_PROGRAM) ld-new$(EXEEXT) $(DESTDIR)$(tooldir)/bin/$(installed_linker)$(EXEEXT); \
+	fi; \
+	if test "x$(install_as_default)" = "xyes"; then \
+	  ld=`echo ld | sed '$(transform)'`; \
+	  rm -f $(DESTDIR)$(bindir)/$$ld$(EXEEXT); \
+	  ln $(DESTDIR)$(bindir)/$$n$(EXEEXT) $(DESTDIR)$(bindir)/$$ld$(EXEEXT) >/dev/null 2>/dev/null \
+	  || $(INSTALL_PROGRAM_ENV) $(LIBTOOL) --mode=install $(INSTALL_PROGRAM) ld-new$(EXEEXT) $(DESTDIR)$(bindir)/$$ld$(EXEEXT); \
+	  if test "$(bindir)" != "$(tooldir)/bin"; then \
+	    rm -f $(DESTDIR)$(tooldir)/bin/ld$(EXEEXT); \
+	    ln $(DESTDIR)$(bindir)/$$n$(EXEEXT) $(DESTDIR)$(tooldir)/bin/ld$(EXEEXT) >/dev/null 2>/dev/null \
+	    || $(INSTALL_PROGRAM_ENV) $(LIBTOOL) --mode=install $(INSTALL_PROGRAM) ld-new$(EXEEXT) $(DESTDIR)$(tooldir)/bin/ld$(EXEEXT); \
+	  fi; \
+	fi
+
+install-data-local:
+	$(mkinstalldirs) $(DESTDIR)$(scriptdir)/ldscripts
+	for f in ldscripts/* ; do \
+	  $(INSTALL_DATA) $$f $(DESTDIR)$(scriptdir)/$$f ; \
+	done
+
+# Stuff that should be included in a distribution.  The diststuff
+# target is run by the taz target in ../Makefile.in.
+EXTRA_DIST = ldgram.c ldgram.h ldlex.c emultempl/spu_ovl.@OBJEXT@_c \
+	     emultempl/spu_icache.@OBJEXT@_c deffilep.c deffilep.h $(man_MANS)
+diststuff: info $(EXTRA_DIST)
+
+# Both info (ld.info) and ld.1 depend on configdoc.texi.
+# But info isn't a direct target. Make info-recursive to depend on
+# ld.1 to support parallel build.
+info-recursive: ld.1
+
+DISTCLEANFILES = tdirs site.exp site.bak stringify.sed
+distclean-local:
+	rm -rf ldscripts
+
+MAINTAINERCLEANFILES += ld.info
+
+# Automake 1.9 will only build info files in the objdir if they are
+# mentioned in DISTCLEANFILES.  It doesn't have to be unconditional,
+# though, so we use a bogus condition.
+if GENINSRC_NEVER
+DISTCLEANFILES += ld.info
+endif
diff -Naur binutils-2.26/ld/Makefile.in binutils-2.26.0007/ld/Makefile.in
--- binutils-2.26/ld/Makefile.in	2015-11-13 09:27:42.000000000 +0100
+++ binutils-2.26.0007/ld/Makefile.in	2016-03-10 17:02:24.390715386 +0100
@@ -494,6 +494,7 @@
 	earclinux_prof.c \
 	earm_epoc_pe.c \
 	earm_wince_pe.c \
+	ethumb2pe.c \
 	earmaoutb.c \
 	earmaoutl.c \
 	earmcoff.c \
@@ -1120,6 +1121,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earcv2elfx.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earm_epoc_pe.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earm_wince_pe.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ethumb2pe.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmaoutb.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmaoutl.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmcoff.Po@am__quote@
@@ -2232,6 +2234,9 @@
 earm_wince_pe.c: $(srcdir)/emulparams/arm_wince_pe.sh \
   $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
 
+ethumb2pe.c: $(srcdir)/emulparams/thumb2pe.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
+
 earmaoutb.c:	$(srcdir)/emulparams/armaoutb.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/armaout.sc ${GEN_DEPENDS}
 
diff -Naur binutils-2.26/ld/Makefile.in.orig binutils-2.26.0007/ld/Makefile.in.orig
--- binutils-2.26/ld/Makefile.in.orig	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.26.0007/ld/Makefile.in.orig	2016-03-10 17:01:12.745620891 +0100
@@ -0,0 +1,3640 @@
+# Makefile.in generated by automake 1.11.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+#
+#   Copyright (C) 2012-2015 Free Software Foundation, Inc.
+#
+# This file is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+#
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+target_triplet = @target@
+bin_PROGRAMS = ld-new$(EXEEXT)
+
+# Automake 1.9 will only build info files in the objdir if they are
+# mentioned in DISTCLEANFILES.  It doesn't have to be unconditional,
+# though, so we use a bogus condition.
+@GENINSRC_NEVER_TRUE@am__append_1 = ld.info
+subdir = .
+DIST_COMMON = NEWS README ChangeLog $(srcdir)/Makefile.in \
+	$(srcdir)/Makefile.am $(top_srcdir)/configure \
+	$(am__configure_deps) $(srcdir)/config.in \
+	$(srcdir)/../mkinstalldirs $(top_srcdir)/po/Make-in ldgram.h \
+	ldgram.c deffilep.h deffilep.c ldlex.c $(srcdir)/../depcomp \
+	$(srcdir)/../ylwrap $(ld_TEXINFOS)
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/../bfd/acinclude.m4 \
+	$(top_srcdir)/../bfd/warning.m4 $(top_srcdir)/../config/acx.m4 \
+	$(top_srcdir)/../config/depstand.m4 \
+	$(top_srcdir)/../config/gettext-sister.m4 \
+	$(top_srcdir)/../config/largefile.m4 \
+	$(top_srcdir)/../config/lcmessage.m4 \
+	$(top_srcdir)/../config/lead-dot.m4 \
+	$(top_srcdir)/../config/nls.m4 \
+	$(top_srcdir)/../config/override.m4 \
+	$(top_srcdir)/../config/plugins.m4 \
+	$(top_srcdir)/../config/po.m4 \
+	$(top_srcdir)/../config/progtest.m4 \
+	$(top_srcdir)/../libtool.m4 $(top_srcdir)/../ltoptions.m4 \
+	$(top_srcdir)/../ltsugar.m4 $(top_srcdir)/../ltversion.m4 \
+	$(top_srcdir)/../lt~obsolete.m4 \
+	$(top_srcdir)/../bfd/version.m4 $(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
+ configure.lineno config.status.lineno
+mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs
+CONFIG_HEADER = config.h
+CONFIG_CLEAN_FILES = po/Makefile.in
+CONFIG_CLEAN_VPATH_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libldtestplug_la_LIBADD =
+@ENABLE_PLUGINS_TRUE@am_libldtestplug_la_OBJECTS =  \
+@ENABLE_PLUGINS_TRUE@	libldtestplug_la-testplug.lo
+libldtestplug_la_OBJECTS = $(am_libldtestplug_la_OBJECTS)
+libldtestplug_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(libldtestplug_la_CFLAGS) \
+	$(CFLAGS) $(libldtestplug_la_LDFLAGS) $(LDFLAGS) -o $@
+@ENABLE_PLUGINS_TRUE@am_libldtestplug_la_rpath =
+libldtestplug2_la_LIBADD =
+@ENABLE_PLUGINS_TRUE@am_libldtestplug2_la_OBJECTS =  \
+@ENABLE_PLUGINS_TRUE@	libldtestplug2_la-testplug2.lo
+libldtestplug2_la_OBJECTS = $(am_libldtestplug2_la_OBJECTS)
+libldtestplug2_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(libldtestplug2_la_CFLAGS) $(CFLAGS) \
+	$(libldtestplug2_la_LDFLAGS) $(LDFLAGS) -o $@
+@ENABLE_PLUGINS_TRUE@am_libldtestplug2_la_rpath =
+libldtestplug3_la_LIBADD =
+@ENABLE_PLUGINS_TRUE@am_libldtestplug3_la_OBJECTS =  \
+@ENABLE_PLUGINS_TRUE@	libldtestplug3_la-testplug3.lo
+libldtestplug3_la_OBJECTS = $(am_libldtestplug3_la_OBJECTS)
+libldtestplug3_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(libldtestplug3_la_CFLAGS) $(CFLAGS) \
+	$(libldtestplug3_la_LDFLAGS) $(LDFLAGS) -o $@
+@ENABLE_PLUGINS_TRUE@am_libldtestplug3_la_rpath =
+am__installdirs = "$(DESTDIR)$(bindir)" "$(DESTDIR)$(infodir)" \
+	"$(DESTDIR)$(man1dir)"
+PROGRAMS = $(bin_PROGRAMS)
+@ENABLE_PLUGINS_TRUE@am__objects_1 = plugin.$(OBJEXT)
+am_ld_new_OBJECTS = ldgram.$(OBJEXT) ldlex-wrapper.$(OBJEXT) \
+	lexsup.$(OBJEXT) ldlang.$(OBJEXT) mri.$(OBJEXT) \
+	ldctor.$(OBJEXT) ldmain.$(OBJEXT) ldwrite.$(OBJEXT) \
+	ldexp.$(OBJEXT) ldemul.$(OBJEXT) ldver.$(OBJEXT) \
+	ldmisc.$(OBJEXT) ldfile.$(OBJEXT) ldcref.$(OBJEXT) \
+	$(am__objects_1) ldbuildid.$(OBJEXT)
+ld_new_OBJECTS = $(am_ld_new_OBJECTS)
+am__DEPENDENCIES_1 =
+DEFAULT_INCLUDES = -I.@am__isrc@
+depcomp = $(SHELL) $(top_srcdir)/../depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+@MAINTAINER_MODE_FALSE@am__skiplex = test -f $@ ||
+LEXCOMPILE = $(LEX) $(LFLAGS) $(AM_LFLAGS)
+LTLEXCOMPILE = $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(LEX) $(LFLAGS) $(AM_LFLAGS)
+YLWRAP = $(top_srcdir)/../ylwrap
+@MAINTAINER_MODE_FALSE@am__skipyacc = test -f $@ ||
+YACCCOMPILE = $(YACC) $(YFLAGS) $(AM_YFLAGS)
+LTYACCCOMPILE = $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(YACC) $(YFLAGS) $(AM_YFLAGS)
+SOURCES = $(libldtestplug_la_SOURCES) $(libldtestplug2_la_SOURCES) \
+	$(libldtestplug3_la_SOURCES) $(ld_new_SOURCES) \
+	$(EXTRA_ld_new_SOURCES)
+INFO_DEPS = ld.info
+am__TEXINFO_TEX_DIR = $(srcdir)/../texinfo
+DVIS = ld.dvi
+PDFS = ld.pdf
+PSS = ld.ps
+HTMLS = ld.html
+TEXINFOS = ld.texinfo
+TEXI2PDF = $(TEXI2DVI) --pdf --batch
+MAKEINFOHTML = $(MAKEINFO) --html
+AM_MAKEINFOHTMLFLAGS = $(AM_MAKEINFOFLAGS)
+DVIPS = dvips
+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
+	html-recursive info-recursive install-data-recursive \
+	install-dvi-recursive install-exec-recursive \
+	install-html-recursive install-info-recursive \
+	install-pdf-recursive install-ps-recursive install-recursive \
+	installcheck-recursive installdirs-recursive pdf-recursive \
+	ps-recursive uninstall-recursive
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
+am__install_max = 40
+am__nobase_strip_setup = \
+  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
+am__nobase_strip = \
+  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
+am__nobase_list = $(am__nobase_strip_setup); \
+  for p in $$list; do echo "$$p $$p"; done | \
+  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
+  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
+    if (++n[$$2] == $(am__install_max)) \
+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
+    END { for (dir in files) print dir, files[dir] }'
+am__base_list = \
+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
+  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+man1dir = $(mandir)/man1
+NROFF = nroff
+MANS = $(man_MANS)
+RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
+  distclean-recursive maintainer-clean-recursive
+AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \
+	$(RECURSIVE_CLEAN_TARGETS:-recursive=) tags TAGS ctags CTAGS
+ETAGS = etags
+CTAGS = ctags
+DEJATOOL = $(PACKAGE)
+RUNTESTDEFAULTFLAGS = --tool $$tool --srcdir $$srcdir
+DIST_SUBDIRS = $(SUBDIRS)
+transform = s/^ld-new$$/$(installed_linker)/;@program_transform_name@
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CATALOGS = @CATALOGS@
+CATOBJEXT = @CATOBJEXT@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DATADIRNAME = @DATADIRNAME@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EMUL = @EMUL@
+EMULATION_LIBPATH = @EMULATION_LIBPATH@
+EMULATION_OFILES = @EMULATION_OFILES@
+EMUL_EXTRA_OFILES = @EMUL_EXTRA_OFILES@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GENCAT = @GENCAT@
+GMSGFMT = @GMSGFMT@
+GREP = @GREP@
+HDEFINES = @HDEFINES@
+
+#stuff for self hosting (can be overridden in config file).
+HOSTING_CRT0 = @HOSTING_CRT0@
+HOSTING_LIBS = @HOSTING_LIBS@
+HOSTING_SCRT0 = @HOSTING_SCRT0@
+HOSTING_SLIBS = @HOSTING_SLIBS@
+INCINTL = @INCINTL@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+INSTOBJEXT = @INSTOBJEXT@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LEX = `if [ -f ../flex/flex ]; then echo ../flex/flex; else echo @LEX@; fi`
+LEXLIB = @LEXLIB@
+LEX_OUTPUT_ROOT = @LEX_OUTPUT_ROOT@
+LIBINTL = @LIBINTL@
+LIBINTL_DEP = @LIBINTL_DEP@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+
+# Search path to override the default search path for -lfoo libraries.
+# If LIB_PATH is empty, the ones in the script (if any) are left alone.
+# (The default is usually /lib:/usr/lib:/usr/local/lib, unless building
+# a cross-linker, in which case the default is empty.  See genscripts.sh.)
+# Otherwise, they are replaced with the ones given in LIB_PATH,
+# which may have the form: LIB_PATH=/lib:/usr/local/lib.  This can be set
+# when the linker is configured via the --with-lib-path configure switch.
+LIB_PATH = @LIB_PATH@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MKINSTALLDIRS = @MKINSTALLDIRS@
+MSGFMT = @MSGFMT@
+MSGMERGE = @MSGMERGE@
+NATIVE_LIB_DIRS = @NATIVE_LIB_DIRS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+NO_WERROR = @NO_WERROR@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+POSUB = @POSUB@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRINGIFY = @STRINGIFY@
+STRIP = @STRIP@
+TARGET_SYSTEM_ROOT = @TARGET_SYSTEM_ROOT@
+TARGET_SYSTEM_ROOT_DEFINE = @TARGET_SYSTEM_ROOT_DEFINE@
+
+# This is the real libbfd.a created by libtool.
+TESTBFDLIB = @TESTBFDLIB@
+USE_NLS = @USE_NLS@
+VERSION = @VERSION@
+WARN_CFLAGS = @WARN_CFLAGS@
+XGETTEXT = @XGETTEXT@
+YACC = `if [ -f ../bison/bison ]; then echo ../bison/bison -y -L$(srcdir)/../bison/; else echo @YACC@; fi`
+YFLAGS = -d
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+do_compare = @do_compare@
+docdir = @docdir@
+dvidir = @dvidir@
+elf_list_options = @elf_list_options@
+elf_plt_unwind_list_options = @elf_plt_unwind_list_options@
+elf_shlib_list_options = @elf_shlib_list_options@
+enable_initfini_array = @enable_initfini_array@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_as_default = @install_as_default@
+install_sh = @install_sh@
+installed_linker = @installed_linker@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target = @target@
+target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+use_sysroot = @use_sysroot@
+AUTOMAKE_OPTIONS = dejagnu no-texinfo.tex no-dist foreign
+ACLOCAL_AMFLAGS = -I .. -I ../config -I ../bfd
+TEXINFO_TEX = ../texinfo/texinfo.tex
+SUBDIRS = po
+tooldir = $(exec_prefix)/$(target_alias)
+
+# Automake 1.10+ disables lex and yacc output file regeneration if
+# maintainer mode is disabled.  Avoid this.
+am__skiplex = 
+am__skipyacc = 
+ELF_CLFAGS = -DELF_LIST_OPTIONS=@elf_list_options@ \
+	   -DELF_SHLIB_LIST_OPTIONS=@elf_shlib_list_options@ \
+	   -DELF_PLT_UNWIND_LIST_OPTIONS=@elf_plt_unwind_list_options@
+
+AM_CFLAGS = $(WARN_CFLAGS) $(ELF_CLFAGS)
+@ENABLE_PLUGINS_FALSE@PLUGIN_C = 
+
+# Conditionally enable the plugin interface.
+@ENABLE_PLUGINS_TRUE@PLUGIN_C = plugin.c
+@ENABLE_PLUGINS_FALSE@PLUGIN_H = 
+@ENABLE_PLUGINS_TRUE@PLUGIN_H = plugin.h
+@ENABLE_PLUGINS_FALSE@PLUGIN_OBJECT = 
+@ENABLE_PLUGINS_TRUE@PLUGIN_OBJECT = plugin.@OBJEXT@
+@ENABLE_PLUGINS_FALSE@PLUGIN_CFLAGS = 
+@ENABLE_PLUGINS_TRUE@PLUGIN_CFLAGS = -DENABLE_PLUGINS
+
+# We put the scripts in the directory $(scriptdir)/ldscripts.
+# We can't put the scripts in $(datadir) because the SEARCH_DIR
+# directives need to be different for native and cross linkers.
+scriptdir = $(tooldir)/lib
+BASEDIR = $(srcdir)/..
+BFDDIR = $(BASEDIR)/bfd
+INCDIR = $(BASEDIR)/include
+
+# What version of the manual to build
+DOCVER = gen
+
+# Options to extract the man page from ld.texinfo
+MANCONF = -Dman
+TEXI2POD = perl $(BASEDIR)/etc/texi2pod.pl $(AM_MAKEINFOFLAGS)
+POD2MAN = pod2man --center="GNU Development Tools" \
+	--release="binutils-$(VERSION)" --section=1
+
+HOSTING_EMU = -m $(EMUL)
+
+# Setup the testing framework, if you have one
+EXPECT = expect
+RUNTEST = runtest
+RUNTESTFLAGS = 
+CC_FOR_TARGET = ` \
+  if [ -f $$r/../gcc/xgcc ] ; then \
+    if [ -f $$r/../newlib/Makefile ] ; then \
+      echo $$r/../gcc/xgcc -B$$r/../gcc/ -idirafter $$r/../newlib/targ-include -idirafter $${srcroot}/../newlib/libc/include -nostdinc; \
+    else \
+      echo $$r/../gcc/xgcc -B$$r/../gcc/; \
+    fi; \
+  else \
+    if [ "@host@" = "@target@" ] ; then \
+      echo $(CC); \
+    else \
+      echo gcc | sed '$(transform)'; \
+    fi; \
+  fi`
+
+CXX_FOR_TARGET = ` \
+  if [ -f $$r/../gcc/g++ ] ; then \
+    if [ -f $$r/../newlib/Makefile ] ; then \
+      echo $$r/../gcc/g++ -B$$r/../gcc/ -idirafter $$r/../newlib/targ-include -idirafter $${srcroot}/../newlib/libc/include -nostdinc; \
+    else \
+      echo $$r/../gcc/g++ -B$$r/../gcc/; \
+    fi; \
+  else \
+    if [ "@host@" = "@target@" ] ; then \
+      echo $(CXX); \
+    else \
+      echo g++ | sed '$(transform)'; \
+    fi; \
+  fi`
+
+info_TEXINFOS = ld.texinfo
+ld_TEXINFOS = configdoc.texi
+noinst_TEXINFOS = ldint.texinfo
+man_MANS = ld.1
+AM_MAKEINFOFLAGS = -I $(srcdir) -I $(BFDDIR)/doc -I ../bfd/doc \
+		   -I $(top_srcdir)/../libiberty
+
+TEXI2DVI = texi2dvi -I $(srcdir) -I $(BFDDIR)/doc -I ../bfd/doc \
+		    -I $(top_srcdir)/../libiberty
+
+AM_CPPFLAGS = -I. -I$(srcdir) -I../bfd -I$(BFDDIR) -I$(INCDIR) \
+	@INCINTL@ $(HDEFINES) $(CFLAGS) $(PLUGIN_CFLAGS) \
+	-DLOCALEDIR="\"$(datadir)/locale\""
+
+BFDLIB = ../bfd/libbfd.la
+LIBIBERTY = ../libiberty/libiberty.a
+ALL_EMULATION_SOURCES = \
+	eaix5ppc.c \
+	eaix5rs6.c \
+	eaixppc.c \
+	eaixrs6.c \
+	ealpha.c \
+	ealphavms.c \
+	earcv2elf.c \
+	earcv2elfx.c \
+	earcelf.c \
+	earcelf_prof.c \
+	earclinux.c \
+	earclinux_prof.c \
+	earm_epoc_pe.c \
+	earm_wince_pe.c \
+	earmaoutb.c \
+	earmaoutl.c \
+	earmcoff.c \
+	earmelf.c \
+	earmelf_fbsd.c \
+	earmelf_linux.c \
+	earmelf_linux_eabi.c \
+	earmelf_nacl.c \
+	earmelf_nbsd.c \
+	earmelf_vxworks.c \
+	earmelfb.c \
+	earmelfb_fbsd.c \
+	earmelfb_linux.c \
+	earmelfb_linux_eabi.c \
+	earmelfb_nacl.c \
+	earmelfb_nbsd.c \
+	earmnbsd.c \
+	earmnto.c \
+	earmpe.c \
+	earmsymbian.c \
+	eavr1.c \
+	eavr2.c \
+	eavr25.c \
+	eavr3.c \
+	eavr31.c \
+	eavr35.c \
+	eavr4.c \
+	eavr5.c \
+	eavr51.c \
+	eavr6.c \
+	eavrxmega1.c \
+	eavrxmega2.c \
+	eavrxmega3.c \
+	eavrxmega4.c \
+	eavrxmega5.c \
+	eavrxmega6.c \
+	eavrxmega7.c \
+	eavrtiny.c   \
+	ecoff_i860.c \
+	ecoff_sparc.c \
+	ecrisaout.c \
+	ecriself.c \
+	ecrislinux.c \
+	ed10velf.c \
+	ed30v_e.c \
+	ed30v_o.c \
+	ed30velf.c \
+	edelta68.c \
+	eelf32_dlx.c \
+	eelf32_i860.c \
+	eelf32_i960.c \
+	eelf32_sparc.c \
+	eelf32_sparc_sol2.c \
+	eelf32_sparc_vxworks.c \
+	eelf32_spu.c \
+	eelf32_tic6x_be.c \
+	eelf32_tic6x_le.c \
+	eelf32_tic6x_linux_be.c \
+	eelf32_tic6x_linux_le.c \
+	eelf32_tic6x_elf_be.c \
+	eelf32_tic6x_elf_le.c \
+	eelf32am33lin.c \
+	eelf32bfin.c \
+	eelf32bfinfd.c \
+	eelf32cr16.c \
+	eelf32cr16c.c \
+	eelf32crx.c \
+	eelf32epiphany.c \
+	eelf32epiphany_4x4.c \
+	eelf32fr30.c \
+	eelf32frv.c \
+	eelf32frvfd.c \
+	eelf32ft32.c \
+	eelf32i370.c \
+	eelf32ip2k.c \
+	eelf32iq10.c \
+	eelf32iq2000.c \
+	eelf32lm32.c \
+	eelf32lm32fd.c \
+	eelf32lppc.c \
+	eelf32lppclinux.c \
+	eelf32lppcnto.c \
+	eelf32lppcsim.c \
+	eelf32m32c.c \
+	eelf32mb_linux.c \
+	eelf32mbel_linux.c \
+	eelf32mcore.c \
+	eelf32mep.c \
+	eelf32metag.c \
+	eelf32microblazeel.c \
+	eelf32microblaze.c \
+	eelf32moxie.c \
+	emoxiebox.c \
+	eelf32mt.c \
+	eelf32or1k.c \
+	eelf32or1k_linux.c \
+	eelf32ppc.c \
+	eelf32ppc_fbsd.c \
+	eelf32ppclinux.c \
+	eelf32ppcnto.c \
+	eelf32ppcsim.c \
+	eelf32ppcvxworks.c \
+	eelf32ppcwindiss.c \
+	eelf32rl78.c \
+	eelf32rx.c \
+	eelf32tilegx.c \
+	eelf32tilegx_be.c \
+	eelf32tilepro.c \
+	eelf32vax.c \
+	eelf32visium.c \
+	eelf32xc16x.c \
+	eelf32xc16xl.c \
+	eelf32xc16xs.c \
+	eelf32xstormy16.c \
+	eelf32xtensa.c \
+	eelf_i386.c \
+	eelf_i386_be.c \
+	eelf_i386_chaos.c \
+	eelf_i386_fbsd.c \
+	eelf_i386_ldso.c \
+	eelf_i386_nacl.c \
+	eelf_i386_sol2.c \
+	eelf_i386_vxworks.c \
+	eelf_iamcu.c \
+	eelf_s390.c \
+	egld960.c \
+	egld960coff.c \
+	eh8300.c \
+	eh8300elf.c \
+	eh8300elf_linux.c \
+	eh8300h.c \
+	eh8300helf.c \
+	eh8300helf_linux.c \
+	eh8300hn.c \
+	eh8300hnelf.c \
+	eh8300s.c \
+	eh8300self.c \
+	eh8300self_linux.c \
+	eh8300sn.c \
+	eh8300snelf.c \
+	eh8300sx.c \
+	eh8300sxelf.c \
+	eh8300sxelf_linux.c \
+	eh8300sxn.c \
+	eh8300sxnelf.c \
+	eh8500.c \
+	eh8500b.c \
+	eh8500c.c \
+	eh8500m.c \
+	eh8500s.c \
+	ehp300bsd.c \
+	ehp3hpux.c \
+	ehppaelf.c \
+	ehppalinux.c \
+	ehppanbsd.c \
+	ehppaobsd.c \
+	ei386aout.c \
+	ei386beos.c \
+	ei386bsd.c \
+	ei386coff.c \
+	ei386go32.c \
+	ei386linux.c \
+	ei386lynx.c \
+	ei386mach.c \
+	ei386moss.c \
+	ei386msdos.c \
+	ei386nbsd.c \
+	ei386nto.c \
+	ei386nw.c \
+	ei386pe.c \
+	ei386pe_posix.c \
+	elnk960.c \
+	em32relf.c \
+	em32relf_linux.c \
+	em32rlelf.c \
+	em32rlelf_linux.c \
+	em68hc11elf.c \
+	em68hc11elfb.c \
+	em68hc12elf.c \
+	em68hc12elfb.c \
+	em68k4knbsd.c \
+	em68kaout.c \
+	em68kaux.c \
+	em68kcoff.c \
+	em68kelf.c \
+	em68kelfnbsd.c \
+	em68klinux.c \
+	em68knbsd.c \
+	em68kpsos.c \
+	em88kbcs.c \
+	emcorepe.c \
+	emn10200.c \
+	emn10300.c \
+	emsp430elf.c \
+	emsp430X.c \
+	ends32elf.c \
+	ends32elf16m.c \
+	ends32elf_linux.c \
+	ends32belf.c \
+	ends32belf16m.c \
+	ends32belf_linux.c \
+	enews.c \
+	ens32knbsd.c \
+	enios2elf.c \
+	enios2linux.c \
+	epc532macha.c \
+	epdp11.c \
+	epjelf.c \
+	epjlelf.c \
+	eppclynx.c \
+	eppcmacos.c \
+	eppcnw.c \
+	eppcpe.c \
+	eriscix.c \
+	escore3_elf.c \
+	escore7_elf.c \
+	esh.c \
+	eshelf.c \
+	eshelf32.c \
+	eshelf32_linux.c \
+	eshelf32_nbsd.c \
+	eshelf_fd.c \
+	eshelf_linux.c \
+	eshelf_nbsd.c \
+	eshelf_nto.c \
+	eshelf_uclinux.c \
+	eshelf_vxworks.c \
+	eshl.c \
+	eshlelf.c \
+	eshlelf32.c \
+	eshlelf32_linux.c \
+	eshlelf32_nbsd.c \
+	eshlelf_fd.c \
+	eshlelf_linux.c \
+	eshlelf_nbsd.c \
+	eshlelf_nto.c \
+	eshlelf_vxworks.c \
+	eshlsymbian.c \
+	eshpe.c \
+	esparcaout.c \
+	esparclinux.c \
+	esparcnbsd.c \
+	est2000.c \
+	esun3.c \
+	esun4.c \
+	etic30aout.c \
+	etic30coff.c \
+	etic3xcoff.c \
+	etic3xcoff_onchip.c \
+	etic4xcoff.c \
+	etic54xcoff.c \
+	etic80coff.c \
+	ev850.c \
+	ev850_rh850.c \
+	evanilla.c \
+	evax.c \
+	evaxnbsd.c \
+	evsta.c \
+	ew65.c \
+	exgateelf.c \
+	ez80.c \
+	ez8001.c \
+	ez8002.c
+
+ALL_EMULATIONS = $(ALL_EMULATION_SOURCES:.c=.@OBJEXT@)
+ALL_64_EMULATION_SOURCES = \
+	eaarch64elf.c \
+	eaarch64elf32.c \
+	eaarch64elfb.c \
+	eaarch64elf32b.c \
+	eaarch64cloudabi.c \
+	eaarch64cloudabib.c \
+	eaarch64fbsd.c \
+	eaarch64fbsdb.c \
+	eaarch64linux.c \
+	eaarch64linuxb.c \
+	eaarch64linux32.c \
+	eaarch64linux32b.c \
+	eelf32_x86_64.c \
+	eelf32_x86_64_nacl.c \
+	eelf32b4300.c \
+	eelf32bmip.c \
+	eelf32bmipn32.c \
+	eelf32bsmip.c \
+	eelf32btsmip.c \
+	eelf32btsmip_fbsd.c \
+	eelf32btsmipn32.c \
+	eelf32btsmipn32_fbsd.c \
+	eelf32ebmip.c \
+	eelf32ebmipvxworks.c \
+	eelf32elmip.c \
+	eelf32elmipvxworks.c \
+	eelf32l4300.c \
+	eelf32lmip.c \
+	eelf32lr5900.c \
+	eelf32lr5900n32.c \
+	eelf32lsmip.c \
+	eelf32ltsmip.c \
+	eelf32ltsmip_fbsd.c \
+	eelf32ltsmipn32.c \
+	eelf32ltsmipn32_fbsd.c \
+	eelf32mipswindiss.c \
+	eelf64_aix.c \
+	eelf64_ia64.c \
+	eelf64_ia64_fbsd.c \
+	eelf64_ia64_vms.c \
+	eelf64_s390.c \
+	eelf64_sparc.c \
+	eelf64_sparc_fbsd.c \
+	eelf64_sparc_sol2.c \
+	eelf64alpha.c \
+	eelf64alpha_fbsd.c \
+	eelf64alpha_nbsd.c \
+	eelf64bmip.c \
+	eelf64btsmip.c \
+	eelf64btsmip_fbsd.c \
+	eelf64hppa.c \
+	eelf64lppc.c \
+	eelf64ltsmip.c \
+	eelf64ltsmip_fbsd.c \
+	eelf64mmix.c \
+	eelf64ppc.c \
+	eelf64ppc_fbsd.c \
+	eelf64rdos.c \
+	eelf64tilegx.c \
+	eelf64tilegx_be.c \
+	eelf_l1om.c \
+	eelf_l1om_fbsd.c \
+	eelf_k1om.c \
+	eelf_k1om_fbsd.c \
+	eelf_x86_64.c \
+	eelf_x86_64_cloudabi.c \
+	eelf_x86_64_fbsd.c \
+	eelf_x86_64_nacl.c \
+	eelf_x86_64_sol2.c \
+	ehppa64linux.c \
+	ei386pep.c \
+	emmo.c \
+	eshelf64.c \
+	eshelf64_nbsd.c \
+	eshlelf64.c \
+	eshlelf64_nbsd.c
+
+ALL_64_EMULATIONS = $(ALL_64_EMULATION_SOURCES:.c=.@OBJEXT@)
+ALL_EMUL_EXTRA_OFILES = \
+	deffilep.@OBJEXT@ \
+	pe-dll.@OBJEXT@
+
+ALL_64_EMUL_EXTRA_OFILES = \
+	pep-dll.@OBJEXT@
+
+CFILES = ldctor.c ldemul.c ldexp.c ldfile.c ldlang.c \
+	ldmain.c ldmisc.c ldver.c ldwrite.c lexsup.c \
+	mri.c ldcref.c pe-dll.c pep-dll.c ldlex-wrapper.c \
+	$(PLUGIN_C) ldbuildid.c
+
+HFILES = ld.h ldctor.h ldemul.h ldexp.h ldfile.h \
+	ldlang.h ldlex.h ldmain.h ldmisc.h ldver.h \
+	ldwrite.h mri.h deffile.h pe-dll.h pep-dll.h \
+	elf-hints-local.h $(PLUGIN_H) ldbuildid.h
+
+GENERATED_CFILES = ldgram.c ldlex.c deffilep.c
+GENERATED_HFILES = ldgram.h ldemul-list.h deffilep.h
+
+# Require an early dependency on the generated headers, as the dependency
+# tracking will not cause them to be built beforehand.
+BUILT_SOURCES = $(GENERATED_HFILES)
+OFILES = ldgram.@OBJEXT@ ldlex-wrapper.@OBJEXT@ lexsup.@OBJEXT@ ldlang.@OBJEXT@ \
+	mri.@OBJEXT@ ldctor.@OBJEXT@ ldmain.@OBJEXT@ $(PLUGIN_OBJECT) \
+	ldwrite.@OBJEXT@ ldexp.@OBJEXT@  ldemul.@OBJEXT@ ldver.@OBJEXT@ ldmisc.@OBJEXT@ \
+	ldfile.@OBJEXT@ ldcref.@OBJEXT@ ${EMULATION_OFILES} ${EMUL_EXTRA_OFILES} \
+	ldbuildid.@OBJEXT@
+
+STAGESTUFF = *.@OBJEXT@ ldscripts/* e*.c
+
+# At the moment this is just a list of those emulation template files
+# that contain internationalised strings.
+EMULATION_FILES = emultempl/pe.em emultempl/armcoff.em
+POTFILES = $(CFILES) $(HFILES) $(EMULATION_FILES)
+
+# These all start with e so 'make clean' can find them.
+GENSCRIPTS = LIB_PATH='${LIB_PATH}' $(SHELL) $(srcdir)/genscripts.sh "${srcdir}" "${libdir}" "${prefix}" "${exec_prefix}" @host@ @target@ @target_alias@ "@EMULATION_LIBPATH@" "@NATIVE_LIB_DIRS@" @use_sysroot@ @enable_initfini_array@
+GEN_DEPENDS = $(srcdir)/genscripts.sh stringify.sed
+ELF_DEPS = $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/elf-generic.em $(srcdir)/scripttempl/DWARF.sc
+ELF_GEN_DEPS = $(srcdir)/emultempl/generic.em $(srcdir)/emultempl/elf-generic.em $(srcdir)/emultempl/genelf.em $(srcdir)/scripttempl/DWARF.sc
+
+# We need this for automake to use YLWRAP.
+# Allow dependency tracking to work for these files, too.
+
+# Dependency tracking for the generated emulation files.
+EXTRA_ld_new_SOURCES = deffilep.y ldlex.l pep-dll.c pe-dll.c \
+	$(ALL_EMULATION_SOURCES) $(ALL_64_EMULATION_SOURCES)
+ld_new_SOURCES = ldgram.y ldlex-wrapper.c lexsup.c ldlang.c mri.c ldctor.c ldmain.c \
+	ldwrite.c ldexp.c ldemul.c ldver.c ldmisc.c ldfile.c ldcref.c $(PLUGIN_C) \
+	ldbuildid.c
+
+ld_new_DEPENDENCIES = $(EMULATION_OFILES) $(EMUL_EXTRA_OFILES) \
+		      $(BFDLIB) $(LIBIBERTY) $(LIBINTL_DEP)
+
+ld_new_LDADD = $(EMULATION_OFILES) $(EMUL_EXTRA_OFILES) $(BFDLIB) $(LIBIBERTY) $(LIBINTL)
+
+# A test program for C++ constructors and destructors.
+# This test is now in the testsuite.
+#
+#cdtest: cdtest-main.@OBJEXT@ cdtest-bar.@OBJEXT@ cdtest-foo.@OBJEXT@ ld.new
+#	./ld.new $(HOSTING_EMU) -o cdtest $(HOSTING_CRT0) \
+#	  cdtest-main.@OBJEXT@ cdtest-bar.@OBJEXT@ cdtest-foo.@OBJEXT@ $(HOSTING_LIBS)
+#
+#cdtest.out: cdtest
+#	./cdtest > cdtest.tmp
+#	mv cdtest.tmp cdtest.out
+#
+#cdtest-ur.@OBJEXT@: cdtest-main.@OBJEXT@ cdtest-bar.@OBJEXT@ cdtest-foo.@OBJEXT@ ld.new
+#	./ld.new $(HOSTING_EMU) -o cdtest-ur.@OBJEXT@ -Ur cdtest-main.@OBJEXT@ \
+#	  cdtest-bar.@OBJEXT@ cdtest-foo.@OBJEXT@
+#
+#cdtest-ur: cdtest-ur.@OBJEXT@
+#	./ld.new $(HOSTING_EMU) -o cdtest-ur $(HOSTING_CRT0) cdtest-ur.@OBJEXT@ \
+#	  $(HOSTING_LIBS)
+#
+#cdtest-ur.out: cdtest-ur
+#	./cdtest-ur > cdtest-ur.tmp
+#	mv cdtest-ur.tmp cdtest-ur.out
+#
+#check-cdtest: cdtest.out cdtest-ur.out $(srcdir)/cdtest.exp
+#	diff $(srcdir)/cdtest.exp cdtest.out
+#	diff $(srcdir)/cdtest.exp cdtest-ur.out
+#
+#.PHONY: check-cdtest
+
+# END OF CHECK TARGETS
+
+#
+# Build a dummy plugin using libtool.
+#
+@ENABLE_PLUGINS_TRUE@noinst_LTLIBRARIES = libldtestplug.la libldtestplug2.la libldtestplug3.la
+@ENABLE_PLUGINS_TRUE@libldtestplug_la_SOURCES = testplug.c
+@ENABLE_PLUGINS_TRUE@libldtestplug_la_CFLAGS = -g -O2
+@ENABLE_PLUGINS_TRUE@libldtestplug_la_LDFLAGS = -no-undefined -rpath /nowhere
+@ENABLE_PLUGINS_TRUE@libldtestplug2_la_SOURCES = testplug2.c
+@ENABLE_PLUGINS_TRUE@libldtestplug2_la_CFLAGS = -g -O2
+@ENABLE_PLUGINS_TRUE@libldtestplug2_la_LDFLAGS = -no-undefined -rpath /nowhere
+@ENABLE_PLUGINS_TRUE@libldtestplug3_la_SOURCES = testplug3.c
+@ENABLE_PLUGINS_TRUE@libldtestplug3_la_CFLAGS = -g -O2
+@ENABLE_PLUGINS_TRUE@libldtestplug3_la_LDFLAGS = -no-undefined -rpath /nowhere
+MAINTAINERCLEANFILES = configdoc.texi ld.1 ld.info
+
+# We want to reconfigure if configure.host or configure.tgt changes.
+# development.sh is used to determine -Werror default.
+CONFIG_STATUS_DEPENDENCIES = $(srcdir)/configure.host $(srcdir)/configure.tgt \
+	$(BFDDIR)/development.sh
+
+MOSTLYCLEANFILES = $(STAGESTUFF) ld1$(EXEEXT) ld2$(EXEEXT) ld3$(EXEEXT) \
+	ldemul-list.h crtbegin.@OBJEXT@ crtend.@OBJEXT@ ld.log ld.sum
+
+CLEANFILES = dep.sed DEP DEPA DEP1 DEP2 spu_ovl.s spu_ovl.@OBJEXT@ spu_icache.s spu_icache.@OBJEXT@
+
+# Stuff that should be included in a distribution.  The diststuff
+# target is run by the taz target in ../Makefile.in.
+EXTRA_DIST = ldgram.c ldgram.h ldlex.c emultempl/spu_ovl.@OBJEXT@_c \
+	     emultempl/spu_icache.@OBJEXT@_c deffilep.c deffilep.h $(man_MANS)
+
+DISTCLEANFILES = tdirs site.exp site.bak stringify.sed $(am__append_1)
+all: $(BUILT_SOURCES) config.h
+	$(MAKE) $(AM_MAKEFLAGS) all-recursive
+
+.SUFFIXES:
+.SUFFIXES: .c .dvi .l .lo .o .obj .ps .y
+am--refresh:
+	@:
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign'; \
+	      $(am__cd) $(srcdir) && $(AUTOMAKE) --foreign \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    echo ' $(SHELL) ./config.status'; \
+	    $(SHELL) ./config.status;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	$(SHELL) ./config.status --recheck
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	$(am__cd) $(srcdir) && $(AUTOCONF)
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)
+$(am__aclocal_m4_deps):
+
+config.h: stamp-h1
+	@if test ! -f $@; then \
+	  rm -f stamp-h1; \
+	  $(MAKE) $(AM_MAKEFLAGS) stamp-h1; \
+	else :; fi
+
+stamp-h1: $(srcdir)/config.in $(top_builddir)/config.status
+	@rm -f stamp-h1
+	cd $(top_builddir) && $(SHELL) ./config.status config.h
+$(srcdir)/config.in: @MAINTAINER_MODE_TRUE@ $(am__configure_deps) 
+	($(am__cd) $(top_srcdir) && $(AUTOHEADER))
+	rm -f stamp-h1
+	touch $@
+
+distclean-hdr:
+	-rm -f config.h stamp-h1
+po/Makefile.in: $(top_builddir)/config.status $(top_srcdir)/po/Make-in
+	cd $(top_builddir) && $(SHELL) ./config.status $@
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libldtestplug.la: $(libldtestplug_la_OBJECTS) $(libldtestplug_la_DEPENDENCIES) 
+	$(libldtestplug_la_LINK) $(am_libldtestplug_la_rpath) $(libldtestplug_la_OBJECTS) $(libldtestplug_la_LIBADD) $(LIBS)
+libldtestplug2.la: $(libldtestplug2_la_OBJECTS) $(libldtestplug2_la_DEPENDENCIES) 
+	$(libldtestplug2_la_LINK) $(am_libldtestplug2_la_rpath) $(libldtestplug2_la_OBJECTS) $(libldtestplug2_la_LIBADD) $(LIBS)
+libldtestplug3.la: $(libldtestplug3_la_OBJECTS) $(libldtestplug3_la_DEPENDENCIES) 
+	$(libldtestplug3_la_LINK) $(am_libldtestplug3_la_rpath) $(libldtestplug3_la_OBJECTS) $(libldtestplug3_la_LIBADD) $(LIBS)
+install-binPROGRAMS: $(bin_PROGRAMS)
+	@$(NORMAL_INSTALL)
+	test -z "$(bindir)" || $(MKDIR_P) "$(DESTDIR)$(bindir)"
+	@list='$(bin_PROGRAMS)'; test -n "$(bindir)" || list=; \
+	for p in $$list; do echo "$$p $$p"; done | \
+	sed 's/$(EXEEXT)$$//' | \
+	while read p p1; do if test -f $$p || test -f $$p1; \
+	  then echo "$$p"; echo "$$p"; else :; fi; \
+	done | \
+	sed -e 'p;s,.*/,,;n;h' -e 's|.*|.|' \
+	    -e 'p;x;s,.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/' | \
+	sed 'N;N;N;s,\n, ,g' | \
+	$(AWK) 'BEGIN { files["."] = ""; dirs["."] = 1 } \
+	  { d=$$3; if (dirs[d] != 1) { print "d", d; dirs[d] = 1 } \
+	    if ($$2 == $$4) files[d] = files[d] " " $$1; \
+	    else { print "f", $$3 "/" $$4, $$1; } } \
+	  END { for (d in files) print "f", d, files[d] }' | \
+	while read type dir files; do \
+	    if test "$$dir" = .; then dir=; else dir=/$$dir; fi; \
+	    test -z "$$files" || { \
+	    echo " $(INSTALL_PROGRAM_ENV) $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL_PROGRAM) $$files '$(DESTDIR)$(bindir)$$dir'"; \
+	    $(INSTALL_PROGRAM_ENV) $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL_PROGRAM) $$files "$(DESTDIR)$(bindir)$$dir" || exit $$?; \
+	    } \
+	; done
+
+uninstall-binPROGRAMS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(bin_PROGRAMS)'; test -n "$(bindir)" || list=; \
+	files=`for p in $$list; do echo "$$p"; done | \
+	  sed -e 'h;s,^.*/,,;s/$(EXEEXT)$$//;$(transform)' \
+	      -e 's/$$/$(EXEEXT)/' `; \
+	test -n "$$list" || exit 0; \
+	echo " ( cd '$(DESTDIR)$(bindir)' && rm -f" $$files ")"; \
+	cd "$(DESTDIR)$(bindir)" && rm -f $$files
+
+clean-binPROGRAMS:
+	@list='$(bin_PROGRAMS)'; test -n "$$list" || exit 0; \
+	echo " rm -f" $$list; \
+	rm -f $$list || exit $$?; \
+	test -n "$(EXEEXT)" || exit 0; \
+	list=`for p in $$list; do echo "$$p"; done | sed 's/$(EXEEXT)$$//'`; \
+	echo " rm -f" $$list; \
+	rm -f $$list
+ldgram.h: ldgram.c
+	@if test ! -f $@; then \
+	  rm -f ldgram.c; \
+	  $(MAKE) $(AM_MAKEFLAGS) ldgram.c; \
+	else :; fi
+deffilep.h: deffilep.c
+	@if test ! -f $@; then \
+	  rm -f deffilep.c; \
+	  $(MAKE) $(AM_MAKEFLAGS) deffilep.c; \
+	else :; fi
+ld-new$(EXEEXT): $(ld_new_OBJECTS) $(ld_new_DEPENDENCIES) 
+	@rm -f ld-new$(EXEEXT)
+	$(LINK) $(ld_new_OBJECTS) $(ld_new_LDADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/deffilep.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eaarch64cloudabi.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eaarch64cloudabib.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eaarch64elf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eaarch64elf32.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eaarch64elf32b.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eaarch64elfb.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eaarch64fbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eaarch64fbsdb.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eaarch64linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eaarch64linux32.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eaarch64linux32b.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eaarch64linuxb.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eaix5ppc.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eaix5rs6.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eaixppc.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eaixrs6.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ealpha.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ealphavms.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earcelf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earcelf_prof.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earclinux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earclinux_prof.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earcv2elf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earcv2elfx.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earm_epoc_pe.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earm_wince_pe.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmaoutb.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmaoutl.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmcoff.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmelf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmelf_fbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmelf_linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmelf_linux_eabi.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmelf_nacl.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmelf_nbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmelf_vxworks.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmelfb.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmelfb_fbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmelfb_linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmelfb_linux_eabi.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmelfb_nacl.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmelfb_nbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmnbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmnto.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmpe.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmsymbian.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavr1.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavr2.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavr25.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavr3.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavr31.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavr35.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavr4.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavr5.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavr51.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavr6.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavrtiny.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavrxmega1.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavrxmega2.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavrxmega3.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavrxmega4.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavrxmega5.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavrxmega6.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavrxmega7.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ecoff_i860.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ecoff_sparc.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ecrisaout.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ecriself.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ecrislinux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ed10velf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ed30v_e.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ed30v_o.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ed30velf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/edelta68.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32_dlx.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32_i860.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32_i960.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32_sparc.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32_sparc_sol2.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32_sparc_vxworks.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32_spu.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32_tic6x_be.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32_tic6x_elf_be.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32_tic6x_elf_le.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32_tic6x_le.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32_tic6x_linux_be.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32_tic6x_linux_le.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32_x86_64.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32_x86_64_nacl.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32am33lin.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32b4300.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32bfin.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32bfinfd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32bmip.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32bmipn32.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32bsmip.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32btsmip.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32btsmip_fbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32btsmipn32.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32btsmipn32_fbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32cr16.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32cr16c.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32crx.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ebmip.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ebmipvxworks.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32elmip.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32elmipvxworks.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32epiphany.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32epiphany_4x4.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32fr30.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32frv.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32frvfd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ft32.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32i370.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ip2k.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32iq10.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32iq2000.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32l4300.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32lm32.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32lm32fd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32lmip.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32lppc.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32lppclinux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32lppcnto.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32lppcsim.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32lr5900.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32lr5900n32.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32lsmip.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ltsmip.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ltsmip_fbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ltsmipn32.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ltsmipn32_fbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32m32c.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32mb_linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32mbel_linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32mcore.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32mep.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32metag.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32microblaze.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32microblazeel.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32mipswindiss.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32moxie.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32mt.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32or1k.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32or1k_linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ppc.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ppc_fbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ppclinux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ppcnto.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ppcsim.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ppcvxworks.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ppcwindiss.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32rl78.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32rx.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32tilegx.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32tilegx_be.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32tilepro.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32vax.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32visium.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32xc16x.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32xc16xl.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32xc16xs.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32xstormy16.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32xtensa.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64_aix.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64_ia64.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64_ia64_fbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64_ia64_vms.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64_s390.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64_sparc.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64_sparc_fbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64_sparc_sol2.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64alpha.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64alpha_fbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64alpha_nbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64bmip.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64btsmip.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64btsmip_fbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64hppa.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64lppc.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64ltsmip.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64ltsmip_fbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64mmix.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64ppc.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64ppc_fbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64rdos.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64tilegx.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64tilegx_be.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf_i386.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf_i386_be.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf_i386_chaos.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf_i386_fbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf_i386_ldso.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf_i386_nacl.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf_i386_sol2.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf_i386_vxworks.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf_iamcu.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf_k1om.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf_k1om_fbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf_l1om.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf_l1om_fbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf_s390.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf_x86_64.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf_x86_64_cloudabi.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf_x86_64_fbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf_x86_64_nacl.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf_x86_64_sol2.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/egld960.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/egld960coff.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8300.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8300elf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8300elf_linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8300h.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8300helf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8300helf_linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8300hn.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8300hnelf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8300s.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8300self.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8300self_linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8300sn.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8300snelf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8300sx.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8300sxelf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8300sxelf_linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8300sxn.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8300sxnelf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8500.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8500b.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8500c.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8500m.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8500s.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ehp300bsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ehp3hpux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ehppa64linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ehppaelf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ehppalinux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ehppanbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ehppaobsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ei386aout.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ei386beos.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ei386bsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ei386coff.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ei386go32.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ei386linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ei386lynx.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ei386mach.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ei386moss.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ei386msdos.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ei386nbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ei386nto.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ei386nw.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ei386pe.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ei386pe_posix.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ei386pep.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elnk960.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em32relf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em32relf_linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em32rlelf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em32rlelf_linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68hc11elf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68hc11elfb.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68hc12elf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68hc12elfb.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68k4knbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68kaout.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68kaux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68kcoff.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68kelf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68kelfnbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68klinux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68knbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68kpsos.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em88kbcs.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emcorepe.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emmo.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emn10200.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emn10300.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emoxiebox.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430X.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430elf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ends32belf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ends32belf16m.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ends32belf_linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ends32elf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ends32elf16m.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ends32elf_linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/enews.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/enios2elf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/enios2linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ens32knbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/epc532macha.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/epdp11.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/epjelf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/epjlelf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eppclynx.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eppcmacos.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eppcnw.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eppcpe.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eriscix.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/escore3_elf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/escore7_elf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/esh.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshelf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshelf32.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshelf32_linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshelf32_nbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshelf64.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshelf64_nbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshelf_fd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshelf_linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshelf_nbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshelf_nto.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshelf_uclinux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshelf_vxworks.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshl.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshlelf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshlelf32.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshlelf32_linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshlelf32_nbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshlelf64.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshlelf64_nbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshlelf_fd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshlelf_linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshlelf_nbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshlelf_nto.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshlelf_vxworks.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshlsymbian.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshpe.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/esparcaout.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/esparclinux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/esparcnbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/est2000.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/esun3.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/esun4.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/etic30aout.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/etic30coff.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/etic3xcoff.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/etic3xcoff_onchip.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/etic4xcoff.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/etic54xcoff.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/etic80coff.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ev850.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ev850_rh850.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/evanilla.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/evax.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/evaxnbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/evsta.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ew65.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/exgateelf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ez80.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ez8001.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ez8002.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldbuildid.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldcref.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldctor.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldemul.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldexp.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldfile.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldgram.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldlang.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldlex-wrapper.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldlex.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldmain.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldmisc.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldver.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldwrite.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lexsup.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libldtestplug2_la-testplug2.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libldtestplug3_la-testplug3.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libldtestplug_la-testplug.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mri.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pe-dll.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pep-dll.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/plugin.Po@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+libldtestplug_la-testplug.lo: testplug.c
+@am__fastdepCC_TRUE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libldtestplug_la_CFLAGS) $(CFLAGS) -MT libldtestplug_la-testplug.lo -MD -MP -MF $(DEPDIR)/libldtestplug_la-testplug.Tpo -c -o libldtestplug_la-testplug.lo `test -f 'testplug.c' || echo '$(srcdir)/'`testplug.c
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libldtestplug_la-testplug.Tpo $(DEPDIR)/libldtestplug_la-testplug.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='testplug.c' object='libldtestplug_la-testplug.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libldtestplug_la_CFLAGS) $(CFLAGS) -c -o libldtestplug_la-testplug.lo `test -f 'testplug.c' || echo '$(srcdir)/'`testplug.c
+
+libldtestplug2_la-testplug2.lo: testplug2.c
+@am__fastdepCC_TRUE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libldtestplug2_la_CFLAGS) $(CFLAGS) -MT libldtestplug2_la-testplug2.lo -MD -MP -MF $(DEPDIR)/libldtestplug2_la-testplug2.Tpo -c -o libldtestplug2_la-testplug2.lo `test -f 'testplug2.c' || echo '$(srcdir)/'`testplug2.c
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libldtestplug2_la-testplug2.Tpo $(DEPDIR)/libldtestplug2_la-testplug2.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='testplug2.c' object='libldtestplug2_la-testplug2.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libldtestplug2_la_CFLAGS) $(CFLAGS) -c -o libldtestplug2_la-testplug2.lo `test -f 'testplug2.c' || echo '$(srcdir)/'`testplug2.c
+
+libldtestplug3_la-testplug3.lo: testplug3.c
+@am__fastdepCC_TRUE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libldtestplug3_la_CFLAGS) $(CFLAGS) -MT libldtestplug3_la-testplug3.lo -MD -MP -MF $(DEPDIR)/libldtestplug3_la-testplug3.Tpo -c -o libldtestplug3_la-testplug3.lo `test -f 'testplug3.c' || echo '$(srcdir)/'`testplug3.c
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libldtestplug3_la-testplug3.Tpo $(DEPDIR)/libldtestplug3_la-testplug3.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='testplug3.c' object='libldtestplug3_la-testplug3.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libldtestplug3_la_CFLAGS) $(CFLAGS) -c -o libldtestplug3_la-testplug3.lo `test -f 'testplug3.c' || echo '$(srcdir)/'`testplug3.c
+
+.l.c:
+	$(am__skiplex) $(SHELL) $(YLWRAP) $< $(LEX_OUTPUT_ROOT).c $@ -- $(LEXCOMPILE)
+
+.y.c:
+	$(am__skipyacc) $(SHELL) $(YLWRAP) $< y.tab.c $@ y.tab.h $*.h y.output $*.output -- $(YACCCOMPILE)
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool config.lt
+
+ld.info: ld.texinfo $(ld_TEXINFOS)
+	restore=: && backupdir="$(am__leading_dot)am$$$$" && \
+	rm -rf $$backupdir && mkdir $$backupdir && \
+	if ($(MAKEINFO) --version) >/dev/null 2>&1; then \
+	  for f in $@ $@-[0-9] $@-[0-9][0-9] $(@:.info=).i[0-9] $(@:.info=).i[0-9][0-9]; do \
+	    if test -f $$f; then mv $$f $$backupdir; restore=mv; else :; fi; \
+	  done; \
+	else :; fi && \
+	if $(MAKEINFO) $(AM_MAKEINFOFLAGS) $(MAKEINFOFLAGS) -I $(srcdir) \
+	 -o $@ `test -f 'ld.texinfo' || echo '$(srcdir)/'`ld.texinfo; \
+	then \
+	  rc=0; \
+	else \
+	  rc=$$?; \
+	  $$restore $$backupdir/* `echo "./$@" | sed 's|[^/]*$$||'`; \
+	fi; \
+	rm -rf $$backupdir; exit $$rc
+
+ld.dvi: ld.texinfo $(ld_TEXINFOS) 
+	TEXINPUTS="$(am__TEXINFO_TEX_DIR)$(PATH_SEPARATOR)$$TEXINPUTS" \
+	MAKEINFO='$(MAKEINFO) $(AM_MAKEINFOFLAGS) $(MAKEINFOFLAGS) -I $(srcdir)' \
+	$(TEXI2DVI) -o $@ `test -f 'ld.texinfo' || echo '$(srcdir)/'`ld.texinfo
+
+ld.pdf: ld.texinfo $(ld_TEXINFOS) 
+	TEXINPUTS="$(am__TEXINFO_TEX_DIR)$(PATH_SEPARATOR)$$TEXINPUTS" \
+	MAKEINFO='$(MAKEINFO) $(AM_MAKEINFOFLAGS) $(MAKEINFOFLAGS) -I $(srcdir)' \
+	$(TEXI2PDF) -o $@ `test -f 'ld.texinfo' || echo '$(srcdir)/'`ld.texinfo
+
+ld.html: ld.texinfo $(ld_TEXINFOS) 
+	rm -rf $(@:.html=.htp)
+	if $(MAKEINFOHTML) $(AM_MAKEINFOHTMLFLAGS) $(MAKEINFOFLAGS) -I $(srcdir) \
+	 -o $(@:.html=.htp) `test -f 'ld.texinfo' || echo '$(srcdir)/'`ld.texinfo; \
+	then \
+	  rm -rf $@; \
+	  if test ! -d $(@:.html=.htp) && test -d $(@:.html=); then \
+	    mv $(@:.html=) $@; else mv $(@:.html=.htp) $@; fi; \
+	else \
+	  if test ! -d $(@:.html=.htp) && test -d $(@:.html=); then \
+	    rm -rf $(@:.html=); else rm -Rf $(@:.html=.htp) $@; fi; \
+	  exit 1; \
+	fi
+.dvi.ps:
+	TEXINPUTS="$(am__TEXINFO_TEX_DIR)$(PATH_SEPARATOR)$$TEXINPUTS" \
+	$(DVIPS) -o $@ $<
+
+uninstall-dvi-am:
+	@$(NORMAL_UNINSTALL)
+	@list='$(DVIS)'; test -n "$(dvidir)" || list=; \
+	for p in $$list; do \
+	  $(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(dvidir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(dvidir)/$$f"; \
+	done
+
+uninstall-html-am:
+	@$(NORMAL_UNINSTALL)
+	@list='$(HTMLS)'; test -n "$(htmldir)" || list=; \
+	for p in $$list; do \
+	  $(am__strip_dir) \
+	  echo " rm -rf '$(DESTDIR)$(htmldir)/$$f'"; \
+	  rm -rf "$(DESTDIR)$(htmldir)/$$f"; \
+	done
+
+uninstall-info-am:
+	@$(PRE_UNINSTALL)
+	@if test -d '$(DESTDIR)$(infodir)' && \
+	    (install-info --version && \
+	     install-info --version 2>&1 | sed 1q | grep -i -v debian) >/dev/null 2>&1; then \
+	  list='$(INFO_DEPS)'; \
+	  for file in $$list; do \
+	    relfile=`echo "$$file" | sed 's|^.*/||'`; \
+	    echo " install-info --info-dir='$(DESTDIR)$(infodir)' --remove '$(DESTDIR)$(infodir)/$$relfile'"; \
+	    if install-info --info-dir="$(DESTDIR)$(infodir)" --remove "$(DESTDIR)$(infodir)/$$relfile"; \
+	    then :; else test ! -f "$(DESTDIR)$(infodir)/$$relfile" || exit 1; fi; \
+	  done; \
+	else :; fi
+	@$(NORMAL_UNINSTALL)
+	@list='$(INFO_DEPS)'; \
+	for file in $$list; do \
+	  relfile=`echo "$$file" | sed 's|^.*/||'`; \
+	  relfile_i=`echo "$$relfile" | sed 's|\.info$$||;s|$$|.i|'`; \
+	  (if test -d "$(DESTDIR)$(infodir)" && cd "$(DESTDIR)$(infodir)"; then \
+	     echo " cd '$(DESTDIR)$(infodir)' && rm -f $$relfile $$relfile-[0-9] $$relfile-[0-9][0-9] $$relfile_i[0-9] $$relfile_i[0-9][0-9]"; \
+	     rm -f $$relfile $$relfile-[0-9] $$relfile-[0-9][0-9] $$relfile_i[0-9] $$relfile_i[0-9][0-9]; \
+	   else :; fi); \
+	done
+
+uninstall-pdf-am:
+	@$(NORMAL_UNINSTALL)
+	@list='$(PDFS)'; test -n "$(pdfdir)" || list=; \
+	for p in $$list; do \
+	  $(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(pdfdir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(pdfdir)/$$f"; \
+	done
+
+uninstall-ps-am:
+	@$(NORMAL_UNINSTALL)
+	@list='$(PSS)'; test -n "$(psdir)" || list=; \
+	for p in $$list; do \
+	  $(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(psdir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(psdir)/$$f"; \
+	done
+
+dist-info: $(INFO_DEPS)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	list='$(INFO_DEPS)'; \
+	for base in $$list; do \
+	  case $$base in \
+	    $(srcdir)/*) base=`echo "$$base" | sed "s|^$$srcdirstrip/||"`;; \
+	  esac; \
+	  if test -f $$base; then d=.; else d=$(srcdir); fi; \
+	  base_i=`echo "$$base" | sed 's|\.info$$||;s|$$|.i|'`; \
+	  for file in $$d/$$base $$d/$$base-[0-9] $$d/$$base-[0-9][0-9] $$d/$$base_i[0-9] $$d/$$base_i[0-9][0-9]; do \
+	    if test -f $$file; then \
+	      relfile=`expr "$$file" : "$$d/\(.*\)"`; \
+	      test -f "$(distdir)/$$relfile" || \
+		cp -p $$file "$(distdir)/$$relfile"; \
+	    else :; fi; \
+	  done; \
+	done
+
+mostlyclean-aminfo:
+	-rm -rf ld.aux ld.cp ld.cps ld.fn ld.fns ld.ky ld.log ld.pg ld.pgs ld.tmp \
+	  ld.toc ld.tp ld.tps ld.vr ld.vrs
+
+clean-aminfo:
+	-test -z "ld.dvi ld.pdf ld.ps ld.html" \
+	|| rm -rf ld.dvi ld.pdf ld.ps ld.html
+
+maintainer-clean-aminfo:
+	@list='$(INFO_DEPS)'; for i in $$list; do \
+	  i_i=`echo "$$i" | sed 's|\.info$$||;s|$$|.i|'`; \
+	  echo " rm -f $$i $$i-[0-9] $$i-[0-9][0-9] $$i_i[0-9] $$i_i[0-9][0-9]"; \
+	  rm -f $$i $$i-[0-9] $$i-[0-9][0-9] $$i_i[0-9] $$i_i[0-9][0-9]; \
+	done
+install-man1: $(man_MANS)
+	@$(NORMAL_INSTALL)
+	test -z "$(man1dir)" || $(MKDIR_P) "$(DESTDIR)$(man1dir)"
+	@list=''; test -n "$(man1dir)" || exit 0; \
+	{ for i in $$list; do echo "$$i"; done; \
+	l2='$(man_MANS)'; for i in $$l2; do echo "$$i"; done | \
+	  sed -n '/\.1[a-z]*$$/p'; \
+	} | while read p; do \
+	  if test -f $$p; then d=; else d="$(srcdir)/"; fi; \
+	  echo "$$d$$p"; echo "$$p"; \
+	done | \
+	sed -e 'n;s,.*/,,;p;h;s,.*\.,,;s,^[^1][0-9a-z]*$$,1,;x' \
+	      -e 's,\.[0-9a-z]*$$,,;$(transform);G;s,\n,.,' | \
+	sed 'N;N;s,\n, ,g' | { \
+	list=; while read file base inst; do \
+	  if test "$$base" = "$$inst"; then list="$$list $$file"; else \
+	    echo " $(INSTALL_DATA) '$$file' '$(DESTDIR)$(man1dir)/$$inst'"; \
+	    $(INSTALL_DATA) "$$file" "$(DESTDIR)$(man1dir)/$$inst" || exit $$?; \
+	  fi; \
+	done; \
+	for i in $$list; do echo "$$i"; done | $(am__base_list) | \
+	while read files; do \
+	  test -z "$$files" || { \
+	    echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(man1dir)'"; \
+	    $(INSTALL_DATA) $$files "$(DESTDIR)$(man1dir)" || exit $$?; }; \
+	done; }
+
+uninstall-man1:
+	@$(NORMAL_UNINSTALL)
+	@list=''; test -n "$(man1dir)" || exit 0; \
+	files=`{ for i in $$list; do echo "$$i"; done; \
+	l2='$(man_MANS)'; for i in $$l2; do echo "$$i"; done | \
+	  sed -n '/\.1[a-z]*$$/p'; \
+	} | sed -e 's,.*/,,;h;s,.*\.,,;s,^[^1][0-9a-z]*$$,1,;x' \
+	      -e 's,\.[0-9a-z]*$$,,;$(transform);G;s,\n,.,'`; \
+	test -z "$$files" || { \
+	  echo " ( cd '$(DESTDIR)$(man1dir)' && rm -f" $$files ")"; \
+	  cd "$(DESTDIR)$(man1dir)" && rm -f $$files; }
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+$(RECURSIVE_TARGETS):
+	@fail= failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+$(RECURSIVE_CLEAN_TARGETS):
+	@fail= failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	rev=''; for subdir in $$list; do \
+	  if test "$$subdir" = "."; then :; else \
+	    rev="$$subdir $$rev"; \
+	  fi; \
+	done; \
+	rev="$$rev ."; \
+	target=`echo $@ | sed s/-recursive//`; \
+	for subdir in $$rev; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES) config.in $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	  empty_fix=.; \
+	else \
+	  include_option=--include; \
+	  empty_fix=; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test ! -f $$subdir/TAGS || \
+	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS) config.in $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES) config.in $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS) config.in $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+site.exp: Makefile
+	@echo 'Making a new site.exp file...'
+	@echo '## these variables are automatically generated by make ##' >site.tmp
+	@echo '# Do not edit here.  If you wish to override these values' >>site.tmp
+	@echo '# edit the last section' >>site.tmp
+	@echo 'set srcdir $(srcdir)' >>site.tmp
+	@echo "set objdir `pwd`" >>site.tmp
+	@echo 'set build_alias "$(build_alias)"' >>site.tmp
+	@echo 'set build_triplet $(build_triplet)' >>site.tmp
+	@echo 'set host_alias "$(host_alias)"' >>site.tmp
+	@echo 'set host_triplet $(host_triplet)' >>site.tmp
+	@echo 'set target_alias "$(target_alias)"' >>site.tmp
+	@echo 'set target_triplet $(target_triplet)' >>site.tmp
+	@echo '## All variables above are generated by configure. Do Not Edit ##' >>site.tmp
+	@test ! -f site.exp || \
+	  sed '1,/^## All variables above are.*##/ d' site.exp >> site.tmp
+	@-rm -f site.bak
+	@test ! -f site.exp || mv site.exp site.bak
+	@mv site.tmp site.exp
+
+distclean-DEJAGNU:
+	-rm -f site.exp site.bak
+	-l='$(DEJATOOL)'; for tool in $$l; do \
+	  rm -f $$tool.sum $$tool.log; \
+	done
+check-am: all-am
+	$(MAKE) $(AM_MAKEFLAGS) check-DEJAGNU
+check: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) check-recursive
+all-am: Makefile $(INFO_DEPS) $(LTLIBRARIES) $(PROGRAMS) $(MANS) \
+		config.h
+installdirs: installdirs-recursive
+installdirs-am:
+	for dir in "$(DESTDIR)$(bindir)" "$(DESTDIR)$(infodir)" "$(DESTDIR)$(man1dir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+	-test -z "$(MOSTLYCLEANFILES)" || rm -f $(MOSTLYCLEANFILES)
+
+clean-generic:
+	-test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+	-test -z "$(DISTCLEANFILES)" || rm -f $(DISTCLEANFILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+	-rm -f deffilep.c
+	-rm -f deffilep.h
+	-rm -f ldgram.c
+	-rm -f ldgram.h
+	-rm -f ldlex.c
+	-test -z "$(BUILT_SOURCES)" || rm -f $(BUILT_SOURCES)
+	-test -z "$(MAINTAINERCLEANFILES)" || rm -f $(MAINTAINERCLEANFILES)
+clean: clean-recursive
+
+clean-am: clean-aminfo clean-binPROGRAMS clean-generic clean-libtool \
+	clean-noinstLTLIBRARIES mostlyclean-am
+
+distclean: distclean-recursive
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-DEJAGNU distclean-compile \
+	distclean-generic distclean-hdr distclean-libtool \
+	distclean-local distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am: $(DVIS)
+
+html: html-recursive
+
+html-am: $(HTMLS)
+
+info: info-recursive
+
+info-am: $(INFO_DEPS)
+
+install-data-am: install-data-local install-info-am install-man
+
+install-dvi: install-dvi-recursive
+
+install-dvi-am: $(DVIS)
+	@$(NORMAL_INSTALL)
+	test -z "$(dvidir)" || $(MKDIR_P) "$(DESTDIR)$(dvidir)"
+	@list='$(DVIS)'; test -n "$(dvidir)" || list=; \
+	for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  echo "$$d$$p"; \
+	done | $(am__base_list) | \
+	while read files; do \
+	  echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(dvidir)'"; \
+	  $(INSTALL_DATA) $$files "$(DESTDIR)$(dvidir)" || exit $$?; \
+	done
+install-exec-am: install-binPROGRAMS install-exec-local
+
+install-html: install-html-recursive
+
+install-html-am: $(HTMLS)
+	@$(NORMAL_INSTALL)
+	test -z "$(htmldir)" || $(MKDIR_P) "$(DESTDIR)$(htmldir)"
+	@list='$(HTMLS)'; list2=; test -n "$(htmldir)" || list=; \
+	for p in $$list; do \
+	  if test -f "$$p" || test -d "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  $(am__strip_dir) \
+	  if test -d "$$d$$p"; then \
+	    echo " $(MKDIR_P) '$(DESTDIR)$(htmldir)/$$f'"; \
+	    $(MKDIR_P) "$(DESTDIR)$(htmldir)/$$f" || exit 1; \
+	    echo " $(INSTALL_DATA) '$$d$$p'/* '$(DESTDIR)$(htmldir)/$$f'"; \
+	    $(INSTALL_DATA) "$$d$$p"/* "$(DESTDIR)$(htmldir)/$$f" || exit $$?; \
+	  else \
+	    list2="$$list2 $$d$$p"; \
+	  fi; \
+	done; \
+	test -z "$$list2" || { echo "$$list2" | $(am__base_list) | \
+	while read files; do \
+	  echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(htmldir)'"; \
+	  $(INSTALL_DATA) $$files "$(DESTDIR)$(htmldir)" || exit $$?; \
+	done; }
+install-info: install-info-recursive
+
+install-info-am: $(INFO_DEPS)
+	@$(NORMAL_INSTALL)
+	test -z "$(infodir)" || $(MKDIR_P) "$(DESTDIR)$(infodir)"
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	list='$(INFO_DEPS)'; test -n "$(infodir)" || list=; \
+	for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	  esac; \
+	  if test -f $$file; then d=.; else d=$(srcdir); fi; \
+	  file_i=`echo "$$file" | sed 's|\.info$$||;s|$$|.i|'`; \
+	  for ifile in $$d/$$file $$d/$$file-[0-9] $$d/$$file-[0-9][0-9] \
+	               $$d/$$file_i[0-9] $$d/$$file_i[0-9][0-9] ; do \
+	    if test -f $$ifile; then \
+	      echo "$$ifile"; \
+	    else : ; fi; \
+	  done; \
+	done | $(am__base_list) | \
+	while read files; do \
+	  echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(infodir)'"; \
+	  $(INSTALL_DATA) $$files "$(DESTDIR)$(infodir)" || exit $$?; done
+	@$(POST_INSTALL)
+	@if (install-info --version && \
+	     install-info --version 2>&1 | sed 1q | grep -i -v debian) >/dev/null 2>&1; then \
+	  list='$(INFO_DEPS)'; test -n "$(infodir)" || list=; \
+	  for file in $$list; do \
+	    relfile=`echo "$$file" | sed 's|^.*/||'`; \
+	    echo " install-info --info-dir='$(DESTDIR)$(infodir)' '$(DESTDIR)$(infodir)/$$relfile'";\
+	    install-info --info-dir="$(DESTDIR)$(infodir)" "$(DESTDIR)$(infodir)/$$relfile" || :;\
+	  done; \
+	else : ; fi
+install-man: install-man1
+
+install-pdf: install-pdf-recursive
+
+install-pdf-am: $(PDFS)
+	@$(NORMAL_INSTALL)
+	test -z "$(pdfdir)" || $(MKDIR_P) "$(DESTDIR)$(pdfdir)"
+	@list='$(PDFS)'; test -n "$(pdfdir)" || list=; \
+	for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  echo "$$d$$p"; \
+	done | $(am__base_list) | \
+	while read files; do \
+	  echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(pdfdir)'"; \
+	  $(INSTALL_DATA) $$files "$(DESTDIR)$(pdfdir)" || exit $$?; done
+install-ps: install-ps-recursive
+
+install-ps-am: $(PSS)
+	@$(NORMAL_INSTALL)
+	test -z "$(psdir)" || $(MKDIR_P) "$(DESTDIR)$(psdir)"
+	@list='$(PSS)'; test -n "$(psdir)" || list=; \
+	for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  echo "$$d$$p"; \
+	done | $(am__base_list) | \
+	while read files; do \
+	  echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(psdir)'"; \
+	  $(INSTALL_DATA) $$files "$(DESTDIR)$(psdir)" || exit $$?; done
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -rf $(top_srcdir)/autom4te.cache
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-aminfo \
+	maintainer-clean-generic
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-aminfo mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool mostlyclean-local
+
+pdf: pdf-recursive
+
+pdf-am: $(PDFS)
+
+ps: ps-recursive
+
+ps-am: $(PSS)
+
+uninstall-am: uninstall-binPROGRAMS uninstall-dvi-am uninstall-html-am \
+	uninstall-info-am uninstall-man uninstall-pdf-am \
+	uninstall-ps-am
+
+uninstall-man: uninstall-man1
+
+.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) all check \
+	check-am ctags-recursive install install-am install-strip \
+	tags-recursive
+
+.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
+	all all-am am--refresh check check-DEJAGNU check-am clean \
+	clean-aminfo clean-binPROGRAMS clean-generic clean-libtool \
+	clean-noinstLTLIBRARIES ctags ctags-recursive dist-info \
+	distclean distclean-DEJAGNU distclean-compile \
+	distclean-generic distclean-hdr distclean-libtool \
+	distclean-local distclean-tags dvi dvi-am html html-am info \
+	info-am install install-am install-binPROGRAMS install-data \
+	install-data-am install-data-local install-dvi install-dvi-am \
+	install-exec install-exec-am install-exec-local install-html \
+	install-html-am install-info install-info-am install-man \
+	install-man1 install-pdf install-pdf-am install-ps \
+	install-ps-am install-strip installcheck installcheck-am \
+	installdirs installdirs-am maintainer-clean \
+	maintainer-clean-aminfo maintainer-clean-generic mostlyclean \
+	mostlyclean-aminfo mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool mostlyclean-local pdf pdf-am ps ps-am tags \
+	tags-recursive uninstall uninstall-am uninstall-binPROGRAMS \
+	uninstall-dvi-am uninstall-html-am uninstall-info-am \
+	uninstall-man uninstall-man1 uninstall-pdf-am uninstall-ps-am
+
+
+# Disable -Werror, if it has been enabled, since old versions of bison/
+# yacc will produce working code which contain compile time warnings.
+ldgram.@OBJEXT@: ldgram.c
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `test -f ldgram.c || echo $(srcdir)/`ldgram.c $(NO_WERROR)
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='ldgram.c' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `test -f ldgram.c || echo $(srcdir)/`ldgram.c $(NO_WERROR)
+
+ldlex-wrapper.@OBJEXT@: ldlex-wrapper.c ldlex.c
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $(srcdir)/ldlex-wrapper.c $(NO_WERROR)
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='ldlex-wrapper.c' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $(srcdir)/ldlex-wrapper.c $(NO_WERROR)
+
+deffilep.@OBJEXT@: deffilep.c
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `test -f deffilep.c || echo $(srcdir)/`deffilep.c $(NO_WERROR)
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='deffilep.c' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `test -f deffilep.c || echo $(srcdir)/`deffilep.c $(NO_WERROR)
+
+po/POTFILES.in: @MAINT@ Makefile
+	for f in $(POTFILES); do echo $$f; done | LC_ALL=C sort > tmp \
+	  && mv tmp $(srcdir)/po/POTFILES.in
+
+ldmain.@OBJEXT@: ldmain.c config.status
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ \
+@am__fastdepCC_TRUE@	  -DDEFAULT_EMULATION='"$(EMUL)"' \
+@am__fastdepCC_TRUE@	  -DBINDIR='"$(bindir)"' -DTOOLBINDIR='"$(tooldir)/bin"' \
+@am__fastdepCC_TRUE@	  -DTARGET='"@target@"' @TARGET_SYSTEM_ROOT_DEFINE@ \
+@am__fastdepCC_TRUE@	  $(srcdir)/ldmain.c
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='ldmain.c' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c -DDEFAULT_EMULATION='"$(EMUL)"' \
+@am__fastdepCC_FALSE@	  -DBINDIR='"$(bindir)"' -DTOOLBINDIR='"$(tooldir)/bin"' \
+@am__fastdepCC_FALSE@	  -DTARGET='"@target@"' @TARGET_SYSTEM_ROOT_DEFINE@ \
+@am__fastdepCC_FALSE@	  $(srcdir)/ldmain.c
+
+ldfile.@OBJEXT@: ldfile.c config.status
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ \
+@am__fastdepCC_TRUE@	-DSCRIPTDIR='"$(scriptdir)"' -DBINDIR='"$(bindir)"' -DTOOLBINDIR='"$(tooldir)/bin"' \
+@am__fastdepCC_TRUE@	 $(srcdir)/ldfile.c
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='ldfile.c' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c -DSCRIPTDIR='"$(scriptdir)"' -DBINDIR='"$(bindir)"' \
+@am__fastdepCC_FALSE@	  -DTOOLBINDIR='"$(tooldir)/bin"' \
+@am__fastdepCC_FALSE@	  $(srcdir)/ldfile.c
+
+eelf32_spu.@OBJEXT@: eelf32_spu.c
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ \
+@am__fastdepCC_TRUE@	  -DEMBEDSPU="\"`echo embedspu | sed '$(transform)'`\"" eelf32_spu.c
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='eelf32_spu.c' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c -DEMBEDSPU="\"`echo embedspu | sed '$(transform)'`\"" \
+@am__fastdepCC_FALSE@	  eelf32_spu.c
+
+ldemul-list.h: Makefile
+	(echo "/* This file is automatically generated.  DO NOT EDIT! */";\
+	for f in `echo " " ${EMULATION_OFILES} "" \
+	 | sed -e 's/ e/ ld/g' -e 's/ ld/ /g' -e 's/[.]o//g'`; do \
+	    echo "extern ld_emulation_xfer_type ld_$${f}_emulation;"; \
+	done;\
+	echo "";\
+	echo "#define EMULATION_LIST \\";\
+	for f in `echo " " ${EMULATION_OFILES} "" \
+	 | sed -e 's/ e/ ld/g' -e 's/ ld/ /g' -e 's/[.]o//g'`; do \
+	    echo "  &ld_$${f}_emulation, \\"; \
+	done;\
+	echo "  0") >ldemul-tmp.h
+	mv ldemul-tmp.h ldemul-list.h
+
+stringify.sed: ${srcdir}/emultempl/$(STRINGIFY)
+	  cp ${srcdir}/emultempl/$(STRINGIFY) stringify.sed
+
+@TDIRS@
+
+# We can't use pattern rules as we don't want to depend on GNU
+# make, or else these rules could have been expressed in one
+# two-liner: 'e%.c:' and '	${GENSCRIPTS} $* "$(tdir_$*)"'.
+# (The recursive variable expansion is portable.)
+
+run-genscripts:
+	${GENSCRIPTS} $(script_target) "$($(script_tdirname))"
+
+.PHONY: run-genscripts
+
+$(ALL_EMULATION_SOURCES) $(ALL_64_EMULATION_SOURCES):
+	base=`echo $@ | sed -e 's,e\(.*\).c,\1,'`; \
+	$(MAKE) run-genscripts "script_target=$$base" "script_tdirname=tdir_$$base"
+
+eaix5ppc.c: $(srcdir)/emulparams/aix5ppc.sh \
+  $(srcdir)/emultempl/aix.em $(srcdir)/scripttempl/aix.sc ${GEN_DEPENDS}
+
+eaix5rs6.c: $(srcdir)/emulparams/aix5rs6.sh \
+  $(srcdir)/emultempl/aix.em $(srcdir)/scripttempl/aix.sc ${GEN_DEPENDS}
+
+eaixppc.c: $(srcdir)/emulparams/aixppc.sh \
+  $(srcdir)/emultempl/aix.em $(srcdir)/scripttempl/aix.sc ${GEN_DEPENDS}
+
+eaixrs6.c: $(srcdir)/emulparams/aixrs6.sh \
+  $(srcdir)/emultempl/aix.em $(srcdir)/scripttempl/aix.sc ${GEN_DEPENDS}
+
+ealpha.c: $(srcdir)/emulparams/alpha.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/alpha.sc ${GEN_DEPENDS}
+
+ealphavms.c: $(srcdir)/emulparams/alphavms.sh \
+  $(srcdir)/emultempl/vms.em $(srcdir)/scripttempl/alphavms.sc \
+  ${GEN_DEPENDS}
+
+earcv2elf.c: $(srcdir)/emulparams/arcv2elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elfarcv2.sc ${GEN_DEPENDS}
+
+earcv2elfx.c: $(srcdir)/emulparams/arcv2elfx.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elfarcv2.sc ${GEN_DEPENDS}
+
+earcelf.c: $(srcdir)/emulparams/arcelf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elfarc.sc ${GEN_DEPENDS}
+
+earcelf_prof.c: $(srcdir)/emulparams/arcelf_prof.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elfarc.sc ${GEN_DEPENDS}
+
+#for linux on arc
+earclinux.c: $(srcdir)/emulparams/arclinux.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/arclinux.em \
+  $(srcdir)/scripttempl/arclinux.sc ${GEN_DEPENDS}
+
+earclinux_prof.c: $(srcdir)/emulparams/arclinux_prof.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/arclinux.em \
+  $(srcdir)/scripttempl/arclinux.sc ${GEN_DEPENDS}
+
+earm_epoc_pe.c: $(srcdir)/emulparams/arm_epoc_pe.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/epocpe.sc ${GEN_DEPENDS}
+
+earm_wince_pe.c: $(srcdir)/emulparams/arm_wince_pe.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
+
+earmaoutb.c:	$(srcdir)/emulparams/armaoutb.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/armaout.sc ${GEN_DEPENDS}
+
+earmaoutl.c:	$(srcdir)/emulparams/armaoutl.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/armaout.sc ${GEN_DEPENDS}
+
+earmcoff.c:	$(srcdir)/emulparams/armcoff.sh \
+  $(srcdir)/emultempl/armcoff.em $(srcdir)/scripttempl/armcoff.sc ${GEN_DEPENDS}
+
+earmelf.c: $(srcdir)/emulparams/armelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+earmelf_fbsd.c: $(srcdir)/emulparams/armelf_fbsd.sh \
+  $(srcdir)/emulparams/armelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+earmelf_linux.c: $(srcdir)/emulparams/armelf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+earmelf_linux_eabi.c: $(srcdir)/emulparams/armelf_linux_eabi.sh \
+  $(srcdir)/emulparams/armelf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+earmelf_nacl.c: $(srcdir)/emulparams/armelf_nacl.sh \
+  $(srcdir)/emulparams/armelf_linux_eabi.sh \
+  $(srcdir)/emulparams/armelf_linux.sh \
+  $(srcdir)/emulparams/elf_nacl.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+earmelf_nbsd.c: $(srcdir)/emulparams/armelf_nbsd.sh \
+  $(srcdir)/emulparams/armelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+earmelf_vxworks.c: $(srcdir)/emulparams/armelf_vxworks.sh \
+  $(srcdir)/emulparams/vxworks.sh $(srcdir)/emulparams/armelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/vxworks.em \
+  $(srcdir)/emultempl/armelf.em $(srcdir)/scripttempl/elf.sc \
+  ${GEN_DEPENDS}
+
+earmelfb.c: $(srcdir)/emulparams/armelfb.sh $(srcdir)/emulparams/armelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+earmelfb_fbsd.c: $(srcdir)/emulparams/armelfb_fbsd.sh \
+  $(srcdir)/emulparams/armelf_fbsd.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+earmelfb_linux.c: $(srcdir)/emulparams/armelfb_linux.sh \
+  $(srcdir)/emulparams/armelf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+earmelfb_linux_eabi.c: $(srcdir)/emulparams/armelfb_linux_eabi.sh \
+  $(srcdir)/emulparams/armelf_linux_eabi.sh \
+  $(srcdir)/emulparams/armelf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+earmelfb_nacl.c: $(srcdir)/emulparams/armelfb_nacl.sh \
+  $(srcdir)/emulparams/armelf_nacl.sh \
+  $(srcdir)/emulparams/armelf_linux_eabi.sh \
+  $(srcdir)/emulparams/armelf_linux.sh \
+  $(srcdir)/emulparams/elf_nacl.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+earmelfb_nbsd.c: $(srcdir)/emulparams/armelfb_nbsd.sh \
+  $(srcdir)/emulparams/armelf_nbsd.sh \
+  $(srcdir)/emulparams/armelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+earmnbsd.c:	$(srcdir)/emulparams/armnbsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+earmnto.c: $(srcdir)/emulparams/armnto.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+earmpe.c: $(srcdir)/emulparams/armpe.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
+
+earmsymbian.c: $(srcdir)/emulparams/armsymbian.sh \
+  $(srcdir)/emulparams/armelf.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/armelf.em $(srcdir)/scripttempl/armbpabi.sc \
+  ${GEN_DEPENDS}
+
+eavr1.c: $(srcdir)/emulparams/avr1.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavr2.c: $(srcdir)/emulparams/avr2.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavr25.c: $(srcdir)/emulparams/avr25.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavr3.c: $(srcdir)/emulparams/avr3.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavr31.c: $(srcdir)/emulparams/avr31.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavr35.c: $(srcdir)/emulparams/avr35.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavr4.c: $(srcdir)/emulparams/avr4.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavr5.c: $(srcdir)/emulparams/avr5.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavr51.c: $(srcdir)/emulparams/avr51.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavr6.c: $(srcdir)/emulparams/avr6.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavrxmega1.c: $(srcdir)/emulparams/avrxmega1.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavrxmega2.c: $(srcdir)/emulparams/avrxmega2.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavrxmega3.c: $(srcdir)/emulparams/avrxmega3.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavrxmega4.c: $(srcdir)/emulparams/avrxmega4.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavrxmega5.c: $(srcdir)/emulparams/avrxmega5.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavrxmega6.c: $(srcdir)/emulparams/avrxmega6.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavrxmega7.c: $(srcdir)/emulparams/avrxmega7.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+
+eavrtiny.c: $(srcdir)/emulparams/avrtiny.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avrtiny.sc \
+  ${GEN_DEPENDS}
+
+ecoff_i860.c: $(srcdir)/emulparams/coff_i860.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/i860coff.sc ${GEN_DEPENDS}
+
+ecoff_sparc.c: $(srcdir)/emulparams/coff_sparc.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/sparccoff.sc ${GEN_DEPENDS}
+
+ecrisaout.c: $(srcdir)/emulparams/crisaout.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/crisaout.sc ${GEN_DEPENDS}
+
+ecriself.c: $(srcdir)/emulparams/criself.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+ecrislinux.c: $(srcdir)/emulparams/crislinux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+ed10velf.c: $(srcdir)/emulparams/d10velf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elfd10v.sc ${GEN_DEPENDS}
+
+ed30v_e.c: $(srcdir)/emulparams/d30v_e.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elfd30v.sc ${GEN_DEPENDS}
+
+ed30v_o.c: $(srcdir)/emulparams/d30v_o.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elfd30v.sc ${GEN_DEPENDS}
+
+ed30velf.c: $(srcdir)/emulparams/d30velf.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elfd30v.sc ${GEN_DEPENDS}
+
+edelta68.c: $(srcdir)/emulparams/delta68.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/delta68.sc ${GEN_DEPENDS}
+
+eelf32_dlx.c: $(srcdir)/emulparams/elf32_dlx.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/dlx.sc ${GEN_DEPENDS}
+
+eelf32_i860.c: $(srcdir)/emulparams/elf32_i860.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32_i960.c: $(srcdir)/emulparams/elf32_i960.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32_sparc.c: $(srcdir)/emulparams/elf32_sparc.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32_sparc_sol2.c: $(srcdir)/emulparams/elf32_sparc_sol2.sh \
+  $(srcdir)/emulparams/elf32_sparc.sh \
+  $(srcdir)/emulparams/solaris2.sh \
+  $(srcdir)/emultempl/solaris2.em $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32_sparc_vxworks.c: $(srcdir)/emulparams/elf32_sparc_vxworks.sh \
+  $(srcdir)/emulparams/vxworks.sh $(srcdir)/emulparams/elf32_sparc.sh \
+  $(srcdir)/emultempl/vxworks.em $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32_spu.c: $(srcdir)/emulparams/elf32_spu.sh $(srcdir)/emultempl/spuelf.em \
+  $(srcdir)/emultempl/spu_ovl.@OBJEXT@_c $(srcdir)/emultempl/spu_icache.@OBJEXT@_c \
+  ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+$(srcdir)/emultempl/spu_ovl.@OBJEXT@_c: @MAINT@ $(srcdir)/emultempl/spu_ovl.S
+	if ../gas/as-new --version \
+		| grep 'target.*spu' >/dev/null 2>/dev/null; then \
+	  cpp -DOVLY_IRQ_SAVE $(srcdir)/emultempl/spu_ovl.S spu_ovl.s; \
+	  ../gas/as-new -o spu_ovl.@OBJEXT@ spu_ovl.s; \
+	  ../binutils/bin2c <spu_ovl.@OBJEXT@ >$@; \
+	fi
+$(srcdir)/emultempl/spu_icache.@OBJEXT@_c: @MAINT@ $(srcdir)/emultempl/spu_icache.S
+	if ../gas/as-new --version \
+		| grep 'target.*spu' >/dev/null 2>/dev/null; then \
+	  cpp -DOVLY_IRQ_SAVE $(srcdir)/emultempl/spu_icache.S spu_icache.s; \
+	  ../gas/as-new -o spu_icache.@OBJEXT@ spu_icache.s; \
+	  ../binutils/bin2c <spu_icache.@OBJEXT@ >$@; \
+	fi
+eelf32_tic6x_be.c: $(srcdir)/emulparams/elf32_tic6x_be.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc $(srcdir)/emultempl/tic6xdsbt.em \
+  ${GEN_DEPENDS}
+
+eelf32_tic6x_elf_be.c: $(srcdir)/emulparams/elf32_tic6x_elf_be.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc  $(srcdir)/emultempl/tic6xdsbt.em \
+  ${GEN_DEPENDS}
+
+eelf32_tic6x_elf_le.c: $(srcdir)/emulparams/elf32_tic6x_elf_le.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc  $(srcdir)/emultempl/tic6xdsbt.em \
+  ${GEN_DEPENDS}
+
+eelf32_tic6x_le.c: $(srcdir)/emulparams/elf32_tic6x_le.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc $(srcdir)/emultempl/tic6xdsbt.em \
+  ${GEN_DEPENDS}
+
+eelf32_tic6x_linux_be.c: $(srcdir)/emulparams/elf32_tic6x_linux_be.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc  $(srcdir)/emultempl/tic6xdsbt.em \
+  ${GEN_DEPENDS}
+
+eelf32_tic6x_linux_le.c: $(srcdir)/emulparams/elf32_tic6x_linux_le.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc  $(srcdir)/emultempl/tic6xdsbt.em \
+  ${GEN_DEPENDS}
+
+eelf32am33lin.c: $(srcdir)/emulparams/elf32am33lin.sh \
+  $(srcdir)/emulparams/elf32am33lin.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32b4300.c: $(srcdir)/emulparams/elf32b4300.sh \
+  $(srcdir)/emulparams/elf32bmip.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32bfin.c: $(srcdir)/emulparams/elf32bfin.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/bfin.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32bfinfd.c: $(srcdir)/emulparams/elf32bfinfd.sh \
+  $(srcdir)/emulparams/elf32bfin.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/bfin.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32bmip.c: $(srcdir)/emulparams/elf32bmip.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32bmipn32.c: $(srcdir)/emulparams/elf32bmipn32.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/irix.em $(srcdir)/emultempl/mipself.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32bsmip.c: $(srcdir)/emulparams/elf32bsmip.sh \
+  $(srcdir)/emulparams/elf32bmip.sh $(ELF_DEPS) $(srcdir)/emultempl/irix.em \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32btsmip.c: $(srcdir)/emulparams/elf32btsmip.sh \
+  $(srcdir)/emulparams/elf32bmip.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32btsmip_fbsd.c: $(srcdir)/emulparams/elf32btsmip_fbsd.sh \
+  $(srcdir)/emulparams/elf32bmip.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32btsmipn32.c: $(srcdir)/emulparams/elf32btsmipn32.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32btsmipn32_fbsd.c: $(srcdir)/emulparams/elf32btsmipn32_fbsd.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32cr16.c: $(srcdir)/emulparams/elf32cr16.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/cr16elf.em \
+  $(srcdir)/scripttempl/elf32cr16.sc ${GEN_DEPENDS}
+
+eelf32cr16c.c: $(srcdir)/emulparams/elf32cr16c.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf32cr16c.sc ${GEN_DEPENDS}
+
+eelf32crx.c: $(srcdir)/emulparams/elf32crx.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/crxelf.em \
+  $(srcdir)/scripttempl/elf32crx.sc ${GEN_DEPENDS}
+
+eelf32ebmip.c: $(srcdir)/emulparams/elf32ebmip.sh \
+  $(srcdir)/emulparams/elf32bmip.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32ebmipvxworks.c: $(srcdir)/emulparams/elf32ebmipvxworks.sh \
+  $(srcdir)/emulparams/elf32bmip.sh $(srcdir)/emulparams/vxworks.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/generic.em $(srcdir)/emultempl/mipself.em \
+  $(srcdir)/emultempl/vxworks.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32elmip.c: $(srcdir)/emulparams/elf32elmip.sh \
+  $(srcdir)/emulparams/elf32lmip.sh $(srcdir)/emulparams/elf32bmip.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc \
+  ${GEN_DEPENDS}
+
+eelf32elmipvxworks.c: $(srcdir)/emulparams/elf32elmipvxworks.sh \
+  $(srcdir)/emulparams/elf32bmip.sh $(srcdir)/emulparams/vxworks.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/generic.em $(srcdir)/emultempl/mipself.em \
+  $(srcdir)/emultempl/vxworks.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32lr5900.c: $(srcdir)/emulparams/elf32lr5900.sh \
+  $(srcdir)/emulparams/elf32bmip.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc \
+  ${GEN_DEPENDS}
+
+eelf32lr5900n32.c: $(srcdir)/emulparams/elf32lr5900n32.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc \
+  ${GEN_DEPENDS}
+
+eelf32epiphany.c: $(srcdir)/emulparams/elf32epiphany.sh \
+  $(ELF_DEPS) ${GEN_DEPENDS}
+
+eelf32epiphany_4x4.c: $(srcdir)/emulparams/elf32epiphany_4x4.sh \
+  $(srcdir)/emultempl/elf32.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/epiphany_4x4.sc ${GEN_DEPENDS}
+
+eelf32fr30.c: $(srcdir)/emulparams/elf32fr30.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32frv.c: $(srcdir)/emulparams/elf32frv.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32frvfd.c: $(srcdir)/emulparams/elf32frvfd.sh \
+  $(srcdir)/emulparams/elf32frv.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32ft32.c: $(srcdir)/emulparams/elf32ft32.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32i370.c: $(srcdir)/emulparams/elf32i370.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elfi370.sc ${GEN_DEPENDS}
+
+eelf32ip2k.c: $(srcdir)/emulparams/elf32ip2k.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32iq10.c: $(srcdir)/emulparams/elf32iq10.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/iq2000.sc ${GEN_DEPENDS}
+
+eelf32iq2000.c: $(srcdir)/emulparams/elf32iq2000.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/iq2000.sc ${GEN_DEPENDS}
+
+eelf32l4300.c: $(srcdir)/emulparams/elf32l4300.sh \
+  $(srcdir)/emulparams/elf32b4300.sh $(srcdir)/emulparams/elf32bmip.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc \
+  ${GEN_DEPENDS}
+
+eelf32lm32.c: $(srcdir)/emulparams/elf32lm32.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32lm32fd.c: $(srcdir)/emulparams/elf32lm32fd.sh \
+  $(srcdir)/emulparams/elf32lm32.sh $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32lmip.c: $(srcdir)/emulparams/elf32lmip.sh \
+  $(srcdir)/emulparams/elf32bmip.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32lppc.c: $(srcdir)/emulparams/elf32lppc.sh \
+  $(srcdir)/emulparams/elf32ppccommon.sh \
+  $(srcdir)/emulparams/elf32ppc.sh \
+  $(srcdir)/emultempl/ppc32elf.em ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32lppclinux.c: $(srcdir)/emulparams/elf32lppclinux.sh \
+  $(srcdir)/emulparams/elf32lppc.sh $(srcdir)/emulparams/elf32ppc.sh \
+  $(srcdir)/emulparams/elf32ppccommon.sh \
+  $(srcdir)/emultempl/ppc32elf.em ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32lppcnto.c: $(srcdir)/emulparams/elf32lppcnto.sh \
+  $(srcdir)/emulparams/elf32ppc.sh $(srcdir)/emulparams/elf32ppccommon.sh \
+  $(srcdir)/emultempl/ppc32elf.em ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32lppcsim.c: $(srcdir)/emulparams/elf32lppcsim.sh \
+  $(srcdir)/emulparams/elf32lppc.sh $(srcdir)/emulparams/elf32ppc.sh \
+  $(srcdir)/emulparams/elf32ppccommon.sh \
+  $(srcdir)/emultempl/ppc32elf.em ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32lsmip.c: $(srcdir)/emulparams/elf32lsmip.sh \
+  $(srcdir)/emulparams/elf32lmip.sh $(srcdir)/emulparams/elf32bmip.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc \
+  ${GEN_DEPENDS}
+
+eelf32ltsmip.c: $(srcdir)/emulparams/elf32ltsmip.sh \
+  $(srcdir)/emulparams/elf32btsmip.sh $(srcdir)/emulparams/elf32bmip.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc \
+  ${GEN_DEPENDS}
+
+eelf32ltsmip_fbsd.c: $(srcdir)/emulparams/elf32ltsmip_fbsd.sh \
+  $(srcdir)/emulparams/elf32btsmip.sh $(srcdir)/emulparams/elf32bmip.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc \
+  ${GEN_DEPENDS}
+
+eelf32ltsmipn32.c: $(srcdir)/emulparams/elf32ltsmipn32.sh \
+  $(srcdir)/emulparams/elf32btsmipn32.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32ltsmipn32_fbsd.c: $(srcdir)/emulparams/elf32ltsmipn32_fbsd.sh \
+  $(srcdir)/emulparams/elf32btsmipn32.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32m32c.c: $(srcdir)/emulparams/elf32m32c.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32mbel_linux.c: $(srcdir)/emulparams/elf32mbel_linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32mb_linux.c: $(srcdir)/emulparams/elf32mb_linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32mcore.c: $(srcdir)/emulparams/elf32mcore.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32mep.c: $(srcdir)/emulparams/elf32mep.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/mep.sc ${GEN_DEPENDS}
+
+eelf32metag.c: $(srcdir)/emulparams/elf32metag.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/metagelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32microblazeel.c: $(srcdir)/emulparams/elf32microblazeel.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elfmicroblaze.sc ${GEN_DEPENDS}
+
+eelf32microblaze.c: $(srcdir)/emulparams/elf32microblaze.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elfmicroblaze.sc ${GEN_DEPENDS}
+
+eelf32mipswindiss.c: $(srcdir)/emulparams/elf32mipswindiss.sh $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32moxie.c: $(srcdir)/emulparams/elf32moxie.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+emoxiebox.c: $(srcdir)/emulparams/moxiebox.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32mt.c: $(srcdir)/emulparams/elf32mt.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32or1k.c: $(srcdir)/emulparams/elf32or1k.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32or1k_linux.c: $(srcdir)/emulparams/elf32or1k_linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32ppc.c: $(srcdir)/emulparams/elf32ppc.sh \
+  $(srcdir)/emulparams/elf32ppccommon.sh \
+  $(srcdir)/emultempl/ppc32elf.em ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32ppc_fbsd.c: $(srcdir)/emulparams/elf32ppc_fbsd.sh \
+  $(srcdir)/emulparams/elf32ppc.sh $(srcdir)/emulparams/elf32ppccommon.sh \
+  $(srcdir)/emultempl/ppc32elf.em ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32ppclinux.c: $(srcdir)/emulparams/elf32ppclinux.sh \
+  $(srcdir)/emulparams/elf32ppc.sh $(srcdir)/emulparams/elf32ppccommon.sh \
+  $(srcdir)/emultempl/ppc32elf.em ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32ppcnto.c: $(srcdir)/emulparams/elf32ppcnto.sh \
+  $(srcdir)/emulparams/elf32ppc.sh $(srcdir)/emulparams/elf32ppccommon.sh \
+  $(srcdir)/emultempl/ppc32elf.em ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32ppcsim.c: $(srcdir)/emulparams/elf32ppcsim.sh \
+  $(srcdir)/emulparams/elf32ppc.sh $(srcdir)/emulparams/elf32ppccommon.sh \
+  $(srcdir)/emultempl/ppc32elf.em ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32ppcvxworks.c: $(srcdir)/emulparams/elf32ppcvxworks.sh \
+  $(srcdir)/emulparams/elf32ppccommon.sh $(srcdir)/emulparams/vxworks.sh \
+  $(srcdir)/emultempl/ppc32elf.em ldemul-list.h \
+  $(srcdir)/emultempl/vxworks.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32ppcwindiss.c: $(srcdir)/emulparams/elf32ppcwindiss.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32rl78.c: $(srcdir)/emulparams/elf32rl78.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32rx.c: $(srcdir)/emulparams/elf32rx.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32tilegx.c: $(srcdir)/emulparams/elf32tilegx.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32tilegx_be.c: $(srcdir)/emulparams/elf32tilegx_be.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32tilepro.c: $(srcdir)/emulparams/elf32tilepro.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32vax.c: $(srcdir)/emulparams/elf32vax.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32visium.c: $(srcdir)/emulparams/elf32visium.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/visium.sc ${GEN_DEPENDS}
+
+eelf32xc16x.c: $(srcdir)/emulparams/elf32xc16x.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32xc16xl.c: $(srcdir)/emulparams/elf32xc16xl.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32xc16xs.c: $(srcdir)/emulparams/elf32xc16xs.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32xstormy16.c: $(srcdir)/emulparams/elf32xstormy16.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/xstormy16.sc ${GEN_DEPENDS}
+
+eelf32xtensa.c: $(srcdir)/emulparams/elf32xtensa.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/xtensaelf.em $(INCDIR)/xtensa-config.h \
+  $(BFDDIR)/elf-bfd.h $(BFDDIR)/libbfd.h $(INCDIR)/elf/xtensa.h \
+  $(srcdir)/scripttempl/elfxtensa.sc ${GEN_DEPENDS}
+
+eelf_i386.c: $(srcdir)/emulparams/elf_i386.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_i386_be.c: $(srcdir)/emulparams/elf_i386_be.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_i386_chaos.c: $(srcdir)/emulparams/elf_i386_chaos.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf_chaos.sc ${GEN_DEPENDS}
+
+eelf_i386_fbsd.c: $(srcdir)/emulparams/elf_i386_fbsd.sh \
+  $(srcdir)/emulparams/elf_i386.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_i386_ldso.c: $(srcdir)/emulparams/elf_i386_ldso.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_i386_nacl.c: $(srcdir)/emulparams/elf_i386_nacl.sh \
+  $(srcdir)/emulparams/elf_i386.sh \
+  $(srcdir)/emulparams/elf_nacl.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_i386_sol2.c: $(srcdir)/emulparams/elf_i386_sol2.sh \
+  $(srcdir)/emulparams/solaris2.sh \
+  $(srcdir)/emultempl/solaris2.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_i386_vxworks.c: $(srcdir)/emulparams/elf_i386_vxworks.sh \
+  $(srcdir)/emulparams/vxworks.sh $(srcdir)/emultempl/vxworks.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_iamcu.c: $(srcdir)/emulparams/elf_iamcu.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_s390.c: $(srcdir)/emulparams/elf_s390.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+egld960.c: $(srcdir)/emulparams/gld960.sh \
+  $(srcdir)/emultempl/gld960.em $(srcdir)/scripttempl/i960.sc ${GEN_DEPENDS}
+
+egld960coff.c: $(srcdir)/emulparams/gld960coff.sh \
+  $(srcdir)/emultempl/gld960c.em $(srcdir)/scripttempl/i960.sc ${GEN_DEPENDS}
+
+eh8300.c: $(srcdir)/emulparams/h8300.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8300.sc ${GEN_DEPENDS}
+
+eh8300elf.c: $(srcdir)/emulparams/h8300elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eh8300elf_linux.c: $(srcdir)/emulparams/h8300elf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eh8300h.c: $(srcdir)/emulparams/h8300h.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8300h.sc ${GEN_DEPENDS}
+
+eh8300helf.c: $(srcdir)/emulparams/h8300helf.sh \
+  $(srcdir)/emulparams/h8300elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eh8300helf_linux.c: $(srcdir)/emulparams/h8300helf_linux.sh \
+  $(srcdir)/emulparams/h8300elf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eh8300hn.c: $(srcdir)/emulparams/h8300hn.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8300hn.sc ${GEN_DEPENDS}
+
+eh8300hnelf.c: $(srcdir)/emulparams/h8300hnelf.sh \
+  $(srcdir)/emulparams/h8300elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eh8300s.c: $(srcdir)/emulparams/h8300s.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8300s.sc ${GEN_DEPENDS}
+
+eh8300self.c: $(srcdir)/emulparams/h8300self.sh \
+  $(srcdir)/emulparams/h8300elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eh8300self_linux.c: $(srcdir)/emulparams/h8300self_linux.sh \
+  $(srcdir)/emulparams/h8300elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eh8300sn.c: $(srcdir)/emulparams/h8300sn.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8300sn.sc ${GEN_DEPENDS}
+
+eh8300snelf.c: $(srcdir)/emulparams/h8300snelf.sh \
+  $(srcdir)/emulparams/h8300elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eh8300sx.c: $(srcdir)/emulparams/h8300sx.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8300sx.sc ${GEN_DEPENDS}
+
+eh8300sxelf.c: $(srcdir)/emulparams/h8300sxelf.sh \
+  $(srcdir)/emulparams/h8300elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eh8300sxelf_linux.c: $(srcdir)/emulparams/h8300sxelf_linux.sh \
+  $(srcdir)/emulparams/h8300elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eh8300sxn.c: $(srcdir)/emulparams/h8300sxn.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8300sxn.sc ${GEN_DEPENDS}
+
+eh8300sxnelf.c: $(srcdir)/emulparams/h8300sxnelf.sh \
+  $(srcdir)/emulparams/h8300elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eh8500.c: $(srcdir)/emulparams/h8500.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8500.sc ${GEN_DEPENDS}
+
+eh8500b.c: $(srcdir)/emulparams/h8500b.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8500b.sc ${GEN_DEPENDS}
+
+eh8500c.c: $(srcdir)/emulparams/h8500c.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8500c.sc ${GEN_DEPENDS}
+
+eh8500m.c: $(srcdir)/emulparams/h8500m.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8500m.sc ${GEN_DEPENDS}
+
+eh8500s.c: $(srcdir)/emulparams/h8500s.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8500s.sc ${GEN_DEPENDS}
+
+ehp300bsd.c: $(srcdir)/emulparams/hp300bsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+ehp3hpux.c: $(srcdir)/emulparams/hp3hpux.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+ehppaelf.c: $(srcdir)/emulparams/hppaelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/hppaelf.em \
+  $(srcdir)/scripttempl/hppaelf.sc ${GEN_DEPENDS}
+
+ehppalinux.c: $(srcdir)/emulparams/hppalinux.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/hppaelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+ehppanbsd.c: $(srcdir)/emulparams/hppanbsd.sh \
+  $(srcdir)/emulparams/hppaelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/hppaelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+ehppaobsd.c: $(srcdir)/emulparams/hppaobsd.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/hppaelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+ei386aout.c: $(srcdir)/emulparams/i386aout.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+ei386beos.c: $(srcdir)/emulparams/i386beos.sh \
+  $(srcdir)/emultempl/beos.em $(srcdir)/scripttempl/i386beos.sc ${GEN_DEPENDS}
+
+ei386bsd.c: $(srcdir)/emulparams/i386bsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+ei386coff.c: $(srcdir)/emulparams/i386coff.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/i386coff.sc ${GEN_DEPENDS}
+
+ei386go32.c: $(srcdir)/emulparams/i386go32.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/i386go32.sc ${GEN_DEPENDS}
+
+ei386linux.c: $(srcdir)/emulparams/i386linux.sh \
+  $(srcdir)/emultempl/linux.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+ei386lynx.c: $(srcdir)/emulparams/i386lynx.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+ei386mach.c: $(srcdir)/emulparams/i386mach.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+ei386moss.c: $(srcdir)/emulparams/i386moss.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+ei386msdos.c: $(srcdir)/emulparams/i386msdos.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/i386msdos.sc ${GEN_DEPENDS}
+
+ei386nbsd.c:	$(srcdir)/emulparams/i386nbsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+ei386nto.c:	$(srcdir)/emulparams/i386nto.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+ei386nw.c:	$(srcdir)/emulparams/i386nw.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/nw.sc ${GEN_DEPENDS}
+
+ei386pe.c: $(srcdir)/emulparams/i386pe.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
+
+ei386pe_posix.c: $(srcdir)/emulparams/i386pe_posix.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
+
+ei386pep.c: $(srcdir)/emulparams/i386pep.sh \
+  $(srcdir)/emultempl/pep.em $(srcdir)/scripttempl/pep.sc ${GEN_DEPENDS}
+
+elnk960.c: $(srcdir)/emulparams/lnk960.sh \
+  $(srcdir)/emultempl/lnk960.em $(srcdir)/scripttempl/i960.sc ${GEN_DEPENDS}
+
+em32relf.c: $(srcdir)/emulparams/m32relf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+em32relf_linux.c: $(srcdir)/emulparams/m32relf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+em32rlelf.c: $(srcdir)/emulparams/m32rlelf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+em32rlelf_linux.c: $(srcdir)/emulparams/m32rlelf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+em68hc11elf.c: $(srcdir)/emulparams/m68hc11elf.sh \
+  $(srcdir)/emultempl/m68hc1xelf.em $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elfm68hc11.sc ${GEN_DEPENDS}
+
+em68hc11elfb.c: $(srcdir)/emulparams/m68hc11elfb.sh \
+  $(srcdir)/emultempl/m68hc1xelf.em $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elfm68hc11.sc ${GEN_DEPENDS}
+
+em68hc12elf.c: $(srcdir)/emulparams/m68hc12elf.sh \
+  $(srcdir)/emultempl/m68hc1xelf.em $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elfm68hc12.sc ${GEN_DEPENDS}
+
+em68hc12elfb.c: $(srcdir)/emulparams/m68hc12elfb.sh \
+  $(srcdir)/emultempl/m68hc1xelf.em $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elfm68hc12.sc ${GEN_DEPENDS}
+
+em68k4knbsd.c:	$(srcdir)/emulparams/m68k4knbsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+em68kaout.c: $(srcdir)/emulparams/m68kaout.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+em68kaux.c: $(srcdir)/emulparams/m68kaux.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/m68kaux.sc ${GEN_DEPENDS}
+
+em68kcoff.c: $(srcdir)/emulparams/m68kcoff.sh \
+  $(srcdir)/emultempl/m68kcoff.em $(srcdir)/scripttempl/m68kcoff.sc ${GEN_DEPENDS}
+
+em68kelf.c: $(srcdir)/emulparams/m68kelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/m68kelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+em68kelfnbsd.c: $(srcdir)/emulparams/m68kelfnbsd.sh \
+  $(srcdir)/emulparams/m68kelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/m68kelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+em68klinux.c: $(srcdir)/emulparams/m68klinux.sh \
+  $(srcdir)/emultempl/linux.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+em68knbsd.c:	$(srcdir)/emulparams/m68knbsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+em68kpsos.c:	$(srcdir)/emulparams/m68kpsos.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/psos.sc ${GEN_DEPENDS}
+
+em88kbcs.c: $(srcdir)/emulparams/m88kbcs.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/m88kbcs.sc ${GEN_DEPENDS}
+
+emcorepe.c: $(srcdir)/emulparams/mcorepe.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
+
+emn10200.c: $(srcdir)/emulparams/mn10200.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+emn10300.c: $(srcdir)/emulparams/mn10300.sh \
+  $(srcdir)/emulparams/mn10200.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+emsp430elf.c: $(srcdir)/emulparams/msp430elf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/msp430.em \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc ${GEN_DEPENDS}
+
+emsp430X.c: $(srcdir)/emulparams/msp430elf.sh $(srcdir)/emulparams/msp430X.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/msp430.em \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc ${GEN_DEPENDS}
+
+ends32elf.c: $(srcdir)/emulparams/nds32elf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/nds32elf.em \
+  $(srcdir)/scripttempl/nds32elf.sc ${GEN_DEPENDS}
+
+ends32elf16m.c: $(srcdir)/emulparams/nds32elf16m.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/nds32elf.em \
+  $(srcdir)/scripttempl/nds32elf.sc ${GEN_DEPENDS}
+
+ends32belf.c: $(srcdir)/emulparams/nds32belf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/nds32elf.em \
+  $(srcdir)/scripttempl/nds32elf.sc ${GEN_DEPENDS}
+
+ends32belf16m.c: $(srcdir)/emulparams/nds32belf16m.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/nds32elf.em \
+  $(srcdir)/scripttempl/nds32elf.sc ${GEN_DEPENDS}
+
+ends32elf_linux.c: $(srcdir)/emulparams/nds32elf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/nds32elf.em \
+  $(srcdir)/scripttempl/nds32elf.sc ${GEN_DEPENDS}
+
+ends32belf_linux.c: $(srcdir)/emulparams/nds32belf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/nds32elf.em \
+  $(srcdir)/scripttempl/nds32elf.sc ${GEN_DEPENDS}
+
+enews.c: $(srcdir)/emulparams/news.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+enios2elf.c: $(srcdir)/emulparams/nios2elf.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/nios2elf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+enios2linux.c: $(srcdir)/emulparams/nios2linux.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/nios2elf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+ens32knbsd.c:	$(srcdir)/emulparams/ns32knbsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/emultempl/netbsd.em \
+  $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+eaarch64elf.c: $(srcdir)/emulparams/aarch64elf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/aarch64elf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eaarch64elf32.c: $(srcdir)/emulparams/aarch64elf32.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/aarch64elf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eaarch64elfb.c: $(srcdir)/emulparams/aarch64elfb.sh $(srcdir)/emulparams/aarch64elf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/aarch64elf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eaarch64elf32b.c: $(srcdir)/emulparams/aarch64elf32b.sh $(srcdir)/emulparams/aarch64elf32.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/aarch64elf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eaarch64cloudabi.c: $(srcdir)/emulparams/aarch64cloudabi.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/aarch64elf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eaarch64cloudabib.c: $(srcdir)/emulparams/aarch64cloudabib.sh $(srcdir)/emulparams/aarch64cloudabi.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/aarch64elf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eaarch64fbsd.c: $(srcdir)/emulparams/aarch64fbsd.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/aarch64elf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eaarch64fbsdb.c: $(srcdir)/emulparams/aarch64fbsdb.sh $(srcdir)/emulparams/aarch64fbsd.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/aarch64elf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eaarch64linux.c: $(srcdir)/emulparams/aarch64linux.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/aarch64elf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eaarch64linuxb.c: $(srcdir)/emulparams/aarch64linuxb.sh $(srcdir)/emulparams/aarch64linux.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/aarch64elf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eaarch64linux32.c: $(srcdir)/emulparams/aarch64linux32.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/aarch64elf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eaarch64linux32b.c: $(srcdir)/emulparams/aarch64linux32b.sh $(srcdir)/emulparams/aarch64linux32.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/aarch64elf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+epc532macha.c: $(srcdir)/emulparams/pc532macha.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+epdp11.c: $(srcdir)/emulparams/pdp11.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+epjelf.c: $(srcdir)/emulparams/pjelf.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+epjlelf.c: $(srcdir)/emulparams/pjlelf.sh $(srcdir)/emulparams/pjelf.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eppclynx.c: $(srcdir)/emulparams/ppclynx.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eppcmacos.c:	$(srcdir)/emulparams/ppcmacos.sh \
+  $(srcdir)/emultempl/aix.em $(srcdir)/scripttempl/aix.sc ${GEN_DEPENDS}
+
+eppcnw.c:	$(srcdir)/emulparams/ppcnw.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/nw.sc ${GEN_DEPENDS}
+
+eppcpe.c: $(srcdir)/emulparams/ppcpe.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/ppcpe.sc ${GEN_DEPENDS}
+
+eriscix.c: $(srcdir)/emulparams/riscix.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+escore3_elf.c: $(srcdir)/emulparams/score3_elf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/scoreelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+escore7_elf.c: $(srcdir)/emulparams/score3_elf.sh \
+  $(srcdir)/emulparams/score7_elf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/scoreelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+esh.c: $(srcdir)/emulparams/sh.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/sh.sc ${GEN_DEPENDS}
+
+eshelf.c: $(srcdir)/emulparams/shelf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshelf32.c: $(srcdir)/emulparams/shelf32.sh \
+  $(BFDDIR)/libbfd.h $(INCDIR)/libiberty.h \
+  $(srcdir)/emultempl/sh64elf.em $(INCDIR)/elf/sh.h $(BFDDIR)/elf-bfd.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshelf32_linux.c: $(srcdir)/emulparams/shelf32_linux.sh \
+  $(srcdir)/emulparams/shelf32.sh \
+  $(BFDDIR)/libbfd.h $(INCDIR)/libiberty.h \
+  $(srcdir)/emultempl/sh64elf.em $(INCDIR)/elf/sh.h $(BFDDIR)/elf-bfd.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshelf32_nbsd.c: $(srcdir)/emulparams/shelf32_nbsd.sh \
+  $(srcdir)/emulparams/shelf32.sh \
+  $(BFDDIR)/libbfd.h $(INCDIR)/libiberty.h \
+  $(srcdir)/emultempl/sh64elf.em $(INCDIR)/elf/sh.h $(BFDDIR)/elf-bfd.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshelf_fd.c: $(srcdir)/emulparams/shelf_fd.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshelf_linux.c: $(srcdir)/emulparams/shelf_linux.sh \
+  $(srcdir)/emulparams/shlelf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshelf_nbsd.c: $(srcdir)/emulparams/shelf_nbsd.sh \
+  $(srcdir)/emulparams/shelf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshelf_nto.c: $(srcdir)/emulparams/shelf_nto.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshelf_uclinux.c: $(srcdir)/emulparams/shelf_uclinux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshelf_vxworks.c: $(srcdir)/emulparams/shelf_vxworks.sh \
+  $(srcdir)/emulparams/vxworks.sh $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc \
+  $(srcdir)/emultempl/vxworks.em ${GEN_DEPENDS}
+
+eshl.c: $(srcdir)/emulparams/shl.sh \
+  $(srcdir)/emulparams/sh.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/sh.sc ${GEN_DEPENDS}
+
+eshlelf.c: $(srcdir)/emulparams/shlelf.sh \
+  $(srcdir)/emulparams/shelf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshlelf32.c: $(srcdir)/emulparams/shlelf32.sh \
+  $(BFDDIR)/libbfd.h $(INCDIR)/libiberty.h $(srcdir)/emulparams/shelf32.sh \
+  $(srcdir)/emultempl/sh64elf.em $(INCDIR)/elf/sh.h $(BFDDIR)/elf-bfd.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshlelf32_linux.c: $(srcdir)/emulparams/shlelf32_linux.sh \
+  $(srcdir)/emulparams/shelf32_linux.sh $(srcdir)/emulparams/shelf32.sh \
+  $(BFDDIR)/libbfd.h $(INCDIR)/libiberty.h \
+  $(srcdir)/emultempl/sh64elf.em $(INCDIR)/elf/sh.h $(BFDDIR)/elf-bfd.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshlelf32_nbsd.c: $(srcdir)/emulparams/shlelf32_nbsd.sh \
+  $(srcdir)/emulparams/shelf32_nbsd.sh $(srcdir)/emulparams/shelf32.sh \
+  $(BFDDIR)/libbfd.h $(INCDIR)/libiberty.h \
+  $(srcdir)/emultempl/sh64elf.em $(INCDIR)/elf/sh.h $(BFDDIR)/elf-bfd.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshlelf_fd.c: $(srcdir)/emulparams/shlelf_fd.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshlelf_linux.c: $(srcdir)/emulparams/shlelf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshlelf_nbsd.c: $(srcdir)/emulparams/shlelf_nbsd.sh \
+  $(srcdir)/emulparams/shelf_nbsd.sh \
+  $(srcdir)/emulparams/shelf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshlelf_nto.c: $(srcdir)/emulparams/shlelf_nto.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshlelf_vxworks.c: $(srcdir)/emulparams/shlelf_vxworks.sh \
+  $(srcdir)/emulparams/shelf_vxworks.sh $(srcdir)/emulparams/vxworks.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc $(srcdir)/emultempl/vxworks.em \
+  ${GEN_DEPENDS}
+
+eshlsymbian.c: $(srcdir)/emulparams/shlsymbian.sh \
+  $(srcdir)/emulparams/shelf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf32sh-symbian.sc ${GEN_DEPENDS}
+
+eshpe.c: $(srcdir)/emulparams/shpe.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
+
+esparcaout.c: $(srcdir)/emulparams/sparcaout.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+esparclinux.c: $(srcdir)/emulparams/sparclinux.sh \
+  $(srcdir)/emultempl/linux.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+esparcnbsd.c:	$(srcdir)/emulparams/sparcnbsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+est2000.c: $(srcdir)/emulparams/st2000.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/st2000.sc ${GEN_DEPENDS}
+
+esun3.c: $(srcdir)/emulparams/sun3.sh \
+  $(srcdir)/emultempl/sunos.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+esun4.c: $(srcdir)/emulparams/sun4.sh \
+  $(srcdir)/emultempl/sunos.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+etic30aout.c: $(srcdir)/emulparams/tic30aout.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/tic30aout.sc ${GEN_DEPENDS}
+
+etic30coff.c: $(srcdir)/emulparams/tic30coff.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/tic30coff.sc ${GEN_DEPENDS}
+
+etic3xcoff.c: $(srcdir)/emulparams/tic3xcoff.sh \
+  $(srcdir)/emultempl/ticoff.em $(srcdir)/scripttempl/tic4xcoff.sc ${GEN_DEPENDS}
+
+etic3xcoff_onchip.c: $(srcdir)/emulparams/tic3xcoff_onchip.sh \
+  $(srcdir)/emultempl/ticoff.em $(srcdir)/scripttempl/tic4xcoff.sc ${GEN_DEPENDS}
+
+etic4xcoff.c: $(srcdir)/emulparams/tic4xcoff.sh \
+  $(srcdir)/emultempl/ticoff.em $(srcdir)/scripttempl/tic4xcoff.sc ${GEN_DEPENDS}
+
+etic54xcoff.c: $(srcdir)/emulparams/tic54xcoff.sh \
+  $(srcdir)/emultempl/ticoff.em $(srcdir)/scripttempl/tic54xcoff.sc ${GEN_DEPENDS}
+
+etic80coff.c: $(srcdir)/emulparams/tic80coff.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/tic80coff.sc ${GEN_DEPENDS}
+
+ev850.c: $(srcdir)/emulparams/v850.sh $(srcdir)/emultempl/v850elf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/v850.sc ${GEN_DEPENDS}
+
+ev850_rh850.c: $(srcdir)/emulparams/v850_rh850.sh $(srcdir)/emultempl/v850elf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/v850_rh850.sc ${GEN_DEPENDS}
+
+evanilla.c: $(srcdir)/emulparams/vanilla.sh \
+  $(srcdir)/emultempl/vanilla.em $(srcdir)/scripttempl/vanilla.sc ${GEN_DEPENDS}
+
+evax.c: $(srcdir)/emulparams/vax.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+evaxnbsd.c: $(srcdir)/emulparams/vaxnbsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+evsta.c: $(srcdir)/emulparams/vsta.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+
+ew65.c: $(srcdir)/emulparams/w65.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/w65.sc ${GEN_DEPENDS}
+
+exgateelf.c: $(srcdir)/emulparams/xgateelf.sh \
+  $(srcdir)/emultempl/generic.em $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elfxgate.sc ${GEN_DEPENDS}
+
+ez80.c: $(srcdir)/emulparams/z80.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/emultempl/z80.em \
+  $(srcdir)/scripttempl/z80.sc ${GEN_DEPENDS}
+
+ez8001.c: $(srcdir)/emulparams/z8001.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/z8000.sc ${GEN_DEPENDS}
+
+ez8002.c: $(srcdir)/emulparams/z8002.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/z8000.sc ${GEN_DEPENDS}
+
+eelf32_x86_64.c: $(srcdir)/emulparams/elf32_x86_64.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32_x86_64_nacl.c: $(srcdir)/emulparams/elf32_x86_64_nacl.sh \
+  $(srcdir)/emulparams/elf32_x86_64.sh \
+  $(srcdir)/emulparams/elf_nacl.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64_aix.c: $(srcdir)/emulparams/elf64_aix.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64_ia64.c: $(srcdir)/emulparams/elf64_ia64.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/ia64elf.em \
+  $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64_ia64_fbsd.c: $(srcdir)/emulparams/elf64_ia64_fbsd.sh \
+  $(srcdir)/emulparams/elf64_ia64.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/ia64elf.em \
+  $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64_ia64_vms.c: $(srcdir)/emulparams/elf64_ia64_vms.sh \
+  $(srcdir)/emultempl/vms.em $(srcdir)/emultempl/elf-generic.em \
+  $(srcdir)/scripttempl/ia64vms.sc ${GEN_DEPENDS}
+
+eelf64_s390.c: $(srcdir)/emulparams/elf64_s390.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64_sparc.c: $(srcdir)/emulparams/elf64_sparc.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64_sparc_fbsd.c: $(srcdir)/emulparams/elf64_sparc_fbsd.sh \
+  $(srcdir)/emulparams/elf64_sparc.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64_sparc_sol2.c: $(srcdir)/emulparams/elf64_sparc_sol2.sh \
+  $(srcdir)/emulparams/elf64_sparc.sh \
+  $(srcdir)/emulparams/solaris2.sh \
+  $(srcdir)/emultempl/solaris2.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64alpha.c: $(srcdir)/emulparams/elf64alpha.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/alphaelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64alpha_fbsd.c: $(srcdir)/emulparams/elf64alpha_fbsd.sh \
+  $(srcdir)/emulparams/elf64alpha.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/alphaelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64alpha_nbsd.c: $(srcdir)/emulparams/elf64alpha_nbsd.sh \
+  $(srcdir)/emulparams/elf64alpha.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/alphaelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64bmip.c: $(srcdir)/emulparams/elf64bmip.sh \
+  $(srcdir)/emulparams/elf64bmip-defs.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/irix.em $(srcdir)/emultempl/mipself.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64btsmip.c: $(srcdir)/emulparams/elf64btsmip.sh \
+  $(srcdir)/emulparams/elf64bmip-defs.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64btsmip_fbsd.c: $(srcdir)/emulparams/elf64btsmip_fbsd.sh \
+  $(srcdir)/emulparams/elf64bmip-defs.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64hppa.c: $(srcdir)/emulparams/elf64hppa.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf64hppa.sc ${GEN_DEPENDS}
+
+eelf64lppc.c: $(srcdir)/emulparams/elf64lppc.sh \
+  $(srcdir)/emulparams/elf64ppc.sh $(srcdir)/emultempl/ppc64elf.em \
+  ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64ltsmip.c: $(srcdir)/emulparams/elf64ltsmip.sh \
+  $(srcdir)/emulparams/elf64btsmip.sh $(srcdir)/emulparams/elf64bmip-defs.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64ltsmip_fbsd.c: $(srcdir)/emulparams/elf64ltsmip_fbsd.sh \
+  $(srcdir)/emulparams/elf64btsmip_fbsd.sh $(srcdir)/emulparams/elf64bmip-defs.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64mmix.c: $(srcdir)/emulparams/elf64mmix.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/mmix-elfnmmo.em \
+  $(srcdir)/emultempl/mmixelf.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64ppc.c: $(srcdir)/emulparams/elf64ppc.sh $(srcdir)/emultempl/ppc64elf.em \
+  ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64ppc_fbsd.c: $(srcdir)/emulparams/elf64ppc_fbsd.sh \
+  $(srcdir)/emultempl/ppc64elf.em ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64rdos.c: $(srcdir)/emulparams/elf64rdos.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64tilegx.c: $(srcdir)/emulparams/elf64tilegx.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf64tilegx_be.c: $(srcdir)/emulparams/elf64tilegx_be.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_l1om.c: $(srcdir)/emulparams/elf_l1om.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_l1om_fbsd.c: $(srcdir)/emulparams/elf_l1om_fbsd.sh \
+  $(srcdir)/emulparams/elf_l1om.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_k1om.c: $(srcdir)/emulparams/elf_k1om.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_k1om_fbsd.c: $(srcdir)/emulparams/elf_k1om_fbsd.sh \
+  $(srcdir)/emulparams/elf_k1om.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_x86_64.c: $(srcdir)/emulparams/elf_x86_64.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_x86_64_cloudabi.c: $(srcdir)/emulparams/elf_x86_64_cloudabi.sh \
+  $(srcdir)/emulparams/elf_x86_64.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_x86_64_fbsd.c: $(srcdir)/emulparams/elf_x86_64_fbsd.sh \
+  $(srcdir)/emulparams/elf_x86_64.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_x86_64_nacl.c: $(srcdir)/emulparams/elf_x86_64_nacl.sh \
+  $(srcdir)/emulparams/elf_x86_64.sh \
+  $(srcdir)/emulparams/elf_nacl.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf_x86_64_sol2.c: $(srcdir)/emulparams/elf_x86_64_sol2.sh \
+  $(srcdir)/emulparams/elf_x86_64.sh \
+  $(srcdir)/emulparams/solaris2.sh \
+  $(srcdir)/emultempl/solaris2.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+ehppa64linux.c: $(srcdir)/emulparams/hppa64linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+emmo.c: $(srcdir)/emulparams/mmo.sh $(srcdir)/emultempl/mmix-elfnmmo.em \
+  $(srcdir)/emultempl/generic.em $(srcdir)/emultempl/elf-generic.em \
+  $(srcdir)/emultempl/mmo.em $(srcdir)/scripttempl/DWARF.sc \
+  $(srcdir)/scripttempl/mmo.sc ${GEN_DEPENDS}
+
+eshelf64.c: $(srcdir)/emulparams/shelf64.sh $(srcdir)/emulparams/shelf32.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshelf64_nbsd.c: $(srcdir)/emulparams/shelf64_nbsd.sh \
+  $(srcdir)/emulparams/shelf32_nbsd.sh $(srcdir)/emulparams/shelf32.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshlelf64.c: $(srcdir)/emulparams/shlelf64.sh \
+  $(srcdir)/emulparams/shelf64.sh $(srcdir)/emulparams/shelf32.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eshlelf64_nbsd.c: $(srcdir)/emulparams/shlelf64_nbsd.sh \
+  $(srcdir)/emulparams/shelf64_nbsd.sh \
+  $(srcdir)/emulparams/shelf32_nbsd.sh $(srcdir)/emulparams/shelf32.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+check-DEJAGNU: site.exp
+	srcroot=`cd $(srcdir) && pwd`; export srcroot; \
+	r=`pwd`; export r; \
+	LC_ALL=C; export LC_ALL; \
+	EXPECT=$(EXPECT); export EXPECT; \
+	runtest=$(RUNTEST); \
+	if $(SHELL) -c "$$runtest --version" > /dev/null 2>&1; then \
+	  $$runtest --tool $(DEJATOOL) --srcdir $${srcroot}/testsuite \
+		CC="$(CC_FOR_TARGET)" CFLAGS="$(CFLAGS)" \
+		CXX="$(CXX_FOR_TARGET)" CXXFLAGS="$(CXXFLAGS)" \
+		CC_FOR_HOST="$(CC)" CFLAGS_FOR_HOST="$(CFLAGS)" \
+		OFILES="$(OFILES)" BFDLIB="$(TESTBFDLIB)" \
+		LIBIBERTY="$(LIBIBERTY) $(LIBINTL)" LIBS="$(LIBS)" \
+		DO_COMPARE="`echo '$(do_compare)' | sed -e 's,\\$$,,g'`" \
+		$(RUNTESTFLAGS); \
+	else echo "WARNING: could not find \`runtest'" 1>&2; :;\
+	fi
+
+# Rules for testing by relinking ld itself.
+# A similar test is in the testsuite.  This target is for ease of use
+# when porting ld.
+
+ld-partial.@OBJEXT@: ld-new$(EXEEXT)
+	./ld-new$(EXEEXT) $(HOSTING_EMU) -o ld-partial.@OBJEXT@ -r $(OFILES)
+ld1$(EXEEXT): ld-partial.@OBJEXT@
+	./ld-new$(EXEEXT) $(HOSTING_EMU) -o ld1$(EXEEXT) $(HOSTING_CRT0) ld-partial.@OBJEXT@ $(TESTBFDLIB) $(LIBIBERTY) $(HOSTING_LIBS) $(LIBS)
+
+ld1-full$(EXEEXT): ld-new
+	./ld-new$(EXEEXT) $(HOSTING_EMU) -o ld1-full$(EXEEXT) $(HOSTING_CRT0) $(OFILES) $(TESTBFDLIB) $(LIBIBERTY) $(HOSTING_LIBS) $(LIBS)
+
+ld2$(EXEEXT): ld1$(EXEEXT)
+	./ld1$(EXEEXT) $(HOSTING_EMU) -o ld2$(EXEEXT) $(HOSTING_CRT0) $(OFILES) $(TESTBFDLIB) $(LIBIBERTY) $(HOSTING_LIBS) $(LIBS)
+
+ld3$(EXEEXT): ld2$(EXEEXT)
+	./ld2$(EXEEXT) $(HOSTING_EMU) -o ld3$(EXEEXT) $(HOSTING_CRT0) $(OFILES) $(TESTBFDLIB) $(LIBIBERTY) $(HOSTING_LIBS) $(LIBS)
+
+bootstrap: ld3$(EXEEXT)
+	cmp ld2$(EXEEXT) ld3$(EXEEXT)
+
+.PHONY: bootstrap
+
+# DOCUMENTATION TARGETS
+# Manual configuration file; not usually attached to normal configuration,
+# because almost all configs use "gen" version of manual.
+#  Set DOCVER above to change.
+configdoc.texi:	${DOCVER}-doc.texi
+	cp ${srcdir}/${DOCVER}-doc.texi ./configdoc.texi
+	chmod u+w ./configdoc.texi
+
+# Build the man page from the texinfo file
+# The sed command removes the no-adjust Nroff command so that
+# the man output looks standard.
+ld.1: $(srcdir)/ld.texinfo configdoc.texi
+	touch $@
+	-$(TEXI2POD) $(MANCONF) < $(srcdir)/ld.texinfo > ld.pod
+	-($(POD2MAN) ld.pod | \
+		sed -e '/^.if n .na/d' > $@.T$$$$ && \
+		mv -f $@.T$$$$ $@) || \
+		(rm -f $@.T$$$$ && exit 1)
+	rm -f ld.pod
+mostlyclean-local:
+	-rm -rf tmpdir
+
+.PHONY: install-exec-local install-data-local
+
+install-exec-local: ld-new$(EXEEXT) install-binPROGRAMS
+	$(mkinstalldirs) $(DESTDIR)$(tooldir)/bin
+	n=`echo $(installed_linker) | sed '$(transform)'`; \
+	if test "$(bindir)" != "$(tooldir)/bin"; then \
+	  rm -f $(DESTDIR)$(tooldir)/bin/$(installed_linker)$(EXEEXT); \
+	  ln $(DESTDIR)$(bindir)/$$n$(EXEEXT) $(DESTDIR)$(tooldir)/bin/$(installed_linker)$(EXEEXT) >/dev/null 2>/dev/null \
+	  || $(INSTALL_PROGRAM_ENV) $(LIBTOOL) --mode=install $(INSTALL_PROGRAM) ld-new$(EXEEXT) $(DESTDIR)$(tooldir)/bin/$(installed_linker)$(EXEEXT); \
+	fi; \
+	if test "x$(install_as_default)" = "xyes"; then \
+	  ld=`echo ld | sed '$(transform)'`; \
+	  rm -f $(DESTDIR)$(bindir)/$$ld$(EXEEXT); \
+	  ln $(DESTDIR)$(bindir)/$$n$(EXEEXT) $(DESTDIR)$(bindir)/$$ld$(EXEEXT) >/dev/null 2>/dev/null \
+	  || $(INSTALL_PROGRAM_ENV) $(LIBTOOL) --mode=install $(INSTALL_PROGRAM) ld-new$(EXEEXT) $(DESTDIR)$(bindir)/$$ld$(EXEEXT); \
+	  if test "$(bindir)" != "$(tooldir)/bin"; then \
+	    rm -f $(DESTDIR)$(tooldir)/bin/ld$(EXEEXT); \
+	    ln $(DESTDIR)$(bindir)/$$n$(EXEEXT) $(DESTDIR)$(tooldir)/bin/ld$(EXEEXT) >/dev/null 2>/dev/null \
+	    || $(INSTALL_PROGRAM_ENV) $(LIBTOOL) --mode=install $(INSTALL_PROGRAM) ld-new$(EXEEXT) $(DESTDIR)$(tooldir)/bin/ld$(EXEEXT); \
+	  fi; \
+	fi
+
+install-data-local:
+	$(mkinstalldirs) $(DESTDIR)$(scriptdir)/ldscripts
+	for f in ldscripts/* ; do \
+	  $(INSTALL_DATA) $$f $(DESTDIR)$(scriptdir)/$$f ; \
+	done
+diststuff: info $(EXTRA_DIST)
+
+# Both info (ld.info) and ld.1 depend on configdoc.texi.
+# But info isn't a direct target. Make info-recursive to depend on
+# ld.1 to support parallel build.
+info-recursive: ld.1
+distclean-local:
+	rm -rf ldscripts
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -Naur binutils-2.26/ld/configure.tgt binutils-2.26.0007/ld/configure.tgt
--- binutils-2.26/ld/configure.tgt	2015-11-13 09:27:42.000000000 +0100
+++ binutils-2.26.0007/ld/configure.tgt	2016-03-10 17:02:24.340716489 +0100
@@ -85,6 +85,11 @@
 			LIB_PATH='${tooldir}/lib/w32api' ;;
 arm-wince-pe | arm-*-wince | arm*-*-mingw32ce*)
 			targ_emul=arm_wince_pe ; targ_extra_ofiles="deffilep.o pe-dll.o" ;;
+arm*-*-mingw*)
+			targ_emul=thumb2pe ; targ_extra_ofiles="deffilep.o pe-dll.o" ;;
+arm*-*-cygwin*)
+			targ_emul=thumb2pe ; targ_extra_ofiles="deffilep.o pe-dll.o" ;
+			test "$targ" != "$host" && LIB_PATH='${tooldir}/lib/w32api' ;;
 arm-*-pe)		targ_emul=armpe ; targ_extra_ofiles="deffilep.o pe-dll.o" ;;
 arm-*-aout | armel-*-aout) targ_emul=armaoutl ;;
 armeb-*-aout)		targ_emul=armaoutb ;;
@@ -861,7 +866,7 @@
   NATIVE_LIB_DIRS='/lib'
   ;;
 
-i[03-9x]86-*-cygwin* | x86_64-*-cygwin*)
+i[03-9x]86-*-cygwin* | x86_64-*-cygwin* | arm*-*-cygwin*)
   NATIVE_LIB_DIRS='/usr/lib /usr/lib/w32api'
   ;;
 
diff -Naur binutils-2.26/ld/configure.tgt.orig binutils-2.26.0007/ld/configure.tgt.orig
--- binutils-2.26/ld/configure.tgt.orig	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.26.0007/ld/configure.tgt.orig	2016-03-10 17:01:12.722288067 +0100
@@ -0,0 +1,878 @@
+# configure.tgt
+#
+#   Copyright (C) 2013-2015 Free Software Foundation, Inc.
+#
+# This file is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# This is the linker target specific file.  This is invoked by the
+# autoconf generated configure script.  Putting it in a separate shell
+# file lets us skip running autoconf when modifying target specific
+# information.
+
+# This file switches on the shell variable ${targ}, and sets the
+# following shell variables:
+#  targ_emul		name of linker emulation to use
+#  targ_extra_emuls	additional linker emulations to provide
+#  targ_extra_libpath	additional linker emulations using LIB_PATH
+#  targ_extra_ofiles	additional host-compiled objects needed by the emulation
+#  targ64_extra_emuls	additional linker emulations to provide if
+#  			--enable-64-bit-bfd is given or if host is 64 bit.
+#  targ64_extra_libpath	additional linker emulations using LIB_PATH if
+#  			--enable-64-bit-bfd is given or if host is 64 bit.
+#  NATIVE_LIB_DIRS	library directories to search on this host
+#			(if we are a native or sysrooted linker)
+
+targ_extra_emuls=
+targ_extra_libpath=
+targ_extra_ofiles=
+targ64_extra_emuls=
+targ64_extra_libpath=
+
+# Please try to keep this table in alphabetic order - it makes it
+# much easier to lookup a specific archictecture.  Naturally any
+# architecture variants should be kept together even if their names
+# break the alpha sorting.
+case "${targ}" in
+aarch64_be-*-elf)	targ_emul=aarch64elfb
+			targ_extra_emuls="aarch64elf aarch64elf32 aarch64elf32b armelfb armelf" ;;
+aarch64-*-elf)		targ_emul=aarch64elf
+			targ_extra_emuls="aarch64elf32 aarch64elf32b aarch64elfb armelf armelfb" ;;
+aarch64-*-cloudabi*)	targ_emul=aarch64cloudabi
+			targ_extra_emuls=aarch64cloudabib ;;
+aarch64-*-freebsd*)	targ_emul=aarch64fbsd
+			targ_extra_emuls="aarch64fbsdb aarch64elf" ;;
+aarch64_be-*-linux*)	targ_emul=aarch64linuxb
+			targ_extra_libpath="aarch64linux aarch64linux32 aarch64linux32b armelfb_linux_eabi armelf_linux_eabi"
+			targ_extra_emuls="aarch64elfb aarch64elf aarch64elf32 aarch64elf32b armelfb armelf $targ_extra_libpath" ;;
+aarch64-*-linux*)	targ_emul=aarch64linux
+			targ_extra_libpath="aarch64linuxb aarch64linux32 aarch64linux32b armelfb_linux_eabi armelf_linux_eabi"
+			targ_extra_emuls="aarch64elf aarch64elf32 aarch64elf32b aarch64elfb armelf armelfb $targ_extra_libpath" ;;
+alpha*-*-freebsd* | alpha*-*-kfreebsd*-gnu)
+		        targ_emul=elf64alpha_fbsd
+			targ_extra_emuls="elf64alpha alpha"
+			tdir_alpha=`echo ${targ_alias} | sed -e 's/freebsd/freebsdecoff/'` ;;
+alpha*-*-linux*ecoff*)	targ_emul=alpha targ_extra_emuls=elf64alpha
+			tdir_elf64alpha=`echo ${targ_alias} | sed -e 's/ecoff//'` ;;
+alpha*-*-linux-*)	targ_emul=elf64alpha targ_extra_emuls=alpha
+			tdir_alpha=`echo ${targ_alias} | sed -e 's/linux\(-gnu\)*/linux\1ecoff/'` ;;
+alpha*-*-osf*)		targ_emul=alpha ;;
+alpha*-*-gnu*)		targ_emul=elf64alpha ;;
+alpha*-*-netware*)	targ_emul=alpha ;;
+alpha*-*-netbsd*)	targ_emul=elf64alpha_nbsd ;;
+alpha*-*-openbsd*)	targ_emul=elf64alpha ;;
+alpha*-*-*vms*)		targ_emul=alphavms
+			;;
+arc*-*-elf*)		targ_emul=arcelf
+            		targ_extra_emuls="arcelf_prof arclinux arclinux_prof arcv2elf arcv2elfx"
+            		;;
+arc*-*-linux-uclibc*)	targ_emul=arclinux
+			targ_extra_emuls="arclinux_prof arcelf arcelf_prof arcv2elf arcv2elfx"
+			;;
+arm-epoc-pe)		targ_emul=arm_epoc_pe ;	targ_extra_ofiles="deffilep.o pe-dll.o" ;;
+arm*-*-cegcc*)		targ_emul=arm_wince_pe ; targ_extra_ofiles="deffilep.o pe-dll.o"
+			LIB_PATH='${tooldir}/lib/w32api' ;;
+arm-wince-pe | arm-*-wince | arm*-*-mingw32ce*)
+			targ_emul=arm_wince_pe ; targ_extra_ofiles="deffilep.o pe-dll.o" ;;
+arm-*-pe)		targ_emul=armpe ; targ_extra_ofiles="deffilep.o pe-dll.o" ;;
+arm-*-aout | armel-*-aout) targ_emul=armaoutl ;;
+armeb-*-aout)		targ_emul=armaoutb ;;
+arm-*-coff)		targ_emul=armcoff ;;
+arm*b-*-freebsd*)	targ_emul=armelfb_fbsd
+			targ_extra_emuls="armelf_fbsd armelf" ;;
+arm*-*-freebsd* | arm-*-kfreebsd*-gnu)
+	       		targ_emul=armelf_fbsd
+			targ_extra_emuls="armelfb_fbsd armelf" ;;
+armeb-*-netbsdelf*)	targ_emul=armelfb_nbsd;
+			targ_extra_emuls="armelf_nbsd armelf armnbsd" ;;
+arm-*-netbsdelf*)	targ_emul=armelf_nbsd;
+			targ_extra_emuls="armelfb_nbsd armelf armnbsd" ;;
+arm-*-netbsd*)		targ_emul=armnbsd;
+			targ_extra_emuls="armelf armelf_nbsd armelfb_nbsd"  ;;
+arm-*-nto*)		targ_emul=armnto ;;
+arm-*-openbsd*)		targ_emul=armnbsd ;;
+arm-*-rtems*)		targ_emul=armelf ;;
+armeb-*-elf | armeb-*-eabi*)
+			targ_emul=armelfb ;;
+arm-*-elf | arm*-*-eabi*)
+	  		targ_emul=armelf ;;
+arm*-*-symbianelf*)     targ_emul=armsymbian;;
+arm-*-kaos*)		targ_emul=armelf ;;
+arm9e-*-elf)		targ_emul=armelf ;;
+arm*b-*-linux-*eabi*)	targ_emul=armelfb_linux_eabi
+			targ_extra_emuls=armelf_linux_eabi
+			targ_extra_libpath=$targ_extra_emuls
+			;;
+arm*b-*-linux-*)	targ_emul=armelfb_linux
+			targ_extra_emuls="armelfb armelf armelf_linux"
+			targ_extra_libpath="armelf_linux"
+			;;
+arm*-*-linux-*eabi*)	targ_emul=armelf_linux_eabi
+			targ_extra_emuls=armelfb_linux_eabi
+			targ_extra_libpath=$targ_extra_emuls
+			;;
+arm*-*-linux-*)	        targ_emul=armelf_linux
+			targ_extra_emuls="armelf armelfb armelfb_linux"
+			targ_extra_libpath="armelfb_linux"
+			;;
+arm*b-*-nacl*)		targ_emul=armelfb_nacl
+			targ_extra_emuls="armelf_nacl elf_i386_nacl"
+			targ_extra_libpath=$targ_extra_emuls
+			targ64_extra_emuls="elf32_x86_64_nacl elf_x86_64_nacl"
+			targ64_extra_libpath=$targ64_extra_emuls
+			;;
+arm*-*-nacl*)		targ_emul=armelf_nacl
+			targ_extra_emuls="armelfb_nacl elf_i386_nacl"
+			targ_extra_libpath=$targ_extra_emuls
+			targ64_extra_emuls="elf32_x86_64_nacl elf_x86_64_nacl"
+			targ64_extra_libpath=$targ64_extra_emuls
+			;;
+arm*-*-uclinux*eabi*)	targ_emul=armelf_linux_eabi
+			targ_extra_emuls=armelfb_linux_eabi
+			targ_extra_libpath=$targ_extra_emuls
+			;;
+arm*-*-uclinux*)	targ_emul=armelf_linux
+			targ_extra_emuls="armelf armelfb armelfb_linux"
+			targ_extra_libpath="armelfb_linux"
+			;;
+arm-*-vxworks)		targ_emul=armelf_vxworks ;;
+arm*-*-conix*)		targ_emul=armelf ;;
+avr-*-*)		targ_emul=avr2
+			targ_extra_emuls="avr1 avr25 avr3 avr31 avr35 avr4 avr5 avr51 avr6 avrxmega1 avrxmega2 avrxmega3 avrxmega4 avrxmega5 avrxmega6 avrxmega7 avrtiny"
+			;;
+bfin-*-elf)		targ_emul=elf32bfin;
+			targ_extra_emuls="elf32bfinfd"
+			targ_extra_libpath=$targ_extra_emuls
+			;;
+bfin-*-rtems*)		targ_emul=elf32bfin;
+			targ_extra_emuls="elf32bfinfd"
+			targ_extra_libpath=$targ_extra_emuls
+			;;
+bfin-*-uclinux*)	targ_emul=elf32bfin;
+			targ_extra_emuls="elf32bfinfd"
+			targ_extra_libpath=$targ_extra_emuls
+			;;
+bfin-*-linux-uclibc*)	targ_emul=elf32bfinfd;
+			targ_extra_emuls="elf32bfin"
+			targ_extra_libpath=$targ_extra_emuls
+			;;
+cr16-*-elf*)            targ_emul=elf32cr16 ;;
+cr16c-*-elf*)           targ_emul=elf32cr16c
+			;;
+cris-*-*aout*)		targ_emul=crisaout
+			targ_extra_emuls="criself crislinux"
+			targ_extra_libpath=$targ_extra_emuls ;;
+cris-*-linux-* | crisv32-*-linux-*)
+			targ_emul=crislinux ;;
+cris-*-* | crisv32-*-*)	targ_emul=criself
+			targ_extra_emuls="crisaout crislinux"
+			targ_extra_libpath=$targ_extra_emuls
+			;;
+crx-*-elf*)		targ_emul=elf32crx
+			;;
+d10v-*-*)		targ_emul=d10velf ;;
+d30v-*-*ext*)		targ_emul=d30v_e; targ_extra_emuls="d30velf d30v_o" ;;
+d30v-*-*onchip*)	targ_emul=d30v_o; targ_extra_emuls="d30velf d30v_e" ;;
+d30v-*-*)		targ_emul=d30velf; targ_extra_emuls="d30v_e d30v_o"
+			;;
+dlx-*-elf*)		targ_emul=elf32_dlx
+			;;
+epiphany-*-elf)		targ_emul=elf32epiphany
+			targ_extra_emuls="elf32epiphany_4x4"
+			;;
+fido*-*-elf*)		targ_emul=m68kelf ;;
+fr30-*-*)		targ_emul=elf32fr30
+			;;
+frv-*-*linux*)		targ_emul=elf32frvfd ;;
+frv-*-*)		targ_emul=elf32frv ; targ_extra_emuls="elf32frvfd"
+			;;
+moxie-*-moxiebox*)	targ_emul=moxiebox
+			;;
+moxie-*-*)		targ_emul=elf32moxie
+			;;
+h8300-*-hms* | h8300-*-coff* | h8300-*-rtemscoff*)
+			targ_emul=h8300; targ_extra_emuls="h8300h h8300s h8300hn h8300sn h8300sx h8300sxn" ;;
+h8300-*-elf* | h8300-*-rtems*)
+			targ_emul=h8300elf;
+			targ_extra_emuls="h8300helf h8300self h8300hnelf h8300snelf h8300sxelf h8300sxnelf" ;;
+h8300-*-linux*)
+			targ_emul=h8300elf_linux;
+			targ_extra_emuls="h8300helf_linux h8300self_linux h8300sxelf_linux" ;;
+h8500-*-hms* | h8500-*-coff* | h8500-*-rtems*)
+			targ_emul=h8500
+			targ_extra_emuls="h8500s h8500b h8500m h8500c"
+			;;
+hppa*64*-*-linux-*)	targ_emul=hppa64linux ;;
+hppa*64*-hpux*)		targ_emul=elf64hppa ;;
+hppa*-*-linux-*)	targ_emul=hppalinux ;;
+hppa*-*-*elf*)		targ_emul=hppaelf ;;
+hppa*-*-lites*)		targ_emul=hppaelf ;;
+hppa*-*-netbsd*)	targ_emul=hppanbsd ;;
+hppa*-*-openbsd*)	targ_emul=hppaobsd
+			;;
+i370-*-elf* | i370-*-linux-*) targ_emul=elf32i370
+			;;
+i[3-7]86-*-nto-qnx*)	targ_emul=i386nto ;;
+i[3-7]86-*-vsta)	targ_emul=vsta ;;
+i[3-7]86-*-go32)	targ_emul=i386go32 ;;
+i[3-7]86-*-msdosdjgpp*) targ_emul=i386go32 ;;
+i[3-7]86-*-aix*)	targ_emul=i386coff ;;
+i[3-7]86-*-sco*)	targ_emul=i386coff ;;
+i[3-7]86-*-isc*)	targ_emul=i386coff ;;
+i[3-7]86-*-lynxos*)	targ_emul=i386lynx ;;
+i[3-7]86-*-coff)	targ_emul=i386coff ;;
+i[3-7]86-*-rtems*)	targ_emul=elf_i386
+			targ_extra_emuls=elf_iamcu ;;
+i[3-7]86-*-aros*)	targ_emul=elf_i386
+			targ_extra_emuls=elf_iamcu ;;
+i[3-7]86-*-rdos*)	targ_emul=elf_i386
+			targ_extra_emuls=elf_iamcu ;;
+x86_64-*-rdos*)		targ_emul=elf64rdos ;;
+x86_64-*-cloudabi*)	targ_emul=elf_x86_64_cloudabi ;;
+i[3-7]86-*-bsd)		targ_emul=i386bsd ;;
+i[3-7]86-*-bsd386)	targ_emul=i386bsd ;;
+i[3-7]86-*-bsdi*)	targ_emul=i386bsd ;;
+i[3-7]86-*-aout)	targ_emul=i386aout ;;
+i[3-7]86-*-linux*aout*)	targ_emul=i386linux
+			targ_extra_emuls="elf_i386 elf_iamcu"
+			tdir_elf_iamcu=`echo ${targ_alias} | sed -e 's/aout//'`
+			tdir_elf_i386=`echo ${targ_alias} | sed -e 's/aout//'` ;;
+i[3-7]86-*-linux*oldld)	targ_emul=i386linux
+			targ_extra_emuls="elf_i386 elf_iamcu" ;;
+i[3-7]86-*-linux-*)	targ_emul=elf_i386
+			targ_extra_emuls="i386linux elf_iamcu"
+			targ64_extra_emuls="elf_x86_64 elf32_x86_64 elf_l1om elf_k1om"
+			targ64_extra_libpath=elf_x86_64
+			targ_extra_libpath=elf32_x86_64
+			tdir_i386linux=${targ_alias}aout ;;
+x86_64-*-linux-gnux32)	targ_emul=elf32_x86_64
+			targ_extra_emuls="elf_x86_64 elf_i386 elf_iamcu i386linux elf_l1om elf_k1om"
+			targ_extra_libpath="elf_i386 elf_iamcu elf_x86_64 elf_l1om elf_k1om"
+			tdir_i386linux=`echo ${targ_alias}aout | sed -e 's/x86_64/i386/' -e 's/-linux-gnux32/-linux-gnu/'`
+			tdir_elf_iamcu=`echo ${targ_alias} | sed -e 's/x86_64/i386/' -e 's/-linux-gnux32/-linux-gnu/'`
+			tdir_elf_i386=`echo ${targ_alias} | sed -e 's/x86_64/i386/' -e 's/-linux-gnux32/-linux-gnu/'` ;;
+x86_64-*-linux-*)	targ_emul=elf_x86_64
+			targ_extra_emuls="elf32_x86_64 elf_i386 elf_iamcu i386linux elf_l1om elf_k1om"
+			targ_extra_libpath="elf_i386 elf32_x86_64 elf_l1om elf_k1om"
+			tdir_i386linux=`echo ${targ_alias}aout | sed -e 's/x86_64/i386/'`
+			tdir_elf_i386=`echo ${targ_alias} | sed -e 's/x86_64/i386/'` ;;
+i[3-7]86-*-sysv[45]*)	targ_emul=elf_i386
+			targ_extra_emuls=elf_iamcu ;;
+i[3-7]86-*-solaris2*)	targ_emul=elf_i386_sol2
+                        targ_extra_emuls="elf_i386_ldso elf_i386 elf_iamcu elf_x86_64_sol2 elf_x86_64 elf_l1om elf_k1om"
+			targ_extra_libpath=$targ_extra_emuls
+                        ;;
+x86_64-*-solaris2*)
+			targ_emul=elf_x86_64_sol2
+			targ_extra_emuls="elf_x86_64 elf_i386_sol2 elf_i386_ldso elf_i386 elf_iamcu elf_l1om elf_k1om"
+			targ_extra_libpath=$targ_extra_emuls
+			tdir_elf_i386=`echo ${targ_alias} | sed -e 's/x86_64/i386/'` ;;
+i[3-7]86-*-unixware)	targ_emul=elf_i386
+			targ_extra_emuls=elf_iamcu ;;
+i[3-7]86-*-solaris*)	targ_emul=elf_i386_ldso
+                        targ_extra_emuls="elf_i386"
+			targ_extra_libpath=$targ_extra_emuls
+                        ;;
+i[3-7]86-*-netbsdelf* | \
+i[3-7]86-*-netbsd*-gnu* | \
+i[3-7]86-*-knetbsd*-gnu)
+			targ_emul=elf_i386
+			targ_extra_emuls="elf_iamcu i386nbsd" ;;
+i[3-7]86-*-netbsdpe*)	targ_emul=i386pe
+			targ_extra_ofiles="deffilep.o pe-dll.o" ;;
+i[3-7]86-*-netbsd*)	targ_emul=i386nbsd
+			targ_extra_emuls=elf_i386 ;;
+x86_64-*-netbsd*)	targ_emul=elf_x86_64
+			targ_extra_emuls="elf_i386 elf_iamcu i386nbsd elf_l1om elf_k1om"
+			tdir_elf_iamcu=`echo ${targ_alias} | \
+			    sed -e 's/x86_64/i386/'`
+			case "${tdir_elf_iamcu}" in
+			*-netbsdelf*)   ;;
+			*)		tdir_elf_iamcu=`echo ${tdir_elf_iamcu} | \
+				        sed -e 's/netbsd/netbsdelf/'`;;
+			esac
+			tdir_elf_i386=`echo ${targ_alias} | \
+			    sed -e 's/x86_64/i386/'`
+			case "${tdir_elf_i386}" in
+			*-netbsdelf*)   ;;
+			*)		tdir_elf_i386=`echo ${tdir_elf_i386} | \
+				        sed -e 's/netbsd/netbsdelf/'`;;
+			esac ;;
+i[3-7]86-*-netware)	targ_emul=i386nw ;;
+i[3-7]86-*-elfiamcu)	targ_emul=elf_iamcu
+			targ_extra_emuls=elf_i386 ;;
+i[3-7]86-*-elf*)	targ_emul=elf_i386
+			targ_extra_emuls=elf_iamcu ;;
+x86_64-*-elf*)		targ_emul=elf_x86_64
+			targ_extra_emuls="elf_i386 elf_iamcu elf32_x86_64 elf_l1om elf_k1om"
+			targ_extra_libpath="elf_i386 elf_iamcu elf32_x86_64 elf_l1om elf_k1om"
+			tdir_elf_i386=`echo ${targ_alias} | sed -e 's/x86_64/i386/'`
+			;;
+i[3-7]86-*-kaos*)	targ_emul=elf_i386 ;;
+i[3-7]86-*-freebsdaout* | i[3-7]86-*-freebsd[12].* | i[3-7]86-*-freebsd[12])
+			targ_emul=i386bsd ;;
+i[3-7]86-*-dragonfly*)	targ_emul=elf_i386
+			targ_extra_emuls="elf_iamcu i386bsd" ;;
+x86_64-*-dragonfly*)	targ_emul=elf_x86_64
+			targ_extra_emuls="elf_i386 elf_iamcu elf_l1om elf_k1om" ;;
+i[3-7]86-*-freebsd* | i[3-7]86-*-kfreebsd*-gnu)
+		        targ_emul=elf_i386_fbsd
+			targ_extra_emuls="elf_i386 elf_iamcu i386bsd" ;;
+x86_64-*-freebsd* | x86_64-*-kfreebsd*-gnu)
+			targ_emul=elf_x86_64_fbsd
+			targ_extra_emuls="elf_i386_fbsd elf_x86_64 elf_i386 elf_iamcu elf_l1om elf_l1om_fbsd elf_k1om elf_k1om_fbsd"
+			targ_extra_libpath="elf_i386_fbsd"
+			tdir_elf_i386_fbsd=`echo ${targ_alias} \
+			    | sed -e 's/x86_64/i386/'`
+			tdir_elf_iamcu=`echo ${targ_alias} \
+			    | sed -e 's/x86_64/i386/'`
+			tdir_elf_i386=`echo ${targ_alias} \
+			    | sed -e 's/x86_64/i386/'` ;;
+i[3-7]86-*-sysv*)	targ_emul=i386coff ;;
+i[3-7]86-*-ptx*)	targ_emul=i386coff ;;
+i[3-7]86-*-mach*)	targ_emul=i386mach ;;
+i[3-7]86-*-gnu*)	targ_emul=elf_i386
+			targ_extra_emuls=elf_iamcu ;;
+i[3-7]86-*-msdos*)	targ_emul=i386msdos; targ_extra_emuls=i386aout ;;
+i[3-7]86-*-moss*)	targ_emul=i386moss; targ_extra_emuls=i386msdos ;;
+i[3-7]86-*-winnt*)	targ_emul=i386pe ;
+			targ_extra_ofiles="deffilep.o pe-dll.o" ;;
+i[3-7]86-*-pe)		targ_emul=i386pe ;
+			targ_extra_ofiles="deffilep.o pe-dll.o" ;;
+i[3-7]86-*-cygwin*)	targ_emul=i386pe ;
+			targ_extra_ofiles="deffilep.o pe-dll.o" ;
+			test "$targ" != "$host" && LIB_PATH='${tooldir}/lib/w32api' ;;
+i[3-7]86-*-mingw32*)	targ_emul=i386pe ;
+			targ_extra_ofiles="deffilep.o pe-dll.o" ;;
+x86_64-*-pe | x86_64-*-pep) targ_emul=i386pep ;
+			targ_extra_emuls=i386pe ;
+			targ_extra_ofiles="deffilep.o pep-dll.o pe-dll.o" ;;
+x86_64-*-cygwin)	targ_emul=i386pep ;
+			targ_extra_emuls=i386pe
+			targ_extra_ofiles="deffilep.o pep-dll.o pe-dll.o"
+			test "$targ" != "$host" && LIB_PATH='${tooldir}/lib/w32api' ;;
+x86_64-*-mingw*)	targ_emul=i386pep ;
+			targ_extra_emuls=i386pe
+			targ_extra_ofiles="deffilep.o pep-dll.o pe-dll.o" ;;
+i[3-7]86-*-interix*)	targ_emul=i386pe_posix;
+ 			targ_extra_ofiles="deffilep.o pe-dll.o" ;;
+i[3-7]86-*-beospe*)	targ_emul=i386beos ;;
+i[3-7]86-*-beos*)	targ_emul=elf_i386_be ;;
+i[3-7]86-*-vxworks*)	targ_emul=elf_i386_vxworks ;;
+i[3-7]86-*-chaos)	targ_emul=elf_i386_chaos
+			;;
+i[3-7]86-*-nacl*)	targ_emul=elf_i386_nacl
+			targ_extra_emuls="armelf_nacl armelfb_nacl"
+			targ_extra_libpath=$targ_extra_emuls
+			targ64_extra_emuls="elf32_x86_64_nacl elf_x86_64_nacl"
+			targ64_extra_libpath=$targ64_extra_emuls
+			;;
+x86_64-*-nacl*)		targ_emul=elf32_x86_64_nacl
+			targ_extra_emuls="elf_i386_nacl elf_x86_64_nacl armelf_nacl armelfb_nacl"
+			targ_extra_libpath=$targ_extra_emuls
+			tdir_elf_i386_nacl=`echo ${targ_alias} | sed -e 's/x86_64/i386/'`
+			;;
+i860-*-coff)		targ_emul=coff_i860 ;;
+i860-stardent-sysv4* | i860-stardent-elf*)
+			targ_emul=elf32_i860
+			;;
+i960-wrs-vxworks5.0*)	targ_emul=gld960 ;;
+i960-wrs-vxworks5*)	targ_emul=gld960coff ;;
+i960-wrs-vxworks*)	targ_emul=gld960 ;;
+i960-*-coff)		targ_emul=gld960coff ;;
+i960-intel-nindy)	targ_emul=gld960 ;;
+i960-*-rtems*)		targ_emul=gld960coff ;;
+i960-*-elf*)		targ_emul=elf32_i960
+			;;
+ia64-*-elf*)		targ_emul=elf64_ia64 ;;
+ia64-*-freebsd* | ia64-*-kfreebsd*-gnu)
+		        targ_emul=elf64_ia64_fbsd
+			targ_extra_emuls="elf64_ia64" ;;
+ia64-*-netbsd*)		targ_emul=elf64_ia64 ;;
+ia64-*-linux*)		targ_emul=elf64_ia64 ;;
+ia64-*-*vms*)		targ_emul=elf64_ia64_vms ;;
+ia64-*-aix*)		targ_emul=elf64_aix
+			;;
+ip2k-*-elf)		targ_emul=elf32ip2k
+			;;
+iq2000-*-elf)           targ_emul=elf32iq2000 ; targ_extra_emuls="elf32iq10"
+			;;
+lm32-*-*linux*)         targ_emul=elf32lm32fd ;;
+lm32-*-*)               targ_emul=elf32lm32 ; targ_extra_emuls="elf32lm32fd"
+                        ;;
+m32c-*-elf | m32c-*-rtems*)
+			targ_emul=elf32m32c
+			;;
+m32r*le-*-elf*)         targ_emul=m32rlelf ;;
+m32r*-*-elf* | m32r*-*-rtems*)
+			targ_emul=m32relf ;;
+m32r*le-*-linux-*)      targ_emul=m32rlelf_linux ;;
+m32r*-*-linux-*)        targ_emul=m32relf_linux
+			;;
+m68hc11-*-*|m6811-*-*)	targ_emul=m68hc11elf
+			targ_extra_emuls="m68hc11elfb m68hc12elf m68hc12elfb" ;;
+m68hc12-*-*|m6812-*-*)	targ_emul=m68hc12elf
+			targ_extra_emuls="m68hc12elfb m68hc11elf m68hc11elfb" ;;
+m68*-sun-sunos[34]*)	targ_emul=sun3 ;;
+m68*-wrs-vxworks*)	targ_emul=sun3 ;;
+m68*-ericsson-ose)	targ_emul=sun3 ;;
+m68*-apple-aux*)	targ_emul=m68kaux ;;
+m68k-sony-*)		targ_emul=news ;;
+m68k-hp-bsd*)		targ_emul=hp300bsd ;;
+m68*-motorola-sysv*)	targ_emul=delta68 ;;
+m68*-*-aout)		targ_emul=m68kaout ;;
+m68*-*-coff)		targ_emul=m68kcoff ;;
+m68*-*-elf)		targ_emul=m68kelf ;;
+m68*-*-hpux*)		targ_emul=hp3hpux ;;
+m68k-*-linux*aout*)	targ_emul=m68klinux
+			targ_extra_emuls=m68kelf
+			tdir_m68kelf=`echo ${targ_alias} | sed -e 's/aout//'` ;;
+m68k-*-linux-*) 	targ_emul=m68kelf
+			targ_extra_emuls=m68klinux
+			tdir_m68klinux=`echo ${targ_alias} | sed -e 's/linux/linuxaout/'` ;;
+m68k-*-uclinux*)	targ_emul=m68kelf ;;
+m68*-*-gnu*)		targ_emul=m68kelf ;;
+m68*-*-netbsd*4k*)	targ_emul=m68k4knbsd
+			targ_extra_emuls="m68knbsd m68kelfnbsd" ;;
+m68*-*-netbsdelf*)	targ_emul=m68kelfnbsd
+			targ_extra_emuls="m68knbsd m68k4knbsd" ;;
+m68*-*-netbsdaout* | m68*-*-netbsd*)
+			targ_emul=m68knbsd
+			targ_extra_emuls="m68kelfnbsd m68k4knbsd" ;;
+m68*-*-psos*)		targ_emul=m68kpsos ;;
+m68*-*-rtemscoff*)	targ_emul=m68kcoff ;;
+m68*-*-rtems*)		targ_emul=m68kelf
+			;;
+m8*-*-*)		targ_emul=m88kbcs
+			;;
+mcore-*-pe)		targ_emul=mcorepe ;
+			targ_extra_ofiles="deffilep.o pe-dll.o" ;;
+mcore-*-elf)		targ_emul=elf32mcore
+			;;
+mep-*-elf)		targ_emul=elf32mep ;;
+metag-*-*)		targ_emul=elf32metag ;;
+microblazeel*-linux*)	targ_emul="elf32mbel_linux"
+			targ_extra_emuls="elf32mb_linux"
+			;;
+microblaze*-linux*)	targ_emul="elf32mb_linux"
+			targ_extra_emuls="elf32mbel_linux"
+			;;
+microblazeel*)		targ_emul=elf32microblazeel
+			targ_extra_emuls=elf32microblaze
+			;;
+microblaze*)		targ_emul=elf32microblaze
+			targ_extra_emuls=elf32microblazeel
+			;;
+mips*-sgi-irix5*)	targ_emul=elf32bsmip ;;
+mips*-sgi-irix6*)	targ_emul=elf32bmipn32
+	                targ_extra_emuls="elf32bsmip elf64bmip"
+			targ_extra_libpath=$targ_extra_emuls ;;
+mips*el-*-netbsd*)	targ_emul=elf32ltsmip
+			targ_extra_emuls="elf32btsmip elf64ltsmip elf64btsmip"
+			;;
+mips*-*-netbsd*)	targ_emul=elf32btsmip
+			targ_extra_emuls="elf32ltsmip elf64btsmip elf64ltsmip"
+  			;;
+mips*vr4300el-*-elf*)	targ_emul=elf32l4300 ;;
+mips*vr4300-*-elf*)	targ_emul=elf32b4300 ;;
+mips*vr4100el-*-elf*)	targ_emul=elf32l4300 ;;
+mips*vr4100-*-elf*)	targ_emul=elf32b4300 ;;
+mips*vr5000el-*-elf*)	targ_emul=elf32l4300 ;;
+mips*vr5000-*-elf*)	targ_emul=elf32b4300 ;;
+mips*el-sde-elf*)	targ_emul=elf32ltsmip
+			targ_extra_emuls="elf32btsmip elf32ltsmipn32 elf64ltsmip elf32btsmipn32 elf64btsmip" ;;
+mips*-sde-elf* | mips*-mti-elf* | mips*-img-elf*)
+			targ_emul=elf32btsmip
+			targ_extra_emuls="elf32ltsmip elf32btsmipn32 elf64btsmip elf32ltsmipn32 elf64ltsmip" ;;
+mips64*el-ps2-elf*)	targ_emul=elf32lr5900n32
+			targ_extra_emuls="elf32lr5900"
+			targ_extra_libpath=$targ_extra_emuls ;;
+mips*el-ps2-elf*)	targ_emul=elf32lr5900
+			targ_extra_emuls="elf32lr5900n32"
+			targ_extra_libpath=$targ_extra_emuls ;;
+mips*el-*-elf*)		targ_emul=elf32elmip ;;
+mips*-*-elf*)		targ_emul=elf32ebmip ;;
+mips*-*-rtems*)		targ_emul=elf32ebmip ;;
+mips*el-*-vxworks*)	targ_emul=elf32elmipvxworks
+			targ_extra_emuls="elf32ebmipvxworks" ;;
+mips*-*-vxworks*)	targ_emul=elf32ebmipvxworks
+		        targ_extra_emuls="elf32elmipvxworks" ;;
+mips*-*-windiss)	targ_emul=elf32mipswindiss ;;
+mips64*el-*-linux-*)	targ_emul=elf32ltsmipn32
+			targ_extra_emuls="elf32btsmipn32 elf32ltsmip elf32btsmip elf64ltsmip elf64btsmip"
+			targ_extra_libpath=$targ_extra_emuls ;;
+mips64*-*-linux-*)	targ_emul=elf32btsmipn32
+			targ_extra_emuls="elf32ltsmipn32 elf32btsmip elf32ltsmip elf64btsmip elf64ltsmip"
+			targ_extra_libpath=$targ_extra_emuls ;;
+mips*el-*-linux-*)	targ_emul=elf32ltsmip
+			targ_extra_emuls="elf32btsmip elf32ltsmipn32 elf64ltsmip elf32btsmipn32 elf64btsmip"
+			targ_extra_libpath=$targ_extra_emuls ;;
+mips*-*-linux-*)	targ_emul=elf32btsmip
+			targ_extra_emuls="elf32ltsmip elf32btsmipn32 elf64btsmip elf32ltsmipn32 elf64ltsmip"
+			targ_extra_libpath=$targ_extra_emuls ;;
+mips64*el-*-freebsd* | mips64*el-*-kfreebsd*-gnu)
+			targ_emul=elf32ltsmipn32_fbsd
+			targ_extra_emuls="elf32ltsmip elf32btsmip elf32ltsmipn32 elf32btsmipn32 elf64ltsmip elf64btsmip elf32ltsmip_fbsd elf32btsmip_fbsd elf32btsmipn32_fbsd elf64ltsmip_fbsd elf64btsmip_fbsd"
+			targ_extra_libpath=$targ_extra_emuls ;;
+mips64*-*-freebsd* | mips64*-*-kfreebsd*-gnu)
+			targ_emul=elf32btsmipn32_fbsd
+			targ_extra_emuls="elf32ltsmip elf32btsmip elf32ltsmipn32 elf32btsmipn32 elf64ltsmip elf64btsmip elf32ltsmip_fbsd elf32btsmip_fbsd elf32ltsmipn32_fbsd elf64ltsmip_fbsd elf64btsmip_fbsd"
+			targ_extra_libpath=$targ_extra_emuls ;;
+mips*el-*-freebsd* | mips*el-*-kfreebsd*-gnu)
+			targ_emul=elf32ltsmip_fbsd
+			targ_extra_emuls="elf32ltsmip elf32btsmip elf32ltsmipn32 elf32btsmipn32 elf64ltsmip elf64btsmip elf32ltsmipn32_fbsd elf32btsmip_fbsd elf32btsmipn32_fbsd elf64ltsmip_fbsd elf64btsmip_fbsd"
+			targ_extra_libpath=$targ_extra_emuls ;;
+mips*-*-freebsd* | mips*-*-kfreebsd*-gnu)
+			targ_emul=elf32btsmip_fbsd
+			targ_extra_emuls="elf32ltsmip elf32btsmip elf32ltsmipn32 elf32btsmipn32 elf64ltsmip elf64btsmip elf32ltsmip_fbsd elf32btsmipn32_fbsd elf32ltsmipn32_fbsd elf64ltsmip_fbsd elf64btsmip_fbsd"
+			targ_extra_libpath=$targ_extra_emuls ;;
+mips*-*-sysv4*)         targ_emul=elf32btsmip
+			;;
+mmix-*-*)		targ_emul=mmo
+			targ_extra_emuls=elf64mmix
+			;;
+am34-*-linux*)		targ_emul=elf32am33lin ;;
+am33_2.0-*-linux*)	targ_emul=elf32am33lin ;;
+mn10200-*-*)		targ_emul=mn10200 ;;
+mn10300-*-*)		targ_emul=mn10300
+			;;
+mt-*elf)                targ_emul=elf32mt
+			;;
+msp430-*-*)             targ_emul=msp430elf
+			targ_extra_emuls="msp430X"
+			;;
+nds32*le-*-elf*)	targ_emul=nds32elf
+			targ_extra_emuls="nds32elf16m nds32belf nds32belf16m"
+			;;
+nds32*be-*-elf*)	targ_emul=nds32belf
+			targ_extra_emuls="nds32elf nds32elf16m nds32belf16m"
+			;;
+nds32*le-*-linux-gnu*)	targ_emul=nds32elf_linux ;;
+nds32*be-*-linux-gnu*)	targ_emul=nds32belf_linux ;;
+nios2*-*-linux*)	targ_emul=nios2linux ;;
+nios2*-*-*)		targ_emul=nios2elf ;;
+ns32k-pc532-mach* | ns32k-pc532-ux*)  targ_emul=pc532macha ;;
+ns32k-*-netbsd* | ns32k-pc532-lites*) targ_emul=ns32knbsd
+			;;
+or1k-*-elf | or1knd-*-elf)		targ_emul=elf32or1k ;;
+or1k-*-linux* | or1knd-*-linux*)	targ_emul=elf32or1k_linux ;;
+or1k-*-rtems* | or1knd-*-rtems*)	targ_emul=elf32or1k
+			;;
+pdp11-*-*)		targ_emul=pdp11
+			;;
+pjl*-*-*)	        targ_emul=pjlelf
+			targ_extra_emuls="elf_i386 elf_iamcu" ;;
+pj*-*-*)	        targ_emul=pjelf
+			;;
+powerpc-*-freebsd* | powerpc-*-kfreebsd*-gnu)
+			targ_emul=elf32ppc_fbsd
+			targ_extra_emuls="elf32ppc elf32ppcsim"
+			targ_extra_libpath=elf32ppc;
+			tdir_elf32ppcsim=`echo ${targ_alias} | sed -e 's/ppc/ppcsim/'` ;;
+powerpc64-*-freebsd*)
+			targ_emul=elf64ppc_fbsd
+			targ_extra_emuls="elf64ppc elf32ppc_fbsd elf32ppc"
+			targ_extra_libpath="elf32ppc_fbsd elf32ppc"
+			tdir_elf32ppc=`echo "${targ_alias}" | sed -e 's/64//'`
+			tdir_elf32ppc_fbsd=$tdir_elf32ppc
+			;;
+powerpc-*-vxworks*)
+			targ_emul=elf32ppcvxworks
+			targ_extra_emuls="elf32ppc elf32ppclinux elf32ppcsim" ;;
+powerpc*-*-elf* | powerpc*-*-eabi* | powerpc*-*-sysv* \
+  | powerpc*-*-linux* | powerpc*-*-netbsd* | powerpc*-*-openbsd* \
+  | powerpc*-*-solaris* | powerpc*-*-kaos* | powerpc*-*-vxworks*)
+			case "${targ}" in
+			*64*)	targ_emul=elf64ppc
+				targ_extra_emuls="elf32ppc elf32ppclinux elf32ppcsim"
+				targ_extra_libpath="elf32ppc elf32ppclinux"
+				td=tdir_elf32ppc
+				case "${targ}" in
+				powerpc*le-*) td=tdir_elf32lppc;;
+				esac
+				eval ${td}=`echo "${targ_alias}" | sed -e 's/64//'`
+				eval ${td}linux=\$${td}
+				eval ${td}sim=\$${td}
+				;;
+			*linux*) targ_emul=elf32ppclinux
+				targ_extra_emuls="elf32ppc elf32ppcsim"
+				targ_extra_libpath=elf32ppc
+				targ64_extra_emuls=elf64ppc
+				targ64_extra_libpath=elf64ppc
+				;;
+			*)	targ_emul=elf32ppc
+				targ_extra_emuls="elf32ppclinux elf32ppcsim"
+				targ_extra_libpath=elf32ppclinux
+				targ64_extra_emuls=elf64ppc
+				targ64_extra_libpath=elf64ppc
+				;;
+			esac
+			case "${targ}" in
+			powerpc*le-*)
+				for z in targ_emul targ_extra_emuls targ_extra_libpath targ64_extra_emuls targ64_extra_libpath
+				do
+				  eval ${z}=\"`eval echo \\$${z} | sed -e 's/ppc/lppc/g'`\"
+				done
+			esac ;;
+powerpc-*-nto*)         targ_emul=elf32ppcnto ;;
+powerpcle-*-nto*)       targ_emul=elf32lppcnto ;;
+powerpc-*-rtems*)	targ_emul=elf32ppc ;;
+powerpc-*-macos*)	targ_emul=ppcmacos ;;
+powerpc-*-netware*)	targ_emul=ppcnw ;;
+powerpcle-*-pe | powerpcle-*-winnt* | powerpcle-*-cygwin*)
+			targ_emul=ppcpe
+			targ_extra_ofiles="deffilep.o pe-dll.o" ;;
+powerpc-*-aix[5-9]*)	targ_emul=aix5ppc ;;
+powerpc-*-aix*)		targ_emul=aixppc ;;
+powerpc-*-beos*)	targ_emul=aixppc ;;
+powerpc-*-windiss*)	targ_emul=elf32ppcwindiss ;;
+powerpc-*-lynxos*)	targ_emul=ppclynx ;;
+rs6000-*-aix[5-9]*)	targ_emul=aix5rs6 ;;
+rs6000-*-aix*)		targ_emul=aixrs6
+			;;
+rl78-*-*)		targ_emul=elf32rl78 ;;
+rx-*-*)			targ_emul=elf32rx ;;
+s390x-*-linux*)         targ_emul=elf64_s390
+			targ_extra_emuls=elf_s390
+			targ_extra_libpath=$targ_extra_emuls
+			tdir_elf_s390=`echo ${targ_alias} | sed -e 's/s390x/s390/'` ;;
+s390x-*-tpf*)		targ_emul=elf64_s390
+			tdir_elf_s390=`echo ${targ_alias} | sed -e 's/s390x/s390/'` ;;
+s390-*-linux*)          targ_emul=elf_s390
+			targ64_extra_emuls=elf64_s390
+			targ64_extra_libpath=elf64_s390
+			tdir_elf64_s390=`echo ${targ_alias} | sed -e 's/s390/s390x/'`
+			;;
+score-*-elf)            targ_emul=score7_elf
+			targ_extra_emuls=score3_elf ;;
+sh-*-linux*)		targ_emul=shlelf_linux
+			targ_extra_emuls="shelf_linux shlelf_fd shelf_fd"
+			targ_extra_libpath=shelf_linux ;;
+sh64eb-*-linux*)	targ_emul=shelf32_linux
+			targ_extra_emuls="shlelf32_linux" ;;
+sh64-*-linux*)		targ_emul=shlelf32_linux
+			targ_extra_emuls="shelf32_linux"
+			targ_extra_libpath=shelf32_linux ;;
+sh*eb-*-linux*)		targ_emul=shelf_linux
+			targ_extra_emuls="shelf_fd" ;;
+sh*-*-linux*)		targ_emul=shlelf_linux
+			targ_extra_emuls="shlelf_fd" ;;
+sh5le-*-netbsd*)	targ_emul=shlelf32_nbsd
+			targ_extra_emuls="shelf32_nbsd shelf64_nbsd shlelf64_nbsd shelf_nbsd shlelf_nbsd" ;;
+sh5-*-netbsd*)		targ_emul=shelf32_nbsd
+			targ_extra_emuls="shlelf32_nbsd shelf64_nbsd shlelf64_nbsd shelf_nbsd shlelf_nbsd" ;;
+sh64le-*-netbsd*)	targ_emul=shlelf64_nbsd
+			targ_extra_emuls="shelf64_nbsd shelf32_nbsd shlelf32_nbsd shelf_nbsd shlelf_nbsd" ;;
+sh64-*-netbsd*)		targ_emul=shelf64_nbsd
+			targ_extra_emuls="shlelf64_nbsd shelf32_nbsd shlelf32_nbsd shelf_nbsd shlelf_nbsd" ;;
+sh*l*-*-netbsdelf*)	targ_emul=shlelf_nbsd
+			targ_extra_emuls=shelf_nbsd ;;
+sh*-*-netbsdelf*)	targ_emul=shelf_nbsd
+			targ_extra_emuls=shlelf_nbsd ;;
+sh*-*-symbianelf*)	targ_emul=shlsymbian ;;
+shle*-*-elf* | sh[1234]*le*-*-elf | shle*-*-kaos*)
+			targ_emul=shlelf
+			targ_extra_emuls="shelf shl sh"	;;
+sh-*-rtemscoff*)	targ_emul=sh; targ_extra_emuls=shl ;;
+sh-*-elf* | sh[1234]*-*-elf | sh-*-rtems* | sh-*-kaos*)
+			targ_emul=shelf
+			targ_extra_emuls="shlelf sh shl" ;;
+sh-*-uclinux* | sh[12]-*-uclinux*)
+			targ_emul=shelf_uclinux
+			targ_extra_emuls="shelf shlelf sh shl shelf_fd shlelf_fd" ;;
+sh-*-vxworks)		targ_emul=shelf_vxworks
+			targ_extra_emuls=shlelf_vxworks ;;
+sh-*-nto*)		targ_emul=shelf_nto
+			targ_extra_emuls=shlelf_nto ;;
+sh-*-pe)		targ_emul=shpe ;
+			targ_extra_ofiles="deffilep.o pe-dll.o" ;;
+sh-*-*)			targ_emul=sh; targ_extra_emuls=shl ;;
+sh64le-*-elf*)		targ_emul=shlelf
+			targ_extra_emuls="shelf shlelf32 shelf32 shlelf64 shelf64"
+			targ_extra_libpath=$targ_extra_emuls ;;
+sh64-*-elf*)		targ_emul=shelf
+			targ_extra_emuls="shlelf shelf32 shlelf32 shelf64 shlelf64"
+			targ_extra_libpath=$targ_extra_emuls ;;
+sparc64-*-aout*)	targ_emul=sparcaout ;;
+sparc64-*-elf*)		targ_emul=elf64_sparc ;;
+sparc64-*-rtems*)	targ_emul=elf64_sparc ;;
+sparc-sun-sunos4*) 	targ_emul=sun4 ;;
+sparclite*-*-elf)	targ_emul=elf32_sparc ;;
+sparclite*-*-coff)	targ_emul=coff_sparc ;;
+sparclite*-fujitsu-*)	targ_emul=sparcaout ;;
+sparc*-*-aout)		targ_emul=sparcaout ;;
+sparc*-*-coff)		targ_emul=coff_sparc ;;
+sparc*-*-elf)		targ_emul=elf32_sparc ;;
+sparc*-*-sysv4*)	targ_emul=elf32_sparc ;;
+sparc*-*-vxworks*)	targ_emul=elf32_sparc_vxworks ;;
+sparc64-*-freebsd* | sparcv9-*-freebsd* | sparc64-*-kfreebsd*-gnu | sparcv9-*-kfreebsd*-gnu)
+			targ_emul=elf64_sparc_fbsd
+			targ_extra_emuls="elf64_sparc elf32_sparc"
+			targ_extra_libpath=$targ_extra_emuls
+			tdir_elf32_sparc=`echo ${targ_alias} | sed -e 's/64//'`	;;
+sparc*-*-linux*aout*)	targ_emul=sparclinux
+			targ_extra_emuls="elf32_sparc sun4"
+			tdir_elf32_sparc=`echo ${targ_alias} | sed -e 's/aout//'`
+			tdir_sun4=sparc-sun-sunos4 ;;
+sparc64-*-linux-*)	targ_emul=elf64_sparc
+			targ_extra_emuls="elf32_sparc sparclinux sun4"
+			targ_extra_libpath=elf32_sparc
+			tdir_elf32_sparc=`echo ${targ_alias} | sed -e 's/64//'`
+			tdir_sparclinux=${tdir_elf32_sparc}aout
+			tdir_sun4=sparc-sun-sunos4 ;;
+sparc*-*-linux-*)	targ_emul=elf32_sparc
+			targ_extra_emuls="sparclinux elf64_sparc sun4"
+			targ_extra_libpath=elf64_sparc
+			tdir_sparclinux=${targ_alias}aout
+			tdir_elf64_sparc=`echo ${targ_alias} | sed -e 's/32//'`
+			tdir_sun4=sparc-sun-sunos4 ;;
+sparc64-*-netbsd* | sparc64-*-openbsd*)
+			targ_emul=elf64_sparc
+			targ_extra_emuls="elf32_sparc" ;;
+sparc*-*-netbsd*elf*)	targ_emul=elf32_sparc ;;
+sparc*-*-netbsd*)	targ_emul=sparcnbsd ;;
+sparc-*-solaris2.[0-6] | sparc-*-solaris2.[0-6].*)
+			targ_emul=elf32_sparc_sol2
+			targ_extra_emuls=elf32_sparc ;;
+sparc-*-solaris2*)	targ_emul=elf32_sparc_sol2
+			targ_extra_emuls="elf32_sparc elf64_sparc_sol2 elf64_sparc"
+			targ_extra_libpath=$targ_extra_emuls
+			tdir_elf64_sparc=`echo ${targ_alias} | sed -e 's/32//'`	;;
+sparcv9-*-solaris2* | sparc64-*-solaris2*)
+			targ_emul=elf64_sparc_sol2
+			targ_extra_emuls="elf64_sparc elf32_sparc_sol2 elf32_sparc"
+			targ_extra_libpath=$targ_extra_emuls
+			tdir_elf32_sparc=`echo ${targ_alias} | sed -e 's/64//'` ;;
+sparc*-*-solaris2*)	targ_emul=elf32_sparc ;;
+sparc*-wrs-vxworks*)	targ_emul=sparcaout ;;
+sparc-*-rtems*)		targ_emul=elf32_sparc
+			;;
+spu-*-elf*)		targ_emul=elf32_spu ;;
+tic30-*-*aout*)		targ_emul=tic30aout ;;
+tic30-*-*coff*)		targ_emul=tic30coff ;;
+tic4x-*-* | c4x-*-*)    targ_emul=tic4xcoff ; targ_extra_emuls="tic3xcoff tic3xcoff_onchip" ;;
+tic54x-*-* | c54x*-*-*)	targ_emul=tic54xcoff ;;
+tic6x-*-elf)		targ_emul=elf32_tic6x_elf_le
+			targ_extra_emuls="elf32_tic6x_elf_be elf32_tic6x_le elf32_tic6x_be"
+			targ_extra_libpath=$targ_extra_emuls
+			;;
+tic6x-*-uclinux)	targ_emul=elf32_tic6x_linux_le
+			targ_extra_emuls="elf32_tic6x_linux_be elf32_tic6x_le elf32_tic6x_be"
+			targ_extra_libpath=$targ_extra_emuls
+			;;
+tic80-*-*)		targ_emul=tic80coff
+			;;
+tilegx-*-*)		targ_emul=elf64tilegx
+			targ_extra_emuls="elf64tilegx_be elf32tilegx elf32tilegx_be"
+			targ_extra_libpath=$targ_extra_emuls ;;
+tilegxbe-*-*)		targ_emul=elf64tilegx_be
+			targ_extra_emuls="elf64tilegx elf32tilegx elf32tilegx_be"
+			targ_extra_libpath=$targ_extra_emuls ;;
+tilepro-*-*)		targ_emul=elf32tilepro ;;
+ft32-*-*)		targ_emul=elf32ft32
+			;;
+v850*-*-*)		targ_emul=v850_rh850
+			targ_extra_emuls=v850
+			;;
+vax-dec-ultrix* | vax-dec-bsd*) targ_emul=vax ;;
+vax-*-netbsdelf*)	targ_emul=elf32vax
+			targ_extra_emuls=vaxnbsd ;;
+vax-*-netbsdaout* | vax-*-netbsd*)
+			targ_emul=vaxnbsd
+			targ_extra_emuls=elf32vax ;;
+vax-*-linux-*)  	targ_emul=elf32vax
+			;;
+visium-*-elf)		targ_emul=elf32visium
+			;;
+w65-*-*)		targ_emul=w65
+			;;
+xc16x-*-elf)		targ_emul=elf32xc16x
+                        targ_extra_emuls="elf32xc16xl elf32xc16xs"
+                        ;;
+xstormy16-*-*)		targ_emul=elf32xstormy16
+			;;
+xtensa*-*-*)		targ_emul=elf32xtensa
+			;;
+xgate-*-*)  		targ_emul=xgateelf
+			;;
+z80-*-coff)		targ_emul=z80
+			;;
+z8k-*-coff) 		targ_emul=z8002; targ_extra_emuls=z8001
+			;;
+*-*-ieee*)		targ_emul=vanilla
+			;;
+*-tandem-none)		targ_emul=st2000
+			;;
+*)
+  echo 2>&1 "*** ld does not support target ${targ}"
+  echo 2>&1 "*** see ld/configure.tgt for supported targets"
+  exit 1
+
+esac
+
+NATIVE_LIB_DIRS='/usr/local/lib /lib /usr/lib'
+case "${target}" in
+
+*-*-dragonfly*)
+  NATIVE_LIB_DIRS='/lib /usr/lib /usr/pkg/lib /usr/local/lib'
+  ;;
+
+*-*-freebsd*)
+  NATIVE_LIB_DIRS='/lib /usr/lib /usr/local/lib'
+  ;;
+
+hppa*64*-*-hpux11*)
+  NATIVE_LIB_DIRS=/usr/lib/pa20_64
+  ;;
+
+i[3-7]86-*-sysv4*)
+  NATIVE_LIB_DIRS='/usr/local/lib /usr/ccs/lib /lib /usr/lib'
+  ;;
+
+i[3-7]86-*-solaris*)
+  NATIVE_LIB_DIRS='/usr/local/lib /usr/ccs/lib /lib /usr/lib'
+  ;;
+
+i[3-7]86-pc-interix*)
+  NATIVE_LIB_DIRS='/usr/local/lib $$INTERIX_ROOT/usr/lib /lib /usr/lib'
+  ;;
+
+ia64-*-aix*)
+  NATIVE_LIB_DIRS='/usr/local/lib /usr/lib/ia64l64 /lib /usr/lib'
+  ;;
+
+sparc*-*-solaris2*)
+  NATIVE_LIB_DIRS='/usr/local/lib /usr/ccs/lib /lib /usr/lib'
+  ;;
+
+spu-*-elf*)
+  # This allows to build a pair of PPU/SPU toolchains with common sysroot.
+  NATIVE_LIB_DIRS='/lib'
+  ;;
+
+i[03-9x]86-*-cygwin* | x86_64-*-cygwin*)
+  NATIVE_LIB_DIRS='/usr/lib /usr/lib/w32api'
+  ;;
+
+*-*-linux*)
+  ;;
+
+*-*-netbsd*)
+  ;;
+
+alpha*-*-*)
+  NATIVE_LIB_DIRS='/usr/local/lib /usr/ccs/lib /lib /usr/lib'
+  ;;
+
+esac
diff -Naur binutils-2.26/ld/emulparams/thumb2pe.sh binutils-2.26.0007/ld/emulparams/thumb2pe.sh
--- binutils-2.26/ld/emulparams/thumb2pe.sh	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.26.0007/ld/emulparams/thumb2pe.sh	2016-03-10 17:02:24.350716269 +0100
@@ -0,0 +1,11 @@
+ARCH=arm
+SCRIPT_NAME=pe
+OUTPUT_FORMAT="pei-arm-winnt-little"
+LITTLE_OUTPUT_FORMAT="pei-arm-winnt-little"
+BIG_OUTPUT_FORMAT="pei-arm-winnt-big"
+RELOCATEABLE_OUTPUT_FORMAT="pe-arm-winnt-little"
+TEMPLATE_NAME=pe
+SUBSYSTEM=PE_DEF_SUBSYSTEM
+INITIAL_SYMBOL_CHAR=\"\"
+TARGET_PAGE_SIZE=0x1000
+GENERATE_AUTO_IMPORT_SCRIPT=1
diff -Naur binutils-2.26/ld/emultempl/pe.em binutils-2.26.0007/ld/emultempl/pe.em
--- binutils-2.26/ld/emultempl/pe.em	2015-11-13 09:27:42.000000000 +0100
+++ binutils-2.26.0007/ld/emultempl/pe.em	2016-03-10 17:02:24.367382568 +0100
@@ -41,6 +41,7 @@
 
 #if defined(TARGET_IS_armpe) \
     || defined(TARGET_IS_arm_epoc_pe) \
+    || defined(TARGET_IS_thumb2pe) \
     || defined(TARGET_IS_arm_wince_pe)
 #define bfd_arm_allocate_interworking_sections \
 	bfd_${EMULATION_NAME}_allocate_interworking_sections
@@ -96,6 +97,7 @@
     || defined(TARGET_IS_shpe) \
     || defined(TARGET_IS_armpe) \
     || defined(TARGET_IS_arm_epoc_pe) \
+    || defined(TARGET_IS_thumb2pe) \
     || defined(TARGET_IS_arm_wince_pe)
 #define DLL_SUPPORT
 #endif
@@ -106,7 +108,9 @@
 #define DEFAULT_PSEUDO_RELOC_VERSION 1
 #endif
 
-#if defined(TARGET_IS_i386pe) || ! defined(DLL_SUPPORT)
+#if defined(TARGET_IS_i386pe) \
+    || defined(TARGET_IS_thumb2pe) \
+    || ! defined(DLL_SUPPORT)
 #define	PE_DEF_SUBSYSTEM		3
 #else
 #undef NT_EXE_IMAGE_BASE
@@ -1532,6 +1536,7 @@
 #if defined (TARGET_IS_i386pe) \
     || defined (TARGET_IS_armpe) \
     || defined (TARGET_IS_arm_epoc_pe) \
+    || defined (TARGET_IS_thumb2pe) \
     || defined (TARGET_IS_arm_wince_pe)
   if (!bfd_link_relocatable (&link_info))
     pe_dll_build_sections (link_info.output_bfd, &link_info);
@@ -1543,7 +1548,8 @@
 #endif
 #endif /* DLL_SUPPORT */
 
-#if defined(TARGET_IS_armpe) || defined(TARGET_IS_arm_epoc_pe) || defined(TARGET_IS_arm_wince_pe)
+#if defined(TARGET_IS_armpe) || defined(TARGET_IS_arm_epoc_pe) \
+    || defined (TARGET_IS_thumb2pe) || defined(TARGET_IS_arm_wince_pe)
   if (strstr (bfd_get_target (link_info.output_bfd), "arm") == NULL)
     {
       /* The arm backend needs special fields in the output hash structure.
@@ -1868,7 +1874,8 @@
   ppc_allocate_toc_section (&link_info);
 #endif /* TARGET_IS_ppcpe */
 
-#if defined(TARGET_IS_armpe) || defined(TARGET_IS_arm_epoc_pe) || defined(TARGET_IS_arm_wince_pe)
+#if defined(TARGET_IS_armpe) || defined(TARGET_IS_arm_epoc_pe) \
+    || defined (TARGET_IS_thumb2pe) || defined(TARGET_IS_arm_wince_pe)
   /* FIXME: we should be able to set the size of the interworking stub
      section.
 
@@ -1890,7 +1897,7 @@
 
   /* We have seen it all. Allocate it, and carry on.  */
   bfd_arm_allocate_interworking_sections (& link_info);
-#endif /* TARGET_IS_armpe || TARGET_IS_arm_epoc_pe || TARGET_IS_arm_wince_pe */
+#endif
 
   before_allocation_default ();
 }
@@ -2008,6 +2015,9 @@
 #ifdef TARGET_IS_arm_epoc_pe
   pe_dll_id_target ("epoc-pei-arm-little");
 #endif
+#ifdef TARGET_IS_thumb2pe
+  pe_dll_id_target ("pei-arm-winnt-little");
+#endif
 #ifdef TARGET_IS_arm_wince_pe
   pe_dll_id_target ("pei-arm-wince-little");
 #endif
@@ -2020,7 +2030,8 @@
 static void
 gld_${EMULATION_NAME}_finish (void)
 {
-#if defined(TARGET_IS_armpe) || defined(TARGET_IS_arm_epoc_pe) || defined(TARGET_IS_arm_wince_pe)
+#if defined(TARGET_IS_armpe) || defined(TARGET_IS_arm_epoc_pe) \
+    || defined(TARGET_IS_thumb2pe) || defined(TARGET_IS_arm_wince_pe)
   struct bfd_link_hash_entry * h;
 
   if (thumb_entry_symbol != NULL)
@@ -2060,7 +2071,7 @@
       else
 	einfo (_("%P: warning: cannot find thumb start symbol %s\n"), thumb_entry_symbol);
     }
-#endif /* defined(TARGET_IS_armpe) || defined(TARGET_IS_arm_epoc_pe) || defined(TARGET_IS_arm_wince_pe) */
+#endif
 
   finish_default ();
 
diff -Naur binutils-2.26/ld/emultempl/pe.em.orig binutils-2.26.0007/ld/emultempl/pe.em.orig
--- binutils-2.26/ld/emultempl/pe.em.orig	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.26.0007/ld/emultempl/pe.em.orig	2016-03-10 17:01:12.568958077 +0100
@@ -0,0 +1,2485 @@
+# This shell script emits a C file. -*- C -*-
+# It does some substitutions.
+if [ -z "$MACHINE" ]; then
+  OUTPUT_ARCH=${ARCH}
+else
+  OUTPUT_ARCH=${ARCH}:${MACHINE}
+fi
+rm -f e${EMULATION_NAME}.c
+(echo;echo;echo;echo;echo)>e${EMULATION_NAME}.c # there, now line numbers match ;-)
+fragment <<EOF
+/* Copyright (C) 1995-2015 Free Software Foundation, Inc.
+
+   This file is part of the GNU Binutils.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+
+/* For WINDOWS_NT */
+/* The original file generated returned different default scripts depending
+   on whether certain switches were set, but these switches pertain to the
+   Linux system and that particular version of coff.  In the NT case, we
+   only determine if the subsystem is console or windows in order to select
+   the correct entry point by default. */
+
+#define TARGET_IS_${EMULATION_NAME}
+
+/* Do this before including bfd.h, so we prototype the right functions.  */
+
+#if defined(TARGET_IS_armpe) \
+    || defined(TARGET_IS_arm_epoc_pe) \
+    || defined(TARGET_IS_arm_wince_pe)
+#define bfd_arm_allocate_interworking_sections \
+	bfd_${EMULATION_NAME}_allocate_interworking_sections
+#define bfd_arm_get_bfd_for_interworking \
+	bfd_${EMULATION_NAME}_get_bfd_for_interworking
+#define bfd_arm_process_before_allocation \
+	bfd_${EMULATION_NAME}_process_before_allocation
+#endif
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "bfdlink.h"
+#include "getopt.h"
+#include "libiberty.h"
+#include "filenames.h"
+#include "ld.h"
+#include "ldmain.h"
+#include "ldexp.h"
+#include "ldlang.h"
+#include "ldfile.h"
+#include "ldemul.h"
+#include <ldgram.h>
+#include "ldlex.h"
+#include "ldmisc.h"
+#include "ldctor.h"
+#include "ldbuildid.h"
+#include "coff/internal.h"
+
+/* FIXME: See bfd/peXXigen.c for why we include an architecture specific
+   header in generic PE code.  */
+#include "coff/i386.h"
+#include "coff/pe.h"
+
+/* FIXME: These are BFD internal header files, and we should not be
+   using it here.  */
+#include "../bfd/libcoff.h"
+#include "../bfd/libpei.h"
+
+#include "deffile.h"
+#include "pe-dll.h"
+#include "safe-ctype.h"
+
+/* Permit the emulation parameters to override the default section
+   alignment by setting OVERRIDE_SECTION_ALIGNMENT.  FIXME: This makes
+   it seem that include/coff/internal.h should not define
+   PE_DEF_SECTION_ALIGNMENT.  */
+#if PE_DEF_SECTION_ALIGNMENT != ${OVERRIDE_SECTION_ALIGNMENT:-PE_DEF_SECTION_ALIGNMENT}
+#undef PE_DEF_SECTION_ALIGNMENT
+#define PE_DEF_SECTION_ALIGNMENT ${OVERRIDE_SECTION_ALIGNMENT}
+#endif
+
+#if defined(TARGET_IS_i386pe) \
+    || defined(TARGET_IS_shpe) \
+    || defined(TARGET_IS_armpe) \
+    || defined(TARGET_IS_arm_epoc_pe) \
+    || defined(TARGET_IS_arm_wince_pe)
+#define DLL_SUPPORT
+#endif
+
+#if defined(TARGET_IS_i386pe)
+#define DEFAULT_PSEUDO_RELOC_VERSION 2
+#else
+#define DEFAULT_PSEUDO_RELOC_VERSION 1
+#endif
+
+#if defined(TARGET_IS_i386pe) || ! defined(DLL_SUPPORT)
+#define	PE_DEF_SUBSYSTEM		3
+#else
+#undef NT_EXE_IMAGE_BASE
+#undef PE_DEF_SECTION_ALIGNMENT
+#undef PE_DEF_FILE_ALIGNMENT
+#define NT_EXE_IMAGE_BASE		0x00010000
+
+#if defined(TARGET_IS_armpe) || defined(TARGET_IS_arm_wince_pe)
+#define PE_DEF_SECTION_ALIGNMENT	0x00001000
+#define	PE_DEF_SUBSYSTEM		9
+#else
+#define PE_DEF_SECTION_ALIGNMENT	0x00000400
+#define	PE_DEF_SUBSYSTEM		2
+#endif
+#define PE_DEF_FILE_ALIGNMENT		0x00000200
+#endif
+
+static struct internal_extra_pe_aouthdr pe;
+static int dll;
+static int pe_subsystem = ${SUBSYSTEM};
+static flagword real_flags = 0;
+static int support_old_code = 0;
+static char * thumb_entry_symbol = NULL;
+static lang_assignment_statement_type *image_base_statement = 0;
+static unsigned short pe_dll_characteristics = 0;
+static bfd_boolean insert_timestamp = TRUE;
+static const char *emit_build_id;
+
+#ifdef DLL_SUPPORT
+static int pe_enable_stdcall_fixup = -1; /* 0=disable 1=enable.  */
+static char *pe_out_def_filename = NULL;
+static char *pe_implib_filename = NULL;
+static int pe_enable_auto_image_base = 0;
+static unsigned long pe_auto_image_base = 0x61500000;
+static char *pe_dll_search_prefix = NULL;
+#endif
+
+extern const char *output_filename;
+
+static int is_underscoring (void)
+{
+  int u = 0;
+  if (pe_leading_underscore != -1)
+    return pe_leading_underscore;
+  if (!bfd_get_target_info ("${OUTPUT_FORMAT}", NULL, NULL, &u, NULL))
+    bfd_get_target_info ("${RELOCATEABLE_OUTPUT_FORMAT}", NULL, NULL, &u, NULL);
+
+  if (u == -1)
+    abort ();
+  pe_leading_underscore = (u != 0 ? 1 : 0);
+  return pe_leading_underscore;
+}
+
+static void
+gld_${EMULATION_NAME}_before_parse (void)
+{
+  is_underscoring ();
+  ldfile_set_output_arch ("${OUTPUT_ARCH}", bfd_arch_`echo ${ARCH} | sed -e 's/:.*//'`);
+  output_filename = "${EXECUTABLE_NAME:-a.exe}";
+#ifdef DLL_SUPPORT
+  input_flags.dynamic = TRUE;
+  config.has_shared = 1;
+EOF
+
+# Cygwin no longer wants these noisy warnings.  Other PE
+# targets might like to consider adding themselves here.
+# See also the mail thread starting here for the reason why
+# merge_rdata defaults to 0 for cygwin:
+#  http://cygwin.com/ml/cygwin-apps/2013-04/msg00187.html
+case ${target} in
+  *-*-cygwin*)
+    default_auto_import=1
+    default_merge_rdata=0
+    ;;
+  i[3-7]86-*-mingw* | x86_64-*-mingw*)
+    default_auto_import=1
+    default_merge_rdata=0
+    ;;
+  *)
+    default_auto_import=-1
+    default_merge_rdata=1
+    ;;
+esac
+
+fragment <<EOF
+  link_info.pei386_auto_import = ${default_auto_import};
+  /* Use by default version.  */
+  link_info.pei386_runtime_pseudo_reloc = DEFAULT_PSEUDO_RELOC_VERSION;
+#endif
+}
+
+/* Indicates if RDATA shall be merged into DATA when pseudo-relocation
+   version 2 is used and auto-import is enabled.  */
+#define MERGE_RDATA_V2 ${default_merge_rdata}
+
+/* PE format extra command line options.  */
+
+/* Used for setting flags in the PE header.  */
+#define OPTION_BASE_FILE		(300  + 1)
+#define OPTION_DLL			(OPTION_BASE_FILE + 1)
+#define OPTION_FILE_ALIGNMENT		(OPTION_DLL + 1)
+#define OPTION_IMAGE_BASE		(OPTION_FILE_ALIGNMENT + 1)
+#define OPTION_MAJOR_IMAGE_VERSION	(OPTION_IMAGE_BASE + 1)
+#define OPTION_MAJOR_OS_VERSION		(OPTION_MAJOR_IMAGE_VERSION + 1)
+#define OPTION_MAJOR_SUBSYSTEM_VERSION	(OPTION_MAJOR_OS_VERSION + 1)
+#define OPTION_MINOR_IMAGE_VERSION	(OPTION_MAJOR_SUBSYSTEM_VERSION + 1)
+#define OPTION_MINOR_OS_VERSION		(OPTION_MINOR_IMAGE_VERSION + 1)
+#define OPTION_MINOR_SUBSYSTEM_VERSION	(OPTION_MINOR_OS_VERSION + 1)
+#define OPTION_SECTION_ALIGNMENT	(OPTION_MINOR_SUBSYSTEM_VERSION + 1)
+#define OPTION_STACK			(OPTION_SECTION_ALIGNMENT + 1)
+#define OPTION_SUBSYSTEM		(OPTION_STACK + 1)
+#define OPTION_HEAP			(OPTION_SUBSYSTEM + 1)
+#define OPTION_SUPPORT_OLD_CODE		(OPTION_HEAP + 1)
+#define OPTION_OUT_DEF			(OPTION_SUPPORT_OLD_CODE + 1)
+#define OPTION_EXPORT_ALL		(OPTION_OUT_DEF + 1)
+#define OPTION_EXCLUDE_SYMBOLS		(OPTION_EXPORT_ALL + 1)
+#define OPTION_EXCLUDE_ALL_SYMBOLS	(OPTION_EXCLUDE_SYMBOLS + 1)
+#define OPTION_KILL_ATS			(OPTION_EXCLUDE_ALL_SYMBOLS + 1)
+#define OPTION_STDCALL_ALIASES		(OPTION_KILL_ATS + 1)
+#define OPTION_ENABLE_STDCALL_FIXUP	(OPTION_STDCALL_ALIASES + 1)
+#define OPTION_DISABLE_STDCALL_FIXUP	(OPTION_ENABLE_STDCALL_FIXUP + 1)
+#define OPTION_IMPLIB_FILENAME		(OPTION_DISABLE_STDCALL_FIXUP + 1)
+#define OPTION_THUMB_ENTRY		(OPTION_IMPLIB_FILENAME + 1)
+#define OPTION_WARN_DUPLICATE_EXPORTS	(OPTION_THUMB_ENTRY + 1)
+#define OPTION_IMP_COMPAT		(OPTION_WARN_DUPLICATE_EXPORTS + 1)
+#define OPTION_ENABLE_AUTO_IMAGE_BASE	(OPTION_IMP_COMPAT + 1)
+#define OPTION_DISABLE_AUTO_IMAGE_BASE	(OPTION_ENABLE_AUTO_IMAGE_BASE + 1)
+#define OPTION_DLL_SEARCH_PREFIX	(OPTION_DISABLE_AUTO_IMAGE_BASE + 1)
+#define OPTION_NO_DEFAULT_EXCLUDES	(OPTION_DLL_SEARCH_PREFIX + 1)
+#define OPTION_DLL_ENABLE_AUTO_IMPORT	(OPTION_NO_DEFAULT_EXCLUDES + 1)
+#define OPTION_DLL_DISABLE_AUTO_IMPORT	(OPTION_DLL_ENABLE_AUTO_IMPORT + 1)
+#define OPTION_ENABLE_EXTRA_PE_DEBUG	(OPTION_DLL_DISABLE_AUTO_IMPORT + 1)
+#define OPTION_EXCLUDE_LIBS		(OPTION_ENABLE_EXTRA_PE_DEBUG + 1)
+#define OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC	\
+					(OPTION_EXCLUDE_LIBS + 1)
+#define OPTION_DLL_DISABLE_RUNTIME_PSEUDO_RELOC	\
+					(OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC + 1)
+#define OPTION_LARGE_ADDRESS_AWARE 	(OPTION_DLL_DISABLE_RUNTIME_PSEUDO_RELOC + 1)
+#define OPTION_DISABLE_LARGE_ADDRESS_AWARE \
+ 					(OPTION_LARGE_ADDRESS_AWARE + 1)
+#define OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC_V1	\
+					(OPTION_DISABLE_LARGE_ADDRESS_AWARE + 1)
+#define OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC_V2	\
+					(OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC_V1 + 1)
+#define OPTION_EXCLUDE_MODULES_FOR_IMPLIB \
+					(OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC_V2 + 1)
+#define OPTION_USE_NUL_PREFIXED_IMPORT_TABLES \
+					(OPTION_EXCLUDE_MODULES_FOR_IMPLIB + 1)
+#define OPTION_NO_LEADING_UNDERSCORE 	(OPTION_USE_NUL_PREFIXED_IMPORT_TABLES + 1)
+#define OPTION_LEADING_UNDERSCORE 	(OPTION_NO_LEADING_UNDERSCORE + 1)
+#define OPTION_ENABLE_LONG_SECTION_NAMES \
+					(OPTION_LEADING_UNDERSCORE + 1)
+#define OPTION_DISABLE_LONG_SECTION_NAMES \
+					(OPTION_ENABLE_LONG_SECTION_NAMES + 1)
+/* DLLCharacteristics flags.  */
+#define OPTION_DYNAMIC_BASE		(OPTION_DISABLE_LONG_SECTION_NAMES + 1)
+#define OPTION_FORCE_INTEGRITY		(OPTION_DYNAMIC_BASE + 1)
+#define OPTION_NX_COMPAT		(OPTION_FORCE_INTEGRITY + 1)
+#define OPTION_NO_ISOLATION		(OPTION_NX_COMPAT + 1)
+#define OPTION_NO_SEH			(OPTION_NO_ISOLATION + 1)
+#define OPTION_NO_BIND			(OPTION_NO_SEH + 1)
+#define OPTION_WDM_DRIVER		(OPTION_NO_BIND + 1)
+#define OPTION_TERMINAL_SERVER_AWARE	(OPTION_WDM_DRIVER + 1)
+/* Determinism.  */
+#define OPTION_INSERT_TIMESTAMP		(OPTION_TERMINAL_SERVER_AWARE + 1)
+#define OPTION_NO_INSERT_TIMESTAMP	(OPTION_INSERT_TIMESTAMP + 1)
+#define OPTION_BUILD_ID			(OPTION_NO_INSERT_TIMESTAMP + 1)
+
+static void
+gld${EMULATION_NAME}_add_options
+  (int ns ATTRIBUTE_UNUSED,
+   char **shortopts ATTRIBUTE_UNUSED,
+   int nl,
+   struct option **longopts,
+   int nrl ATTRIBUTE_UNUSED,
+   struct option **really_longopts ATTRIBUTE_UNUSED)
+{
+  static const struct option xtra_long[] =
+  {
+    /* PE options.  */
+    {"base-file", required_argument, NULL, OPTION_BASE_FILE},
+    {"dll", no_argument, NULL, OPTION_DLL},
+    {"file-alignment", required_argument, NULL, OPTION_FILE_ALIGNMENT},
+    {"heap", required_argument, NULL, OPTION_HEAP},
+    {"image-base", required_argument, NULL, OPTION_IMAGE_BASE},
+    {"major-image-version", required_argument, NULL, OPTION_MAJOR_IMAGE_VERSION},
+    {"major-os-version", required_argument, NULL, OPTION_MAJOR_OS_VERSION},
+    {"major-subsystem-version", required_argument, NULL, OPTION_MAJOR_SUBSYSTEM_VERSION},
+    {"minor-image-version", required_argument, NULL, OPTION_MINOR_IMAGE_VERSION},
+    {"minor-os-version", required_argument, NULL, OPTION_MINOR_OS_VERSION},
+    {"minor-subsystem-version", required_argument, NULL, OPTION_MINOR_SUBSYSTEM_VERSION},
+    {"section-alignment", required_argument, NULL, OPTION_SECTION_ALIGNMENT},
+    {"stack", required_argument, NULL, OPTION_STACK},
+    {"subsystem", required_argument, NULL, OPTION_SUBSYSTEM},
+    {"support-old-code", no_argument, NULL, OPTION_SUPPORT_OLD_CODE},
+    {"thumb-entry", required_argument, NULL, OPTION_THUMB_ENTRY},
+    {"use-nul-prefixed-import-tables", no_argument, NULL,
+     OPTION_USE_NUL_PREFIXED_IMPORT_TABLES},
+    {"no-leading-underscore", no_argument, NULL, OPTION_NO_LEADING_UNDERSCORE},
+    {"leading-underscore", no_argument, NULL, OPTION_LEADING_UNDERSCORE},
+    {"insert-timestamp", no_argument, NULL, OPTION_INSERT_TIMESTAMP},
+    {"no-insert-timestamp", no_argument, NULL, OPTION_NO_INSERT_TIMESTAMP},
+#ifdef DLL_SUPPORT
+    /* getopt allows abbreviations, so we do this to stop it
+       from treating -o as an abbreviation for this option.  */
+    {"output-def", required_argument, NULL, OPTION_OUT_DEF},
+    {"output-def", required_argument, NULL, OPTION_OUT_DEF},
+    {"export-all-symbols", no_argument, NULL, OPTION_EXPORT_ALL},
+    {"exclude-symbols", required_argument, NULL, OPTION_EXCLUDE_SYMBOLS},
+    {"exclude-all-symbols", no_argument, NULL, OPTION_EXCLUDE_ALL_SYMBOLS},
+    {"exclude-libs", required_argument, NULL, OPTION_EXCLUDE_LIBS},
+    {"exclude-modules-for-implib", required_argument, NULL, OPTION_EXCLUDE_MODULES_FOR_IMPLIB},
+    {"kill-at", no_argument, NULL, OPTION_KILL_ATS},
+    {"add-stdcall-alias", no_argument, NULL, OPTION_STDCALL_ALIASES},
+    {"enable-stdcall-fixup", no_argument, NULL, OPTION_ENABLE_STDCALL_FIXUP},
+    {"disable-stdcall-fixup", no_argument, NULL, OPTION_DISABLE_STDCALL_FIXUP},
+    {"out-implib", required_argument, NULL, OPTION_IMPLIB_FILENAME},
+    {"warn-duplicate-exports", no_argument, NULL, OPTION_WARN_DUPLICATE_EXPORTS},
+    /* getopt() allows abbreviations, so we do this to stop it from
+       treating -c as an abbreviation for these --compat-implib.  */
+    {"compat-implib", no_argument, NULL, OPTION_IMP_COMPAT},
+    {"compat-implib", no_argument, NULL, OPTION_IMP_COMPAT},
+    {"enable-auto-image-base", optional_argument, NULL, OPTION_ENABLE_AUTO_IMAGE_BASE},
+    {"disable-auto-image-base", no_argument, NULL, OPTION_DISABLE_AUTO_IMAGE_BASE},
+    {"dll-search-prefix", required_argument, NULL, OPTION_DLL_SEARCH_PREFIX},
+    {"no-default-excludes", no_argument, NULL, OPTION_NO_DEFAULT_EXCLUDES},
+    {"enable-auto-import", no_argument, NULL, OPTION_DLL_ENABLE_AUTO_IMPORT},
+    {"disable-auto-import", no_argument, NULL, OPTION_DLL_DISABLE_AUTO_IMPORT},
+    {"enable-extra-pe-debug", no_argument, NULL, OPTION_ENABLE_EXTRA_PE_DEBUG},
+    {"enable-runtime-pseudo-reloc", no_argument, NULL, OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC},
+    {"disable-runtime-pseudo-reloc", no_argument, NULL, OPTION_DLL_DISABLE_RUNTIME_PSEUDO_RELOC},
+    {"enable-runtime-pseudo-reloc-v1", no_argument, NULL, OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC_V1},
+    {"enable-runtime-pseudo-reloc-v2", no_argument, NULL, OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC_V2},
+#endif
+    {"large-address-aware", no_argument, NULL, OPTION_LARGE_ADDRESS_AWARE},
+    {"disable-large-address-aware", no_argument, NULL, OPTION_DISABLE_LARGE_ADDRESS_AWARE},
+    {"enable-long-section-names", no_argument, NULL, OPTION_ENABLE_LONG_SECTION_NAMES},
+    {"disable-long-section-names", no_argument, NULL, OPTION_DISABLE_LONG_SECTION_NAMES},
+    {"dynamicbase",no_argument, NULL, OPTION_DYNAMIC_BASE},
+    {"forceinteg", no_argument, NULL, OPTION_FORCE_INTEGRITY},
+    {"nxcompat", no_argument, NULL, OPTION_NX_COMPAT},
+    {"no-isolation", no_argument, NULL, OPTION_NO_ISOLATION},
+    {"no-seh", no_argument, NULL, OPTION_NO_SEH},
+    {"no-bind", no_argument, NULL, OPTION_NO_BIND},
+    {"wdmdriver", no_argument, NULL, OPTION_WDM_DRIVER},
+    {"tsaware", no_argument, NULL, OPTION_TERMINAL_SERVER_AWARE},
+    {"build-id", optional_argument, NULL, OPTION_BUILD_ID},
+    {NULL, no_argument, NULL, 0}
+  };
+
+  *longopts
+    = xrealloc (*longopts, nl * sizeof (struct option) + sizeof (xtra_long));
+  memcpy (*longopts + nl, &xtra_long, sizeof (xtra_long));
+}
+
+/* PE/WIN32; added routines to get the subsystem type, heap and/or stack
+   parameters which may be input from the command line.  */
+
+typedef struct
+{
+  void *ptr;
+  int size;
+  int value;
+  char *symbol;
+  int inited;
+  /* FALSE for an assembly level symbol and TRUE for a C visible symbol.
+     C visible symbols can be prefixed by underscore dependent to target's
+     settings.  */
+  bfd_boolean is_c_symbol;
+} definfo;
+
+/* Get symbol name dependent to kind and C visible state of
+   underscore.  */
+#define GET_INIT_SYMBOL_NAME(IDX) \
+  (init[(IDX)].symbol \
+  + ((init[(IDX)].is_c_symbol == FALSE || (is_underscoring () != 0)) ? 0 : 1))
+
+/* Decorates the C visible symbol by underscore, if target requires.  */
+#define U(CSTR) \
+  ((is_underscoring () == 0) ? CSTR : "_" CSTR)
+
+/* Get size of constant string for a possible underscore prefixed
+   C visible symbol.  */
+#define U_SIZE(CSTR) \
+  (sizeof (CSTR) + (is_underscoring () == 0 ? 0 : 1))
+
+#define D(field,symbol,def,usc)  {&pe.field, sizeof (pe.field), def, symbol, 0, usc}
+
+static definfo init[] =
+{
+  /* imagebase must be first */
+#define IMAGEBASEOFF 0
+  D(ImageBase,"__image_base__", NT_EXE_IMAGE_BASE, FALSE),
+#define DLLOFF 1
+  {&dll, sizeof(dll), 0, "__dll__", 0, FALSE},
+#define MSIMAGEBASEOFF	2
+  D(ImageBase, "___ImageBase", NT_EXE_IMAGE_BASE, TRUE),
+  D(SectionAlignment,"__section_alignment__", PE_DEF_SECTION_ALIGNMENT, FALSE),
+  D(FileAlignment,"__file_alignment__", PE_DEF_FILE_ALIGNMENT, FALSE),
+  D(MajorOperatingSystemVersion,"__major_os_version__", 4, FALSE),
+  D(MinorOperatingSystemVersion,"__minor_os_version__", 0, FALSE),
+  D(MajorImageVersion,"__major_image_version__", 1, FALSE),
+  D(MinorImageVersion,"__minor_image_version__", 0, FALSE),
+#if defined(TARGET_IS_armpe)  || defined(TARGET_IS_arm_wince_pe)
+  D(MajorSubsystemVersion,"__major_subsystem_version__", 3, FALSE),
+#else
+  D(MajorSubsystemVersion,"__major_subsystem_version__", 4, FALSE),
+#endif
+  D(MinorSubsystemVersion,"__minor_subsystem_version__", 0, FALSE),
+  D(Subsystem,"__subsystem__", ${SUBSYSTEM}, FALSE),
+  D(SizeOfStackReserve,"__size_of_stack_reserve__", 0x200000, FALSE),
+  D(SizeOfStackCommit,"__size_of_stack_commit__", 0x1000, FALSE),
+  D(SizeOfHeapReserve,"__size_of_heap_reserve__", 0x100000, FALSE),
+  D(SizeOfHeapCommit,"__size_of_heap_commit__", 0x1000, FALSE),
+  D(LoaderFlags,"__loader_flags__", 0x0, FALSE),
+  D(DllCharacteristics, "__dll_characteristics__", 0x0, FALSE),
+  { NULL, 0, 0, NULL, 0 , FALSE}
+};
+
+
+static void
+gld_${EMULATION_NAME}_list_options (FILE *file)
+{
+  fprintf (file, _("  --base_file <basefile>             Generate a base file for relocatable DLLs\n"));
+  fprintf (file, _("  --dll                              Set image base to the default for DLLs\n"));
+  fprintf (file, _("  --file-alignment <size>            Set file alignment\n"));
+  fprintf (file, _("  --heap <size>                      Set initial size of the heap\n"));
+  fprintf (file, _("  --image-base <address>             Set start address of the executable\n"));
+  fprintf (file, _("  --major-image-version <number>     Set version number of the executable\n"));
+  fprintf (file, _("  --major-os-version <number>        Set minimum required OS version\n"));
+  fprintf (file, _("  --major-subsystem-version <number> Set minimum required OS subsystem version\n"));
+  fprintf (file, _("  --minor-image-version <number>     Set revision number of the executable\n"));
+  fprintf (file, _("  --minor-os-version <number>        Set minimum required OS revision\n"));
+  fprintf (file, _("  --minor-subsystem-version <number> Set minimum required OS subsystem revision\n"));
+  fprintf (file, _("  --section-alignment <size>         Set section alignment\n"));
+  fprintf (file, _("  --stack <size>                     Set size of the initial stack\n"));
+  fprintf (file, _("  --subsystem <name>[:<version>]     Set required OS subsystem [& version]\n"));
+  fprintf (file, _("  --support-old-code                 Support interworking with old code\n"));
+  fprintf (file, _("  --[no-]leading-underscore          Set explicit symbol underscore prefix mode\n"));
+  fprintf (file, _("  --thumb-entry=<symbol>             Set the entry point to be Thumb <symbol>\n"));
+  fprintf (file, _("  --[no-]insert-timestamp            Use a real timestamp rather than zero (default).\n"));
+  fprintf (file, _("                                     This makes binaries non-deterministic\n"));
+#ifdef DLL_SUPPORT
+  fprintf (file, _("  --add-stdcall-alias                Export symbols with and without @nn\n"));
+  fprintf (file, _("  --disable-stdcall-fixup            Don't link _sym to _sym@nn\n"));
+  fprintf (file, _("  --enable-stdcall-fixup             Link _sym to _sym@nn without warnings\n"));
+  fprintf (file, _("  --exclude-symbols sym,sym,...      Exclude symbols from automatic export\n"));
+  fprintf (file, _("  --exclude-all-symbols              Exclude all symbols from automatic export\n"));
+  fprintf (file, _("  --exclude-libs lib,lib,...         Exclude libraries from automatic export\n"));
+  fprintf (file, _("  --exclude-modules-for-implib mod,mod,...\n"));
+  fprintf (file, _("                                     Exclude objects, archive members from auto\n"));
+  fprintf (file, _("                                     export, place into import library instead.\n"));
+  fprintf (file, _("  --export-all-symbols               Automatically export all globals to DLL\n"));
+  fprintf (file, _("  --kill-at                          Remove @nn from exported symbols\n"));
+  fprintf (file, _("  --out-implib <file>                Generate import library\n"));
+  fprintf (file, _("  --output-def <file>                Generate a .DEF file for the built DLL\n"));
+  fprintf (file, _("  --warn-duplicate-exports           Warn about duplicate exports\n"));
+  fprintf (file, _("  --compat-implib                    Create backward compatible import libs;\n\
+                                       create __imp_<SYMBOL> as well.\n"));
+  fprintf (file, _("  --enable-auto-image-base[=<address>] Automatically choose image base for DLLs\n\
+                                       (optionally starting with address) unless\n\
+                                       specifically set with --image-base\n"));
+  fprintf (file, _("  --disable-auto-image-base          Do not auto-choose image base. (default)\n"));
+  fprintf (file, _("  --dll-search-prefix=<string>       When linking dynamically to a dll without\n\
+                                       an importlib, use <string><basename>.dll\n\
+                                       in preference to lib<basename>.dll \n"));
+  fprintf (file, _("  --enable-auto-import               Do sophisticated linking of _sym to\n\
+                                       __imp_sym for DATA references\n"));
+  fprintf (file, _("  --disable-auto-import              Do not auto-import DATA items from DLLs\n"));
+  fprintf (file, _("  --enable-runtime-pseudo-reloc      Work around auto-import limitations by\n\
+                                       adding pseudo-relocations resolved at\n\
+                                       runtime.\n"));
+  fprintf (file, _("  --disable-runtime-pseudo-reloc     Do not add runtime pseudo-relocations for\n\
+                                       auto-imported DATA.\n"));
+  fprintf (file, _("  --enable-extra-pe-debug            Enable verbose debug output when building\n\
+                                       or linking to DLLs (esp. auto-import)\n"));
+#endif
+  fprintf (file, _("  --large-address-aware              Executable supports virtual addresses\n\
+                                       greater than 2 gigabytes\n"));
+  fprintf (file, _("  --disable-large-address-aware      Executable does not support virtual\n\
+                                       addresses greater than 2 gigabytes\n"));
+  fprintf (file, _("  --enable-long-section-names        Use long COFF section names even in\n\
+                                       executable image files\n"));
+  fprintf (file, _("  --disable-long-section-names       Never use long COFF section names, even\n\
+                                       in object files\n"));
+  fprintf (file, _("  --dynamicbase			 Image base address may be relocated using\n\
+				       address space layout randomization (ASLR)\n"));
+  fprintf (file, _("  --forceinteg		 Code integrity checks are enforced\n"));
+  fprintf (file, _("  --nxcompat		 Image is compatible with data execution prevention\n"));
+  fprintf (file, _("  --no-isolation		 Image understands isolation but do not isolate the image\n"));
+  fprintf (file, _("  --no-seh			 Image does not use SEH. No SE handler may\n\
+				       be called in this image\n"));
+  fprintf (file, _("  --no-bind			 Do not bind this image\n"));
+  fprintf (file, _("  --wdmdriver		 Driver uses the WDM model\n"));
+  fprintf (file, _("  --tsaware                  Image is Terminal Server aware\n"));
+  fprintf (file, _("  --build-id[=STYLE]         Generate build ID\n"));
+}
+
+
+static void
+set_pe_name (char *name, long val)
+{
+  int i;
+  is_underscoring ();
+
+  /* Find the name and set it.  */
+  for (i = 0; init[i].ptr; i++)
+    {
+      if (strcmp (name, GET_INIT_SYMBOL_NAME (i)) == 0)
+	{
+	  init[i].value = val;
+	  init[i].inited = 1;
+	  if (strcmp (name,"__image_base__") == 0)
+	    set_pe_name (U ("__ImageBase"), val);
+	  return;
+	}
+    }
+  abort ();
+}
+
+static void
+set_entry_point (void)
+{
+  const char *entry;
+  const char *initial_symbol_char;
+  int i;
+
+  static const struct
+    {
+      const int value;
+      const char *entry;
+    }
+  v[] =
+    {
+      { 1, "NtProcessStartup"  },
+      { 2, "WinMainCRTStartup" },
+      { 3, "mainCRTStartup"    },
+      { 7, "__PosixProcessStartup"},
+      { 9, "WinMainCRTStartup" },
+      {14, "mainCRTStartup"    },
+      { 0, NULL          }
+    };
+
+  /* Entry point name for arbitrary subsystem numbers.  */
+  static const char default_entry[] = "mainCRTStartup";
+
+  if (bfd_link_pic (&link_info) || dll)
+    {
+#if defined (TARGET_IS_i386pe)
+      entry = "DllMainCRTStartup@12";
+#else
+      entry = "DllMainCRTStartup";
+#endif
+    }
+  else
+    {
+
+      for (i = 0; v[i].entry; i++)
+        if (v[i].value == pe_subsystem)
+          break;
+
+      /* If no match, use the default.  */
+      if (v[i].entry != NULL)
+        entry = v[i].entry;
+      else
+        entry = default_entry;
+    }
+
+  initial_symbol_char = (is_underscoring () != 0 ? "_" : "");
+
+  if (*initial_symbol_char != '\0')
+    {
+      char *alc_entry;
+
+      /* lang_default_entry expects its argument to be permanently
+	 allocated, so we don't free this string.  */
+      alc_entry = xmalloc (strlen (initial_symbol_char)
+			   + strlen (entry)
+			   + 1);
+      strcpy (alc_entry, initial_symbol_char);
+      strcat (alc_entry, entry);
+      entry = alc_entry;
+    }
+
+  lang_default_entry (entry);
+}
+
+static void
+set_pe_subsystem (void)
+{
+  const char *sver;
+  char *end;
+  int len;
+  int i;
+  unsigned long temp_subsystem;
+  static const struct
+    {
+      const char *name;
+      const int value;
+    }
+  v[] =
+    {
+      { "native",  1},
+      { "windows", 2},
+      { "console", 3},
+      { "posix",   7},
+      { "wince",   9},
+      { "xbox",   14},
+      { NULL, 0 }
+    };
+
+  /* Check for the presence of a version number.  */
+  sver = strchr (optarg, ':');
+  if (sver == NULL)
+    len = strlen (optarg);
+  else
+    {
+      len = sver - optarg;
+      set_pe_name ("__major_subsystem_version__",
+		    strtoul (sver + 1, &end, 0));
+      if (*end == '.')
+	set_pe_name ("__minor_subsystem_version__",
+		      strtoul (end + 1, &end, 0));
+      if (*end != '\0')
+	einfo (_("%P: warning: bad version number in -subsystem option\n"));
+    }
+
+  /* Check for numeric subsystem.  */
+  temp_subsystem = strtoul (optarg, & end, 0);
+  if ((*end == ':' || *end == '\0') && (temp_subsystem < 65536))
+    {
+      /* Search list for a numeric match to use its entry point.  */
+      for (i = 0; v[i].name; i++)
+	if (v[i].value == (int) temp_subsystem)
+	  break;
+
+      /* Use this subsystem.  */
+      pe_subsystem = (int) temp_subsystem;
+    }
+  else
+    {
+      /* Search for subsystem by name.  */
+      for (i = 0; v[i].name; i++)
+	if (strncmp (optarg, v[i].name, len) == 0
+	    && v[i].name[len] == '\0')
+	  break;
+
+      if (v[i].name == NULL)
+	{
+	  einfo (_("%P%F: invalid subsystem type %s\n"), optarg);
+	  return;
+	}
+
+      pe_subsystem = v[i].value;
+    }
+
+  set_pe_name ("__subsystem__", pe_subsystem);
+
+  return;
+}
+
+
+static void
+set_pe_value (char *name)
+{
+  char *end;
+
+  set_pe_name (name,  strtoul (optarg, &end, 0));
+
+  if (end == optarg)
+    einfo (_("%P%F: invalid hex number for PE parameter '%s'\n"), optarg);
+
+  optarg = end;
+}
+
+
+static void
+set_pe_stack_heap (char *resname, char *comname)
+{
+  set_pe_value (resname);
+
+  if (*optarg == ',')
+    {
+      optarg++;
+      set_pe_value (comname);
+    }
+  else if (*optarg)
+    einfo (_("%P%F: strange hex info for PE parameter '%s'\n"), optarg);
+}
+
+#define DEFAULT_BUILD_ID_STYLE	"md5"
+
+static bfd_boolean
+gld${EMULATION_NAME}_handle_option (int optc)
+{
+  switch (optc)
+    {
+    default:
+      return FALSE;
+
+    case OPTION_BASE_FILE:
+      link_info.base_file = fopen (optarg, FOPEN_WB);
+      if (link_info.base_file == NULL)
+	einfo (_("%F%P: cannot open base file %s\n"), optarg);
+      break;
+
+      /* PE options.  */
+    case OPTION_HEAP:
+      set_pe_stack_heap ("__size_of_heap_reserve__", "__size_of_heap_commit__");
+      break;
+    case OPTION_STACK:
+      set_pe_stack_heap ("__size_of_stack_reserve__", "__size_of_stack_commit__");
+      break;
+    case OPTION_SUBSYSTEM:
+      set_pe_subsystem ();
+      break;
+    case OPTION_MAJOR_OS_VERSION:
+      set_pe_value ("__major_os_version__");
+      break;
+    case OPTION_MINOR_OS_VERSION:
+      set_pe_value ("__minor_os_version__");
+      break;
+    case OPTION_MAJOR_SUBSYSTEM_VERSION:
+      set_pe_value ("__major_subsystem_version__");
+      break;
+    case OPTION_MINOR_SUBSYSTEM_VERSION:
+      set_pe_value ("__minor_subsystem_version__");
+      break;
+    case OPTION_MAJOR_IMAGE_VERSION:
+      set_pe_value ("__major_image_version__");
+      break;
+    case OPTION_MINOR_IMAGE_VERSION:
+      set_pe_value ("__minor_image_version__");
+      break;
+    case OPTION_FILE_ALIGNMENT:
+      set_pe_value ("__file_alignment__");
+      break;
+    case OPTION_SECTION_ALIGNMENT:
+      set_pe_value ("__section_alignment__");
+      break;
+    case OPTION_DLL:
+      set_pe_name ("__dll__", 1);
+      break;
+    case OPTION_IMAGE_BASE:
+      set_pe_value ("__image_base__");
+      break;
+    case OPTION_SUPPORT_OLD_CODE:
+      support_old_code = 1;
+      break;
+    case OPTION_THUMB_ENTRY:
+      thumb_entry_symbol = optarg;
+      break;
+    case OPTION_USE_NUL_PREFIXED_IMPORT_TABLES:
+      pe_use_nul_prefixed_import_tables = TRUE;
+      break;
+    case OPTION_NO_LEADING_UNDERSCORE:
+      pe_leading_underscore = 0;
+      break;
+    case OPTION_LEADING_UNDERSCORE:
+      pe_leading_underscore = 1;
+      break;
+    case OPTION_INSERT_TIMESTAMP:
+      insert_timestamp = TRUE;
+      break;
+    case OPTION_NO_INSERT_TIMESTAMP:
+      insert_timestamp = FALSE;
+      break;
+#ifdef DLL_SUPPORT
+    case OPTION_OUT_DEF:
+      pe_out_def_filename = xstrdup (optarg);
+      break;
+    case OPTION_EXPORT_ALL:
+      pe_dll_export_everything = 1;
+      break;
+    case OPTION_EXCLUDE_SYMBOLS:
+      pe_dll_add_excludes (optarg, EXCLUDESYMS);
+      break;
+    case OPTION_EXCLUDE_ALL_SYMBOLS:
+      pe_dll_exclude_all_symbols = 1;
+      break;
+    case OPTION_EXCLUDE_LIBS:
+      pe_dll_add_excludes (optarg, EXCLUDELIBS);
+      break;
+    case OPTION_EXCLUDE_MODULES_FOR_IMPLIB:
+      pe_dll_add_excludes (optarg, EXCLUDEFORIMPLIB);
+      break;
+    case OPTION_KILL_ATS:
+      pe_dll_kill_ats = 1;
+      break;
+    case OPTION_STDCALL_ALIASES:
+      pe_dll_stdcall_aliases = 1;
+      break;
+    case OPTION_ENABLE_STDCALL_FIXUP:
+      pe_enable_stdcall_fixup = 1;
+      break;
+    case OPTION_DISABLE_STDCALL_FIXUP:
+      pe_enable_stdcall_fixup = 0;
+      break;
+    case OPTION_IMPLIB_FILENAME:
+      pe_implib_filename = xstrdup (optarg);
+      break;
+    case OPTION_WARN_DUPLICATE_EXPORTS:
+      pe_dll_warn_dup_exports = 1;
+      break;
+    case OPTION_IMP_COMPAT:
+      pe_dll_compat_implib = 1;
+      break;
+    case OPTION_ENABLE_AUTO_IMAGE_BASE:
+      pe_enable_auto_image_base = 1;
+      if (optarg && *optarg)
+	{
+	  char *end;
+	  pe_auto_image_base = strtoul (optarg, &end, 0);
+	  /* XXX should check that we actually parsed something */
+	}
+      break;
+    case OPTION_DISABLE_AUTO_IMAGE_BASE:
+      pe_enable_auto_image_base = 0;
+      break;
+    case OPTION_DLL_SEARCH_PREFIX:
+      pe_dll_search_prefix = xstrdup (optarg);
+      break;
+    case OPTION_NO_DEFAULT_EXCLUDES:
+      pe_dll_do_default_excludes = 0;
+      break;
+    case OPTION_DLL_ENABLE_AUTO_IMPORT:
+      link_info.pei386_auto_import = 1;
+      break;
+    case OPTION_DLL_DISABLE_AUTO_IMPORT:
+      link_info.pei386_auto_import = 0;
+      break;
+    case OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC:
+      link_info.pei386_runtime_pseudo_reloc =
+	DEFAULT_PSEUDO_RELOC_VERSION;
+      break;
+    case OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC_V1:
+      link_info.pei386_runtime_pseudo_reloc = 1;
+      break;
+    case OPTION_DLL_ENABLE_RUNTIME_PSEUDO_RELOC_V2:
+      link_info.pei386_runtime_pseudo_reloc = 2;
+      break;
+    case OPTION_DLL_DISABLE_RUNTIME_PSEUDO_RELOC:
+      link_info.pei386_runtime_pseudo_reloc = 0;
+      break;
+    case OPTION_ENABLE_EXTRA_PE_DEBUG:
+      pe_dll_extra_pe_debug = 1;
+      break;
+#endif
+    case OPTION_LARGE_ADDRESS_AWARE:
+      real_flags |= IMAGE_FILE_LARGE_ADDRESS_AWARE;
+      break;
+    case OPTION_DISABLE_LARGE_ADDRESS_AWARE:
+      real_flags &= ~ IMAGE_FILE_LARGE_ADDRESS_AWARE;
+      break;
+    case OPTION_ENABLE_LONG_SECTION_NAMES:
+      pe_use_coff_long_section_names = 1;
+      break;
+    case OPTION_DISABLE_LONG_SECTION_NAMES:
+      pe_use_coff_long_section_names = 0;
+      break;
+/*  Get DLLCharacteristics bits  */
+    case OPTION_DYNAMIC_BASE:
+      pe_dll_characteristics |= IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE;
+      break;
+    case OPTION_FORCE_INTEGRITY:
+      pe_dll_characteristics |= IMAGE_DLL_CHARACTERISTICS_FORCE_INTEGRITY;
+      break;
+    case OPTION_NX_COMPAT:
+      pe_dll_characteristics |= IMAGE_DLL_CHARACTERISTICS_NX_COMPAT;
+      break;
+    case OPTION_NO_ISOLATION:
+      pe_dll_characteristics |= IMAGE_DLLCHARACTERISTICS_NO_ISOLATION;
+      break;
+    case OPTION_NO_SEH:
+      pe_dll_characteristics |= IMAGE_DLLCHARACTERISTICS_NO_SEH;
+      break;
+    case OPTION_NO_BIND:
+      pe_dll_characteristics |= IMAGE_DLLCHARACTERISTICS_NO_BIND;
+      break;
+    case OPTION_WDM_DRIVER:
+      pe_dll_characteristics |= IMAGE_DLLCHARACTERISTICS_WDM_DRIVER;
+      break;
+    case OPTION_TERMINAL_SERVER_AWARE:
+      pe_dll_characteristics |= IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE;
+      break;
+    case OPTION_BUILD_ID:
+      if (emit_build_id != NULL)
+	{
+	  free ((char *) emit_build_id);
+	  emit_build_id = NULL;
+	}
+      if (optarg == NULL)
+	optarg = DEFAULT_BUILD_ID_STYLE;
+      if (strcmp (optarg, "none"))
+	emit_build_id = xstrdup (optarg);
+      break;
+    }
+
+  /*  Set DLLCharacteristics bits  */
+  set_pe_name ("__dll_characteristics__", pe_dll_characteristics);
+
+  return TRUE;
+}
+
+
+#ifdef DLL_SUPPORT
+static unsigned long
+strhash (const char *str)
+{
+  const unsigned char *s;
+  unsigned long hash;
+  unsigned int c;
+  unsigned int len;
+
+  hash = 0;
+  len = 0;
+  s = (const unsigned char *) str;
+  while ((c = *s++) != '\0')
+    {
+      hash += c + (c << 17);
+      hash ^= hash >> 2;
+      ++len;
+    }
+  hash += len + (len << 17);
+  hash ^= hash >> 2;
+
+  return hash;
+}
+
+/* Use the output file to create a image base for relocatable DLLs.  */
+
+static unsigned long
+compute_dll_image_base (const char *ofile)
+{
+  unsigned long hash = strhash (ofile);
+  return pe_auto_image_base + ((hash << 16) & 0x0FFC0000);
+}
+#endif
+
+/* Assign values to the special symbols before the linker script is
+   read.  */
+
+static void
+gld_${EMULATION_NAME}_set_symbols (void)
+{
+  /* Run through and invent symbols for all the
+     names and insert the defaults.  */
+  int j;
+
+  is_underscoring ();
+
+  if (!init[IMAGEBASEOFF].inited)
+    {
+      if (bfd_link_relocatable (&link_info))
+	init[IMAGEBASEOFF].value = 0;
+      else if (init[DLLOFF].value || bfd_link_dll (&link_info))
+	{
+#ifdef DLL_SUPPORT
+	  init[IMAGEBASEOFF].value = (pe_enable_auto_image_base
+				      ? compute_dll_image_base (output_filename)
+				      : NT_DLL_IMAGE_BASE);
+#else
+	  init[IMAGEBASEOFF].value = NT_DLL_IMAGE_BASE;
+#endif
+	}
+      else
+	init[IMAGEBASEOFF].value = NT_EXE_IMAGE_BASE;
+      init[MSIMAGEBASEOFF].value = init[IMAGEBASEOFF].value;
+    }
+
+  /* Don't do any symbol assignments if this is a relocatable link.  */
+  if (bfd_link_relocatable (&link_info))
+    return;
+
+  /* Glue the assignments into the abs section.  */
+  push_stat_ptr (&abs_output_section->children);
+
+  for (j = 0; init[j].ptr; j++)
+    {
+      long val = init[j].value;
+      lang_assignment_statement_type *rv;
+
+      rv = lang_add_assignment (exp_assign (GET_INIT_SYMBOL_NAME (j),
+					    exp_intop (val), FALSE));
+      if (init[j].size == sizeof (short))
+	*(short *) init[j].ptr = val;
+      else if (init[j].size == sizeof (int))
+	*(int *) init[j].ptr = val;
+      else if (init[j].size == sizeof (long))
+	*(long *) init[j].ptr = val;
+      /* This might be a long long or other special type.  */
+      else if (init[j].size == sizeof (bfd_vma))
+	*(bfd_vma *) init[j].ptr = val;
+      else	abort ();
+      if (j == IMAGEBASEOFF)
+	image_base_statement = rv;
+    }
+  /* Restore the pointer.  */
+  pop_stat_ptr ();
+
+  if (pe.FileAlignment > pe.SectionAlignment)
+    {
+      einfo (_("%P: warning, file alignment > section alignment.\n"));
+    }
+}
+
+/* This is called after the linker script and the command line options
+   have been read.  */
+
+static void
+gld_${EMULATION_NAME}_after_parse (void)
+{
+  /* PR ld/6744:  Warn the user if they have used an ELF-only
+     option hoping it will work on PE.  */
+  if (link_info.export_dynamic)
+    einfo (_("%P: warning: --export-dynamic is not supported for PE "
+      "targets, did you mean --export-all-symbols?\n"));
+
+  set_entry_point ();
+
+  after_parse_default ();
+}
+
+/* pe-dll.c directly accesses pe_data_import_dll,
+   so it must be defined outside of #ifdef DLL_SUPPORT.
+   Note - this variable is deliberately not initialised.
+   This allows it to be treated as a common varaible, and only
+   exist in one incarnation in a multiple target enabled linker.  */
+char * pe_data_import_dll;
+
+#ifdef DLL_SUPPORT
+static struct bfd_link_hash_entry *pe_undef_found_sym;
+
+static bfd_boolean
+pe_undef_cdecl_match (struct bfd_link_hash_entry *h, void *inf)
+{
+  int sl;
+  char *string = inf;
+  const char *hs = h->root.string;
+
+  sl = strlen (string);
+  if (h->type == bfd_link_hash_defined
+      && ((*hs == '@' && *string == '_'
+		   && strncmp (hs + 1, string + 1, sl - 1) == 0)
+		  || strncmp (hs, string, sl) == 0)
+      && h->root.string[sl] == '@')
+    {
+      pe_undef_found_sym = h;
+      return FALSE;
+    }
+  return TRUE;
+}
+
+static void
+pe_fixup_stdcalls (void)
+{
+  static int gave_warning_message = 0;
+  struct bfd_link_hash_entry *undef, *sym;
+
+  if (pe_dll_extra_pe_debug)
+    printf ("%s\n", __FUNCTION__);
+
+  for (undef = link_info.hash->undefs; undef; undef=undef->u.undef.next)
+    if (undef->type == bfd_link_hash_undefined)
+      {
+	char* at = strchr (undef->root.string, '@');
+	int lead_at = (*undef->root.string == '@');
+	if (lead_at)
+	  at = strchr (undef->root.string + 1, '@');
+
+	if (at || lead_at)
+	  {
+	    /* The symbol is a stdcall symbol, so let's look for a
+	       cdecl symbol with the same name and resolve to that.  */
+	    char *cname = xstrdup (undef->root.string);
+
+	    if (lead_at)
+	      *cname = '_';
+	    at = strchr (cname, '@');
+	    if (at)
+	      *at = 0;
+	    sym = bfd_link_hash_lookup (link_info.hash, cname, 0, 0, 1);
+
+	    if (sym && sym->type == bfd_link_hash_defined)
+	      {
+		undef->type = bfd_link_hash_defined;
+		undef->u.def.value = sym->u.def.value;
+		undef->u.def.section = sym->u.def.section;
+
+		if (pe_enable_stdcall_fixup == -1)
+		  {
+		    einfo (_("Warning: resolving %s by linking to %s\n"),
+			   undef->root.string, cname);
+		    if (! gave_warning_message)
+		      {
+			gave_warning_message = 1;
+			einfo (_("Use --enable-stdcall-fixup to disable these warnings\n"));
+			einfo (_("Use --disable-stdcall-fixup to disable these fixups\n"));
+		      }
+		  }
+	      }
+	  }
+	else
+	  {
+	    /* The symbol is a cdecl symbol, so we look for stdcall
+	       symbols - which means scanning the whole symbol table.  */
+	    pe_undef_found_sym = 0;
+	    bfd_link_hash_traverse (link_info.hash, pe_undef_cdecl_match,
+				    (char *) undef->root.string);
+	    sym = pe_undef_found_sym;
+	    if (sym)
+	      {
+		undef->type = bfd_link_hash_defined;
+		undef->u.def.value = sym->u.def.value;
+		undef->u.def.section = sym->u.def.section;
+
+		if (pe_enable_stdcall_fixup == -1)
+		  {
+		    einfo (_("Warning: resolving %s by linking to %s\n"),
+			   undef->root.string, sym->root.string);
+		    if (! gave_warning_message)
+		      {
+			gave_warning_message = 1;
+			einfo (_("Use --enable-stdcall-fixup to disable these warnings\n"));
+			einfo (_("Use --disable-stdcall-fixup to disable these fixups\n"));
+		      }
+		  }
+	      }
+	  }
+      }
+}
+
+static int
+make_import_fixup (arelent *rel, asection *s)
+{
+  struct bfd_symbol *sym = *rel->sym_ptr_ptr;
+  char addend[4];
+
+  if (pe_dll_extra_pe_debug)
+    printf ("arelent: %s@%#lx: add=%li\n", sym->name,
+	    (unsigned long) rel->address, (long) rel->addend);
+
+  if (! bfd_get_section_contents (s->owner, s, addend, rel->address, sizeof (addend)))
+    einfo (_("%C: Cannot get section contents - auto-import exception\n"),
+	   s->owner, s, rel->address);
+
+  pe_create_import_fixup (rel, s, bfd_get_32 (s->owner, addend));
+
+  return 1;
+}
+
+static void
+pe_find_data_imports (void)
+{
+  struct bfd_link_hash_entry *undef, *sym;
+
+  if (link_info.pei386_auto_import == 0)
+    return;
+
+  for (undef = link_info.hash->undefs; undef; undef=undef->u.undef.next)
+    {
+      if (undef->type == bfd_link_hash_undefined)
+	{
+	  /* C++ symbols are *long*.  */
+#define BUF_SIZE 4096
+	  char buf[BUF_SIZE];
+
+	  if (pe_dll_extra_pe_debug)
+	    printf ("%s:%s\n", __FUNCTION__, undef->root.string);
+
+	  if (strlen (undef->root.string) > (BUF_SIZE - 6))
+	    {
+	      /* PR linker/18466.  */
+	      einfo (_("%P: internal error: symbol too long: %s\n"),
+		     undef->root.string);
+	      return;
+	    }
+
+	  sprintf (buf, "__imp_%s", undef->root.string);
+
+	  sym = bfd_link_hash_lookup (link_info.hash, buf, 0, 0, 1);
+
+	  if (sym && sym->type == bfd_link_hash_defined)
+	    {
+	      bfd *b = sym->u.def.section->owner;
+	      asymbol **symbols;
+	      int nsyms, i;
+
+	      if (link_info.pei386_auto_import == -1)
+		{
+		  static bfd_boolean warned = FALSE;
+
+		  info_msg (_("Info: resolving %s by linking to %s (auto-import)\n"),
+			    undef->root.string, buf);
+
+		  /* PR linker/4844.  */
+		  if (! warned)
+		    {
+		      warned = TRUE;
+		      einfo (_("%P: warning: auto-importing has been activated without --enable-auto-import specified on the command line.\n\
+This should work unless it involves constant data structures referencing symbols from auto-imported DLLs.\n"));
+		    }
+		}
+
+	      if (!bfd_generic_link_read_symbols (b))
+		{
+		  einfo (_("%B%F: could not read symbols: %E\n"), b);
+		  return;
+		}
+
+	      symbols = bfd_get_outsymbols (b);
+	      nsyms = bfd_get_symcount (b);
+
+	      for (i = 0; i < nsyms; i++)
+		{
+		  if (! CONST_STRNEQ (symbols[i]->name,
+				      U ("_head_")))
+		    continue;
+
+		  if (pe_dll_extra_pe_debug)
+		    printf ("->%s\n", symbols[i]->name);
+
+		  pe_data_import_dll = (char *) (symbols[i]->name
+						 + U_SIZE ("_head_") - 1);
+		  break;
+		}
+
+	      pe_walk_relocs_of_symbol (&link_info, undef->root.string,
+					make_import_fixup);
+
+	      /* Let's differentiate it somehow from defined.  */
+	      undef->type = bfd_link_hash_defweak;
+	      /* We replace original name with __imp_ prefixed, this
+		 1) may trash memory 2) leads to duplicate symbol generation.
+		 Still, IMHO it's better than having name poluted.  */
+	      undef->root.string = sym->root.string;
+	      undef->u.def.value = sym->u.def.value;
+	      undef->u.def.section = sym->u.def.section;
+	    }
+	}
+    }
+}
+
+static bfd_boolean
+pr_sym (struct bfd_hash_entry *h, void *inf ATTRIBUTE_UNUSED)
+{
+  printf ("+%s\n", h->string);
+
+  return TRUE;
+}
+#endif /* DLL_SUPPORT */
+
+static void
+debug_section_p (bfd *abfd ATTRIBUTE_UNUSED, asection *sect, void *obj)
+{
+  int *found = (int *) obj;
+  if (strncmp (".debug_", sect->name, sizeof (".debug_") - 1) == 0)
+    *found = 1;
+}
+
+static bfd_boolean
+pecoff_checksum_contents (bfd *abfd,
+			  void (*process) (const void *, size_t, void *),
+			  void *arg)
+{
+  file_ptr filepos = (file_ptr) 0;
+
+  while (1)
+    {
+      unsigned char b;
+      int status;
+
+      if (bfd_seek (abfd, filepos, SEEK_SET) != 0)
+	return 0;
+
+      status = bfd_bread (&b, (bfd_size_type) 1, abfd);
+      if (status < 1)
+        {
+          break;
+        }
+
+      (*process) (&b, 1, arg);
+      filepos += 1;
+    }
+
+  return TRUE;
+}
+
+static bfd_boolean
+write_build_id (bfd *abfd)
+{
+  struct pe_tdata *t = pe_data (abfd);
+  asection *asec;
+  struct bfd_link_order *link_order = NULL;
+  unsigned char *contents;
+  bfd_size_type size;
+  bfd_size_type build_id_size;
+  unsigned char *build_id;
+
+  /* Find the section the .buildid output section has been merged info.  */
+  for (asec = abfd->sections; asec != NULL; asec = asec->next)
+    {
+      struct bfd_link_order *l = NULL;
+      for (l = asec->map_head.link_order; l != NULL; l = l->next)
+        {
+          if (l->type == bfd_indirect_link_order)
+            {
+              if (l->u.indirect.section == t->build_id.sec)
+                {
+                  link_order = l;
+                  break;
+                }
+            }
+        }
+
+      if (link_order)
+        break;
+    }
+
+  if (!link_order)
+    {
+      einfo (_("%P: warning: .buildid section discarded,"
+               " --build-id ignored.\n"));
+      return TRUE;
+    }
+
+  if (t->build_id.sec->contents == NULL)
+    t->build_id.sec->contents = (unsigned char *) xmalloc (t->build_id.sec->size);
+  contents = t->build_id.sec->contents;
+  size = t->build_id.sec->size;
+
+  build_id_size = compute_build_id_size (t->build_id.style);
+  build_id = xmalloc (build_id_size);
+  generate_build_id (abfd, t->build_id.style, pecoff_checksum_contents, build_id, build_id_size);
+
+  bfd_vma ib = pe_data (link_info.output_bfd)->pe_opthdr.ImageBase;
+
+  /* Construct a debug directory entry which points to an immediately following CodeView record.  */
+  struct internal_IMAGE_DEBUG_DIRECTORY idd;
+  idd.Characteristics = 0;
+  idd.TimeDateStamp = 0;
+  idd.MajorVersion = 0;
+  idd.MinorVersion = 0;
+  idd.Type = PE_IMAGE_DEBUG_TYPE_CODEVIEW;
+  idd.SizeOfData = sizeof (CV_INFO_PDB70) + 1;
+  idd.AddressOfRawData = asec->vma - ib + link_order->offset
+    + sizeof (struct external_IMAGE_DEBUG_DIRECTORY);
+  idd.PointerToRawData = asec->filepos + link_order->offset
+    + sizeof (struct external_IMAGE_DEBUG_DIRECTORY);
+
+  struct external_IMAGE_DEBUG_DIRECTORY *ext = (struct external_IMAGE_DEBUG_DIRECTORY *)contents;
+  _bfd_XXi_swap_debugdir_out (abfd, &idd, ext);
+
+  /* Write the debug directory entry.  */
+  if (bfd_seek (abfd, asec->filepos + link_order->offset, SEEK_SET) != 0)
+    return 0;
+
+  if (bfd_bwrite (contents, size, abfd) != size)
+    return 0;
+
+  /* Construct the CodeView record.  */
+  CODEVIEW_INFO cvinfo;
+  cvinfo.CVSignature = CVINFO_PDB70_CVSIGNATURE;
+  cvinfo.Age = 1;
+
+  /* Zero pad or truncate the generated build_id to fit in the CodeView record.  */
+  memset (&(cvinfo.Signature), 0, CV_INFO_SIGNATURE_LENGTH);
+  memcpy (&(cvinfo.Signature), build_id, (build_id_size > CV_INFO_SIGNATURE_LENGTH)
+	  ? CV_INFO_SIGNATURE_LENGTH :  build_id_size);
+
+  free (build_id);
+
+  /* Write the codeview record.  */
+  if (_bfd_XXi_write_codeview_record (abfd, idd.PointerToRawData, &cvinfo) == 0)
+    return 0;
+
+  /* Record the location of the debug directory in the data directory.  */
+  pe_data (link_info.output_bfd)->pe_opthdr.DataDirectory[PE_DEBUG_DATA].VirtualAddress
+    = asec->vma  - ib + link_order->offset;
+  pe_data (link_info.output_bfd)->pe_opthdr.DataDirectory[PE_DEBUG_DATA].Size
+    = sizeof (struct external_IMAGE_DEBUG_DIRECTORY);
+
+  return TRUE;
+}
+
+/* Make .buildid section, and set up coff_tdata->build_id. */
+static bfd_boolean
+setup_build_id (bfd *ibfd)
+{
+  asection *s;
+  flagword flags;
+
+  if (!validate_build_id_style (emit_build_id))
+    {
+      einfo ("%P: warning: unrecognized --build-id style ignored.\n");
+      return FALSE;
+    }
+
+  flags = (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_IN_MEMORY
+	   | SEC_LINKER_CREATED | SEC_READONLY | SEC_DATA);
+  s = bfd_make_section_anyway_with_flags (ibfd, ".buildid", flags);
+  if (s != NULL)
+    {
+      struct pe_tdata *t = pe_data (link_info.output_bfd);
+      t->build_id.after_write_object_contents = &write_build_id;
+      t->build_id.style = emit_build_id;
+      t->build_id.sec = s;
+
+      /* Section is a fixed size:
+	 One IMAGE_DEBUG_DIRECTORY entry, of type IMAGE_DEBUG_TYPE_CODEVIEW,
+	 pointing at a CV_INFO_PDB70 record containing the build-id, with a
+	 null byte for PdbFileName.  */
+      s->size = sizeof (struct external_IMAGE_DEBUG_DIRECTORY)
+	+ sizeof (CV_INFO_PDB70) + 1;
+
+      return TRUE;
+    }
+
+  einfo ("%P: warning: Cannot create .buildid section,"
+	 " --build-id ignored.\n");
+  return FALSE;
+}
+
+static void
+gld_${EMULATION_NAME}_after_open (void)
+{
+  after_open_default ();
+
+#ifdef DLL_SUPPORT
+  if (pe_dll_extra_pe_debug)
+    {
+      bfd *a;
+      struct bfd_link_hash_entry *sym;
+
+      printf ("%s()\n", __FUNCTION__);
+
+      for (sym = link_info.hash->undefs; sym; sym=sym->u.undef.next)
+	printf ("-%s\n", sym->root.string);
+      bfd_hash_traverse (&link_info.hash->table, pr_sym, NULL);
+
+      for (a = link_info.input_bfds; a; a = a->link.next)
+	printf ("*%s\n",a->filename);
+    }
+#endif
+
+  if (emit_build_id != NULL)
+    {
+      bfd *abfd;
+
+      /* Find a COFF input.  */
+      for (abfd = link_info.input_bfds;
+	   abfd != (bfd *) NULL; abfd = abfd->link.next)
+	if (bfd_get_flavour (abfd) == bfd_target_coff_flavour)
+	  break;
+
+      /* If there are no COFF input files do not try to
+	 add a build-id section.  */
+      if (abfd == NULL
+	  || !setup_build_id (abfd))
+	{
+	  free ((char *) emit_build_id);
+	  emit_build_id = NULL;
+	}
+    }
+
+  /* Pass the wacky PE command line options into the output bfd.
+     FIXME: This should be done via a function, rather than by
+     including an internal BFD header.  */
+
+  if (coff_data (link_info.output_bfd) == NULL
+      || coff_data (link_info.output_bfd)->pe == 0)
+    einfo (_("%F%P: cannot perform PE operations on non PE output file '%B'.\n"),
+	   link_info.output_bfd);
+
+  pe_data (link_info.output_bfd)->pe_opthdr = pe;
+  pe_data (link_info.output_bfd)->dll = init[DLLOFF].value;
+  pe_data (link_info.output_bfd)->real_flags |= real_flags;
+  pe_data (link_info.output_bfd)->insert_timestamp = insert_timestamp;
+
+  /* At this point we must decide whether to use long section names
+     in the output or not.  If the user hasn't explicitly specified
+     on the command line, we leave it to the default for the format
+     (object files yes, image files no), except if there is debug
+     information present; GDB relies on the long section names to
+     find it, so enable it in that case.  */
+  if (pe_use_coff_long_section_names < 0 && link_info.strip == strip_none)
+    {
+      if (bfd_link_relocatable (&link_info))
+	pe_use_coff_long_section_names = 1;
+      else
+	{
+	  /* Iterate over all sections of all input BFDs, checking
+	     for any that begin 'debug_' and are long names.  */
+	  LANG_FOR_EACH_INPUT_STATEMENT (is)
+	  {
+	    int found_debug = 0;
+
+	    bfd_map_over_sections (is->the_bfd, debug_section_p, &found_debug);
+	    if (found_debug)
+	      {
+		pe_use_coff_long_section_names = 1;
+		break;
+	      }
+	  }
+	}
+    }
+
+  pe_output_file_set_long_section_names (link_info.output_bfd);
+
+#ifdef DLL_SUPPORT
+  if (pe_enable_stdcall_fixup) /* -1=warn or 1=disable */
+    pe_fixup_stdcalls ();
+
+  pe_process_import_defs (link_info.output_bfd, &link_info);
+
+  pe_find_data_imports ();
+
+  /* As possibly new symbols are added by imports, we rerun
+     stdcall/fastcall fixup here.  */
+  if (pe_enable_stdcall_fixup) /* -1=warn or 1=disable */
+    pe_fixup_stdcalls ();
+
+#if defined (TARGET_IS_i386pe) \
+    || defined (TARGET_IS_armpe) \
+    || defined (TARGET_IS_arm_epoc_pe) \
+    || defined (TARGET_IS_arm_wince_pe)
+  if (!bfd_link_relocatable (&link_info))
+    pe_dll_build_sections (link_info.output_bfd, &link_info);
+#else
+  if (bfd_link_pic (&link_info))
+    pe_dll_build_sections (link_info.output_bfd, &link_info);
+  else
+    pe_exe_build_sections (link_info.output_bfd, &link_info);
+#endif
+#endif /* DLL_SUPPORT */
+
+#if defined(TARGET_IS_armpe) || defined(TARGET_IS_arm_epoc_pe) || defined(TARGET_IS_arm_wince_pe)
+  if (strstr (bfd_get_target (link_info.output_bfd), "arm") == NULL)
+    {
+      /* The arm backend needs special fields in the output hash structure.
+	 These will only be created if the output format is an arm format,
+	 hence we do not support linking and changing output formats at the
+	 same time.  Use a link followed by objcopy to change output formats.  */
+      einfo ("%F%X%P: error: cannot change output format whilst linking ARM binaries\n");
+      return;
+    }
+  {
+    /* Find a BFD that can hold the interworking stubs.  */
+    LANG_FOR_EACH_INPUT_STATEMENT (is)
+      {
+	if (bfd_arm_get_bfd_for_interworking (is->the_bfd, & link_info))
+	  break;
+      }
+  }
+#endif
+
+  {
+    /* This next chunk of code tries to detect the case where you have
+       two import libraries for the same DLL (specifically,
+       symbolically linking libm.a and libc.a in cygwin to
+       libcygwin.a).  In those cases, it's possible for function
+       thunks from the second implib to be used but without the
+       head/tail objects, causing an improper import table.  We detect
+       those cases and rename the "other" import libraries to match
+       the one the head/tail come from, so that the linker will sort
+       things nicely and produce a valid import table.  */
+
+    LANG_FOR_EACH_INPUT_STATEMENT (is)
+      {
+	if (is->the_bfd->my_archive)
+	  {
+	    int idata2 = 0, reloc_count=0, is_imp = 0;
+	    asection *sec;
+
+	    /* See if this is an import library thunk.  */
+	    for (sec = is->the_bfd->sections; sec; sec = sec->next)
+	      {
+		if (strcmp (sec->name, ".idata\$2") == 0)
+		  idata2 = 1;
+		if (CONST_STRNEQ (sec->name, ".idata\$"))
+		  is_imp = 1;
+		reloc_count += sec->reloc_count;
+	      }
+
+	    if (is_imp && !idata2 && reloc_count)
+	      {
+		/* It is, look for the reference to head and see if it's
+		   from our own library.  */
+		for (sec = is->the_bfd->sections; sec; sec = sec->next)
+		  {
+		    int i;
+		    long relsize;
+		    asymbol **symbols;
+		    arelent **relocs;
+		    int nrelocs;
+
+		    relsize = bfd_get_reloc_upper_bound (is->the_bfd, sec);
+		    if (relsize < 1)
+		      break;
+
+		    if (!bfd_generic_link_read_symbols (is->the_bfd))
+		      {
+			einfo (_("%B%F: could not read symbols: %E\n"),
+			       is->the_bfd);
+			return;
+		      }
+		    symbols = bfd_get_outsymbols (is->the_bfd);
+
+		    relocs = xmalloc ((size_t) relsize);
+		    nrelocs = bfd_canonicalize_reloc (is->the_bfd, sec,
+						      relocs, symbols);
+		    if (nrelocs < 0)
+		      {
+			free (relocs);
+			einfo ("%X%P: unable to process relocs: %E\n");
+			return;
+		      }
+
+		    for (i = 0; i < nrelocs; i++)
+		      {
+			struct bfd_symbol *s;
+			struct bfd_link_hash_entry * blhe;
+			char *other_bfd_filename;
+			char *n;
+
+			s = (relocs[i]->sym_ptr_ptr)[0];
+
+			if (s->flags & BSF_LOCAL)
+			  continue;
+
+			/* Thunk section with reloc to another bfd.  */
+			blhe = bfd_link_hash_lookup (link_info.hash,
+						     s->name,
+						     FALSE, FALSE, TRUE);
+
+			if (blhe == NULL
+			    || blhe->type != bfd_link_hash_defined)
+			  continue;
+
+			other_bfd_filename
+			  = blhe->u.def.section->owner->my_archive
+			    ? bfd_get_filename (blhe->u.def.section->owner->my_archive)
+			    : bfd_get_filename (blhe->u.def.section->owner);
+
+			if (filename_cmp (bfd_get_filename
+					    (is->the_bfd->my_archive),
+					  other_bfd_filename) == 0)
+			  continue;
+
+			/* Rename this implib to match the other one.  */
+			n = xmalloc (strlen (other_bfd_filename) + 1);
+			strcpy (n, other_bfd_filename);
+			is->the_bfd->my_archive->filename = n;
+		      }
+
+		    free (relocs);
+		    /* Note - we do not free the symbols,
+		       they are now cached in the BFD.  */
+		  }
+	      }
+	  }
+      }
+  }
+
+  {
+    int is_ms_arch = 0;
+    bfd *cur_arch = 0;
+    lang_input_statement_type *is2;
+    lang_input_statement_type *is3;
+
+    /* Careful - this is a shell script.  Watch those dollar signs! */
+    /* Microsoft import libraries have every member named the same,
+       and not in the right order for us to link them correctly.  We
+       must detect these and rename the members so that they'll link
+       correctly.  There are three types of objects: the head, the
+       thunks, and the sentinel(s).  The head is easy; it's the one
+       with idata2.  We assume that the sentinels won't have relocs,
+       and the thunks will.  It's easier than checking the symbol
+       table for external references.  */
+    LANG_FOR_EACH_INPUT_STATEMENT (is)
+      {
+	if (is->the_bfd->my_archive)
+	  {
+	    char *pnt;
+	    bfd *arch = is->the_bfd->my_archive;
+
+	    if (cur_arch != arch)
+	      {
+		cur_arch = arch;
+		is_ms_arch = 1;
+
+		for (is3 = is;
+		     is3 && is3->the_bfd->my_archive == arch;
+		     is3 = (lang_input_statement_type *) is3->next)
+		  {
+		    /* A MS dynamic import library can also contain static
+		       members, so look for the first element with a .dll
+		       extension, and use that for the remainder of the
+		       comparisons.  */
+		    pnt = strrchr (is3->the_bfd->filename, '.');
+		    if (pnt != NULL && filename_cmp (pnt, ".dll") == 0)
+		      break;
+		  }
+
+		if (is3 == NULL)
+		  is_ms_arch = 0;
+		else
+		  {
+		    /* OK, found one.  Now look to see if the remaining
+		       (dynamic import) members use the same name.  */
+		    for (is2 = is;
+			 is2 && is2->the_bfd->my_archive == arch;
+			 is2 = (lang_input_statement_type *) is2->next)
+		      {
+			/* Skip static members, ie anything with a .obj
+			   extension.  */
+			pnt = strrchr (is2->the_bfd->filename, '.');
+			if (pnt != NULL && filename_cmp (pnt, ".obj") == 0)
+			  continue;
+
+			if (filename_cmp (is3->the_bfd->filename,
+					  is2->the_bfd->filename))
+			  {
+			    is_ms_arch = 0;
+			    break;
+			  }
+		      }
+		  }
+	      }
+
+	    /* This fragment might have come from an .obj file in a Microsoft
+	       import, and not an actual import record. If this is the case,
+	       then leave the filename alone.  */
+	    pnt = strrchr (is->the_bfd->filename, '.');
+
+	    if (is_ms_arch && (filename_cmp (pnt, ".dll") == 0))
+	      {
+		int idata2 = 0, reloc_count=0;
+		asection *sec;
+		char *new_name, seq;
+
+		for (sec = is->the_bfd->sections; sec; sec = sec->next)
+		  {
+		    if (strcmp (sec->name, ".idata\$2") == 0)
+		      idata2 = 1;
+		    reloc_count += sec->reloc_count;
+		  }
+
+		if (idata2) /* .idata2 is the TOC */
+		  seq = 'a';
+		else if (reloc_count > 0) /* thunks */
+		  seq = 'b';
+		else /* sentinel */
+		  seq = 'c';
+
+		new_name = xmalloc (strlen (is->the_bfd->filename) + 3);
+		sprintf (new_name, "%s.%c", is->the_bfd->filename, seq);
+		is->the_bfd->filename = new_name;
+
+		new_name = xmalloc (strlen (is->filename) + 3);
+		sprintf (new_name, "%s.%c", is->filename, seq);
+		is->filename = new_name;
+	      }
+	  }
+      }
+  }
+
+  {
+    /* The following chunk of code tries to identify jump stubs in
+       import libraries which are dead code and eliminates them
+       from the final link. For each exported symbol <sym>, there
+       is a object file in the import library with a .text section
+       and several .idata\$* sections. The .text section contains the
+       symbol definition for <sym> which is a jump stub of the form
+       jmp *__imp_<sym>. The .idata\$5 contains the symbol definition
+       for __imp_<sym> which is the address of the slot for <sym> in
+       the import address table. When a symbol is imported explicitly
+       using __declspec(dllimport) declaration, the compiler generates
+       a reference to __imp_<sym> which directly resolves to the
+       symbol in .idata\$5, in which case the jump stub code is not
+       needed. The following code tries to identify jump stub sections
+       in import libraries which are not referred to by anyone and
+       marks them for exclusion from the final link.  */
+    LANG_FOR_EACH_INPUT_STATEMENT (is)
+      {
+	if (is->the_bfd->my_archive)
+	  {
+	    int is_imp = 0;
+	    asection *sec, *stub_sec = NULL;
+
+	    /* See if this is an import library thunk.  */
+	    for (sec = is->the_bfd->sections; sec; sec = sec->next)
+	      {
+		if (strncmp (sec->name, ".idata\$", 7) == 0)
+		  is_imp = 1;
+		/* The section containing the jmp stub has code
+		   and has a reloc.  */
+		if ((sec->flags & SEC_CODE) && sec->reloc_count)
+		  stub_sec = sec;
+	      }
+
+	    if (is_imp && stub_sec)
+	      {
+		asymbol **symbols;
+		long nsyms, src_count;
+		struct bfd_link_hash_entry * blhe;
+
+		if (!bfd_generic_link_read_symbols (is->the_bfd))
+		  {
+		    einfo (_("%B%F: could not read symbols: %E\n"),
+			   is->the_bfd);
+		    return;
+		  }
+		symbols = bfd_get_outsymbols (is->the_bfd);
+		nsyms = bfd_get_symcount (is->the_bfd);
+
+		for (src_count = 0; src_count < nsyms; src_count++)
+		  {
+		    if (symbols[src_count]->section->id == stub_sec->id)
+		      {
+			/* This symbol belongs to the section containing
+			   the stub.  */
+			blhe = bfd_link_hash_lookup (link_info.hash,
+						     symbols[src_count]->name,
+						     FALSE, FALSE, TRUE);
+			/* If the symbol in the stub section has no other
+			   undefined references, exclude the stub section
+			   from the final link.  */
+			if (blhe != NULL
+			    && blhe->type == bfd_link_hash_defined
+			    && blhe->u.undef.next == NULL
+			    && blhe != link_info.hash->undefs_tail)
+			  stub_sec->flags |= SEC_EXCLUDE;
+		      }
+		  }
+	      }
+	  }
+      }
+  }
+}
+
+static void
+gld_${EMULATION_NAME}_before_allocation (void)
+{
+#ifdef TARGET_IS_ppcpe
+  /* Here we rummage through the found bfds to collect toc information.  */
+  {
+    LANG_FOR_EACH_INPUT_STATEMENT (is)
+      {
+	if (!ppc_process_before_allocation (is->the_bfd, &link_info))
+	  {
+	    /* xgettext:c-format */
+	    einfo (_("Errors encountered processing file %s\n"), is->filename);
+	  }
+      }
+  }
+
+  /* We have seen it all. Allocate it, and carry on.  */
+  ppc_allocate_toc_section (&link_info);
+#endif /* TARGET_IS_ppcpe */
+
+#if defined(TARGET_IS_armpe) || defined(TARGET_IS_arm_epoc_pe) || defined(TARGET_IS_arm_wince_pe)
+  /* FIXME: we should be able to set the size of the interworking stub
+     section.
+
+     Here we rummage through the found bfds to collect glue
+     information.  FIXME: should this be based on a command line
+     option?  krk@cygnus.com.  */
+  {
+    LANG_FOR_EACH_INPUT_STATEMENT (is)
+      {
+	if (! bfd_arm_process_before_allocation
+	    (is->the_bfd, & link_info, support_old_code))
+	  {
+	    /* xgettext:c-format */
+	    einfo (_("Errors encountered processing file %s for interworking\n"),
+		   is->filename);
+	  }
+      }
+  }
+
+  /* We have seen it all. Allocate it, and carry on.  */
+  bfd_arm_allocate_interworking_sections (& link_info);
+#endif /* TARGET_IS_armpe || TARGET_IS_arm_epoc_pe || TARGET_IS_arm_wince_pe */
+
+  before_allocation_default ();
+}
+
+#ifdef DLL_SUPPORT
+/* This is called when an input file isn't recognized as a BFD.  We
+   check here for .DEF files and pull them in automatically.  */
+
+static int
+saw_option (char *option)
+{
+  int i;
+
+  for (i = 0; init[i].ptr; i++)
+    if (strcmp (GET_INIT_SYMBOL_NAME (i), option) == 0)
+      return init[i].inited;
+  return 0;
+}
+#endif /* DLL_SUPPORT */
+
+static bfd_boolean
+gld_${EMULATION_NAME}_unrecognized_file (lang_input_statement_type *entry ATTRIBUTE_UNUSED)
+{
+#ifdef DLL_SUPPORT
+  const char *ext = entry->filename + strlen (entry->filename) - 4;
+
+  if (filename_cmp (ext, ".def") == 0 || filename_cmp (ext, ".DEF") == 0)
+    {
+      pe_def_file = def_file_parse (entry->filename, pe_def_file);
+
+      if (pe_def_file)
+	{
+	  int i, buflen=0, len;
+	  char *buf;
+
+	  for (i = 0; i < pe_def_file->num_exports; i++)
+	    {
+	      len = strlen (pe_def_file->exports[i].internal_name);
+	      if (buflen < len + 2)
+		buflen = len + 2;
+	    }
+
+	  buf = xmalloc (buflen);
+
+	  for (i = 0; i < pe_def_file->num_exports; i++)
+	    {
+	      struct bfd_link_hash_entry *h;
+
+	      sprintf (buf, "%s%s", U (""),
+	               pe_def_file->exports[i].internal_name);
+
+	      h = bfd_link_hash_lookup (link_info.hash, buf, TRUE, TRUE, TRUE);
+	      if (h == (struct bfd_link_hash_entry *) NULL)
+		einfo (_("%P%F: bfd_link_hash_lookup failed: %E\n"));
+	      if (h->type == bfd_link_hash_new)
+		{
+		  h->type = bfd_link_hash_undefined;
+		  h->u.undef.abfd = NULL;
+		  bfd_link_add_undef (link_info.hash, h);
+		}
+	    }
+	  free (buf);
+
+	  /* def_file_print (stdout, pe_def_file); */
+	  if (pe_def_file->is_dll == 1)
+	    link_info.type = type_dll;
+
+	  if (pe_def_file->base_address != (bfd_vma)(-1))
+	    {
+	      pe.ImageBase
+		= pe_data (link_info.output_bfd)->pe_opthdr.ImageBase
+		= init[IMAGEBASEOFF].value
+		= pe_def_file->base_address;
+	      init[IMAGEBASEOFF].inited = 1;
+	      if (image_base_statement)
+		image_base_statement->exp
+		  = exp_assign ("__image_base__", exp_intop (pe.ImageBase),
+				FALSE);
+	    }
+
+	  if (pe_def_file->stack_reserve != -1
+	      && ! saw_option ("__size_of_stack_reserve__"))
+	    {
+	      pe.SizeOfStackReserve = pe_def_file->stack_reserve;
+	      if (pe_def_file->stack_commit != -1)
+		pe.SizeOfStackCommit = pe_def_file->stack_commit;
+	    }
+	  if (pe_def_file->heap_reserve != -1
+	      && ! saw_option ("__size_of_heap_reserve__"))
+	    {
+	      pe.SizeOfHeapReserve = pe_def_file->heap_reserve;
+	      if (pe_def_file->heap_commit != -1)
+		pe.SizeOfHeapCommit = pe_def_file->heap_commit;
+	    }
+	  return TRUE;
+	}
+    }
+#endif
+  return FALSE;
+}
+
+static bfd_boolean
+gld_${EMULATION_NAME}_recognized_file (lang_input_statement_type *entry ATTRIBUTE_UNUSED)
+{
+#ifdef DLL_SUPPORT
+#ifdef TARGET_IS_i386pe
+  pe_dll_id_target ("pei-i386");
+#endif
+#ifdef TARGET_IS_shpe
+  pe_dll_id_target ("pei-shl");
+#endif
+#ifdef TARGET_IS_armpe
+  pe_dll_id_target ("pei-arm-little");
+#endif
+#ifdef TARGET_IS_arm_epoc_pe
+  pe_dll_id_target ("epoc-pei-arm-little");
+#endif
+#ifdef TARGET_IS_arm_wince_pe
+  pe_dll_id_target ("pei-arm-wince-little");
+#endif
+  if (pe_bfd_is_dll (entry->the_bfd))
+    return pe_implied_import_dll (entry->filename);
+#endif
+  return FALSE;
+}
+
+static void
+gld_${EMULATION_NAME}_finish (void)
+{
+#if defined(TARGET_IS_armpe) || defined(TARGET_IS_arm_epoc_pe) || defined(TARGET_IS_arm_wince_pe)
+  struct bfd_link_hash_entry * h;
+
+  if (thumb_entry_symbol != NULL)
+    {
+      h = bfd_link_hash_lookup (link_info.hash, thumb_entry_symbol,
+				FALSE, FALSE, TRUE);
+
+      if (h != (struct bfd_link_hash_entry *) NULL
+	  && (h->type == bfd_link_hash_defined
+	      || h->type == bfd_link_hash_defweak)
+	  && h->u.def.section->output_section != NULL)
+	{
+	  static char buffer[32];
+	  bfd_vma val;
+
+	  /* Special procesing is required for a Thumb entry symbol.  The
+	     bottom bit of its address must be set.  */
+	  val = (h->u.def.value
+		 + bfd_get_section_vma (link_info.output_bfd,
+					h->u.def.section->output_section)
+		 + h->u.def.section->output_offset);
+
+	  val |= 1;
+
+	  /* Now convert this value into a string and store it in entry_symbol
+	     where the lang_finish() function will pick it up.  */
+	  buffer[0] = '0';
+	  buffer[1] = 'x';
+
+	  sprintf_vma (buffer + 2, val);
+
+	  if (entry_symbol.name != NULL && entry_from_cmdline)
+	    einfo (_("%P: warning: '--thumb-entry %s' is overriding '-e %s'\n"),
+		   thumb_entry_symbol, entry_symbol.name);
+	  entry_symbol.name = buffer;
+	}
+      else
+	einfo (_("%P: warning: cannot find thumb start symbol %s\n"), thumb_entry_symbol);
+    }
+#endif /* defined(TARGET_IS_armpe) || defined(TARGET_IS_arm_epoc_pe) || defined(TARGET_IS_arm_wince_pe) */
+
+  finish_default ();
+
+#ifdef DLL_SUPPORT
+  if (bfd_link_pic (&link_info)
+#if !defined(TARGET_IS_shpe)
+      || (!bfd_link_relocatable (&link_info)
+	  && pe_def_file->num_exports != 0)
+#endif
+    )
+    {
+      pe_dll_fill_sections (link_info.output_bfd, &link_info);
+      if (pe_implib_filename)
+	pe_dll_generate_implib (pe_def_file, pe_implib_filename, &link_info);
+    }
+#if defined(TARGET_IS_shpe)
+  /* ARM doesn't need relocs.  */
+  else
+    {
+      pe_exe_fill_sections (link_info.output_bfd, &link_info);
+    }
+#endif
+
+  if (pe_out_def_filename)
+    pe_dll_generate_def_file (pe_out_def_filename);
+#endif /* DLL_SUPPORT */
+
+  /* I don't know where .idata gets set as code, but it shouldn't be.  */
+  {
+    asection *asec = bfd_get_section_by_name (link_info.output_bfd, ".idata");
+
+    if (asec)
+      {
+	asec->flags &= ~SEC_CODE;
+	asec->flags |= SEC_DATA;
+      }
+  }
+}
+
+
+/* Place an orphan section.
+
+   We use this to put sections in a reasonable place in the file, and
+   to ensure that they are aligned as required.
+
+   We handle grouped sections here as well.  A section named .foo\$nn
+   goes into the output section .foo.  All grouped sections are sorted
+   by name.
+
+   Grouped sections for the default sections are handled by the
+   default linker script using wildcards, and are sorted by
+   sort_sections.  */
+
+static lang_output_section_statement_type *
+gld_${EMULATION_NAME}_place_orphan (asection *s,
+				    const char *secname,
+				    int constraint)
+{
+  const char *orig_secname = secname;
+  char *dollar = NULL;
+  lang_output_section_statement_type *os;
+  lang_statement_list_type add_child;
+  lang_output_section_statement_type *match_by_name = NULL;
+  lang_statement_union_type **pl;
+
+  /* Look through the script to see where to place this section.  */
+  if (!bfd_link_relocatable (&link_info)
+      && (dollar = strchr (secname, '\$')) != NULL)
+    {
+      size_t len = dollar - secname;
+      char *newname = xmalloc (len + 1);
+      memcpy (newname, secname, len);
+      newname[len] = '\0';
+      secname = newname;
+    }
+
+  lang_list_init (&add_child);
+
+  os = NULL;
+  if (constraint == 0)
+    for (os = lang_output_section_find (secname);
+	 os != NULL;
+	 os = next_matching_output_section_statement (os, 0))
+      {
+	/* If we don't match an existing output section, tell
+	   lang_insert_orphan to create a new output section.  */
+	constraint = SPECIAL;
+
+	if (os->bfd_section != NULL
+	    && (os->bfd_section->flags == 0
+		|| ((s->flags ^ os->bfd_section->flags)
+		    & (SEC_LOAD | SEC_ALLOC)) == 0))
+	  {
+	    /* We already have an output section statement with this
+	       name, and its bfd section has compatible flags.
+	       If the section already exists but does not have any flags set,
+	       then it has been created by the linker, probably as a result of
+	       a --section-start command line switch.  */
+	    lang_add_section (&add_child, s, NULL, os);
+	    break;
+	  }
+
+	/* Save unused output sections in case we can match them
+	   against orphans later.  */
+	if (os->bfd_section == NULL)
+	  match_by_name = os;
+      }
+
+  /* If we didn't match an active output section, see if we matched an
+     unused one and use that.  */
+  if (os == NULL && match_by_name)
+    {
+      lang_add_section (&match_by_name->children, s, NULL, match_by_name);
+      return match_by_name;
+    }
+
+  if (os == NULL)
+    {
+      static struct orphan_save hold[] =
+	{
+	  { ".text",
+	    SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE,
+	    0, 0, 0, 0 },
+	  { ".idata",
+	    SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_DATA,
+	    0, 0, 0, 0 },
+	  { ".rdata",
+	    SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_DATA,
+	    0, 0, 0, 0 },
+	  { ".data",
+	    SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_DATA,
+	    0, 0, 0, 0 },
+	  { ".bss",
+	    SEC_ALLOC,
+	    0, 0, 0, 0 }
+	};
+      enum orphan_save_index
+	{
+	  orphan_text = 0,
+	  orphan_idata,
+	  orphan_rodata,
+	  orphan_data,
+	  orphan_bss
+	};
+      static int orphan_init_done = 0;
+      struct orphan_save *place;
+      lang_output_section_statement_type *after;
+      etree_type *address;
+      flagword flags;
+      asection *nexts;
+
+      if (!orphan_init_done)
+	{
+	  struct orphan_save *ho;
+	  for (ho = hold; ho < hold + sizeof (hold) / sizeof (hold[0]); ++ho)
+	    if (ho->name != NULL)
+	      {
+		ho->os = lang_output_section_find (ho->name);
+		if (ho->os != NULL && ho->os->flags == 0)
+		  ho->os->flags = ho->flags;
+	      }
+	  orphan_init_done = 1;
+	}
+
+      /* Try to put the new output section in a reasonable place based
+	 on the section name and section flags.  */
+
+      flags = s->flags;
+      nexts = s;
+      while ((nexts = bfd_get_next_section_by_name (nexts->owner, nexts)))
+	if (nexts->output_section == NULL
+	    && (nexts->flags & SEC_EXCLUDE) == 0
+	    && ((nexts->flags ^ flags) & (SEC_LOAD | SEC_ALLOC)) == 0
+	    && (nexts->owner->flags & DYNAMIC) == 0
+	    && nexts->owner->usrdata != NULL
+	    && !(((lang_input_statement_type *) nexts->owner->usrdata)
+		 ->flags.just_syms))
+	  flags = (((flags ^ SEC_READONLY) | (nexts->flags ^ SEC_READONLY))
+		   ^ SEC_READONLY);
+      place = NULL;
+      if ((flags & SEC_ALLOC) == 0)
+	;
+      else if ((flags & (SEC_LOAD | SEC_HAS_CONTENTS)) == 0)
+	place = &hold[orphan_bss];
+      else if ((flags & SEC_READONLY) == 0)
+	place = &hold[orphan_data];
+      else if ((flags & SEC_CODE) == 0)
+	{
+	  place = (!strncmp (secname, ".idata\$", 7) ? &hold[orphan_idata]
+						     : &hold[orphan_rodata]);
+	}
+      else
+	place = &hold[orphan_text];
+
+      after = NULL;
+      if (place != NULL)
+	{
+	  if (place->os == NULL)
+	    place->os = lang_output_section_find (place->name);
+	  after = place->os;
+	  if (after == NULL)
+	    after = lang_output_section_find_by_flags (s, flags, &place->os,
+						       NULL);
+	  if (after == NULL)
+	    /* *ABS* is always the first output section statement.  */
+	    after = (&lang_output_section_statement.head
+		     ->output_section_statement);
+	}
+
+      /* All sections in an executable must be aligned to a page boundary.
+	 In a relocatable link, just preserve the incoming alignment; the
+	 address is discarded by lang_insert_orphan in that case, anyway.  */
+      address = exp_unop (ALIGN_K, exp_nameop (NAME, "__section_alignment__"));
+      os = lang_insert_orphan (s, secname, constraint, after, place, address,
+			       &add_child);
+      if (bfd_link_relocatable (&link_info))
+	{
+	  os->section_alignment = s->alignment_power;
+	  os->bfd_section->alignment_power = s->alignment_power;
+	}
+    }
+
+  /* If the section name has a '\$', sort it with the other '\$'
+     sections.  */
+  for (pl = &os->children.head; *pl != NULL; pl = &(*pl)->header.next)
+    {
+      lang_input_section_type *ls;
+      const char *lname;
+
+      if ((*pl)->header.type != lang_input_section_enum)
+	continue;
+
+      ls = &(*pl)->input_section;
+
+      lname = bfd_get_section_name (ls->section->owner, ls->section);
+      if (strchr (lname, '\$') != NULL
+	  && (dollar == NULL || strcmp (orig_secname, lname) < 0))
+	break;
+    }
+
+  if (add_child.head != NULL)
+    {
+      *add_child.tail = *pl;
+      *pl = add_child.head;
+    }
+
+  return os;
+}
+
+static bfd_boolean
+gld_${EMULATION_NAME}_open_dynamic_archive
+  (const char *arch ATTRIBUTE_UNUSED,
+   search_dirs_type *search,
+   lang_input_statement_type *entry)
+{
+  static const struct
+    {
+      const char * format;
+      bfd_boolean use_prefix;
+    }
+  libname_fmt [] =
+    {
+      /* Preferred explicit import library for dll's.  */
+      { "lib%s.dll.a", FALSE },
+      /* Alternate explicit import library for dll's.  */
+      { "%s.dll.a", FALSE },
+      /* "libfoo.a" could be either an import lib or a static lib.
+          For backwards compatibility, libfoo.a needs to precede
+          libfoo.dll and foo.dll in the search.  */
+      { "lib%s.a", FALSE },
+      /* The 'native' spelling of an import lib name is "foo.lib".  */
+      { "%s.lib", FALSE },
+#ifdef DLL_SUPPORT
+      /* Try "<prefix>foo.dll" (preferred dll name, if specified).  */
+      {	"%s%s.dll", TRUE },
+#endif
+      /* Try "libfoo.dll" (default preferred dll name).  */
+      {	"lib%s.dll", FALSE },
+      /* Finally try 'native' dll name "foo.dll".  */
+      {  "%s.dll", FALSE },
+      /* Note: If adding more formats to this table, make sure to check to
+	 see if their length is longer than libname_fmt[0].format, and if
+	 so, update the call to xmalloc() below.  */
+      { NULL, FALSE }
+    };
+  static unsigned int format_max_len = 0;
+  const char * filename;
+  char * full_string;
+  char * base_string;
+  unsigned int i;
+
+
+  if (! entry->flags.maybe_archive || entry->flags.full_name_provided)
+    return FALSE;
+
+  filename = entry->filename;
+
+  if (format_max_len == 0)
+    /* We need to allow space in the memory that we are going to allocate
+       for the characters in the format string.  Since the format array is
+       static we only need to calculate this information once.  In theory
+       this value could also be computed statically, but this introduces
+       the possibility for a discrepancy and hence a possible memory
+       corruption.  The lengths we compute here will be too long because
+       they will include any formating characters (%s) in the strings, but
+       this will not matter.  */
+    for (i = 0; libname_fmt[i].format; i++)
+      if (format_max_len < strlen (libname_fmt[i].format))
+	format_max_len = strlen (libname_fmt[i].format);
+
+  full_string = xmalloc (strlen (search->name)
+			 + strlen (filename)
+			 + format_max_len
+#ifdef DLL_SUPPORT
+			 + (pe_dll_search_prefix
+			    ? strlen (pe_dll_search_prefix) : 0)
+#endif
+			 /* Allow for the terminating NUL and for the path
+			    separator character that is inserted between
+			    search->name and the start of the format string.  */
+			 + 2);
+
+  sprintf (full_string, "%s/", search->name);
+  base_string = full_string + strlen (full_string);
+
+  for (i = 0; libname_fmt[i].format; i++)
+    {
+#ifdef DLL_SUPPORT
+      if (libname_fmt[i].use_prefix)
+	{
+	  if (!pe_dll_search_prefix)
+	    continue;
+	  sprintf (base_string, libname_fmt[i].format, pe_dll_search_prefix, filename);
+	}
+      else
+#endif
+	sprintf (base_string, libname_fmt[i].format, filename);
+
+      if (ldfile_try_open_bfd (full_string, entry))
+	break;
+    }
+
+  if (!libname_fmt[i].format)
+    {
+      free (full_string);
+      return FALSE;
+    }
+
+  entry->filename = full_string;
+
+  return TRUE;
+}
+
+static int
+gld_${EMULATION_NAME}_find_potential_libraries
+  (char *name, lang_input_statement_type *entry)
+{
+  return ldfile_open_file_search (name, entry, "", ".lib");
+}
+
+static char *
+gld_${EMULATION_NAME}_get_script (int *isfile)
+EOF
+# Scripts compiled in.
+# sed commands to quote an ld script as a C string.
+sc="-f stringify.sed"
+
+fragment <<EOF
+{
+  *isfile = 0;
+
+  if (bfd_link_relocatable (&link_info) && config.build_constructors)
+    return
+EOF
+sed $sc ldscripts/${EMULATION_NAME}.xu			>> e${EMULATION_NAME}.c
+echo '  ; else if (bfd_link_relocatable (&link_info)) return' >> e${EMULATION_NAME}.c
+sed $sc ldscripts/${EMULATION_NAME}.xr			>> e${EMULATION_NAME}.c
+echo '  ; else if (!config.text_read_only) return'	>> e${EMULATION_NAME}.c
+sed $sc ldscripts/${EMULATION_NAME}.xbn			>> e${EMULATION_NAME}.c
+echo '  ; else if (!config.magic_demand_paged) return'	>> e${EMULATION_NAME}.c
+sed $sc ldscripts/${EMULATION_NAME}.xn			>> e${EMULATION_NAME}.c
+if test -n "$GENERATE_AUTO_IMPORT_SCRIPT" ; then
+echo '  ; else if (link_info.pei386_auto_import == 1 && (MERGE_RDATA_V2 || link_info.pei386_runtime_pseudo_reloc != 2)) return'	>> e${EMULATION_NAME}.c
+sed $sc ldscripts/${EMULATION_NAME}.xa			>> e${EMULATION_NAME}.c
+fi
+echo '  ; else return'					>> e${EMULATION_NAME}.c
+sed $sc ldscripts/${EMULATION_NAME}.x			>> e${EMULATION_NAME}.c
+echo '; }'						>> e${EMULATION_NAME}.c
+
+fragment <<EOF
+
+
+struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation =
+{
+  gld_${EMULATION_NAME}_before_parse,
+  syslib_default,
+  hll_default,
+  gld_${EMULATION_NAME}_after_parse,
+  gld_${EMULATION_NAME}_after_open,
+  after_allocation_default,
+  set_output_arch_default,
+  ldemul_default_target,
+  gld_${EMULATION_NAME}_before_allocation,
+  gld_${EMULATION_NAME}_get_script,
+  "${EMULATION_NAME}",
+  "${OUTPUT_FORMAT}",
+  gld_${EMULATION_NAME}_finish,
+  NULL, /* Create output section statements.  */
+  gld_${EMULATION_NAME}_open_dynamic_archive,
+  gld_${EMULATION_NAME}_place_orphan,
+  gld_${EMULATION_NAME}_set_symbols,
+  NULL, /* parse_args */
+  gld${EMULATION_NAME}_add_options,
+  gld${EMULATION_NAME}_handle_option,
+  gld_${EMULATION_NAME}_unrecognized_file,
+  gld_${EMULATION_NAME}_list_options,
+  gld_${EMULATION_NAME}_recognized_file,
+  gld_${EMULATION_NAME}_find_potential_libraries,
+  NULL,	/* new_vers_pattern.  */
+  NULL	/* extra_map_file_text.  */
+};
+EOF
diff -Naur binutils-2.26/ld/pe-dll.c binutils-2.26.0007/ld/pe-dll.c
--- binutils-2.26/ld/pe-dll.c	2015-11-13 09:27:42.000000000 +0100
+++ binutils-2.26.0007/ld/pe-dll.c	2016-03-10 17:02:24.394048646 +0100
@@ -245,6 +245,7 @@
 #define PE_ARCH_arm	 4
 #define PE_ARCH_arm_epoc 5
 #define PE_ARCH_arm_wince 6
+#define PE_ARCH_arm_winnt 7
 
 /* Don't make it constant as underscore mode gets possibly overriden
    by target or -(no-)leading-underscore option.  */
@@ -314,6 +315,15 @@
     FALSE,
     autofilter_symbollist_generic
   },
+  {
+    "pei-arm-winnt-little",
+    "pe-arm-winnt-little",
+    17,  /* ARM_MOV32T on Windows NT, see bfd/coff-arm.c.  */
+    PE_ARCH_arm_winnt,
+    bfd_arch_arm,
+    FALSE,
+    autofilter_symbollist_generic
+  },
   { NULL, NULL, 0, 0, 0, FALSE, NULL }
 };
 
@@ -2113,6 +2123,7 @@
 	case PE_ARCH_arm:
 	case PE_ARCH_arm_epoc:
 	case PE_ARCH_arm_wince:
+  case PE_ARCH_arm_winnt:
 	  jmp_bytes = jmp_arm_bytes;
 	  jmp_byte_count = sizeof (jmp_arm_bytes);
 	  break;
@@ -2201,6 +2212,7 @@
 	case PE_ARCH_arm:
  	case PE_ARCH_arm_epoc:
  	case PE_ARCH_arm_wince:
+  case PE_ARCH_arm_winnt:
 	  quick_reloc (abfd, 8, BFD_RELOC_32, 2);
 	  break;
 	default:
