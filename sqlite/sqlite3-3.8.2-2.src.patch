--- origsrc/sqlite-autoconf-3080200/README	2013-12-06 16:05:18.000000000 +0100
+++ src/sqlite-autoconf-3080200/README	2013-12-09 12:10:52.530409600 +0100
@@ -1,32 +1,166 @@
+sqlite3
+-------------------------------------------
+SQLite is a C library that implements an embeddable SQL database engine.
+Programs that link with the SQLite library can have SQL database access
+without running a separate RDBMS process.  The distribution comes with a
+standalone command-line access program (sqlite) that can be used to
+administer an SQLite database and which serves as an example of how to 
+use the SQLite library.
+
+Runtime requirements:
+  cygwin-1.7
+  libreadline7
+
+Build requirements:
+(besides corresponding devel packages)
+  binutils-2.23.51-1
+  cygport-0.14.0-1
+  gawk-4.1.0-1
+  gcc-core-4.8.2-1
+  libtool-2.4-1
+  make-4.0-2
+  sed-4.2.2-3
+
+Canonical homepage:
+  http://www.sqlite.org/
+
+-------------------------------------------
+
+Build instructions:
+  unpack sqlite3-3.8.2-2-src.tar.bz2
+    if you use setup to install this src package, it will be
+	 unpacked under /usr/src automatically
+  cd /usr/src
+  cygport ./sqlite3-3.8.2-2.cygport all
+
+This will create:
+  /usr/src/libsqlite3-devel-3.8.2-2.tar.bz2
+  /usr/src/libsqlite3_0-3.8.2-2.tar.bz2
+  /usr/src/sqlite3-3.8.2-2-src.tar.bz2
+  /usr/src/sqlite3-3.8.2-2.tar.bz2
+
+-------------------------------------------
+
+Files included in the binary packages:
+
+(sqlite3)
+  /usr/bin/sqlite3.exe
+  /usr/share/doc/Cygwin/sqlite3.README
+  /usr/share/doc/sqlite3/README
+  /usr/share/man/man1/sqlite3.1.gz
+
+(libsqlite3_0)
+  /usr/bin/cygsqlite3-0.dll
+
+(libsqlite3-devel)
+  usr/include/sqlite3.h
+  usr/include/sqlite3ext.h
+  usr/lib/libsqlite3.a
+  usr/lib/libsqlite3.dll.a
+  usr/lib/libsqlite3.la
+  usr/lib/pkgconfig/sqlite3.pc
+
+------------------
+
+Port Notes:
+
+The Cygwin build contains VFS'es which are both win32
+and unix compatible:
+
+   "unix" (default): The real vfs is specified using
+       the environment variable CYGWIN_SQLITE_LOCKING,
+       which can have the following values:
+   "winnt": (default if CYGWIN_SQLITE_LOCKING not specified)
+       Uses Win32 file locking
+   "win32": Uses Win32 API, has 260 byte path limit.
+   "win32-longpath": Uses Win32 API.
+   "unix-posix": (default if CYGWIN_SQLITE_LOCKING starts with "unix")
+   "unix-excl":
+   "unix-namedsem":
+   "unix-flock":
+   "unix-dotfile":
+   "unix-none":
+
+   All Cygwin VFS'es have an 4096 byte path limit, except "win32".
+   The "win32" and "win32-longpath" VFS's cannot be specified in
+   the "CYGWIN_SQLITE_LOCKING environment variable.
+
+   Although the above values for CYGWIN_SQLITE_LOCKING are
+   recommended, the values "posix", "bsd" and "dotfile" are
+   recognized too, for compatibility with earlier Cygwin
+   SQLite builds.
+
+----- version 3.8.2-2 -----
+Version bump.
+New "unix-namedsem" VFS.
+Better UNC/Extended windows path handling in "win32", "winnt"
+and "win32-longpath" VFS's
+
+Corresponds to upstream SQLite 3.8.2
+
+----- version 3.8.1-1 -----
+Version bump.
+New "win32", "win32-longpath", and "winnt" VFS. The default is
+"unix", which behaves identical to earlier Cygwin versions.
+
+Versions below starting with 3.5.8-1 were done by Warren Young
+
+----- version 3.7.x-y -----
+Version bump, not further specified here.
+
+----- version 3.6.2-1 -----
+Restored DLL version of library
+Distributing *.a in devel package instead of lib package.
+
+----- version 3.5.8-1 -----
+Fork of Cygwin Ports version, removing Tcl support since Cygwin doesn't
+distribute Tcl anymore.
+
+Maintainer of versions below unknown.
+
+----- version 3.5.6-1 -----
+Version bump.
+Enabled the load_extension API for the PHP bindings.
+
+----- version 3.5.4-1 -----
+Version bump.
+
+----- version 3.5.3-1 -----
+Version bump.
+
+----- version 3.5.2-1 -----
+Version bump.
+
+----- version 3.3.17-1 -----
+Version bump.
+
+----- version 3.3.12-1 -----
+Version bump.
+
+----- version 3.3.10-1 -----
+Version bump.
+
+----- version 3.3.7-1 -----
+Version bump.  Broke out separate binary packages.
+
+----- version 3.3.5-1 -----
+Version bump.
+
+----- version 3.2.8-1 -----
+Version bump.
+
+----- version 3.2.7-1 -----
+Version bump.
+
+----- version 3.2.6-1 -----
+Version bump.
+
+----- version 3.2.1-1 -----
+Version bump for 3.0 branch.
+
+----- version 3.0.8-1 -----
+Initial release of the 3.0 branch for Cygwin.
+This package can be installed in parallel with sqlite-2.8.x.
 
-This package contains:
-
- * the SQLite library amalgamation (single file) source code distribution,
- * the shell.c file used to build the sqlite3 shell too, and
- * the sqlite3.h and sqlite3ext.h header files required to link programs
-   and sqlite extensions against the installed libary.
- * autoconf/automake installation infrastucture.
-
-The generic installation instructions for autoconf/automake are found
-in the INSTALL file.
-
-The following SQLite specific boolean options are supported:
-
-  --enable-readline           use readline in shell tool   [default=yes]
-  --enable-threadsafe         build a thread-safe library  [default=yes]
-  --enable-dynamic-extensions support loadable extensions  [default=yes]
-
-The default value for the CFLAGS variable (options passed to the C 
-compiler) includes debugging symbols in the build, resulting in larger
-binaries than are necessary. Override it on the configure command
-line like this:
-
-  $ CFLAGS="-Os" ./configure
-
-to produce a smaller installation footprint.
-
-Other SQLite compilation parameters can also be set using CFLAGS. For
-example:
-
-  $ CFLAGS="-Os -DSQLITE_OMIT_TRIGGERS" ./configure
 
+Cygwin port maintained by Jan Nijtmans
--- origsrc/sqlite-autoconf-3080200/shell.c	2013-12-06 16:05:18.000000000 +0100
+++ src/sqlite-autoconf-3080200/shell.c	2013-12-09 11:29:01.552789900 +0100
@@ -1135,6 +1135,10 @@ static int display_stats(
     fprintf(pArg->out, "Statement Heap/Lookaside Usage:      %d bytes\n", iCur); 
   }
 
+#ifndef SQLITE_STMTSTATUS_VM_STEP
+#  define SQLITE_STMTSTATUS_VM_STEP 4
+#endif
+  
   if( pArg && pArg->out && db && pArg->pStmt ){
     iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_FULLSCAN_STEP, bReset);
     fprintf(pArg->out, "Fullscan Steps:                      %d\n", iCur);
@@ -1142,8 +1146,10 @@ static int display_stats(
     fprintf(pArg->out, "Sort Operations:                     %d\n", iCur);
     iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_AUTOINDEX, bReset);
     fprintf(pArg->out, "Autoindex Inserts:                   %d\n", iCur);
-    iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_VM_STEP, bReset);
-    fprintf(pArg->out, "Virtual Machine Steps:               %d\n", iCur);
+    if( sqlite3_libversion_number()>=3008000 ){
+      iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_VM_STEP, bReset);
+      fprintf(pArg->out, "Virtual Machine Steps:               %d\n", iCur);
+    }
   }
 
   return 0;
@@ -3297,11 +3303,13 @@ int main(int argc, char **argv){
   int i;
   int rc = 0;
 
+#if 0
   if( strcmp(sqlite3_sourceid(),SQLITE_SOURCE_ID)!=0 ){
     fprintf(stderr, "SQLite header and source version mismatch\n%s\n%s\n",
             sqlite3_sourceid(), SQLITE_SOURCE_ID);
     exit(1);
   }
+#endif
   Argv0 = argv[0];
   main_init(&data);
   stdin_is_interactive = isatty(0);
--- origsrc/sqlite-autoconf-3080200/sqlite3.1	2013-12-06 16:05:18.000000000 +0100
+++ src/sqlite-autoconf-3080200/sqlite3.1	2013-12-09 11:29:08.147167100 +0100
@@ -2,7 +2,7 @@
 .\" First parameter, NAME, should be all caps
 .\" Second parameter, SECTION, should be 1-8, maybe w/ subsection
 .\" other parameters are allowed: see man(7), man(1)
-.TH SQLITE3 1 "Mon Apr 15 23:49:17 2002"
+.TH SQLITE3 1 "Mon Dec 2 14:31:01 2013"
 .\" Please adjust this date whenever revising the manpage.
 .\"
 .\" Some roff macros, for reference:
@@ -49,7 +49,7 @@ a table named "memos" and insert a coupl
 $ 
 .B sqlite3 mydata.db
 .br
-SQLite version 3.1.3
+SQLite version 3.8.2
 .br
 Enter ".help" for instructions
 .br
@@ -108,15 +108,24 @@ sqlite>
 .B .help
 .nf
 .cc |
+.backup ?DB? FILE      Backup DB (default "main") to FILE
+.bail ON|OFF           Stop after hitting an error.  Default OFF
 .databases             List names and files of attached databases
 .dump ?TABLE? ...      Dump the database in an SQL text format
+                         If TABLE specified, only dump tables matching
+                         LIKE pattern TABLE.
 .echo ON|OFF           Turn command echo on or off
 .exit                  Exit this program
-.explain ON|OFF        Turn output mode suitable for EXPLAIN on or off.
+.explain ?ON|OFF?      Turn output mode suitable for EXPLAIN on or off.
+                         With no args, it turns EXPLAIN on.
 .header(s) ON|OFF      Turn display of headers on or off
 .help                  Show this message
 .import FILE TABLE     Import data from FILE into TABLE
-.indices TABLE         Show names of all indices on TABLE
+.indices ?TABLE?       Show names of all indices
+                         If TABLE specified, only show indices for tables
+                         matching LIKE pattern TABLE.
+.load FILE ?ENTRY?     Load an extension library
+.log FILE|off          Turn logging on or off.  FILE can be stderr/stdout
 .mode MODE ?TABLE?     Set output mode where MODE is one of:
                          csv      Comma-separated values
                          column   Left-aligned columns.  (See .width)
@@ -126,18 +135,29 @@ sqlite>
                          list     Values delimited by .separator string
                          tabs     Tab-separated values
                          tcl      TCL list elements
-.nullvalue STRING      Print STRING in place of NULL values
+.nullvalue STRING      Use STRING in place of NULL values
+.open ?FILENAME?       Close existing database and reopen FILENAME
 .output FILENAME       Send output to FILENAME
 .output stdout         Send output to the screen
+.print STRING...       Print literal STRING
 .prompt MAIN CONTINUE  Replace the standard prompts
 .quit                  Exit this program
 .read FILENAME         Execute SQL in FILENAME
+.restore ?DB? FILE     Restore content of DB (default "main") from FILE
 .schema ?TABLE?        Show the CREATE statements
+                         If TABLE specified, only show tables matching
+                         LIKE pattern TABLE.
 .separator STRING      Change separator used by output mode and .import
 .show                  Show the current values for various settings
-.tables ?PATTERN?      List names of tables matching a LIKE pattern
+.stats ON|OFF          Turn stats on or off
+.tables ?TABLE?        List names of tables
+                         If TABLE specified, only list tables matching
+                         LIKE pattern TABLE.
 .timeout MS            Try opening locked tables for MS milliseconds
-.width NUM NUM ...     Set column widths for "column" mode
+.trace FILE|off        Output each SQL statement as it is run
+.vfsname ?AUX?         Print the name of the VFS stack
+.width NUM1 NUM2 ...   Set column widths for "column" mode
+.timer ON|OFF          Turn the CPU timer measurement on or off
 sqlite>
 |cc .
 .sp
@@ -147,25 +167,45 @@ sqlite>
 .B sqlite3
 has the following options:
 .TP
-.BI \-init\ file
-Read and execute commands from
-.I file
-, which can contain a mix of SQL statements and meta-commands.
+.B \-bail
+Stop after hitting an error.
+.TP
+.B \-batch
+force batch I/O.
+.TP
+.B \-column
+Query results will be displayed in a table like form, using
+whitespace characters to separate the columns and align the
+output.
+.TP
+.BI \-cmd\  command
+run
+.I command
+before reading stdin
+.TP
+.B \-csv
+Query results will be output as CSV format.
 .TP
 .B \-echo
 Print commands before execution.
 .TP
+.BI \-init\  file
+Read and execute commands from
+.I file
+, which can contain a mix of SQL statements and meta-commands.
+.TP
 .B \-[no]header
 Turn headers on or off.
 .TP
-.B \-column
-Query results will be displayed in a table like form, using
-whitespace characters to separate the columns and align the
-output.
+.B \-help
+Show help on options and exit.
 .TP
 .B \-html
 Query results will be output as simple HTML tables.
 .TP
+.B \-interactive
+Force interactive I/O.
+.TP
 .B \-line
 Query results will be displayed with one value per line, rows
 separated by a blank line.  Designed to be easily parsed by
@@ -175,18 +215,23 @@ scripts or other programs
 Query results will be displayed with the separator (|, by default)
 character between each field value.  The default.
 .TP
-.BI \-separator\  separator
-Set output field separator.  Default is '|'.
-.TP
 .BI \-nullvalue\  string
 Set string used to represent NULL values.  Default is ''
 (empty string).
 .TP
+.BI \-separator\  separator
+Set output field separator.  Default is '|'.
+.TP
+.B \-stats
+Print memory stats before each finalize.
+.TP
 .B \-version
 Show SQLite version.
 .TP
-.B \-help
-Show help on options and exit.
+.BI \-vfs\  name
+Use
+.I name
+as the default VFS.
 
 
 .SH INIT FILE
--- origsrc/sqlite-autoconf-3080200/sqlite3.c	2013-12-06 16:05:18.000000000 +0100
+++ src/sqlite-autoconf-3080200/sqlite3.c	2013-12-09 12:27:15.946657800 +0100
@@ -9726,7 +9726,10 @@ SQLITE_PRIVATE void sqlite3PCacheSetDefa
 #if !defined(SQLITE_OS_UNIX) && !defined(SQLITE_OS_OTHER)
 # define SQLITE_OS_OTHER 0
 # ifndef SQLITE_OS_WIN
-#   if defined(_WIN32) || defined(WIN32) || defined(__CYGWIN__) || defined(__MINGW32__) || defined(__BORLANDC__)
+#   if defined(__CYGWIN__)
+#     define SQLITE_OS_WIN 1
+#     define SQLITE_OS_UNIX 1
+#   elif defined(_WIN32) || defined(WIN32) || defined(__MINGW32__) || defined(__BORLANDC__)
 #     define SQLITE_OS_WIN 1
 #     define SQLITE_OS_UNIX 0
 #   else
@@ -9742,7 +9745,7 @@ SQLITE_PRIVATE void sqlite3PCacheSetDefa
 # endif
 #endif
 
-#if SQLITE_OS_WIN
+#if SQLITE_OS_WIN && !defined(__CYGWIN__)
 # include <windows.h>
 #endif
 
@@ -10014,10 +10017,10 @@ SQLITE_PRIVATE int sqlite3OsCloseFree(sq
 # define SQLITE_MUTEX_OMIT
 #endif
 #if SQLITE_THREADSAFE && !defined(SQLITE_MUTEX_NOOP)
-#  if SQLITE_OS_UNIX
-#    define SQLITE_MUTEX_PTHREADS
-#  elif SQLITE_OS_WIN
+#  if SQLITE_OS_WIN
 #    define SQLITE_MUTEX_W32
+#  elif SQLITE_OS_UNIX
+#    define SQLITE_MUTEX_PTHREADS
 #  else
 #    define SQLITE_MUTEX_NOOP
 #  endif
@@ -18618,6 +18621,10 @@ SQLITE_PRIVATE sqlite3_mutex_methods con
 ** This file contains the C functions that implement mutexes for win32
 */
 
+#ifdef __CYGWIN__
+# include <windows.h> /* amalgamator: keep */
+#endif
+
 /*
 ** The code in this file is only used if we are compiling multithreaded
 ** on a win32 system.
@@ -18714,6 +18721,9 @@ static int winMutex_isInit = 0;
 */
 static LONG winMutex_lock = 0;
 
+#if defined(__CYGWIN__) && defined(SQLITE_AMALGAMATION)
+static
+#endif
 SQLITE_API void sqlite3_win32_sleep(DWORD milliseconds); /* os_win.c */
 
 static int winMutexInit(void){ 
@@ -23221,13 +23231,17 @@ SQLITE_PRIVATE const char *sqlite3Opcode
 #include <sys/mman.h>
 #endif
 
+#ifdef __CYGWIN__
+# include <sys/cygwin.h>
+#endif
 
-#if SQLITE_ENABLE_LOCKING_STYLE
+#if SQLITE_ENABLE_LOCKING_STYLE || defined(__CYGWIN__)
 # include <sys/ioctl.h>
-# if OS_VXWORKS
+# if OS_VXWORKS || defined(__CYGWIN__)
 #  include <semaphore.h>
 #  include <limits.h>
-# else
+# endif
+# if !OS_VXWORKS
 #  include <sys/file.h>
 #  include <sys/param.h>
 # endif
@@ -23272,7 +23286,15 @@ SQLITE_PRIVATE const char *sqlite3Opcode
 /*
 ** Maximum supported path-length.
 */
-#define MAX_PATHNAME 512
+#ifndef MAX_PATHNAME
+#  if defined(PATH_MAX)
+#    define MAX_PATHNAME PATH_MAX
+#  elif defined(MAXPATHLEN)
+#    define MAX_PATHNAME MAXPATHLEN
+#  else
+#    define MAX_PATHNAME 512
+#  endif
+#endif
 
 /*
 ** Only set the lastErrno if the error code is a real error and not 
@@ -23327,10 +23349,10 @@ struct unixFile {
   int sectorSize;                     /* Device sector size */
   int deviceCharacteristics;          /* Precomputed device characteristics */
 #endif
-#if SQLITE_ENABLE_LOCKING_STYLE
+#if SQLITE_ENABLE_LOCKING_STYLE && !defined(__CYGWIN__)
   int openFlags;                      /* The flags specified at open() */
 #endif
-#if SQLITE_ENABLE_LOCKING_STYLE || defined(__APPLE__)
+#if SQLITE_ENABLE_LOCKING_STYLE && !defined(__CYGWIN__) || defined(__APPLE__)
   unsigned fsFlags;                   /* cached details from statfs() */
 #endif
 #if OS_VXWORKS
@@ -23656,6 +23678,7 @@ static int openDirectory(const char*, in
 ** testing and sandboxing.  The following array holds the names and pointers
 ** to all overrideable system calls.
 */
+#define aSyscall aUnixSyscall
 static struct unix_syscall {
   const char *zName;            /* Name of the system call */
   sqlite3_syscall_ptr pCurrent; /* Current value of the system call */
@@ -24152,7 +24175,9 @@ struct vxworksFileId {
 ** variable:
 */
 static struct vxworksFileId *vxworksFileList = 0;
+#endif /* OS_VXWORKS */
 
+#if OS_VXWORKS || defined(__CYGWIN__)
 /*
 ** Simplify a filename into its canonical form
 ** by making the following changes:
@@ -24171,7 +24196,13 @@ static int vxworksSimplifyName(char *z,
   while( n>1 && z[n-1]=='/' ){ n--; }
   for(i=j=0; i<n; i++){
     if( z[i]=='/' ){
-      if( z[i+1]=='/' ) continue;
+      if( z[i+1]=='/' ){
+#ifdef __CYGWIN__
+      /* Make an exception for UNC paths */
+      if( i!=0 )
+#endif
+      continue;
+      }
       if( z[i+1]=='.' && i+2<n && z[i+2]=='/' ){
         i += 1;
         continue;
@@ -24188,7 +24219,9 @@ static int vxworksSimplifyName(char *z,
   z[j] = 0;
   return j;
 }
+#endif
 
+#if OS_VXWORKS
 /*
 ** Find a unique file ID for the given absolute pathname.  Return
 ** a pointer to the vxworksFileId object.  This pointer is the unique
@@ -24383,10 +24416,10 @@ struct unixInodeInfo {
   UnixUnusedFd *pUnused;          /* Unused file descriptors to close */
   unixInodeInfo *pNext;           /* List of all unixInodeInfo objects */
   unixInodeInfo *pPrev;           /*    .... doubly linked */
-#if SQLITE_ENABLE_LOCKING_STYLE
+#if SQLITE_ENABLE_LOCKING_STYLE && !defined(__CYGWIN__)
   unsigned long long sharedByte;  /* for AFP simulated shared lock */
 #endif
-#if OS_VXWORKS
+#if OS_VXWORKS || defined(__CYGWIN__)
   sem_t *pSem;                    /* Named POSIX semaphore */
   char aSemName[MAX_PATHNAME+2];  /* Name of that semaphore */
 #endif
@@ -25526,7 +25559,7 @@ static int dotlockClose(sqlite3_file *id
 ** Omit this section if SQLITE_ENABLE_LOCKING_STYLE is turned off or if
 ** compiling for VXWORKS.
 */
-#if SQLITE_ENABLE_LOCKING_STYLE && !OS_VXWORKS
+#if SQLITE_ENABLE_LOCKING_STYLE && !OS_VXWORKS || defined(__CYGWIN__)
 
 /*
 ** Retry flock() calls that fail with EINTR
@@ -25732,7 +25765,7 @@ static int flockClose(sqlite3_file *id)
 ** the database file at a time.  This reduces potential concurrency, but
 ** makes the lock implementation much easier.
 */
-#if OS_VXWORKS
+#if OS_VXWORKS || defined(__CYGWIN__)
 
 /*
 ** This routine checks if there is a RESERVED lock held on the specified
@@ -26671,8 +26704,7 @@ static int unixWrite(
 ** Count the number of fullsyncs and normal syncs.  This is used to test
 ** that syncs and fullsyncs are occurring at the right times.
 */
-SQLITE_API int sqlite3_sync_count = 0;
-SQLITE_API int sqlite3_fullsync_count = 0;
+extern int sqlite3_sync_count, sqlite3_fullsync_count;
 #endif
 
 /*
@@ -28263,7 +28295,19 @@ IOMETHODS(
   dotlockCheckReservedLock  /* xCheckReservedLock method */
 )
 
-#if SQLITE_ENABLE_LOCKING_STYLE && !OS_VXWORKS
+#if defined(__CYGWIN__)
+IOMETHODS(
+  winntIoFinder,            /* Finder function name */
+  winntIoMethods,           /* sqlite3_io_methods object name */
+  1,                        /* shared memory is disabled */
+  flockClose,               /* xClose method */
+  flockLock,                /* xLock method */
+  flockUnlock,              /* xUnlock method */
+  flockCheckReservedLock    /* xCheckReservedLock method */
+)
+#endif
+
+#if SQLITE_ENABLE_LOCKING_STYLE && !OS_VXWORKS || defined(__CYGWIN__)
 IOMETHODS(
   flockIoFinder,            /* Finder function name */
   flockIoMethods,           /* sqlite3_io_methods object name */
@@ -28275,7 +28319,7 @@ IOMETHODS(
 )
 #endif
 
-#if OS_VXWORKS
+#if OS_VXWORKS || defined(__CYGWIN__)
 IOMETHODS(
   semIoFinder,              /* Finder function name */
   semIoMethods,             /* sqlite3_io_methods object name */
@@ -28441,6 +28485,63 @@ static const sqlite3_io_methods
 
 #endif /* OS_VXWORKS && SQLITE_ENABLE_LOCKING_STYLE */
 
+#if defined(__CYGWIN__) && SQLITE_ENABLE_LOCKING_STYLE
+/*
+** This "finder" function attempts to determine the best locking strategy
+** for the database file "filePath".  It then returns the sqlite3_io_methods
+** object that implements that strategy.
+**
+** This is for Cygwin only.
+*/
+static const sqlite3_io_methods *autolockIoFinderImpl(
+  const char *filePath,    /* name of the database file */
+  unixFile *pNew           /* the open file object */
+){
+  static const sqlite3_io_methods *ioMethods = NULL;
+
+  if( !filePath ){
+    /* If filePath==NULL that means we are dealing with a transient file
+    ** that does not need to be locked. */
+    return &nolockIoMethods;
+  }
+
+  if( !ioMethods ){
+    const char *strategy = getenv("CYGWIN_SQLITE_LOCKING");
+    ioMethods = &winntIoMethods;
+
+    if( strategy ){
+      if( !sqlite3_strnicmp(strategy, "unix", 4) ){
+        if( (strategy[4]=='-') || (strategy[4]=='_')){
+          strategy += 5;
+        }
+        ioMethods = &posixIoMethods;
+      }
+      if( sqlite3_stricmp(strategy, "excl") == 0 ){
+   	    pNew->ctrlFlags |= UNIXFILE_EXCL;
+        ioMethods = &posixIoMethods;
+      }else if( sqlite3_stricmp(strategy, "posix") == 0 ){
+        ioMethods = &posixIoMethods;
+      }else if( sqlite3_stricmp(strategy, "bsd") == 0
+          || sqlite3_stricmp(strategy, "flock") == 0 ){
+        ioMethods = &flockIoMethods;
+      }else if( sqlite3_stricmp(strategy, "dotfile") == 0 ){
+        ioMethods = &dotlockIoMethods;
+      }else if( sqlite3_strnicmp(strategy, "win", 3) == 0
+          || sqlite3_stricmp(strategy, "nfs") == 0 ){
+        /* Not reasonable, fall back to default */
+        ioMethods = &winntIoMethods;
+      }else if( sqlite3_stricmp(strategy, "none") == 0 ){
+        ioMethods = &nolockIoMethods;
+      }
+    }
+  }
+  return ioMethods;
+}
+static const sqlite3_io_methods
+  *(*const autolockIoFinder)(const char*,unixFile*) = autolockIoFinderImpl;
+
+#endif /* OS_VXWORKS && SQLITE_ENABLE_LOCKING_STYLE */
+
 /*
 ** An abstract type for a pointer to a IO method finder function:
 */
@@ -28597,7 +28698,7 @@ static int fillInUnixFile(
     pNew->lockingContext = zLockFile;
   }
 
-#if OS_VXWORKS
+#if OS_VXWORKS || defined(__CYGWIN__)
   else if( pLockingStyle == &semIoMethods ){
     /* Named semaphore locking uses the file path so it needs to be
     ** included in the semLockingContext
@@ -28607,8 +28708,14 @@ static int fillInUnixFile(
     if( (rc==SQLITE_OK) && (pNew->pInode->pSem==NULL) ){
       char *zSemName = pNew->pInode->aSemName;
       int n;
+#if OS_VXWORKS
       sqlite3_snprintf(MAX_PATHNAME, zSemName, "/%s.sem",
                        pNew->pId->zCanonicalName);
+#else
+      sqlite3_snprintf(MAX_PATHNAME, zSemName, "/%s.sem",
+                       zFilename);
+      vxworksSimplifyName(zSemName, MAX_PATHNAME);
+#endif
       for( n=1; zSemName[n]; n++ )
         if( zSemName[n]=='/' ) zSemName[n] = '_';
       pNew->pInode->pSem = sem_open(zSemName, O_CREAT, 0666, 1);
@@ -28620,6 +28727,15 @@ static int fillInUnixFile(
     unixLeaveMutex();
   }
 #endif
+
+#if defined(__CYGWIN__)
+  else if( pLockingStyle == &winntIoMethods ){
+    if ((osFcntl(h, F_LCK_MANDATORY, 1) != 0) && (errno != EINVAL)) {
+      /* The API exists but it refused to enable mandatory locking! */
+      rc = SQLITE_IOERR_ACCESS;
+    }
+  }
+#endif
   
   pNew->lastErrno = 0;
 #if OS_VXWORKS
@@ -28649,6 +28765,8 @@ static const char *unixTempFileDir(void)
      0,
      0,
      0,
+     0,
+     0,
      "/var/tmp",
      "/usr/tmp",
      "/tmp",
@@ -28661,6 +28779,8 @@ static const char *unixTempFileDir(void)
   azDirs[0] = sqlite3_temp_directory;
   if( !azDirs[1] ) azDirs[1] = getenv("SQLITE_TMPDIR");
   if( !azDirs[2] ) azDirs[2] = getenv("TMPDIR");
+  if( !azDirs[3] ) azDirs[2] = getenv("TMP");
+  if( !azDirs[4] ) azDirs[3] = getenv("TEMP");
   for(i=0; i<sizeof(azDirs)/sizeof(azDirs[0]); zDir=azDirs[i++]){
     if( zDir==0 ) continue;
     if( osStat(zDir, &buf) ) continue;
@@ -28898,10 +29018,10 @@ static int unixOpen(
   int isCreate     = (flags & SQLITE_OPEN_CREATE);
   int isReadonly   = (flags & SQLITE_OPEN_READONLY);
   int isReadWrite  = (flags & SQLITE_OPEN_READWRITE);
-#if SQLITE_ENABLE_LOCKING_STYLE
+#if SQLITE_ENABLE_LOCKING_STYLE && !defined(__CYGWIN__)
   int isAutoProxy  = (flags & SQLITE_OPEN_AUTOPROXY);
 #endif
-#if defined(__APPLE__) || SQLITE_ENABLE_LOCKING_STYLE
+#if defined(__APPLE__) || SQLITE_ENABLE_LOCKING_STYLE && !defined(__CYGWIN__)
   struct statfs fsInfo;
 #endif
 
@@ -29042,7 +29162,7 @@ static int unixOpen(
     osUnlink(zName);
 #endif
   }
-#if SQLITE_ENABLE_LOCKING_STYLE
+#if SQLITE_ENABLE_LOCKING_STYLE && !defined(__CYGWIN__)
   else{
     p->openFlags = openFlags;
   }
@@ -29051,7 +29171,7 @@ static int unixOpen(
   noLock = eType!=SQLITE_OPEN_MAIN_DB;
 
   
-#if defined(__APPLE__) || SQLITE_ENABLE_LOCKING_STYLE
+#if defined(__APPLE__) || SQLITE_ENABLE_LOCKING_STYLE && !defined(__CYGWIN__)
   if( fstatfs(fd, &fsInfo) == -1 ){
     ((unixFile*)pFile)->lastErrno = errno;
     robust_close(p, fd, __LINE__);
@@ -29069,7 +29189,7 @@ static int unixOpen(
   if( syncDir )                 ctrlFlags |= UNIXFILE_DIRSYNC;
   if( flags & SQLITE_OPEN_URI ) ctrlFlags |= UNIXFILE_URI;
 
-#if SQLITE_ENABLE_LOCKING_STYLE
+#if SQLITE_ENABLE_LOCKING_STYLE && !defined(__CYGWIN__)
 #if SQLITE_PREFER_PROXY_LOCKING
   isAutoProxy = 1;
 #endif
@@ -29211,6 +29331,13 @@ static int unixAccess(
 }
 
 
+#if SQLITE_OS_WIN
+#  if defined(SQLITE_AMALGAMATION)
+    static
+#  endif
+  void winSimplifyName(char *z);
+#endif
+
 /*
 ** Turn a relative pathname into a full pathname. The relative path
 ** is stored as a nul-terminated string in the buffer pointed to by
@@ -29226,6 +29353,9 @@ static int unixFullPathname(
   int nOut,                     /* Size of output buffer in bytes */
   char *zOut                    /* Output buffer */
 ){
+#ifdef __CYGWIN__
+  int i;
+#endif
 
   /* It's odd to simulate an io-error here, but really this is just
   ** using the io-error infrastructure to test that SQLite handles this
@@ -29238,6 +29368,35 @@ static int unixFullPathname(
   UNUSED_PARAMETER(pVfs);
 
   zOut[nOut-1] = '\0';
+#ifdef __CYGWIN__
+  if( sqlite3Isalpha(zPath[0]) && (zPath[1]==':')
+      && ((zPath[2]=='\\') || (zPath[2]=='/')) ){
+    int nDrive;
+    char temp[4];
+    temp[0] = zPath[0];
+    memcpy(&temp[1], ":\\", 3);
+    cygwin_conv_path(CCP_WIN_A_TO_POSIX, temp, zOut, nOut);
+    nDrive = (int)strlen(zOut);
+    sqlite3_snprintf(nOut-nDrive, &zOut[nDrive], "%s", zPath+2);
+  }else if( ((zPath[0]=='\\') || (zPath[0]=='/')) && ((zPath[1]=='\\') || (zPath[1]=='/'))
+      && (zPath[2]=='?') && ((zPath[3]=='\\') || (zPath[3]=='/')) && sqlite3Isalpha(zPath[4])
+      && (zPath[5]==':') && ((zPath[6]=='\\') || (zPath[6]=='/')) ){
+    int nDrive;
+    char temp[4];
+    temp[0] = zPath[4];
+    memcpy(&temp[1], ":\\", 3);
+    cygwin_conv_path(CCP_WIN_A_TO_POSIX, temp, zOut, nOut);
+    nDrive = (int)strlen(zOut);
+    sqlite3_snprintf(nOut-nDrive, &zOut[nDrive], "%s", zPath+6);
+  }else if( ((zPath[0]=='\\') || (zPath[0]=='/')) && ((zPath[1]=='\\') || (zPath[1]=='/'))
+      && (zPath[2]=='?') && ((zPath[3]=='\\') || (zPath[3]=='/')) && sqlite3_strnicmp(zPath+4, "UNC", 3)==0
+      && ((zPath[7]=='\\') || (zPath[7]=='/')) ){
+    /* UNC paths in Cygwin start with "//" */
+    sqlite3_snprintf(nOut, zOut, "//%s", zPath+8);
+  }else if( zPath[0]=='\\' ){
+    sqlite3_snprintf(nOut, zOut, "%s", zPath);
+  }else
+#endif
   if( zPath[0]=='/' ){
     sqlite3_snprintf(nOut, zOut, "%s", zPath);
   }else{
@@ -29248,6 +29407,9 @@ static int unixFullPathname(
     nCwd = (int)strlen(zOut);
     sqlite3_snprintf(nOut-nCwd, &zOut[nCwd], "/%s", zPath);
   }
+#if SQLITE_OS_WIN && defined(__CYGWIN__) 
+  winSimplifyName(zOut);
+#endif
   return SQLITE_OK;
 }
 
@@ -29391,7 +29553,7 @@ static int unixSleep(sqlite3_vfs *NotUse
 ** sqlite3OsCurrentTime() during testing.
 */
 #ifdef SQLITE_TEST
-SQLITE_API int sqlite3_current_time = 0;  /* Fake system time in seconds since 1970. */
+SQLITE_API extern int sqlite3_current_time;  /* Fake system time in seconds since 1970. */
 #endif
 
 /*
@@ -29684,7 +29846,7 @@ static int proxyGetLockPath(const char *
  */
 static int proxyCreateLockPath(const char *lockPath){
   int i, len;
-  char buf[MAXPATHLEN];
+  char buf[MAX_PATHNAME];
   int start = 0;
   
   assert(lockPath!=NULL);
@@ -29850,7 +30012,7 @@ static int proxyGetHostID(unsigned char
 #define PROXY_CONCHVERSION 2   /* 1-byte header, 16-byte host id, path */
 #define PROXY_HEADERLEN    1   /* conch file header length */
 #define PROXY_PATHINDEX    (PROXY_HEADERLEN+PROXY_HOSTIDLEN)
-#define PROXY_MAXCONCHLEN  (PROXY_HEADERLEN+PROXY_HOSTIDLEN+MAXPATHLEN)
+#define PROXY_MAXCONCHLEN  (PROXY_HEADERLEN+PROXY_HOSTIDLEN+MAX_PATHNAME)
 
 /* 
 ** Takes an open conch file, copies the contents to a new path and then moves 
@@ -29861,7 +30023,7 @@ static int proxyGetHostID(unsigned char
 static int proxyBreakConchLock(unixFile *pFile, uuid_t myHostID){
   proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext; 
   unixFile *conchFile = pCtx->conchFile;
-  char tPath[MAXPATHLEN];
+  char tPath[MAX_PATHNAME];
   char buf[PROXY_MAXCONCHLEN];
   char *cPath = pCtx->conchFilePath;
   size_t readLen = 0;
@@ -29872,8 +30034,8 @@ static int proxyBreakConchLock(unixFile
   UNUSED_PARAMETER(myHostID);
 
   /* create a new path by replace the trailing '-conch' with '-break' */
-  pathLen = strlcpy(tPath, cPath, MAXPATHLEN);
-  if( pathLen>MAXPATHLEN || pathLen<6 || 
+  pathLen = strlcpy(tPath, cPath, MAX_PATHNAME);
+  if( pathLen>MAX_PATHNAME || pathLen<6 || 
      (strlcpy(&tPath[pathLen-5], "break", 6) != 5) ){
     sqlite3_snprintf(sizeof(errmsg),errmsg,"path error (len %d)",(int)pathLen);
     goto end_breaklock;
@@ -30006,7 +30168,7 @@ static int proxyTakeConch(unixFile *pFil
     uuid_t myHostID;
     int pError = 0;
     char readBuf[PROXY_MAXCONCHLEN];
-    char lockPath[MAXPATHLEN];
+    char lockPath[MAX_PATHNAME];
     char *tempLockPath = NULL;
     int rc = SQLITE_OK;
     int createConch = 0;
@@ -30058,8 +30220,8 @@ static int proxyTakeConch(unixFile *pFil
           if( hostIdMatch ){
             size_t pathLen = (readLen - PROXY_PATHINDEX);
             
-            if( pathLen>=MAXPATHLEN ){
-              pathLen=MAXPATHLEN-1;
+            if( pathLen>=MAX_PATHNAME ){
+              pathLen=MAX_PATHNAME-1;
             }
             memcpy(lockPath, &readBuf[PROXY_PATHINDEX], pathLen);
             lockPath[pathLen] = 0;
@@ -30085,7 +30247,7 @@ static int proxyTakeConch(unixFile *pFil
       
       /* either the conch didn't match or we need to create a new one */
       if( !pCtx->lockProxyPath ){
-        proxyGetLockPath(pCtx->dbPath, lockPath, MAXPATHLEN);
+        proxyGetLockPath(pCtx->dbPath, lockPath, MAX_PATHNAME);
         tempLockPath = lockPath;
         /* create a copy of the lock path _only_ if the conch is taken */
       }
@@ -30113,9 +30275,9 @@ static int proxyTakeConch(unixFile *pFil
         writeBuffer[0] = (char)PROXY_CONCHVERSION;
         memcpy(&writeBuffer[PROXY_HEADERLEN], myHostID, PROXY_HOSTIDLEN);
         if( pCtx->lockProxyPath!=NULL ){
-          strlcpy(&writeBuffer[PROXY_PATHINDEX], pCtx->lockProxyPath, MAXPATHLEN);
+          strlcpy(&writeBuffer[PROXY_PATHINDEX], pCtx->lockProxyPath, MAX_PATHNAME);
         }else{
-          strlcpy(&writeBuffer[PROXY_PATHINDEX], tempLockPath, MAXPATHLEN);
+          strlcpy(&writeBuffer[PROXY_PATHINDEX], tempLockPath, MAX_PATHNAME);
         }
         writeSize = PROXY_PATHINDEX + strlen(&writeBuffer[PROXY_PATHINDEX]);
         robust_ftruncate(conchFile->h, writeSize);
@@ -30294,7 +30456,7 @@ static int switchLockProxyPath(unixFile
 
   /* nothing to do if the path is NULL, :auto: or matches the existing path */
   if( !path || path[0]=='\0' || !strcmp(path, ":auto:") ||
-    (oldPath && !strncmp(oldPath, path, MAXPATHLEN)) ){
+    (oldPath && !strncmp(oldPath, path, MAX_PATHNAME)) ){
     return SQLITE_OK;
   }else{
     unixFile *lockProxy = pCtx->lockProxy;
@@ -30314,7 +30476,7 @@ static int switchLockProxyPath(unixFile
 
 /*
 ** pFile is a file that has been opened by a prior xOpen call.  dbPath
-** is a string buffer at least MAXPATHLEN+1 characters in size.
+** is a string buffer at least MAX_PATHNAME+1 characters in size.
 **
 ** This routine find the filename associated with pFile and writes it
 ** int dbPath.
@@ -30324,8 +30486,8 @@ static int proxyGetDbPathForUnixFile(uni
   if( pFile->pMethod == &afpIoMethods ){
     /* afp style keeps a reference to the db path in the filePath field 
     ** of the struct */
-    assert( (int)strlen((char*)pFile->lockingContext)<=MAXPATHLEN );
-    strlcpy(dbPath, ((afpLockingContext *)pFile->lockingContext)->dbPath, MAXPATHLEN);
+    assert( (int)strlen((char*)pFile->lockingContext)<=MAX_PATHNAME );
+    strlcpy(dbPath, ((afpLockingContext *)pFile->lockingContext)->dbPath, MAX_PATHNAME);
   } else
 #endif
   if( pFile->pMethod == &dotlockIoMethods ){
@@ -30335,8 +30497,8 @@ static int proxyGetDbPathForUnixFile(uni
     memcpy(dbPath, (char *)pFile->lockingContext, len + 1);
   }else{
     /* all other styles use the locking context to store the db file path */
-    assert( strlen((char*)pFile->lockingContext)<=MAXPATHLEN );
-    strlcpy(dbPath, (char *)pFile->lockingContext, MAXPATHLEN);
+    assert( strlen((char*)pFile->lockingContext)<=MAX_PATHNAME );
+    strlcpy(dbPath, (char *)pFile->lockingContext, MAX_PATHNAME);
   }
   return SQLITE_OK;
 }
@@ -30351,7 +30513,7 @@ static int proxyGetDbPathForUnixFile(uni
 */
 static int proxyTransformUnixFile(unixFile *pFile, const char *path) {
   proxyLockingContext *pCtx;
-  char dbPath[MAXPATHLEN+1];       /* Name of the database file */
+  char dbPath[MAX_PATHNAME+1];       /* Name of the database file */
   char *lockPath=NULL;
   int rc = SQLITE_OK;
   
@@ -30472,7 +30634,7 @@ static int proxyFileControl(sqlite3_file
             (proxyLockingContext*)pFile->lockingContext;
           if( !strcmp(pArg, ":auto:") 
            || (pCtx->lockProxyPath &&
-               !strncmp(pCtx->lockProxyPath, proxyPath, MAXPATHLEN))
+               !strncmp(pCtx->lockProxyPath, proxyPath, MAX_PATHNAME))
           ){
             rc = SQLITE_OK;
           }else{
@@ -30650,7 +30812,15 @@ static int proxyClose(sqlite3_file *id)
 ** necessarily been initialized when this routine is called, and so they
 ** should not be used.
 */
-SQLITE_API int sqlite3_os_init(void){ 
+#if SQLITE_OS_WIN
+#if defined(SQLITE_AMALGAMATION)
+static
+#endif
+SQLITE_API int sqlite3_os_unix_init(void){
+#else
+SQLITE_API int sqlite3_os_init(void){
+#endif
+
   /* 
   ** The following macro defines an initializer for an sqlite3_vfs object.
   ** The name of the VFS is NAME.  The pAppData is a pointer to a pointer
@@ -30704,22 +30874,29 @@ SQLITE_API int sqlite3_os_init(void){
   ** array cannot be const.
   */
   static sqlite3_vfs aVfs[] = {
-#if SQLITE_ENABLE_LOCKING_STYLE && (OS_VXWORKS || defined(__APPLE__))
+#if SQLITE_ENABLE_LOCKING_STYLE && (OS_VXWORKS || defined(__APPLE__) || defined(__CYGWIN__))
     UNIXVFS("unix",          autolockIoFinder ),
 #else
     UNIXVFS("unix",          posixIoFinder ),
 #endif
+#ifdef __CYGWIN__
+    UNIXVFS("winnt",         winntIoFinder ),
+#if !SQLITE_OS_WIN
+    UNIXVFS("win32",         winntIoFinder ),
+    UNIXVFS("win32-longpath", winntIoFinder ),
+#endif
+#endif
     UNIXVFS("unix-none",     nolockIoFinder ),
     UNIXVFS("unix-dotfile",  dotlockIoFinder ),
     UNIXVFS("unix-excl",     posixIoFinder ),
-#if OS_VXWORKS
+#if OS_VXWORKS || defined(__CYGWIN__)
     UNIXVFS("unix-namedsem", semIoFinder ),
 #endif
 #if SQLITE_ENABLE_LOCKING_STYLE
     UNIXVFS("unix-posix",    posixIoFinder ),
-#if !OS_VXWORKS
-    UNIXVFS("unix-flock",    flockIoFinder ),
 #endif
+#if SQLITE_ENABLE_LOCKING_STYLE && !OS_VXWORKS || defined(__CYGWIN__)
+    UNIXVFS("unix-flock",    flockIoFinder ),
 #endif
 #if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)
     UNIXVFS("unix-afp",      afpIoFinder ),
@@ -30731,7 +30908,11 @@ SQLITE_API int sqlite3_os_init(void){
 
   /* Double-check that the aSyscall[] array has been constructed
   ** correctly.  See ticket [bb3a86e890c8e96ab] */
+#if !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0
   assert( ArraySize(aSyscall)==24 );
+#else
+  assert( ArraySize(aSyscall)==21 );
+#endif
 
   /* Register all VFSes defined in the aVfs[] array */
   for(i=0; i<(sizeof(aVfs)/sizeof(sqlite3_vfs)); i++){
@@ -30740,6 +30921,8 @@ SQLITE_API int sqlite3_os_init(void){
   return SQLITE_OK; 
 }
 
+#undef aSyscall
+#if !SQLITE_OS_WIN
 /*
 ** Shutdown the operating system interface.
 **
@@ -30750,6 +30933,7 @@ SQLITE_API int sqlite3_os_init(void){
 SQLITE_API int sqlite3_os_end(void){ 
   return SQLITE_OK; 
 }
+#endif /* !SQLITE_OS_WIN */
  
 #endif /* SQLITE_OS_UNIX */
 
@@ -30772,8 +30956,15 @@ SQLITE_API int sqlite3_os_end(void){
 #if SQLITE_OS_WIN               /* This file is used for Windows only */
 
 #ifdef __CYGWIN__
-# include <sys/cygwin.h>
+/* # include <windows.h> */
+# include <sys/cygwin.h> /* amalgamator: keep */
+# include <unistd.h> /* amalgamator: keep */
 # include <errno.h> /* amalgamator: keep */
+#else
+enum {
+    CCP_POSIX_TO_WIN_W=1,
+    CCP_WIN_A_TO_POSIX
+};
 #endif
 
 /*
@@ -31002,7 +31193,8 @@ SQLITE_API int sqlite3_open_file_count =
 ** Are most of the Win32 ANSI APIs available (i.e. with certain exceptions
 ** based on the sub-platform)?
 */
-#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && !defined(SQLITE_WIN32_NO_ANSI)
+#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && !defined(SQLITE_WIN32_NO_ANSI) \
+   && !defined(_WIN64) && !defined(__x86_64__)
 #  define SQLITE_WIN32_HAS_ANSI
 #endif
 
@@ -31625,7 +31817,8 @@ static struct win_syscall {
 
 #define osGetLastError ((DWORD(WINAPI*)(VOID))aSyscall[26].pCurrent)
 
-#if !defined(SQLITE_OMIT_LOAD_EXTENSION)
+#if !defined(SQLITE_OMIT_LOAD_EXTENSION) || \
+        (SQLITE_OS_WINNT && !defined(__CYGWIN__))
 #if SQLITE_OS_WINCE
   /* The GetProcAddressA() routine is only available on Windows CE. */
   { "GetProcAddressA",         (SYSCALL)GetProcAddressA,         0 },
@@ -31686,8 +31879,7 @@ static struct win_syscall {
 
 #define osGetTickCount ((DWORD(WINAPI*)(VOID))aSyscall[33].pCurrent)
 
-#if defined(SQLITE_WIN32_HAS_ANSI) && defined(SQLITE_WIN32_GETVERSIONEX) && \
-        SQLITE_WIN32_GETVERSIONEX
+#if defined(SQLITE_WIN32_HAS_ANSI) && SQLITE_WIN32_GETVERSIONEX
   { "GetVersionExA",           (SYSCALL)GetVersionExA,           0 },
 #else
   { "GetVersionExA",           (SYSCALL)0,                       0 },
@@ -31697,7 +31889,7 @@ static struct win_syscall {
         LPOSVERSIONINFOA))aSyscall[34].pCurrent)
 
 #if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE) && \
-        defined(SQLITE_WIN32_GETVERSIONEX) && SQLITE_WIN32_GETVERSIONEX
+        SQLITE_WIN32_GETVERSIONEX
   { "GetVersionExW",           (SYSCALL)GetVersionExW,           0 },
 #else
   { "GetVersionExW",           (SYSCALL)0,                       0 },
@@ -32012,6 +32204,73 @@ static struct win_syscall {
 #define osCreateFileMappingFromApp ((HANDLE(WINAPI*)(HANDLE, \
         LPSECURITY_ATTRIBUTES,ULONG,ULONG64,LPCWSTR))aSyscall[75].pCurrent)
 
+#if SQLITE_OS_WINNT && defined(SQLITE_WIN32_HAS_ANSI) && !defined(__CYGWIN__)
+  { "GetModuleHandleA",         (SYSCALL)GetModuleHandleA,       0 },
+#else
+  { "GetModuleHandleA",         (SYSCALL)0,                      0 },
+#endif
+
+#define osGetModuleHandleA ((HMODULE(*)(LPCSTR))aSyscall[76].pCurrent)
+
+#if SQLITE_OS_WINNT && defined(SQLITE_WIN32_HAS_WIDE) && !defined(__CYGWIN__)
+  { "GetModuleHandleW",         (SYSCALL)GetModuleHandleW,       0 },
+#else
+  { "GetModuleHandleW",         (SYSCALL)0,                      0 },
+#endif
+
+#define osGetModuleHandleW ((HMODULE(*)(LPCWSTR))aSyscall[77].pCurrent)
+
+#if defined(__CYGWIN__)
+  { "getenv",                   (SYSCALL)getenv,                 0 },
+#else
+  { "getenv",                   (SYSCALL)0,                      0 },
+#endif
+
+#define getenv ((const char *(*)(const char *))aSyscall[78].pCurrent)
+
+#if defined(__CYGWIN__)
+  { "getcwd",                   (SYSCALL)getcwd,                 0 },
+#else
+  { "getcwd",                   (SYSCALL)0,                      0 },
+#endif
+
+#define getcwd ((char*(*)(char*,size_t))aSyscall[79].pCurrent)
+
+#if defined(__CYGWIN__)
+  { "__errno",                  (SYSCALL)__errno,                0 },
+#else
+  { "__errno",                  (SYSCALL)0,                      0 },
+#endif
+
+#define osErrno (*((int*(*)(void))aSyscall[80].pCurrent)())
+
+#if defined(__CYGWIN__) && defined(SQLITE_WIN32_HAS_WIDE)
+  { "cygwin_conv_path",         (SYSCALL)cygwin_conv_path,       0 },
+#else
+  { "cygwin_conv_path",         (SYSCALL)0,                      0 },
+#endif
+
+#define cygwin_conv_path ((ssize_t(*)(unsigned int, \
+		const void *, void *, size_t))aSyscall[81].pCurrent)
+
+#if defined(__CYGWIN__)  && defined(SQLITE_WIN32_HAS_ANSI)
+  { "cygwin_conv_to_full_win32_path", (SYSCALL)cygwin_conv_to_full_win32_path,0 },
+#else
+  { "cygwin_conv_to_full_win32_path", (SYSCALL)0,                      0 },
+#endif
+
+#define cygwin_conv_to_full_win32_path ((void(*)(const char *, \
+		char *))aSyscall[82].pCurrent)
+
+#if defined(__CYGWIN__)  && defined(SQLITE_WIN32_HAS_ANSI)
+  { "cygwin_conv_to_full_posix_path", (SYSCALL)cygwin_conv_to_full_posix_path,0 },
+#else
+  { "cygwin_conv_to_full_posix_path", (SYSCALL)0,                      0 },
+#endif
+
+#define cygwin_conv_to_full_posix_path ((void(*)(const char *, \
+		char *))aSyscall[83].pCurrent)
+
 }; /* End of the overrideable system calls */
 
 /*
@@ -32185,6 +32444,7 @@ SQLITE_API int sqlite3_win32_reset_heap(
 }
 #endif /* SQLITE_WIN32_MALLOC */
 
+#ifndef __CYGWIN__
 /*
 ** This function outputs the specified (ANSI) string to the Win32 debugger
 ** (if available).
@@ -32221,6 +32481,7 @@ SQLITE_API void sqlite3_win32_write_debu
   }
 #endif
 }
+#endif /* !__CYGWIN__ */
 
 /*
 ** The following routine suspends the current thread for at least ms
@@ -32230,6 +32491,9 @@ SQLITE_API void sqlite3_win32_write_debu
 static HANDLE sleepObj = NULL;
 #endif
 
+#if defined(__CYGWIN__) && defined(SQLITE_AMALGAMATION)
+static
+#endif
 SQLITE_API void sqlite3_win32_sleep(DWORD milliseconds){
 #if SQLITE_OS_WINRT
   if ( sleepObj==NULL ){
@@ -32255,9 +32519,9 @@ SQLITE_API void sqlite3_win32_sleep(DWOR
 ** the LockFileEx() API.
 */
 
-#if !defined(SQLITE_WIN32_GETVERSIONEX) || !SQLITE_WIN32_GETVERSIONEX
+#if !SQLITE_WIN32_GETVERSIONEX
 # define osIsNT()  (1)
-#elif SQLITE_OS_WINCE || SQLITE_OS_WINRT || !defined(SQLITE_WIN32_HAS_ANSI)
+#elif !defined(SQLITE_WIN32_HAS_ANSI)
 # define osIsNT()  (1)
 #elif !defined(SQLITE_WIN32_HAS_WIDE)
 # define osIsNT()  (0)
@@ -32487,9 +32751,12 @@ SQLITE_PRIVATE void sqlite3MemSetDefault
 /*
 ** Convert a UTF-8 string to Microsoft Unicode (UTF-16?). 
 **
-** Space to hold the returned string is obtained from malloc.
+** Space to hold the returned string is obtained from malloc,
+** unless buf is not NULL and the needed size is less than
+** SQLITE_WIN32_MAX_PATH_CHARS bytes. As a conveniance, the
+** Unicode string "\\?\" is always prepended to the result.
 */
-static LPWSTR winUtf8ToUnicode(const char *zFilename){
+static LPWSTR winUtf8ToUnicode(const char *zFilename, void *buf){
   int nChar;
   LPWSTR zWideFilename;
 
@@ -32497,11 +32764,16 @@ static LPWSTR winUtf8ToUnicode(const cha
   if( nChar==0 ){
     return 0;
   }
-  zWideFilename = sqlite3MallocZero( nChar*sizeof(zWideFilename[0]) );
-  if( zWideFilename==0 ){
-    return 0;
+  if( buf && (nChar < ((SQLITE_WIN32_MAX_PATH_CHARS-8)/sizeof(zWideFilename[0]))) ){
+    zWideFilename = buf;
+  }else{
+    zWideFilename = sqlite3Malloc( nChar*sizeof(zWideFilename[0])+8 );
+    if( zWideFilename==0 ){
+      return 0;
+    }
   }
-  nChar = osMultiByteToWideChar(CP_UTF8, 0, zFilename, -1, zWideFilename,
+  memcpy(zWideFilename, L"\\\\?\\", 8);
+  nChar = osMultiByteToWideChar(CP_UTF8, 0, zFilename, -1, zWideFilename+4,
                                 nChar);
   if( nChar==0 ){
     sqlite3_free(zWideFilename);
@@ -32552,7 +32824,7 @@ static LPWSTR winMbcsToUnicode(const cha
   if( nByte==0 ){
     return 0;
   }
-  zMbcsFilename = sqlite3MallocZero( nByte*sizeof(zMbcsFilename[0]) );
+  zMbcsFilename = sqlite3Malloc( nByte*sizeof(zMbcsFilename[0]) );
   if( zMbcsFilename==0 ){
     return 0;
   }
@@ -32581,7 +32853,7 @@ static char *winUnicodeToMbcs(LPCWSTR zW
   if( nByte == 0 ){
     return 0;
   }
-  zFilename = sqlite3MallocZero( nByte );
+  zFilename = sqlite3Malloc( nByte );
   if( zFilename==0 ){
     return 0;
   }
@@ -32594,6 +32866,7 @@ static char *winUnicodeToMbcs(LPCWSTR zW
   return zFilename;
 }
 
+#ifdef SQLITE_WIN32_HAS_ANSI
 /*
 ** Convert multibyte character string to UTF-8.  Space to hold the
 ** returned string is obtained from sqlite3_malloc().
@@ -32619,15 +32892,17 @@ SQLITE_API char *sqlite3_win32_utf8_to_m
   char *zFilenameMbcs;
   LPWSTR zTmpWide;
 
-  zTmpWide = winUtf8ToUnicode(zFilename);
+  zTmpWide = winUtf8ToUnicode(zFilename, 0);
   if( zTmpWide==0 ){
     return 0;
   }
-  zFilenameMbcs = winUnicodeToMbcs(zTmpWide);
+  zFilenameMbcs = winUnicodeToMbcs(zTmpWide+4);
   sqlite3_free(zTmpWide);
   return zFilenameMbcs;
 }
+#endif /* SQLITE_WIN32_HAS_ANSI */
 
+#ifndef __CYGWIN__
 /*
 ** This function sets the data directory or the temporary directory based on
 ** the provided arguments.  The type argument must be 1 in order to set the
@@ -32650,7 +32925,7 @@ SQLITE_API int sqlite3_win32_set_directo
           || type==SQLITE_WIN32_TEMP_DIRECTORY_TYPE
   );
   assert( !ppDirectory || sqlite3MemdebugHasType(*ppDirectory, MEMTYPE_HEAP) );
-  if( ppDirectory ){
+  if( !getenv && ppDirectory ){
     char *zValueUtf8 = 0;
     if( zValue && zValue[0] ){
       zValueUtf8 = winUnicodeToUtf8(zValue);
@@ -32664,6 +32939,7 @@ SQLITE_API int sqlite3_win32_set_directo
   }
   return SQLITE_ERROR;
 }
+#endif
 
 /*
 ** The return value of winGetLastErrorMsg
@@ -32898,7 +33174,7 @@ static int winceCreateLock(const char *z
   BOOL bLogged = FALSE;
   BOOL bInit = TRUE;
 
-  zName = winUtf8ToUnicode(zFilename);
+  zName = winUtf8ToUnicode(zFilename, 0);
   if( zName==0 ){
     /* out of memory */
     return SQLITE_IOERR_NOMEM;
@@ -32909,13 +33185,13 @@ static int winceCreateLock(const char *z
 
   /* Replace the backslashes from the filename and lowercase it
   ** to derive a mutex name. */
-  zTok = osCharLowerW(zName);
+  zTok = osCharLowerW(zName+4);
   for (;*zTok;zTok++){
     if (*zTok == '\\') *zTok = '_';
   }
 
   /* Create/open the named mutex */
-  pFile->hMutex = osCreateMutexW(NULL, FALSE, zName);
+  pFile->hMutex = osCreateMutexW(NULL, FALSE, zName+4);
   if (!pFile->hMutex){
     pFile->lastErrno = osGetLastError();
     sqlite3_free(zName);
@@ -32930,10 +33206,10 @@ static int winceCreateLock(const char *z
   ** case-sensitive, take advantage of that by uppercasing the mutex name
   ** and using that as the shared filemapping name.
   */
-  osCharUpperW(zName);
+  osCharUpperW(zName+4);
   pFile->hShared = osCreateFileMappingW(INVALID_HANDLE_VALUE, NULL,
                                         PAGE_READWRITE, 0, sizeof(winceLock),
-                                        zName);  
+                                        zName+4);  
 
   /* Set a flag that indicates we're the first to create the memory so it 
   ** must be zero-initialized */
@@ -33580,8 +33856,7 @@ static int winTruncate(sqlite3_file *id,
 ** Count the number of fullsyncs and normal syncs.  This is used to test
 ** that syncs and fullsyncs are occuring at the right times.
 */
-SQLITE_API int sqlite3_sync_count = 0;
-SQLITE_API int sqlite3_fullsync_count = 0;
+extern int sqlite3_sync_count, sqlite3_fullsync_count;
 #endif
 
 /*
@@ -34083,7 +34358,7 @@ static int winFileControl(sqlite3_file *
       return SQLITE_OK;
     }
     case SQLITE_FCNTL_VFSNAME: {
-      *(char**)pArg = sqlite3_mprintf("win32");
+      *(char**)pArg = sqlite3_mprintf("%s", pFile->pVfs->zName);
       OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));
       return SQLITE_OK;
     }
@@ -34165,7 +34440,7 @@ static int winDeviceCharacteristics(sqli
 ** During sqlite3_os_init() we do a GetSystemInfo()
 ** to get the granularity size.
 */
-SYSTEM_INFO winSysInfo;
+static SYSTEM_INFO winSysInfo;
 
 #ifndef SQLITE_OMIT_WAL
 
@@ -35067,7 +35342,7 @@ static const sqlite3_io_methods winIoMet
 ** sqlite3_vfs object.
 */
 
-#if defined(__CYGWIN__)
+#if 0
 /*
 ** Convert a filename from whatever the underlying operating system
 ** supports for filenames into UTF-8.  Space to hold the result is
@@ -35092,14 +35367,52 @@ static char *winConvertToUtf8Filename(co
 ** Convert a UTF-8 filename into whatever form the underlying
 ** operating system wants filenames in.  Space to hold the result
 ** is obtained from malloc and must be freed by the calling
-** function.
+** function, unless buf is not NULL and the needed size is less
+** than SQLITE_WIN32_MAX_PATH_CHARS bytes. This function should
+** never receive paths starthing with "\\?\", but it will produce
+** such paths when >=WinNT.
 */
-static void *winConvertFromUtf8Filename(const char *zFilename){
+static void *winConvertFromUtf8Filename(const char *zFilename, void *buf){
   void *zConverted = 0;
   if( osIsNT() ){
-    zConverted = winUtf8ToUnicode(zFilename);
+    if( (cygwin_conv_path!=NULL) && !(winIsDriveLetterAndColon(zFilename)
+        && winIsDirSep(zFilename[2]))){
+      int nByte = cygwin_conv_path(CCP_POSIX_TO_WIN_W, zFilename, 0, 0);
+      if( nByte>0 ){
+        if( buf && (nByte<SQLITE_WIN32_MAX_PATH_CHARS) ){
+          zConverted = buf;
+        }else{
+          zConverted = sqlite3Malloc(nByte);
+          if ( zConverted==0 ){
+            return zConverted;
+          }
+        }
+        if( zConverted==0 || cygwin_conv_path(CCP_POSIX_TO_WIN_W,
+            zFilename, zConverted, nByte)==0 ){
+          return zConverted;
+        }
+        if( zConverted!=buf ){
+          sqlite3_free(zConverted);
+        }
+      }
+    }else if( (cygwin_conv_to_full_win32_path!=NULL) &&
+        !(winIsDriveLetterAndColon(zFilename) && winIsDirSep(zFilename[2]))){
+      char buf1[SQLITE_WIN32_MAX_PATH_CHARS];
+      cygwin_conv_to_full_win32_path(zFilename, buf1);
+      return winMbcsToUnicode(buf1);
+    }
+    zConverted = winUtf8ToUnicode(zFilename, buf);
   }
 #ifdef SQLITE_WIN32_HAS_ANSI
+  else if( (cygwin_conv_to_full_win32_path!=NULL) &&
+      !(winIsDriveLetterAndColon(zFilename) && winIsDirSep(zFilename[2])) ){
+    char buf[SQLITE_WIN32_MAX_PATH_CHARS];
+    cygwin_conv_to_full_win32_path(zFilename, buf);
+    zConverted = sqlite3Malloc(strlen(buf)+1);
+    if( zConverted ){
+      strcpy(zConverted, buf);
+    }
+  }
   else{
     zConverted = sqlite3_win32_utf8_to_mbcs(zFilename);
   }
@@ -35120,7 +35433,14 @@ static int winMakeEndInDirSep(int nBuf,
       if( winIsDirSep(zBuf[nLen-1]) ){
         return 1;
       }else if( nLen+1<nBuf ){
-        zBuf[nLen] = winGetDirSep();
+        if( !getenv ){
+          zBuf[nLen] = '\\';
+        }else if( winIsDriveLetterAndColon(zBuf) && winIsDirSep(zBuf[2]) ){
+          zBuf[nLen] = '\\';
+          zBuf[2]='\\';
+        }else{
+          zBuf[nLen] = '/';
+        }
         zBuf[nLen+1] = '\0';
         return 1;
       }
@@ -35179,8 +35499,8 @@ static int winGetTempname(sqlite3_vfs *p
       sqlite3_snprintf(nMax, zBuf, "%s", sqlite3_temp_directory);
     }
   }
-#if defined(__CYGWIN__)
-  else{
+#if SQLITE_OS_WINNT
+  else if( getenv!=NULL ){
     static const char *azDirs[] = {
        0, /* getenv("SQLITE_TMPDIR") */
        0, /* getenv("TMPDIR") */
@@ -35209,8 +35529,9 @@ static int winGetTempname(sqlite3_vfs *p
       ** it must be converted to a native Win32 path via the Cygwin API
       ** prior to using it.
       */
-      if( winIsDriveLetterAndColon(zDir) ){
-        zConverted = winConvertFromUtf8Filename(zDir);
+      {
+        char buf[SQLITE_WIN32_MAX_PATH_CHARS];
+        zConverted = winConvertFromUtf8Filename(zDir, buf);
         if( !zConverted ){
           sqlite3_free(zBuf);
           OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));
@@ -35218,10 +35539,15 @@ static int winGetTempname(sqlite3_vfs *p
         }
         if( winIsDir(zConverted) ){
           sqlite3_snprintf(nMax, zBuf, "%s", zDir);
-          sqlite3_free(zConverted);
+          if( zConverted!=buf ){
+            sqlite3_free(zConverted);
+          }
           break;
         }
-        sqlite3_free(zConverted);
+        if( zConverted!=buf ){
+          sqlite3_free(zConverted);
+        }
+#if 0 /* No longer necessary */
       }else{
         zConverted = sqlite3MallocZero( nMax+1 );
         if( !zConverted ){
@@ -35256,13 +35582,16 @@ static int winGetTempname(sqlite3_vfs *p
           break;
         }
         sqlite3_free(zConverted);
+#endif /* No longer necessary */
       }
     }
   }
-#elif !SQLITE_OS_WINRT && !defined(__CYGWIN__)
+#endif
+
+#if !SQLITE_OS_WINRT && !defined(__CYGWIN__)
   else if( osIsNT() ){
     char *zMulti;
-    LPWSTR zWidePath = sqlite3MallocZero( nMax*sizeof(WCHAR) );
+    LPWSTR zWidePath = sqlite3Malloc( nMax*sizeof(WCHAR) );
     if( !zWidePath ){
       sqlite3_free(zBuf);
       OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));
@@ -35290,7 +35619,7 @@ static int winGetTempname(sqlite3_vfs *p
 #ifdef SQLITE_WIN32_HAS_ANSI
   else{
     char *zUtf8;
-    char *zMbcsPath = sqlite3MallocZero( nMax );
+    char *zMbcsPath = sqlite3Malloc( nMax );
     if( !zMbcsPath ){
       sqlite3_free(zBuf);
       OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));
@@ -35497,7 +35826,7 @@ static int winOpen(
        zUtf8Name[sqlite3Strlen30(zUtf8Name)+1]==0 );
 
   /* Convert the filename to the system encoding. */
-  zConverted = winConvertFromUtf8Filename(zUtf8Name);
+  zConverted = winConvertFromUtf8Filename(zUtf8Name, 0);
   if( zConverted==0 ){
     sqlite3_free(zTmpname);
     OSTRACE(("OPEN name=%s, rc=SQLITE_IOERR_NOMEM", zUtf8Name));
@@ -35698,7 +36027,7 @@ static int winDelete(
   SimulateIOError(return SQLITE_IOERR_DELETE);
   OSTRACE(("DELETE name=%s, syncDir=%d\n", zFilename, syncDir));
 
-  zConverted = winConvertFromUtf8Filename(zFilename);
+  zConverted = winConvertFromUtf8Filename(zFilename, 0);
   if( zConverted==0 ){
     OSTRACE(("DELETE name=%s, rc=SQLITE_IOERR_NOMEM\n", zFilename));
     return SQLITE_IOERR_NOMEM;
@@ -35800,13 +36129,14 @@ static int winAccess(
   int rc = 0;
   DWORD lastErrno = 0;
   void *zConverted;
+  char buf[SQLITE_WIN32_MAX_PATH_CHARS];
   UNUSED_PARAMETER(pVfs);
 
   SimulateIOError( return SQLITE_IOERR_ACCESS; );
   OSTRACE(("ACCESS name=%s, flags=%x, pResOut=%p\n",
            zFilename, flags, pResOut));
 
-  zConverted = winConvertFromUtf8Filename(zFilename);
+  zConverted = winConvertFromUtf8Filename(zFilename, buf);
   if( zConverted==0 ){
     OSTRACE(("ACCESS name=%s, rc=SQLITE_IOERR_NOMEM\n", zFilename));
     return SQLITE_IOERR_NOMEM;
@@ -35832,7 +36162,9 @@ static int winAccess(
     }else{
       winLogIoerr(cnt);
       if( lastErrno!=ERROR_FILE_NOT_FOUND && lastErrno!=ERROR_PATH_NOT_FOUND ){
-        sqlite3_free(zConverted);
+        if( zConverted!=buf ){
+          sqlite3_free(zConverted);
+        }
         return winLogError(SQLITE_IOERR_ACCESS, lastErrno, "winAccess",
                            zFilename);
       }else{
@@ -35845,7 +36177,9 @@ static int winAccess(
     attr = osGetFileAttributesA((char*)zConverted);
   }
 #endif
-  sqlite3_free(zConverted);
+  if( zConverted!=buf ){
+    sqlite3_free(zConverted);
+  }
   switch( flags ){
     case SQLITE_ACCESS_READ:
     case SQLITE_ACCESS_EXISTS:
@@ -35911,6 +36245,46 @@ static BOOL winIsVerbatimPathname(
   return FALSE;
 }
 
+#if defined(_WIN32) || defined(__CYGWIN__)
+/*
+** Simplify a filename into its canonical form
+** by making the following changes:
+**
+**  * convert any '\' to '/'
+**  * removing any trailing and duplicate / (except for UNC paths)
+**  * convert /./ into just /
+**
+** Changes are made in-place.  Return the new name length.
+**
+** The original filename is in z[0..]. If the path is shortened,
+** no-longer used bytes will be written by '\0'.
+*/
+#if defined(SQLITE_AMALGAMATION)
+  static
+#endif
+void winSimplifyName(char *z){
+  int i, j;
+  for(i=j=0; z[i]; ++i){
+    if( winIsDirSep(z[i]) ){
+#if !defined(SQLITE_TEST)
+      /* Some test-cases assume that "./foo" and "foo" are different */
+      if( z[i+1]=='.' && winIsDirSep(z[i+2]) ){
+        ++i;
+        continue;
+      }
+#endif
+      if( !z[i+1] || (winIsDirSep(z[i+1]) && (i!=0)) ){
+        continue;
+      }
+      z[j++] = '/';
+    }else{
+      z[j++] = z[i];
+    }
+  }
+  while(j<i) z[j++] = '\0';
+}
+#endif
+
 /*
 ** Turn a relative pathname into a full pathname.  Write the full
 ** pathname into zOut[].  zOut[] will be at least pVfs->mxPathname
@@ -35923,7 +36297,73 @@ static int winFullPathname(
   char *zFull                   /* Output buffer */
 ){
   
-#if defined(__CYGWIN__)
+#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && !defined(__CYGWIN__)
+  DWORD nByte;
+  void *zConverted;
+  char *zOut;
+#endif
+
+  if( cygwin_conv_path || cygwin_conv_to_full_posix_path ){
+    int i;
+    /* It's odd to simulate an io-error here, but really this is just
+    ** using the io-error infrastructure to test that SQLite handles this
+    ** function failing. This function could fail if, for example, the
+    ** current working directory has been unlinked.
+    */
+    SimulateIOError( return SQLITE_ERROR );
+    UNUSED_PARAMETER(pVfs);
+
+    zFull[nFull-1] = '\0';
+    if( winIsDirSep(zRelative[0]) && winIsDirSep(zRelative[1])
+        && zRelative[2]=='?' && winIsDirSep(zRelative[3])){
+      /* This is an extended path. Convert to non-extended form. */
+      if( winIsDriveLetterAndColon(&zRelative[4]) && winIsDirSep(zRelative[6]) ){
+        int nDrive;
+        char temp[4];
+        temp[0] = zRelative[4];
+        memcpy(&temp[1], ":\\", 3);
+        if( cygwin_conv_path ){
+          cygwin_conv_path(CCP_WIN_A_TO_POSIX, temp, zFull, nFull);
+        }else{
+          cygwin_conv_to_full_posix_path(temp, zFull);
+        }
+        nDrive = (int)strlen(zFull);
+        sqlite3_snprintf(nFull-nDrive, &zFull[nDrive], "%s", zRelative+4);
+      }else if( sqlite3_strnicmp(zRelative+4, "UNC", 3)==0 && winIsDirSep(zRelative[7]) ){
+        /* UNC paths in Cygwin start with "//" */
+        sqlite3_snprintf(nFull, zFull, "//%s", zRelative+8);
+      }else{
+        /* Something wrong, no conversion */
+        sqlite3_snprintf(nFull, zFull, "%s", zRelative);
+      }
+    }else if( winIsDriveLetterAndColon(zRelative) && winIsDirSep(zRelative[2]) ){
+      int nDrive;
+      char temp[4];
+      temp[0] = zRelative[0];
+      memcpy(&temp[1], ":\\", 3);
+      if( cygwin_conv_path ){
+        cygwin_conv_path(CCP_WIN_A_TO_POSIX, temp, zFull, nFull);
+      }else{
+        cygwin_conv_to_full_posix_path(temp, zFull);
+      }
+      nDrive = (int)strlen(zFull);
+      sqlite3_snprintf(nFull-nDrive, &zFull[nDrive], "%s", zRelative+2);
+    }else if( getcwd && !winIsDirSep(zRelative[0]) ){
+      int nCwd;
+      if( getcwd(zFull, nFull-1)==0 ){
+        return winLogError(SQLITE_CANTOPEN_BKPT, (DWORD)osErrno, "getcwd", zRelative);
+      }
+      nCwd = (int)strlen(zFull);
+      sqlite3_snprintf(nFull-nCwd, &zFull[nCwd], "/%s", zRelative);
+    }else{
+      sqlite3_snprintf(nFull, zFull, "%s", zRelative);
+    }
+#if defined(_WIN32) || defined(__CYGWIN__)
+    winSimplifyName(zFull);
+#endif
+    return SQLITE_OK;
+  }
+#if 0
   SimulateIOError( return SQLITE_ERROR );
   UNUSED_PARAMETER(nFull);
   assert( nFull>=pVfs->mxPathname );
@@ -36000,9 +36440,11 @@ static int winFullPathname(
 #endif
 
 #if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && !defined(__CYGWIN__)
+#if 0
   DWORD nByte;
   void *zConverted;
   char *zOut;
+#endif
 
   /* If this path name begins with "/X:", where "X" is any alphabetic
   ** character, discard the initial "/" from the pathname.
@@ -36028,7 +36470,7 @@ static int winFullPathname(
                      sqlite3_data_directory, winGetDirSep(), zRelative);
     return SQLITE_OK;
   }
-  zConverted = winConvertFromUtf8Filename(zRelative);
+  zConverted = winConvertFromUtf8Filename(zRelative, 0);
   if( zConverted==0 ){
     return SQLITE_IOERR_NOMEM;
   }
@@ -36041,7 +36483,7 @@ static int winFullPathname(
                          "winFullPathname1", zRelative);
     }
     nByte += 3;
-    zTemp = sqlite3MallocZero( nByte*sizeof(zTemp[0]) );
+    zTemp = sqlite3Malloc( nByte*sizeof(zTemp[0]) );
     if( zTemp==0 ){
       sqlite3_free(zConverted);
       return SQLITE_IOERR_NOMEM;
@@ -36067,7 +36509,7 @@ static int winFullPathname(
                          "winFullPathname3", zRelative);
     }
     nByte += 3;
-    zTemp = sqlite3MallocZero( nByte*sizeof(zTemp[0]) );
+    zTemp = sqlite3Malloc( nByte*sizeof(zTemp[0]) );
     if( zTemp==0 ){
       sqlite3_free(zConverted);
       return SQLITE_IOERR_NOMEM;
@@ -36105,7 +36547,8 @@ static int winFullPathname(
 */
 static void *winDlOpen(sqlite3_vfs *pVfs, const char *zFilename){
   HANDLE h;
-  void *zConverted = winConvertFromUtf8Filename(zFilename);
+  char buf[SQLITE_WIN32_MAX_PATH_CHARS];
+  void *zConverted = winConvertFromUtf8Filename(zFilename, buf);
   UNUSED_PARAMETER(pVfs);
   if( zConverted==0 ){
     return 0;
@@ -36122,7 +36565,9 @@ static void *winDlOpen(sqlite3_vfs *pVfs
     h = osLoadLibraryA((char*)zConverted);
   }
 #endif
-  sqlite3_free(zConverted);
+  if( zConverted!=buf ){
+    sqlite3_free(zConverted);
+  }
   return (void*)h;
 }
 static void winDlError(sqlite3_vfs *pVfs, int nBuf, char *zBufOut){
@@ -36205,7 +36650,7 @@ static int winSleep(sqlite3_vfs *pVfs, i
 ** sqlite3OsCurrentTime() during testing.
 */
 #ifdef SQLITE_TEST
-SQLITE_API int sqlite3_current_time = 0;  /* Fake system time in seconds since 1970. */
+SQLITE_API extern int sqlite3_current_time;  /* Fake system time in seconds since 1970. */
 #endif
 
 /*
@@ -36306,6 +36751,10 @@ static int winGetLastError(sqlite3_vfs *
   return winGetLastErrorMsg(osGetLastError(), nBuf, zBuf);
 }
 
+#if SQLITE_OS_UNIX && !defined(SQLITE_AMALGAMATION)
+SQLITE_API int sqlite3_os_unix_init(void);
+#endif
+
 /*
 ** Initialize and deinitialize the operating system interface.
 */
@@ -36360,10 +36809,12 @@ SQLITE_API int sqlite3_os_init(void){
     winNextSystemCall,   /* xNextSystemCall */
   };
 #endif
+  int i;
+  HMODULE module;
 
   /* Double-check that the aSyscall[] array has been constructed
   ** correctly.  See ticket [bb3a86e890c8e96ab] */
-  assert( ArraySize(aSyscall)==76 );
+  assert( ArraySize(aSyscall)==84 );
 
   /* get memory map allocation granularity */
   memset(&winSysInfo, 0, sizeof(SYSTEM_INFO));
@@ -36375,10 +36826,35 @@ SQLITE_API int sqlite3_os_init(void){
   assert( winSysInfo.dwAllocationGranularity>0 );
   assert( winSysInfo.dwPageSize>0 );
 
+#if SQLITE_OS_WINNT && !defined(__CYGWIN__)
+  if( osIsNT() ){
+    module = osGetModuleHandleW(L"CYGWIN1.DLL");
+    if( !module){
+      module = osGetModuleHandleW(L"MSYS-1.0.DLL");
+    }
+  }else{
+    module = osGetModuleHandleA("CYGWIN1.DLL");
+    if( !module){
+      module = osGetModuleHandleA("MSYS-1.0.DLL");
+    }
+  }
+  if( module ){
+    for(i=78;i<ArraySize(aSyscall);++i){
+ 	    aSyscall[i].pCurrent = (SYSCALL) osGetProcAddressA(module,
+ 	        aSyscall[i].zName);
+    }
+  }
+#endif
+
   sqlite3_vfs_register(&winVfs, 1);
 
 #if defined(SQLITE_WIN32_HAS_WIDE)
-  sqlite3_vfs_register(&winLongPathVfs, 0);
+  sqlite3_vfs_register(&winLongPathVfs, osIsNT()
+	      && (cygwin_conv_path!=NULL));
+#endif
+
+#if SQLITE_OS_UNIX
+  sqlite3_os_unix_init();
 #endif
 
   return SQLITE_OK; 
--- origsrc/sqlite-autoconf-3080200/sqlite3.h	2013-12-06 16:05:18.000000000 +0100
+++ src/sqlite-autoconf-3080200/sqlite3.h	2013-12-09 11:34:05.776190500 +0100
@@ -108,7 +108,8 @@ extern "C" {
 ** [sqlite_version()] and [sqlite_source_id()].
 */
 #define SQLITE_VERSION        "3.8.2"
-#define SQLITE_VERSION_NUMBER 3008002
+/* Lying here on purpose: */
+#define SQLITE_VERSION_NUMBER 3008001
 #define SQLITE_SOURCE_ID      "2013-12-06 14:53:30 27392118af4c38c5203a04b8013e1afdb1cebd0d"
 
 /*
