--- origsrc/sqlite-autoconf-3080100/sqlite3.c	2013-10-17 15:57:34.000000000 +0200
+++ src/sqlite-autoconf-3080100/sqlite3.c	2013-11-13 14:30:38.528187400 +0100
@@ -9669,7 +9669,10 @@ SQLITE_PRIVATE void sqlite3PCacheSetDefa
 #if !defined(SQLITE_OS_UNIX) && !defined(SQLITE_OS_OTHER)
 # define SQLITE_OS_OTHER 0
 # ifndef SQLITE_OS_WIN
-#   if defined(_WIN32) || defined(WIN32) || defined(__CYGWIN__) || defined(__MINGW32__) || defined(__BORLANDC__)
+#   if defined(__CYGWIN__)
+#     define SQLITE_OS_WIN 1
+#     define SQLITE_OS_UNIX 1
+#   elif defined(_WIN32) || defined(WIN32) || defined(__MINGW32__) || defined(__BORLANDC__)
 #     define SQLITE_OS_WIN 1
 #     define SQLITE_OS_UNIX 0
 #   else
@@ -9685,7 +9688,7 @@ SQLITE_PRIVATE void sqlite3PCacheSetDefa
 # endif
 #endif
 
-#if SQLITE_OS_WIN
+#if SQLITE_OS_WIN && !defined(__CYGWIN__)
 # include <windows.h>
 #endif
 
@@ -9957,10 +9960,10 @@ SQLITE_PRIVATE int sqlite3OsCloseFree(sq
 # define SQLITE_MUTEX_OMIT
 #endif
 #if SQLITE_THREADSAFE && !defined(SQLITE_MUTEX_NOOP)
-#  if SQLITE_OS_UNIX
-#    define SQLITE_MUTEX_PTHREADS
-#  elif SQLITE_OS_WIN
+#  if SQLITE_OS_WIN
 #    define SQLITE_MUTEX_W32
+#  elif SQLITE_OS_UNIX
+#    define SQLITE_MUTEX_PTHREADS
 #  else
 #    define SQLITE_MUTEX_NOOP
 #  endif
@@ -18485,6 +18488,10 @@ SQLITE_PRIVATE sqlite3_mutex_methods con
 ** This file contains the C functions that implement mutexes for win32
 */
 
+#ifdef __CYGWIN__
+# include <windows.h> /* amalgamator: keep */
+#endif
+
 /*
 ** The code in this file is only used if we are compiling multithreaded
 ** on a win32 system.
@@ -23007,21 +23014,23 @@ SQLITE_PRIVATE const char *sqlite3Opcode
 ** There are various methods for file locking used for concurrency
 ** control:
 **
-**   1. POSIX locking (the default),
+**   1. POSIX locking (the default, except on Cygwin),
 **   2. No locking,
 **   3. Dot-file locking,
 **   4. flock() locking,
 **   5. AFP locking (OSX only),
 **   6. Named POSIX semaphores (VXWorks only),
 **   7. proxy locking. (OSX only)
+**   8. winnt locking. (Cygwin only, default on Cygwin)
 **
 ** Styles 4, 5, and 7 are only available of SQLITE_ENABLE_LOCKING_STYLE
 ** is defined to 1.  The SQLITE_ENABLE_LOCKING_STYLE also enables automatic
 ** selection of the appropriate locking style based on the filesystem
-** where the database is located.  
+** where the database is located.  On Cygwin, flock() locking is always
+** available, but winnt locking is the default.
 */
 #if !defined(SQLITE_ENABLE_LOCKING_STYLE)
-#  if defined(__APPLE__)
+#  if defined(__APPLE__) || defined(__CYGWIN__)
 #    define SQLITE_ENABLE_LOCKING_STYLE 1
 #  else
 #    define SQLITE_ENABLE_LOCKING_STYLE 0
@@ -23080,8 +23089,11 @@ SQLITE_PRIVATE const char *sqlite3Opcode
 #include <sys/mman.h>
 #endif
 
+#ifdef __CYGWIN__
+# include <sys/cygwin.h>
+#endif
 
-#if SQLITE_ENABLE_LOCKING_STYLE
+#if SQLITE_ENABLE_LOCKING_STYLE || defined(__CYGWIN__)
 # include <sys/ioctl.h>
 # if OS_VXWORKS
 #  include <semaphore.h>
@@ -23186,10 +23198,10 @@ struct unixFile {
   int sectorSize;                     /* Device sector size */
   int deviceCharacteristics;          /* Precomputed device characteristics */
 #endif
-#if SQLITE_ENABLE_LOCKING_STYLE
+#if SQLITE_ENABLE_LOCKING_STYLE && !defined(__CYGWIN__)
   int openFlags;                      /* The flags specified at open() */
 #endif
-#if SQLITE_ENABLE_LOCKING_STYLE || defined(__APPLE__)
+#if SQLITE_ENABLE_LOCKING_STYLE && !defined(__CYGWIN__) || defined(__APPLE__)
   unsigned fsFlags;                   /* cached details from statfs() */
 #endif
 #if OS_VXWORKS
@@ -23515,6 +23527,9 @@ static int openDirectory(const char*, in
 ** testing and sandboxing.  The following array holds the names and pointers
 ** to all overrideable system calls.
 */
+#if SQLITE_OS_WIN
+#  define aSyscall aUnixSyscall
+#endif
 static struct unix_syscall {
   const char *zName;            /* Name of the system call */
   sqlite3_syscall_ptr pCurrent; /* Current value of the system call */
@@ -25381,9 +25396,9 @@ static int dotlockClose(sqlite3_file *id
 ** only a single process can be reading the database at a time.
 **
 ** Omit this section if SQLITE_ENABLE_LOCKING_STYLE is turned off or if
-** compiling for VXWORKS.
+** compiling for VXWORKS, except on Cygwin.
 */
-#if SQLITE_ENABLE_LOCKING_STYLE && !OS_VXWORKS
+#if SQLITE_ENABLE_LOCKING_STYLE && !OS_VXWORKS || defined(__CYGWIN__)
 
 /*
 ** Retry flock() calls that fail with EINTR
@@ -26528,8 +26543,7 @@ static int unixWrite(
 ** Count the number of fullsyncs and normal syncs.  This is used to test
 ** that syncs and fullsyncs are occurring at the right times.
 */
-SQLITE_API int sqlite3_sync_count = 0;
-SQLITE_API int sqlite3_fullsync_count = 0;
+extern int sqlite3_sync_count, sqlite3_fullsync_count;
 #endif
 
 /*
@@ -28120,7 +28134,19 @@ IOMETHODS(
   dotlockCheckReservedLock  /* xCheckReservedLock method */
 )
 
-#if SQLITE_ENABLE_LOCKING_STYLE && !OS_VXWORKS
+#if defined(__CYGWIN__)
+IOMETHODS(
+  winntIoFinder,            /* Finder function name */
+  winntIoMethods,           /* sqlite3_io_methods object name */
+  1,                        /* shared memory is disabled */
+  flockClose,               /* xClose method */
+  flockLock,                /* xLock method */
+  flockUnlock,              /* xUnlock method */
+  flockCheckReservedLock    /* xCheckReservedLock method */
+)
+#endif
+
+#if SQLITE_ENABLE_LOCKING_STYLE && !OS_VXWORKS || defined(__CYGWIN__)
 IOMETHODS(
   flockIoFinder,            /* Finder function name */
   flockIoMethods,           /* sqlite3_io_methods object name */
@@ -28298,6 +28324,46 @@ static const sqlite3_io_methods
 
 #endif /* OS_VXWORKS && SQLITE_ENABLE_LOCKING_STYLE */
 
+#if defined(__CYGWIN__) && SQLITE_ENABLE_LOCKING_STYLE
+/*
+** This "finder" function attempts to determine the best locking strategy
+** for the database file "filePath".  It then returns the sqlite3_io_methods
+** object that implements that strategy.
+**
+** This is for Cygwin only.
+*/
+static const sqlite3_io_methods *autolockIoFinderImpl(
+  const char *filePath,    /* name of the database file */
+  unixFile *pNew           /* the open file object */
+){
+  static const sqlite3_io_methods *ioMethods = NULL;
+
+  if( !filePath ){
+    /* If filePath==NULL that means we are dealing with a transient file
+    ** that does not need to be locked. */
+    return &nolockIoMethods;
+  }
+
+  if( !ioMethods ){
+    const char *strategy = getenv("CYGWIN_SQLITE_LOCKING");
+    ioMethods = &winntIoMethods;
+    if( strategy ){
+      if( sqlite3_stricmp(strategy, "posix") == 0 ){
+        ioMethods = &posixIoMethods;
+      }else if( sqlite3_stricmp(strategy, "bsd") == 0 ){
+        ioMethods = &flockIoMethods;
+      }else if( sqlite3_stricmp(strategy, "dotfile") == 0 ){
+        ioMethods = &dotlockIoMethods;
+      }
+    }
+  }
+  return ioMethods;
+}
+static const sqlite3_io_methods
+  *(*const autolockIoFinder)(const char*,unixFile*) = autolockIoFinderImpl;
+
+#endif /* OS_VXWORKS && SQLITE_ENABLE_LOCKING_STYLE */
+
 /*
 ** An abstract type for a pointer to a IO method finder function:
 */
@@ -28477,7 +28543,16 @@ static int fillInUnixFile(
     unixLeaveMutex();
   }
 #endif
-  
+
+#if defined(__CYGWIN__)
+  else if( pLockingStyle == &winntIoMethods ){
+    if ((osFcntl(h, F_LCK_MANDATORY, 1) != 0) && (errno != EINVAL)) {
+      /* The API exists but it refused to enable mandatory locking! */
+      rc = SQLITE_IOERR_ACCESS;
+    }
+  }
+#endif
+
   pNew->lastErrno = 0;
 #if OS_VXWORKS
   if( rc!=SQLITE_OK ){
@@ -28506,6 +28581,8 @@ static const char *unixTempFileDir(void)
      0,
      0,
      0,
+     0,
+     0,
      "/var/tmp",
      "/usr/tmp",
      "/tmp",
@@ -28518,6 +28595,8 @@ static const char *unixTempFileDir(void)
   azDirs[0] = sqlite3_temp_directory;
   if( !azDirs[1] ) azDirs[1] = getenv("SQLITE_TMPDIR");
   if( !azDirs[2] ) azDirs[2] = getenv("TMPDIR");
+  if( !azDirs[3] ) azDirs[2] = getenv("TMP");
+  if( !azDirs[4] ) azDirs[3] = getenv("TEMP");
   for(i=0; i<sizeof(azDirs)/sizeof(azDirs[0]); zDir=azDirs[i++]){
     if( zDir==0 ) continue;
     if( osStat(zDir, &buf) ) continue;
@@ -28755,10 +28834,10 @@ static int unixOpen(
   int isCreate     = (flags & SQLITE_OPEN_CREATE);
   int isReadonly   = (flags & SQLITE_OPEN_READONLY);
   int isReadWrite  = (flags & SQLITE_OPEN_READWRITE);
-#if SQLITE_ENABLE_LOCKING_STYLE
+#if SQLITE_ENABLE_LOCKING_STYLE && !defined(__CYGWIN__)
   int isAutoProxy  = (flags & SQLITE_OPEN_AUTOPROXY);
 #endif
-#if defined(__APPLE__) || SQLITE_ENABLE_LOCKING_STYLE
+#if defined(__APPLE__) || SQLITE_ENABLE_LOCKING_STYLE && !defined(__CYGWIN__)
   struct statfs fsInfo;
 #endif
 
@@ -28899,7 +28978,7 @@ static int unixOpen(
     osUnlink(zName);
 #endif
   }
-#if SQLITE_ENABLE_LOCKING_STYLE
+#if SQLITE_ENABLE_LOCKING_STYLE && !defined(__CYGWIN__)
   else{
     p->openFlags = openFlags;
   }
@@ -28908,7 +28987,7 @@ static int unixOpen(
   noLock = eType!=SQLITE_OPEN_MAIN_DB;
 
   
-#if defined(__APPLE__) || SQLITE_ENABLE_LOCKING_STYLE
+#if defined(__APPLE__) || SQLITE_ENABLE_LOCKING_STYLE && !defined(__CYGWIN__)
   if( fstatfs(fd, &fsInfo) == -1 ){
     ((unixFile*)pFile)->lastErrno = errno;
     robust_close(p, fd, __LINE__);
@@ -28926,7 +29005,7 @@ static int unixOpen(
   if( syncDir )                 ctrlFlags |= UNIXFILE_DIRSYNC;
   if( flags & SQLITE_OPEN_URI ) ctrlFlags |= UNIXFILE_URI;
 
-#if SQLITE_ENABLE_LOCKING_STYLE
+#if SQLITE_ENABLE_LOCKING_STYLE && !defined(__CYGWIN__)
 #if SQLITE_PREFER_PROXY_LOCKING
   isAutoProxy = 1;
 #endif
@@ -29248,7 +29327,7 @@ static int unixSleep(sqlite3_vfs *NotUse
 ** sqlite3OsCurrentTime() during testing.
 */
 #ifdef SQLITE_TEST
-SQLITE_API int sqlite3_current_time = 0;  /* Fake system time in seconds since 1970. */
+SQLITE_API extern int sqlite3_current_time;  /* Fake system time in seconds since 1970. */
 #endif
 
 /*
@@ -30507,7 +30586,12 @@ static int proxyClose(sqlite3_file *id)
 ** necessarily been initialized when this routine is called, and so they
 ** should not be used.
 */
-SQLITE_API int sqlite3_os_init(void){ 
+#if SQLITE_OS_WIN
+SQLITE_API int sqlite3_os_unix_init(void){
+#else
+SQLITE_API int sqlite3_os_init(void){
+#endif
+
   /* 
   ** The following macro defines an initializer for an sqlite3_vfs object.
   ** The name of the VFS is NAME.  The pAppData is a pointer to a pointer
@@ -30561,9 +30645,12 @@ SQLITE_API int sqlite3_os_init(void){
   ** array cannot be const.
   */
   static sqlite3_vfs aVfs[] = {
-#if SQLITE_ENABLE_LOCKING_STYLE && (OS_VXWORKS || defined(__APPLE__))
+#if SQLITE_ENABLE_LOCKING_STYLE && (OS_VXWORKS || defined(__APPLE__) || defined(__CYGWIN__))
     UNIXVFS("unix",          autolockIoFinder ),
 #else
+#ifdef __CYGWIN__
+    UNIXVFS("winnt",         winntIoFinder ),
+#endif
     UNIXVFS("unix",          posixIoFinder ),
 #endif
     UNIXVFS("unix-none",     nolockIoFinder ),
@@ -30572,7 +30659,7 @@ SQLITE_API int sqlite3_os_init(void){
 #if OS_VXWORKS
     UNIXVFS("unix-namedsem", semIoFinder ),
 #endif
-#if SQLITE_ENABLE_LOCKING_STYLE
+#if SQLITE_ENABLE_LOCKING_STYLE || defined(__CYGWIN__)
     UNIXVFS("unix-posix",    posixIoFinder ),
 #if !OS_VXWORKS
     UNIXVFS("unix-flock",    flockIoFinder ),
@@ -30597,6 +30684,8 @@ SQLITE_API int sqlite3_os_init(void){
   return SQLITE_OK; 
 }
 
+#undef aSyscall
+#if !SQLITE_OS_WIN
 /*
 ** Shutdown the operating system interface.
 **
@@ -30607,6 +30696,7 @@ SQLITE_API int sqlite3_os_init(void){
 SQLITE_API int sqlite3_os_end(void){ 
   return SQLITE_OK; 
 }
+#endif /* !SQLITE_OS_WIN */
  
 #endif /* SQLITE_OS_UNIX */
 
@@ -30629,7 +30719,8 @@ SQLITE_API int sqlite3_os_end(void){
 #if SQLITE_OS_WIN               /* This file is used for Windows only */
 
 #ifdef __CYGWIN__
-# include <sys/cygwin.h>
+/* # include <windows.h> */
+/* # include <sys/cygwin.h> */
 # include <errno.h> /* amalgamator: keep */
 #endif
 
@@ -30881,6 +30972,13 @@ SQLITE_API int sqlite3_open_file_count =
 #endif
 
 /*
+** This constant should already be defined (in the "WinDef.h" SDK file).
+*/
+#ifndef MAX_PATH
+#  define MAX_PATH                      (260)
+#endif
+
+/*
 ** Maximum pathname length (in chars) for Win32.  This should normally be
 ** MAX_PATH.
 */
@@ -30889,16 +30987,23 @@ SQLITE_API int sqlite3_open_file_count =
 #endif
 
 /*
+** This constant should already be defined (in the "WinNT.h" SDK file).
+*/
+#ifndef UNICODE_STRING_MAX_CHARS
+#  define UNICODE_STRING_MAX_CHARS      (32767)
+#endif
+
+/*
 ** Maximum pathname length (in chars) for WinNT.  This should normally be
-** 32767.
+** UNICODE_STRING_MAX_CHARS.
 */
 #ifndef SQLITE_WINNT_MAX_PATH_CHARS
-#  define SQLITE_WINNT_MAX_PATH_CHARS   (32767)
+#  define SQLITE_WINNT_MAX_PATH_CHARS   (UNICODE_STRING_MAX_CHARS)
 #endif
 
 /*
 ** Maximum pathname length (in bytes) for Win32.  The MAX_PATH macro is in
-** characters, so we allocate 3 bytes per character assuming worst-case of
+** characters, so we allocate 4 bytes per character assuming worst-case of
 ** 4-bytes-per-character for UTF8.
 */
 #ifndef SQLITE_WIN32_MAX_PATH_BYTES
@@ -30907,7 +31012,7 @@ SQLITE_API int sqlite3_open_file_count =
 
 /*
 ** Maximum pathname length (in bytes) for WinNT.  This should normally be
-** 32767 * sizeof(WCHAR).
+** UNICODE_STRING_MAX_CHARS * sizeof(WCHAR).
 */
 #ifndef SQLITE_WINNT_MAX_PATH_BYTES
 #  define SQLITE_WINNT_MAX_PATH_BYTES   \
@@ -30938,14 +31043,10 @@ SQLITE_API int sqlite3_open_file_count =
 #endif
 
 /*
-** Returns the string that should be used as the directory separator.
+** Returns the character that should be used as the directory separator.
 */
-#ifndef winGetDirDep
-#  ifdef __CYGWIN__
-#    define winGetDirDep()              "/"
-#  else
-#    define winGetDirDep()              "\\"
-#  endif
+#ifndef winGetDirSep
+#  define winGetDirSep()                '\\'
 #endif
 
 /*
@@ -32003,7 +32104,7 @@ static void *winMemMalloc(int nBytes){
   assert( hHeap!=0 );
   assert( hHeap!=INVALID_HANDLE_VALUE );
 #if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_MALLOC_VALIDATE)
-  assert ( osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, NULL) );
+  assert( osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, NULL) );
 #endif
   assert( nBytes>=0 );
   p = osHeapAlloc(hHeap, SQLITE_WIN32_HEAP_FLAGS, (SIZE_T)nBytes);
@@ -32025,7 +32126,7 @@ static void winMemFree(void *pPrior){
   assert( hHeap!=0 );
   assert( hHeap!=INVALID_HANDLE_VALUE );
 #if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_MALLOC_VALIDATE)
-  assert ( osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, pPrior) );
+  assert( osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, pPrior) );
 #endif
   if( !pPrior ) return; /* Passing NULL to HeapFree is undefined. */
   if( !osHeapFree(hHeap, SQLITE_WIN32_HEAP_FLAGS, pPrior) ){
@@ -32046,7 +32147,7 @@ static void *winMemRealloc(void *pPrior,
   assert( hHeap!=0 );
   assert( hHeap!=INVALID_HANDLE_VALUE );
 #if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_MALLOC_VALIDATE)
-  assert ( osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, pPrior) );
+  assert( osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, pPrior) );
 #endif
   assert( nBytes>=0 );
   if( !pPrior ){
@@ -32074,7 +32175,7 @@ static int winMemSize(void *p){
   assert( hHeap!=0 );
   assert( hHeap!=INVALID_HANDLE_VALUE );
 #if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_MALLOC_VALIDATE)
-  assert ( osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, NULL) );
+  assert( osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, p) );
 #endif
   if( !p ) return 0;
   n = osHeapSize(hHeap, SQLITE_WIN32_HEAP_FLAGS, p);
@@ -33281,8 +33382,7 @@ static int winTruncate(sqlite3_file *id,
 ** Count the number of fullsyncs and normal syncs.  This is used to test
 ** that syncs and fullsyncs are occuring at the right times.
 */
-SQLITE_API int sqlite3_sync_count = 0;
-SQLITE_API int sqlite3_fullsync_count = 0;
+extern int sqlite3_sync_count, sqlite3_fullsync_count;
 #endif
 
 /*
@@ -34811,12 +34911,21 @@ static void *winConvertFromUtf8Filename(
 
 /*
 ** This function returns non-zero if the specified UTF-8 string buffer
-** ends with a directory separator character.
+** ends with a directory separator character or one was successfully
+** added to it.
 */
-static int winEndsInDirSep(char *zBuf){
+static int winMakeEndInDirSep(int nBuf, char *zBuf){
   if( zBuf ){
     int nLen = sqlite3Strlen30(zBuf);
-    return nLen>0 && winIsDirSep(zBuf[nLen-1]);
+    if( nLen>0 ){
+      if( winIsDirSep(zBuf[nLen-1]) ){
+        return 1;
+      }else if( nLen+1<nBuf ){
+        zBuf[nLen] = winGetDirSep();
+        zBuf[nLen+1] = '\0';
+        return 1;
+      }
+    }
   }
   return 0;
 }
@@ -34831,7 +34940,8 @@ static int winGetTempname(sqlite3_vfs *p
     "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
     "0123456789";
   size_t i, j;
-  int nBuf, nLen;
+  int nPre = sqlite3Strlen30(SQLITE_TEMP_FILE_PREFIX);
+  int nMax, nBuf, nDir, nLen;
   char *zBuf;
 
   /* It's odd to simulate an io-error here, but really this is just
@@ -34843,8 +34953,8 @@ static int winGetTempname(sqlite3_vfs *p
   /* Allocate a temporary buffer to store the fully qualified file
   ** name for the temporary file.  If this fails, we cannot continue.
   */
-  nBuf = pVfs->mxPathname;
-  zBuf = sqlite3MallocZero( nBuf+2 );
+  nMax = pVfs->mxPathname; nBuf = nMax + 2;
+  zBuf = sqlite3MallocZero( nBuf );
   if( !zBuf ){
     OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));
     return SQLITE_IOERR_NOMEM;
@@ -34854,11 +34964,21 @@ static int winGetTempname(sqlite3_vfs *p
   ** has been explicitly set by the application; otherwise, use the one
   ** configured by the operating system.
   */
-  assert( nBuf>30 );
+  nDir = nMax - (nPre + 15);
+  assert( nDir>0 );
   if( sqlite3_temp_directory ){
-    sqlite3_snprintf(nBuf-30, zBuf, "%s%s", sqlite3_temp_directory,
-                     winEndsInDirSep(sqlite3_temp_directory) ? "" :
-                     winGetDirDep());
+    int nDirLen = sqlite3Strlen30(sqlite3_temp_directory);
+    if( nDirLen>0 ){
+      if( !winIsDirSep(sqlite3_temp_directory[nDirLen-1]) ){
+        nDirLen++;
+      }
+      if( nDirLen>nDir ){
+        sqlite3_free(zBuf);
+        OSTRACE(("TEMP-FILENAME rc=SQLITE_ERROR\n"));
+        return winLogError(SQLITE_ERROR, 0, "winGetTempname1", 0);
+      }
+      sqlite3_snprintf(nMax, zBuf, "%s", sqlite3_temp_directory);
+    }
   }
 #if defined(__CYGWIN__)
   else{
@@ -34887,8 +35007,8 @@ static int winGetTempname(sqlite3_vfs *p
       if( zDir==0 ) continue;
       /* If the path starts with a drive letter followed by the colon
       ** character, assume it is already a native Win32 path; otherwise,
-      ** it must be converted to a native Win32 path prior via the Cygwin
-      ** API prior to using it.
+      ** it must be converted to a native Win32 path via the Cygwin API
+      ** prior to using it.
       */
       if( winIsDriveLetterAndColon(zDir) ){
         zConverted = winConvertFromUtf8Filename(zDir);
@@ -34898,13 +35018,13 @@ static int winGetTempname(sqlite3_vfs *p
           return SQLITE_IOERR_NOMEM;
         }
         if( winIsDir(zConverted) ){
-          sqlite3_snprintf(nBuf-30, zBuf, "%s", zDir);
+          sqlite3_snprintf(nMax, zBuf, "%s", zDir);
           sqlite3_free(zConverted);
           break;
         }
         sqlite3_free(zConverted);
       }else{
-        zConverted = sqlite3MallocZero( nBuf+1 );
+        zConverted = sqlite3MallocZero( nMax+1 );
         if( !zConverted ){
           sqlite3_free(zBuf);
           OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));
@@ -34912,12 +35032,12 @@ static int winGetTempname(sqlite3_vfs *p
         }
         if( cygwin_conv_path(
                 osIsNT() ? CCP_POSIX_TO_WIN_W : CCP_POSIX_TO_WIN_A, zDir,
-                zConverted, nBuf+1)<0 ){
+                zConverted, nMax+1)<0 ){
           sqlite3_free(zConverted);
           sqlite3_free(zBuf);
           OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_CONVPATH\n"));
           return winLogError(SQLITE_IOERR_CONVPATH, (DWORD)errno,
-                             "winGetTempname1", zDir);
+                             "winGetTempname2", zDir);
         }
         if( winIsDir(zConverted) ){
           /* At this point, we know the candidate directory exists and should
@@ -34932,12 +35052,12 @@ static int winGetTempname(sqlite3_vfs *p
               OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));
               return SQLITE_IOERR_NOMEM;
             }
-            sqlite3_snprintf(nBuf-30, zBuf, "%s", zUtf8);
+            sqlite3_snprintf(nMax, zBuf, "%s", zUtf8);
             sqlite3_free(zUtf8);
             sqlite3_free(zConverted);
             break;
           }else{
-            sqlite3_snprintf(nBuf-30, zBuf, "%s", zConverted);
+            sqlite3_snprintf(nMax, zBuf, "%s", zConverted);
             sqlite3_free(zConverted);
             break;
           }
@@ -34949,22 +35069,22 @@ static int winGetTempname(sqlite3_vfs *p
 #elif !SQLITE_OS_WINRT && !defined(__CYGWIN__)
   else if( osIsNT() ){
     char *zMulti;
-    LPWSTR zWidePath = sqlite3MallocZero( nBuf*sizeof(WCHAR) );
+    LPWSTR zWidePath = sqlite3MallocZero( nMax*sizeof(WCHAR) );
     if( !zWidePath ){
       sqlite3_free(zBuf);
       OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));
       return SQLITE_IOERR_NOMEM;
     }
-    if( osGetTempPathW(nBuf, zWidePath)==0 ){
+    if( osGetTempPathW(nMax, zWidePath)==0 ){
       sqlite3_free(zWidePath);
       sqlite3_free(zBuf);
       OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_GETTEMPPATH\n"));
       return winLogError(SQLITE_IOERR_GETTEMPPATH, osGetLastError(),
-                         "winGetTempname1", 0);
+                         "winGetTempname2", 0);
     }
     zMulti = winUnicodeToUtf8(zWidePath);
     if( zMulti ){
-      sqlite3_snprintf(nBuf-30, zBuf, "%s", zMulti);
+      sqlite3_snprintf(nMax, zBuf, "%s", zMulti);
       sqlite3_free(zMulti);
       sqlite3_free(zWidePath);
     }else{
@@ -34977,21 +35097,21 @@ static int winGetTempname(sqlite3_vfs *p
 #ifdef SQLITE_WIN32_HAS_ANSI
   else{
     char *zUtf8;
-    char *zMbcsPath = sqlite3MallocZero( nBuf );
+    char *zMbcsPath = sqlite3MallocZero( nMax );
     if( !zMbcsPath ){
       sqlite3_free(zBuf);
       OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));
       return SQLITE_IOERR_NOMEM;
     }
-    if( osGetTempPathA(nBuf, zMbcsPath)==0 ){
+    if( osGetTempPathA(nMax, zMbcsPath)==0 ){
       sqlite3_free(zBuf);
       OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_GETTEMPPATH\n"));
       return winLogError(SQLITE_IOERR_GETTEMPPATH, osGetLastError(),
-                         "winGetTempname2", 0);
+                         "winGetTempname3", 0);
     }
     zUtf8 = sqlite3_win32_mbcs_to_utf8(zMbcsPath);
     if( zUtf8 ){
-      sqlite3_snprintf(nBuf-30, zBuf, "%s", zUtf8);
+      sqlite3_snprintf(nMax, zBuf, "%s", zUtf8);
       sqlite3_free(zUtf8);
     }else{
       sqlite3_free(zBuf);
@@ -35002,18 +35122,36 @@ static int winGetTempname(sqlite3_vfs *p
 #endif /* SQLITE_WIN32_HAS_ANSI */
 #endif /* !SQLITE_OS_WINRT */
 
-  /* Check that the output buffer is large enough for the temporary file 
-  ** name. If it is not, return SQLITE_ERROR.
+  /*
+  ** Check to make sure the temporary directory ends with an appropriate
+  ** separator.  If it does not and there is not enough space left to add
+  ** one, fail.
   */
-  nLen = sqlite3Strlen30(zBuf);
+  if( !winMakeEndInDirSep(nDir+1, zBuf) ){
+    sqlite3_free(zBuf);
+    OSTRACE(("TEMP-FILENAME rc=SQLITE_ERROR\n"));
+    return winLogError(SQLITE_ERROR, 0, "winGetTempname4", 0);
+  }
 
-  if( (nLen + sqlite3Strlen30(SQLITE_TEMP_FILE_PREFIX) + 18) >= nBuf ){
+  /*
+  ** Check that the output buffer is large enough for the temporary file 
+  ** name in the following format:
+  **
+  **   "<temporary_directory>/etilqs_XXXXXXXXXXXXXXX\0\0"
+  **
+  ** If not, return SQLITE_ERROR.  The number 17 is used here in order to
+  ** account for the space used by the 15 character random suffix and the
+  ** two trailing NUL characters.  The final directory separator character
+  ** has already added if it was not already present.
+  */
+  nLen = sqlite3Strlen30(zBuf);
+  if( (nLen + nPre + 17) > nBuf ){
     sqlite3_free(zBuf);
     OSTRACE(("TEMP-FILENAME rc=SQLITE_ERROR\n"));
-    return winLogError(SQLITE_ERROR, 0, "winGetTempname3", 0);
+    return winLogError(SQLITE_ERROR, 0, "winGetTempname5", 0);
   }
 
-  sqlite3_snprintf(nBuf-18-nLen, zBuf+nLen, SQLITE_TEMP_FILE_PREFIX);
+  sqlite3_snprintf(nBuf-16-nLen, zBuf+nLen, SQLITE_TEMP_FILE_PREFIX);
 
   j = sqlite3Strlen30(zBuf);
   sqlite3_randomness(15, &zBuf[j]);
@@ -35068,7 +35206,7 @@ static int winOpen(
   int *pOutFlags            /* Status return flags */
 ){
   HANDLE h;
-  DWORD lastErrno;
+  DWORD lastErrno = 0;
   DWORD dwDesiredAccess;
   DWORD dwShareMode;
   DWORD dwCreationDisposition;
@@ -35359,7 +35497,7 @@ static int winDelete(
   int cnt = 0;
   int rc;
   DWORD attr;
-  DWORD lastErrno;
+  DWORD lastErrno = 0;
   void *zConverted;
   UNUSED_PARAMETER(pVfs);
   UNUSED_PARAMETER(syncDir);
@@ -35467,7 +35605,7 @@ static int winAccess(
 ){
   DWORD attr;
   int rc = 0;
-  DWORD lastErrno;
+  DWORD lastErrno = 0;
   void *zConverted;
   UNUSED_PARAMETER(pVfs);
 
@@ -35613,8 +35751,8 @@ static int winFullPathname(
       return winLogError(SQLITE_CANTOPEN_CONVPATH, (DWORD)errno,
                          "winFullPathname1", zRelative);
     }
-    sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, "%s%s%s",
-                     sqlite3_data_directory, winGetDirDep(), zOut);
+    sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, "%s%c%s",
+                     sqlite3_data_directory, winGetDirSep(), zOut);
     sqlite3_free(zOut);
   }else{
     if( cygwin_conv_path(CCP_POSIX_TO_WIN_A, zRelative, zFull, nFull)<0 ){
@@ -35636,8 +35774,8 @@ static int winFullPathname(
     **       for converting the relative path name to an absolute
     **       one by prepending the data directory and a backslash.
     */
-    sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, "%s%s%s",
-                     sqlite3_data_directory, winGetDirDep(), zRelative);
+    sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, "%s%c%s",
+                     sqlite3_data_directory, winGetDirSep(), zRelative);
   }else{
     sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, "%s", zRelative);
   }
@@ -35669,8 +35807,8 @@ static int winFullPathname(
     **       for converting the relative path name to an absolute
     **       one by prepending the data directory and a backslash.
     */
-    sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, "%s%s%s",
-                     sqlite3_data_directory, winGetDirDep(), zRelative);
+    sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, "%s%c%s",
+                     sqlite3_data_directory, winGetDirSep(), zRelative);
     return SQLITE_OK;
   }
   zConverted = winConvertFromUtf8Filename(zRelative);
@@ -35850,7 +35988,7 @@ static int winSleep(sqlite3_vfs *pVfs, i
 ** sqlite3OsCurrentTime() during testing.
 */
 #ifdef SQLITE_TEST
-SQLITE_API int sqlite3_current_time = 0;  /* Fake system time in seconds since 1970. */
+SQLITE_API extern int sqlite3_current_time;  /* Fake system time in seconds since 1970. */
 #endif
 
 /*
@@ -36026,7 +36164,11 @@ SQLITE_API int sqlite3_os_init(void){
   sqlite3_vfs_register(&winLongPathVfs, 0);
 #endif
 
+#if SQLITE_OS_UNIX
+  return sqlite3_os_unix_init();
+#else
   return SQLITE_OK; 
+#endif
 }
 
 SQLITE_API int sqlite3_os_end(void){ 
